Disassembly Listing for Dazzler
Generated From:
C:/Users/hansel/home/projects/Dazzler/PIC32/firmware/Dazzler.X/dist/default/production/Dazzler.X.production.elf
Mar 26, 2018 7:42:31 AM

---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/system_tasks.c  -----
1:                   /*******************************************************************************
2:                    System Tasks File
3:                   
4:                     File Name:
5:                       system_tasks.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to maintain system's polled state
9:                       machines.
10:                  
11:                    Description:
12:                      This file contains source code necessary to maintain system's polled state
13:                      machines.  It implements the "SYS_Tasks" function that calls the individual
14:                      "Tasks" functions for all polled MPLAB Harmony modules in the system.
15:                  
16:                    Remarks:
17:                      This file requires access to the systemObjects global data structure that
18:                      contains the object handles to all MPLAB Harmony module objects executing
19:                      polled in the system.  These handles are passed into the individual module
20:                      "Tasks" functions to identify the instance of the module to maintain.
21:                   *******************************************************************************/
22:                  
23:                  // DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                   *******************************************************************************/
46:                  // DOM-IGNORE-END
47:                  
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Section: Included Files
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  
54:                  #include "system_config.h"
55:                  #include "system_definitions.h"
56:                  
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: System "Tasks" Routine
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  /*******************************************************************************
65:                    Function:
66:                      void SYS_Tasks ( void )
67:                  
68:                    Remarks:
69:                      See prototype in system/common/sys_module.h.
70:                  */
71:                  
72:                  void SYS_Tasks ( void )
73:                  {
9D00953C  27BDFFE8   ADDIU SP, SP, -24
9D009540  AFBF0014   SW RA, 20(SP)
9D009544  AFB00010   SW S0, 16(SP)
74:                      /* Maintain system services */
75:                      /* SYS_TMR Device layer tasks routine */ 
76:                      SYS_TMR_Tasks(sysObj.sysTmr);
9D009548  3C10A000   LUI S0, -24576
9D00954C  0F4009D6   JAL SYS_TMR_Tasks
9D009550  8E040620   LW A0, 1568(S0)
77:                  
78:                      /* Maintain Device Drivers */
79:                  
80:                      /* Maintain Middleware & Other Libraries */
81:                  
82:                      
83:                      /* USB FS Driver Task Routine */ 
84:                       DRV_USBFS_Tasks(sysObj.drvUSBObject);
9D009554  26100620   ADDIU S0, S0, 1568
9D009558  0F4026C1   JAL DRV_USBFS_Tasks
9D00955C  8E040008   LW A0, 8(S0)
85:                       
86:                   
87:                      /* USB Host layer task routine.*/
88:                      USB_HOST_Tasks(sysObj.usbHostObject0);
9D009560  0F400FE2   JAL USB_HOST_Tasks
9D009564  8E04000C   LW A0, 12(S0)
89:                  
90:                  
91:                      /* Maintain the application's state machine. */
92:                      APP_Tasks();
9D009568  0F401C07   JAL APP_Tasks
9D00956C  00000000   NOP
93:                  }
9D009570  8FBF0014   LW RA, 20(SP)
94:                  
95:                  
96:                  /*******************************************************************************
97:                   End of File
98:                   */
99:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/system_interrupt.c  -
1:                   /*******************************************************************************
2:                    System Interrupts File
3:                   
4:                     File Name:
5:                       system_interrupt.c
6:                   
7:                     Summary:
8:                       Raw ISR definitions.
9:                   
10:                    Description:
11:                      This file contains a definitions of the raw ISRs required to support the
12:                      interrupt sub-system.
13:                  
14:                    Summary:
15:                      This file contains source code for the interrupt vector functions in the
16:                      system.
17:                  
18:                    Description:
19:                      This file contains source code for the interrupt vector functions in the
20:                      system.  It implements the system and part specific vector "stub" functions
21:                      from which the individual "Tasks" functions are called for any modules
22:                      executing interrupt-driven in the MPLAB Harmony system.
23:                  
24:                    Remarks:
25:                      This file requires access to the systemObjects global data structure that
26:                      contains the object handles to all MPLAB Harmony module objects executing
27:                      interrupt-driven in the system.  These handles are passed into the individual
28:                      module "Tasks" functions to identify the instance of the module to maintain.
29:                   *******************************************************************************/
30:                  
31:                  // DOM-IGNORE-BEGIN
32:                  /*******************************************************************************
33:                  Copyright (c) 2011-2014 released Microchip Technology Inc.  All rights reserved.
34:                  
35:                  Microchip licenses to you the right to use, modify, copy and distribute
36:                  Software only when embedded on a Microchip microcontroller or digital signal
37:                  controller that is integrated into your product or third party product
38:                  (pursuant to the sublicense terms in the accompanying license agreement).
39:                  
40:                  You should refer to the license agreement accompanying this Software for
41:                  additional information regarding your rights and obligations.
42:                  
43:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
44:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
45:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
46:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
47:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
48:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
49:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
50:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
51:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
52:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
53:                   *******************************************************************************/
54:                  // DOM-IGNORE-END
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  
62:                  #include "system/common/sys_common.h"
63:                  #include "app.h"
64:                  #include "system_definitions.h"
65:                  
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  // Section: System Interrupt Vector Functions
69:                  // *****************************************************************************
70:                  // *****************************************************************************
71:                  
72:                   
73:                  
74:                  void __ISR(_TIMER_1_VECTOR, ipl1AUTO) IntHandlerDrvTmrInstance0(void)
75:                  {
9D006060  415DE800   RDPGPR SP, SP
9D006064  401B7000   MFC0 K1, EPC
9D006068  401A6002   MFC0 K0, SRSCtl
9D00606C  27BDFF90   ADDIU SP, SP, -112
9D006070  AFBB006C   SW K1, 108(SP)
9D006074  401B6000   MFC0 K1, Status
9D006078  AFBA0064   SW K0, 100(SP)
9D00607C  AFBB0068   SW K1, 104(SP)
9D006080  7C1B7844   INS K1, ZERO, 1, 15
9D006084  377B0400   ORI K1, K1, 1024
9D006088  409B6000   MTC0 K1, Status
9D00608C  AFA30018   SW V1, 24(SP)
9D006090  AFA20014   SW V0, 20(SP)
9D006094  8FA30064   LW V1, 100(SP)
9D006098  3063000F   ANDI V1, V1, 15
9D00609C  14600011   BNE V1, ZERO, 0x9D0060E4
9D0060A0  00000000   NOP
9D0060A4  AFBF0054   SW RA, 84(SP)
9D0060A8  AFB90050   SW T9, 80(SP)
9D0060AC  AFB8004C   SW T8, 76(SP)
9D0060B0  AFAF0048   SW T7, 72(SP)
9D0060B4  AFAE0044   SW T6, 68(SP)
9D0060B8  AFAD0040   SW T5, 64(SP)
9D0060BC  AFAC003C   SW T4, 60(SP)
9D0060C0  AFAB0038   SW T3, 56(SP)
9D0060C4  AFAA0034   SW T2, 52(SP)
9D0060C8  AFA90030   SW T1, 48(SP)
9D0060CC  AFA8002C   SW T0, 44(SP)
9D0060D0  AFA70028   SW A3, 40(SP)
9D0060D4  AFA60024   SW A2, 36(SP)
9D0060D8  AFA50020   SW A1, 32(SP)
9D0060DC  AFA4001C   SW A0, 28(SP)
9D0060E0  AFA10010   SW AT, 16(SP)
9D0060E4  00001012   MFLO V0
9D0060E8  AFA2005C   SW V0, 92(SP)
9D0060EC  00001810   MFHI V1
9D0060F0  AFA30058   SW V1, 88(SP)
76:                      DRV_TMR_Tasks(sysObj.drvTmr0);
9D0060F4  3C02A000   LUI V0, -24576
9D0060F8  0F401E1D   JAL DRV_TMR_Tasks
9D0060FC  8C440624   LW A0, 1572(V0)
77:                  }
9D006100  8FA2005C   LW V0, 92(SP)
78:                    
79:                  void __ISR( _USB_1_VECTOR , IPL4AUTO)_IntHandler_USB_stub ( void )
80:                  {
9D006194  415DE800   RDPGPR SP, SP
9D006198  401B7000   MFC0 K1, EPC
9D00619C  401A6002   MFC0 K0, SRSCtl
9D0061A0  27BDFF90   ADDIU SP, SP, -112
9D0061A4  AFBB006C   SW K1, 108(SP)
9D0061A8  401B6000   MFC0 K1, Status
9D0061AC  AFBA0064   SW K0, 100(SP)
9D0061B0  AFBB0068   SW K1, 104(SP)
9D0061B4  7C1B7844   INS K1, ZERO, 1, 15
9D0061B8  377B1000   ORI K1, K1, 4096
9D0061BC  409B6000   MTC0 K1, Status
9D0061C0  AFA30018   SW V1, 24(SP)
9D0061C4  AFA20014   SW V0, 20(SP)
9D0061C8  8FA30064   LW V1, 100(SP)
9D0061CC  3063000F   ANDI V1, V1, 15
9D0061D0  14600011   BNE V1, ZERO, 0x9D006218
9D0061D4  00000000   NOP
9D0061D8  AFBF0054   SW RA, 84(SP)
9D0061DC  AFB90050   SW T9, 80(SP)
9D0061E0  AFB8004C   SW T8, 76(SP)
9D0061E4  AFAF0048   SW T7, 72(SP)
9D0061E8  AFAE0044   SW T6, 68(SP)
9D0061EC  AFAD0040   SW T5, 64(SP)
9D0061F0  AFAC003C   SW T4, 60(SP)
9D0061F4  AFAB0038   SW T3, 56(SP)
9D0061F8  AFAA0034   SW T2, 52(SP)
9D0061FC  AFA90030   SW T1, 48(SP)
9D006200  AFA8002C   SW T0, 44(SP)
9D006204  AFA70028   SW A3, 40(SP)
9D006208  AFA60024   SW A2, 36(SP)
9D00620C  AFA50020   SW A1, 32(SP)
9D006210  AFA4001C   SW A0, 28(SP)
9D006214  AFA10010   SW AT, 16(SP)
9D006218  00001012   MFLO V0
9D00621C  AFA2005C   SW V0, 92(SP)
9D006220  00001810   MFHI V1
9D006224  AFA30058   SW V1, 88(SP)
81:                      DRV_USBFS_Tasks_ISR(sysObj.drvUSBObject);
9D006228  3C02A000   LUI V0, -24576
9D00622C  0F402178   JAL DRV_USBFS_Tasks_ISR
9D006230  8C440628   LW A0, 1576(V0)
82:                  }
9D006234  8FA2005C   LW V0, 92(SP)
83:                  
84:                  /*******************************************************************************
85:                   End of File
86:                  */
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/system_init.c  ------
1:                   /*******************************************************************************
2:                     System Initialization File
3:                   
4:                     File Name:
5:                       system_init.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the system.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "SYS_Initialize" function, defines the configuration bits,
13:                      and allocates any necessary global system resources, such as the
14:                      sysObj structure that contains the object handles to all the MPLAB Harmony
15:                      module objects in the system.
16:                   *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                   *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  
49:                  #include "system_config.h"
50:                  #include "system_definitions.h"
51:                  
52:                  
53:                  // ****************************************************************************
54:                  // ****************************************************************************
55:                  // Section: Configuration Bits
56:                  // ****************************************************************************
57:                  // ****************************************************************************
58:                  // <editor-fold defaultstate="collapsed" desc="Configuration Bits">
59:                  
60:                  /*** DEVCFG0 ***/
61:                  
62:                  #pragma config DEBUG =      OFF
63:                  #pragma config JTAGEN =     OFF
64:                  #pragma config ICESEL =     ICS_PGx3
65:                  #pragma config PWP =        OFF
66:                  #pragma config BWP =        OFF
67:                  #pragma config CP =         OFF
68:                  
69:                  /*** DEVCFG1 ***/
70:                  
71:                  #pragma config FNOSC =      FRCPLL
72:                  #pragma config FSOSCEN =    OFF
73:                  #pragma config IESO =       OFF
74:                  #pragma config POSCMOD =    XT
75:                  #pragma config OSCIOFNC =   OFF
76:                  #pragma config FPBDIV =     DIV_2
77:                  #pragma config FCKSM =      CSDCMD
78:                  #pragma config WDTPS =      PS1048576
79:                  #pragma config FWDTEN =     OFF
80:                  #pragma config WINDIS =     OFF
81:                  #pragma config FWDTWINSZ =  WINSZ_50
82:                  /*** DEVCFG2 ***/
83:                  
84:                  #pragma config FPLLIDIV =   DIV_2
85:                  #pragma config FPLLMUL =    MUL_24
86:                  #pragma config FPLLODIV =   DIV_2
87:                  #pragma config UPLLIDIV =   DIV_2
88:                  #pragma config UPLLEN =     ON
89:                  /*** DEVCFG3 ***/
90:                  
91:                  #pragma config USERID =     0xffff
92:                  #pragma config PMDL1WAY =   ON
93:                  #pragma config IOL1WAY =    ON
94:                  #pragma config FUSBIDIO =   OFF
95:                  #pragma config FVBUSONIO =  OFF
96:                  // </editor-fold>
97:                  
98:                  // *****************************************************************************
99:                  // *****************************************************************************
100:                 // Section: Driver Initialization Data
101:                 // *****************************************************************************
102:                 // *****************************************************************************
103:                 // <editor-fold defaultstate="collapsed" desc="DRV_Timer Initialization Data">
104:                 /*** TMR Driver Initialization Data ***/
105:                 
106:                 const DRV_TMR_INIT drvTmr0InitData =
107:                 {
108:                     .moduleInit.sys.powerState = DRV_TMR_POWER_STATE_IDX0,
109:                     .tmrId = DRV_TMR_PERIPHERAL_ID_IDX0,
110:                     .clockSource = DRV_TMR_CLOCK_SOURCE_IDX0,
111:                     .prescale = DRV_TMR_PRESCALE_IDX0,
112:                     .mode = DRV_TMR_OPERATION_MODE_16_BIT,
113:                     .interruptSource = DRV_TMR_INTERRUPT_SOURCE_IDX0,
114:                     .asyncWriteEnable = false,
115:                 };
116:                 // </editor-fold>
117:                 // <editor-fold defaultstate="collapsed" desc="DRV_USB Initialization Data">
118:                 /******************************************************
119:                  * USB Driver Initialization
120:                  ******************************************************/
121:                 /****************************************************
122:                  * Endpoint Table needed by the Device Layer.
123:                  ****************************************************/
124:                 uint8_t __attribute__((aligned(512))) endPointTable[DRV_USBFS_ENDPOINTS_NUMBER * 32];
125:                 const DRV_USBFS_INIT drvUSBFSInit =
126:                 {
127:                     /* Assign the endpoint table */
128:                     .endpointTable= endPointTable,
129:                 
130:                     /* Interrupt Source for USB module */
131:                     .interruptSource = INT_SOURCE_USB_1,
132:                     
133:                     /* System module initialization */
134:                     .moduleInit = {SYS_MODULE_POWER_RUN_FULL},
135:                     
136:                     /* Operation Mode */
137:                     .operationMode = DRV_USBFS_OPMODE_HOST,
138:                     
139:                     .operationSpeed = USB_SPEED_FULL,
140:                     
141:                     /* Stop in idle */
142:                     .stopInIdle = false,
143:                 
144:                     /* Suspend in sleep */
145:                     .suspendInSleep = false,
146:                 
147:                     /* Identifies peripheral (PLIB-level) ID */
148:                     .usbID = USB_ID_1,
149:                     
150:                     /* Root Hub Port indication */ 
151:                     .portIndication = NULL,
152:                         
153:                      /* Over Current detection */ 
154:                 	.portOverCurrentDetect = NULL,
155:                     
156:                     /* Power Enable */ 
157:                     .portPowerEnable = NULL,
158:                      
159:                      /* Available Current */ 
160:                     .rootHubAvailableCurrent = 500,
161:                 };
162:                 // </editor-fold>
163:                 
164:                 // *****************************************************************************
165:                 // *****************************************************************************
166:                 // Section: System Data
167:                 // *****************************************************************************
168:                 // *****************************************************************************
169:                 
170:                 /* Structure to hold the object handles for the modules in the system. */
171:                 SYSTEM_OBJECTS sysObj;
172:                 
173:                 // *****************************************************************************
174:                 // *****************************************************************************
175:                 // Section: Module Initialization Data
176:                 // *****************************************************************************
177:                 // *****************************************************************************
178:                 // <editor-fold defaultstate="collapsed" desc="SYS_TMR Initialization Data">
179:                 /*** TMR Service Initialization Data ***/
180:                 const SYS_TMR_INIT sysTmrInitData =
181:                 {
182:                     .moduleInit = {SYS_MODULE_POWER_RUN_FULL},
183:                     .drvIndex = DRV_TMR_INDEX_0,
184:                     .tmrFreq = 1000, 
185:                 };
186:                 // </editor-fold>
187:                 
188:                 // *****************************************************************************
189:                 // *****************************************************************************
190:                 // Section: Library/Stack Initialization Data
191:                 // *****************************************************************************
192:                 // *****************************************************************************
193:                 // <editor-fold defaultstate="collapsed" desc="USB Host Initialization Data"> 
194:                 
195:                 
196:                 
197:                 const USB_HOST_TPL_ENTRY USBTPList[ 1 ] =
198:                 {
199:                 	
200:                 
201:                 
202:                 
203:                 
204:                     TPL_INTERFACE_CLASS(0x02, NULL,  USB_HOST_CDC_INTERFACE),
205:                 
206:                 
207:                 };
208:                 
209:                 const USB_HOST_HCD hcdTable = 
210:                 {
211:                     .drvIndex = DRV_USBFS_INDEX_0,
212:                     .hcdInterface = DRV_USBFS_HOST_INTERFACE
213:                 };
214:                 
215:                 
216:                 const USB_HOST_INIT usbHostInitData = 
217:                 {
218:                     .nTPLEntries = 1 ,
219:                     .tplList = (USB_HOST_TPL_ENTRY *)USBTPList,
220:                     .hostControllerDrivers = (USB_HOST_HCD *)&hcdTable
221:                     
222:                 };
223:                 // </editor-fold>
224:                 
225:                 // *****************************************************************************
226:                 // *****************************************************************************
227:                 // Section: System Initialization
228:                 // *****************************************************************************
229:                 // *****************************************************************************
230:                 
231:                 /*******************************************************************************
232:                   Function:
233:                     void SYS_Initialize ( void *data )
234:                 
235:                   Summary:
236:                     Initializes the board, services, drivers, application and other modules.
237:                 
238:                   Remarks:
239:                     See prototype in system/common/sys_module.h.
240:                  */
241:                 
242:                 void SYS_Initialize ( void* data )
243:                 {
9D0063F4  27BDFFE0   ADDIU SP, SP, -32
9D0063F8  AFBF001C   SW RA, 28(SP)
9D0063FC  AFB20018   SW S2, 24(SP)
9D006400  AFB10014   SW S1, 20(SP)
9D006404  AFB00010   SW S0, 16(SP)
244:                     /* Core Processor Initialization */
245:                     SYS_CLK_Initialize( NULL );
9D006408  0F402352   JAL SYS_CLK_Initialize
9D00640C  00002021   ADDU A0, ZERO, ZERO
246:                     SYS_DEVCON_Initialize(SYS_DEVCON_INDEX_0, (SYS_MODULE_INIT*)NULL);
9D006410  00002021   ADDU A0, ZERO, ZERO
9D006414  0F4026A6   JAL SYS_DEVCON_Initialize
9D006418  00002821   ADDU A1, ZERO, ZERO
247:                     SYS_DEVCON_PerformanceConfig(SYS_CLK_SystemFrequencyGet());
9D00641C  0F4026B8   JAL SYS_CLK_SystemFrequencyGet
9D006420  3C12A000   LUI S2, -24576
9D006424  0F402440   JAL SYS_DEVCON_PerformanceConfig
9D006428  00402021   ADDU A0, V0, ZERO
248:                     SYS_PORTS_Initialize();
9D00642C  0F401EE4   JAL SYS_PORTS_Initialize
9D006430  26510620   ADDIU S1, S2, 1568
249:                 
250:                     /* Initialize Drivers */
251:                 
252:                     sysObj.drvTmr0 = DRV_TMR_Initialize(DRV_TMR_INDEX_0, (SYS_MODULE_INIT *)&drvTmr0InitData);
9D006434  00002021   ADDU A0, ZERO, ZERO
9D006438  3C059D01   LUI A1, -25343
9D00643C  0F401267   JAL DRV_TMR_Initialize
9D006440  24A58934   ADDIU A1, A1, -30412
9D006444  AE220004   SW V0, 4(S1)
253:                 
254:                     SYS_INT_VectorPrioritySet(INT_VECTOR_T1, INT_PRIORITY_LEVEL1);
255:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_T1, INT_SUBPRIORITY_LEVEL0);
256:                  
257:                  
258:                      /* Initialize USB Driver */ 
259:                     sysObj.drvUSBObject = DRV_USBFS_Initialize(DRV_USBFS_INDEX_0, (SYS_MODULE_INIT *) &drvUSBFSInit);
9D00647C  00002021   ADDU A0, ZERO, ZERO
9D006480  3C059D01   LUI A1, -25343
9D006484  0F40177A   JAL DRV_USBFS_Initialize
9D006488  24A58908   ADDIU A1, A1, -30456
9D00648C  AE220008   SW V0, 8(S1)
260:                     
261:                     /* Set priority of USB interrupt source */
262:                     SYS_INT_VectorPrioritySet(INT_VECTOR_USB1, INT_PRIORITY_LEVEL4);
263:                 
264:                     /* Set Sub-priority of USB interrupt source */
265:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_USB1, INT_SUBPRIORITY_LEVEL0);
266:                 
267:                     /* Initialize System Services */
268:                 
269:                     /*** Interrupt Service Initialization Code ***/
270:                     SYS_INT_Initialize();
9D0064C0  0F4026AB   JAL SYS_INT_Initialize
9D0064C4  00000000   NOP
271:                 
272:                     /*** TMR Service Initialization Code ***/
273:                     sysObj.sysTmr  = SYS_TMR_Initialize(SYS_TMR_INDEX_0, (const SYS_MODULE_INIT  * const)&sysTmrInitData);
9D0064C8  00002021   ADDU A0, ZERO, ZERO
9D0064CC  3C059D01   LUI A1, -25343
9D0064D0  0F401F46   JAL SYS_TMR_Initialize
9D0064D4  24A58900   ADDIU A1, A1, -30464
9D0064D8  AE420620   SW V0, 1568(S2)
274:                 
275:                     /* Initialize Middleware */
276:                  
277:                     /* Initialize the USB Host layer */
278:                     sysObj.usbHostObject0 = USB_HOST_Initialize (( SYS_MODULE_INIT *)& usbHostInitData );
9D0064DC  3C049D01   LUI A0, -25343
9D0064E0  0F401991   JAL USB_HOST_Initialize
9D0064E4  248488D8   ADDIU A0, A0, -30504
9D0064E8  AE22000C   SW V0, 12(S1)
279:                 
280:                     /* Enable Global Interrupts */
281:                     SYS_INT_Enable();
9D0064EC  40026000   MFC0 V0, Status
9D0064F0  34420001   ORI V0, V0, 1
9D0064F4  40826000   MTC0 V0, Status
9D0064F8  000000C0   EHB
282:                 
283:                     /* Initialize the Application */
284:                     APP_Initialize();
9D0064FC  0F400C10   JAL APP_Initialize
9D006500  00000000   NOP
285:                 }
9D006504  8FBF001C   LW RA, 28(SP)
286:                 
287:                 
288:                 /*******************************************************************************
289:                  End of File
290:                 */
291:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/system_exceptions.c  
1:                   /*******************************************************************************
2:                     MPLAB Harmony Exceptions Source File
3:                   
4:                     File Name:
5:                       system_exceptions.c
6:                   
7:                     Summary:
8:                       This file contains a function which overrides the deafult _weak_ exception
9:                       handler provided by the XC32 compiler.
10:                  
11:                    Description:
12:                      This file redefines the default _weak_  exception handler with a more debug
13:                      friendly one. If an unexpected exception occurs the code will stop in a
14:                      while(1) loop.  The debugger can be halted and two variables _excep_code and
15:                      _except_addr can be examined to determine the cause and address where the
16:                      exception occured.
17:                   *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013-2017 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  
45:                  #include <xc.h>                 /* Defines special function registers, CP0 regs  */
46:                  #include "system_config.h"
47:                  #include "system_definitions.h"
48:                  #include "system/debug/sys_debug.h"
49:                  
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Global Data Definitions
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  /*******************************************************************************
58:                    Exception Reason Data
59:                  
60:                    <editor-fold defaultstate="expanded" desc="Exception Reason Data">
61:                  
62:                    Remarks:
63:                      These global static items are used instead of local variables in the
64:                      _general_exception_handler function because the stack may not be available
65:                      if an exception has occured.
66:                  */
67:                  
68:                  /* Code identifying the cause of the exception (CP0 Cause register). */
69:                  static unsigned int _excep_code;
70:                  
71:                  /* Address of instruction that caused the exception. */
72:                  static unsigned int _excep_addr;
73:                  
74:                  /* Pointer to the string describing the cause of the exception. */
75:                  static char *_cause_str;
76:                  
77:                  /* Array identifying the cause (indexed by _exception_code). */
78:                  static char *cause[] =
79:                  {
80:                      "Interrupt",
81:                      "Undefined",
82:                      "Undefined",
83:                      "Undefined",
84:                      "Load/fetch address error",
85:                      "Store address error",
86:                      "Instruction bus error",
87:                      "Data bus error",
88:                      "Syscall",
89:                      "Breakpoint",
90:                      "Reserved instruction",
91:                      "Coprocessor unusable",
92:                      "Arithmetic overflow",
93:                      "Trap",
94:                      "Reserved",
95:                      "Reserved",
96:                      "Reserved",
97:                      "Reserved",
98:                      "Reserved"
99:                  };
100:                 
101:                 // </editor-fold>
102:                 
103:                 
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 // Section: Exception Handling
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 
110:                 /*******************************************************************************
111:                   Function:
112:                     void _general_exception_handler ( void )
113:                 
114:                   Summary:
115:                     Overrides the XC32 _weak_ _generic_exception_handler.
116:                 
117:                   Description:
118:                     This function overrides the XC32 default _weak_ _generic_exception_handler.
119:                 
120:                   Remarks:
121:                     Refer to the XC32 User's Guide for additional information.
122:                  */
123:                 
124:                 
125:                 void _general_exception_handler ( void )
126:                 {
9D009604  27BDFFF8   ADDIU SP, SP, -8
9D009608  AFBF0004   SW RA, 4(SP)
127:                     /* Mask off Mask of the ExcCode Field from the Cause Register
128:                     Refer to the MIPs Software User's manual */
129:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
9D00960C  40026800   MFC0 V0, Cause
9D009610  7C422080   EXT V0, V0, 2, 5
9D009614  AF828040   SW V0, -32704(GP)
130:                     _excep_addr = _CP0_GET_EPC();
9D009618  40027000   MFC0 V0, EPC
9D00961C  AF82803C   SW V0, -32708(GP)
131:                     _cause_str  = cause[_excep_code];
9D009620  8F838040   LW V1, -32704(GP)
132:                     SYS_DEBUG_PRINT(SYS_ERROR_FATAL, "\n\rGeneral Exception %s (cause=%d, addr=%x).\n\r",
133:                                     _cause_str, _excep_code, _excep_addr);
134:                 
135:                     while (1)
136:                     {
137:                         SYS_DEBUG_BreakPoint();
138:                     }
139:                 }
140:                 
141:                 /*******************************************************************************
142:                  End of File
143:                 */
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/usb/src/dynamic/usb_host_cdc.c
1:                   /*******************************************************************************
2:                     USB Host CDC Client Driver Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       usb_host_cdc.c
9:                   
10:                    Summary:
11:                      USB Host CDC Client Driver Implementation
12:                  
13:                    Description:
14:                      This file contains the implementation of the CDC Client Driver API. It
15:                      should be included in the application if the CDC Host Client Driver
16:                      functionality is desired.
17:                  *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute Software
24:                  only when embedded on a Microchip microcontroller or digital  signal  controller
25:                  that is integrated into your product or third party  product  (pursuant  to  the
26:                  sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
32:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
36:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
38:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
39:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
41:                  *******************************************************************************/
42:                  
43:                  #include "usb/usb_host_cdc.h"
44:                  #include "usb/usb_host_client_driver.h"
45:                  #include "usb/usb_host.h"
46:                  #include "usb/usb_cdc.h"
47:                  #include "usb/src/usb_host_cdc_local.h"
48:                  
49:                  /************************************************
50:                   * CDC Host Client Driver instance objects. One
51:                   * for each CDC device.
52:                   ************************************************/
53:                   USB_HOST_CDC_INSTANCE_OBJ gUSBHostCDCObj[USB_HOST_CDC_INSTANCES_NUMBER];
54:                  
55:                  /***********************************************
56:                   * USB Host CDC Attach Listener Objects
57:                   ***********************************************/
58:                   USB_HOST_CDC_ATTACH_LISTENER_OBJ gUSBHostCDCAttachListener[USB_HOST_CDC_ATTACH_LISTENERS_NUMBER];
59:                  
60:                  /************************************************
61:                   * CDC Interface to the host layer
62:                   ************************************************/
63:                  USB_HOST_CLIENT_DRIVER gUSBHostCDCClientDriver =
64:                  {
65:                      .initialize = _USB_HOST_CDC_Initialize,
66:                      .deinitialize = _USB_HOST_CDC_Deinitialize,
67:                      .reinitialize = _USB_HOST_CDC_Reinitialize,
68:                      .interfaceAssign = _USB_HOST_CDC_InterfaceAssign,
69:                      .interfaceRelease = _USB_HOST_CDC_InterfaceRelease,
70:                      .interfaceEventHandler = _USB_HOST_CDC_InterfaceEventHandler,
71:                      .interfaceTasks = _USB_HOST_CDC_InterfaceTasks,
72:                      .deviceEventHandler = _USB_HOST_CDC_DeviceEventHandler,
73:                      .deviceAssign = _USB_HOST_CDC_DeviceAssign,
74:                      .deviceRelease = _USB_HOST_CDC_DeviceRelease,
75:                      .deviceTasks = _USB_HOST_CDC_DeviceTasks
76:                  };
77:                  
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  // CDC Host Client Driver Local function
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  
84:                  // *****************************************************************************
85:                  /* Function:  
86:                      USB_HOST_CDC_RESULT _USB_HOST_CDC_HostResutlToCDCResultMap
87:                      (
88:                          USB_HOST_RESULT hostResult
89:                      )
90:                  
91:                    Summary: 
92:                      This function will map the USB Host result to CDC Result.
93:                  
94:                    Description:
95:                      This function will map the USB Host result to CDC Result.
96:                  
97:                    Remarks:
98:                      This is a local function and should not be called by directly by the
99:                      application.
100:                 */
101:                 
102:                 USB_HOST_CDC_RESULT _USB_HOST_CDC_HostResutlToCDCResultMap
103:                 (
104:                     USB_HOST_RESULT result
105:                 )
106:                 {
107:                     USB_HOST_CDC_RESULT cdcResult;
108:                   
109:                     switch(result)
9D009158  2402FF9E   ADDIU V0, ZERO, -98
9D00915C  10820010   BEQ A0, V0, 0x9D0091A0
9D009160  00000000   NOP
9D009164  2882FF9F   SLTI V0, A0, -97
9D009168  10400006   BEQ V0, ZERO, 0x9D009184
9D00916C  2403FF9F   ADDIU V1, ZERO, -97
9D009170  2403FF9C   ADDIU V1, ZERO, -100
9D009174  1083000C   BEQ A0, V1, 0x9D0091A8
9D009178  2402FF9D   ADDIU V0, ZERO, -99
9D009184  10830008   BEQ A0, V1, 0x9D0091A8
9D009188  2402FF9E   ADDIU V0, ZERO, -98
9D00918C  24030001   ADDIU V1, ZERO, 1
9D009190  10830005   BEQ A0, V1, 0x9D0091A8
9D009194  24020001   ADDIU V0, ZERO, 1
110:                     {
111:                         case USB_HOST_RESULT_SUCCESS:
112:                             cdcResult = USB_HOST_CDC_RESULT_SUCCESS;
113:                             break;
114:                         case USB_HOST_RESULT_FAILURE:
115:                             /* Note the fall through here. This is intentional */
116:                         case USB_HOST_RESULT_PARAMETER_INVALID:
117:                         case USB_HOST_RESULT_PIPE_HANDLE_INVALID:
118:                             cdcResult = USB_HOST_CDC_RESULT_FAILURE;
9D00917C  03E00008   JR RA
9D009180  2402FF9C   ADDIU V0, ZERO, -100
9D009198  03E00008   JR RA
9D00919C  2402FF9C   ADDIU V0, ZERO, -100
119:                             break;
120:                         case USB_HOST_RESULT_REQUEST_BUSY:
121:                             cdcResult = USB_HOST_CDC_RESULT_BUSY;
122:                             break;
123:                         case USB_HOST_RESULT_REQUEST_STALLED:
124:                             cdcResult = USB_HOST_CDC_RESULT_REQUEST_STALLED;
125:                             break;
126:                         case USB_HOST_RESULT_TRANSFER_ABORTED:
127:                             cdcResult = USB_HOST_CDC_RESULT_ABORTED;
128:                             break;
9D0091A0  03E00008   JR RA
9D0091A4  2402FFA1   ADDIU V0, ZERO, -95
129:                         default:
130:                             cdcResult = USB_HOST_CDC_RESULT_FAILURE;
131:                             break;
132:                     }
133:                   
134:                     return(cdcResult);
135:                 }
9D0091A8  03E00008   JR RA
136:                 
137:                 // *****************************************************************************
138:                 /* Function:
139:                     int _USB_HOST_CDC_DeviceHandleToInstance
140:                     (
141:                         USB_HOST_DEVICE_CLIENT_HANDLE deviceClientHandle
142:                     );
143:                 
144:                   Summary:
145:                     This function will return the index of the CDC object that own this device.
146:                 
147:                   Description:
148:                     This function will return the index of the CDC object that own this device.
149:                     If an instance is not found, the function will return -1.
150:                 
151:                   Remarks:
152:                     This is a local function and should not be called directly by the
153:                     application.
154:                 */
155:                 
156:                 int _USB_HOST_CDC_DeviceHandleToInstance
157:                 (
158:                     USB_HOST_DEVICE_CLIENT_HANDLE deviceClientHandle
159:                 )
160:                 {
161:                     int result = -1;
162:                     int iterator;
163:                 
164:                     for(iterator = 0; iterator < USB_HOST_CDC_INSTANCES_NUMBER; iterator++)
165:                     {
166:                         if(gUSBHostCDCObj[iterator].deviceClientHandle == deviceClientHandle)
9D009778  3C02A000   LUI V0, -24576
9D00977C  8C4204D0   LW V0, 1232(V0)
9D009780  10440007   BEQ V0, A0, 0x9D0097A0
9D009784  24030001   ADDIU V1, ZERO, 1
9D009788  3C02A000   LUI V0, -24576
9D00978C  8C42051C   LW V0, 1308(V0)
9D009790  00442026   XOR A0, V0, A0
9D009794  2402FFFF   ADDIU V0, ZERO, -1
9D009798  03E00008   JR RA
9D00979C  0064100A   MOVZ V0, V1, A0
167:                         {
168:                             result = iterator;
169:                             break;
170:                         }
171:                     }
172:                 
173:                     return(result);
174:                 }
9D0097A0  03E00008   JR RA
175:                 
176:                 // *****************************************************************************
177:                 /* Function:
178:                     int _USB_HOST_CDC_InterfaceHandleToInstance
179:                     (
180:                         USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
181:                     );
182:                 
183:                   Summary:
184:                     This function will return the index of the CDC object that own this
185:                     interface.
186:                 
187:                   Description:
188:                     This function will return the index of the CDC object that owns this
189:                     interface.  If an instance is not found, the function will return -1.
190:                 
191:                   Remarks:
192:                     This is a local function and should not be called directly by the
193:                     application.
194:                 */
195:                 
196:                 int _USB_HOST_CDC_InterfaceHandleToInstance
197:                 (
198:                     USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
199:                 )
200:                 {
201:                     int result = -1;
202:                     int iterator;
203:                 
204:                     for(iterator = 0; iterator < USB_HOST_CDC_INSTANCES_NUMBER; iterator++)
9D008F80  03E00008   JR RA
9D008F84  00001021   ADDU V0, ZERO, ZERO
9D008F88  03E00008   JR RA
9D008F8C  00001021   ADDU V0, ZERO, ZERO
205:                     {
206:                         if((gUSBHostCDCObj[iterator].communicationInterfaceHandle == interfaceHandle) ||
9D008F38  3C02A000   LUI V0, -24576
9D008F3C  8C4204DC   LW V0, 1244(V0)
9D008F40  1044000F   BEQ V0, A0, 0x9D008F80
9D008F44  00000000   NOP
9D008F4C  8C4204D8   LW V0, 1240(V0)
9D008F50  1044000D   BEQ V0, A0, 0x9D008F88
9D008F54  00000000   NOP
9D008F58  3C02A000   LUI V0, -24576
9D008F5C  8C420528   LW V0, 1320(V0)
9D008F60  1044000B   BEQ V0, A0, 0x9D008F90
9D008F64  24030001   ADDIU V1, ZERO, 1
9D008F6C  8C420524   LW V0, 1316(V0)
9D008F70  00442026   XOR A0, V0, A0
9D008F74  2402FFFF   ADDIU V0, ZERO, -1
9D008F78  03E00008   JR RA
9D008F7C  0064100A   MOVZ V0, V1, A0
207:                             (gUSBHostCDCObj[iterator].dataInterfaceHandle == interfaceHandle))
9D008F48  3C02A000   LUI V0, -24576
9D008F68  3C02A000   LUI V0, -24576
208:                 
209:                         {
210:                             result = iterator;
211:                             break;
212:                         }
213:                     }
214:                 
215:                     return(result);
216:                 }
9D008F90  03E00008   JR RA
217:                 
218:                 // *****************************************************************************
219:                 /* Function:
220:                     int _USB_HOST_CDC_DeviceObjHandleToInstance
221:                     (
222:                         USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle
223:                     );
224:                 
225:                   Summary:
226:                     This function will return the index of the CDC object that is associated
227:                     with this device.
228:                 
229:                   Description:
230:                     This function will return the index of the CDC object that is associated
231:                     with this device.
232:                 
233:                   Remarks:
234:                     This is a local function and should not be called directly by the
235:                     application.
236:                 */
237:                 
238:                 int _USB_HOST_CDC_DeviceObjHandleToInstance
239:                 (
240:                     USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle
241:                 )
242:                 {
243:                     int result = -1;
244:                     int iterator;
245:                 
246:                     for(iterator = 0; iterator < USB_HOST_CDC_INSTANCES_NUMBER; iterator++)
247:                     {
248:                         if(gUSBHostCDCObj[iterator].deviceObjHandle == deviceObjHandle) 
9D0097A8  3C02A000   LUI V0, -24576
9D0097AC  8C4204D4   LW V0, 1236(V0)
9D0097B0  10440007   BEQ V0, A0, 0x9D0097D0
9D0097B4  24030001   ADDIU V1, ZERO, 1
9D0097B8  3C02A000   LUI V0, -24576
9D0097BC  8C420520   LW V0, 1312(V0)
9D0097C0  00442026   XOR A0, V0, A0
9D0097C4  2402FFFF   ADDIU V0, ZERO, -1
9D0097C8  03E00008   JR RA
9D0097CC  0064100A   MOVZ V0, V1, A0
249:                         {
250:                             result = iterator;
251:                             break;
252:                         }
253:                     }
254:                 
255:                     return(result);
256:                 }
9D0097D0  03E00008   JR RA
257:                 
258:                 // *****************************************************************************
259:                 /* Function:
260:                     void _USB_HOST_CDC_Initialize(void * msdInitData)
261:                 
262:                   Summary:
263:                     This function is called when the Host Layer is initializing.
264:                 
265:                   Description:
266:                     This function is called when the Host Layer is initializing.
267:                 
268:                   Remarks:
269:                     This is a local function and should not be called directly by the
270:                     application.
271:                 */
272:                 
273:                 void _USB_HOST_CDC_Initialize(void * data)
274:                 {
275:                     int iterator;
276:                     USB_HOST_CDC_INSTANCE_OBJ * cdcInstanceObj;
277:                 
278:                     for(iterator = 0; iterator < USB_HOST_CDC_INSTANCES_NUMBER; iterator ++)
279:                     {
280:                         /* Set the pipes handles to invalid */
281:                         cdcInstanceObj = &gUSBHostCDCObj[iterator];
282:                         cdcInstanceObj->deviceClientHandle = USB_HOST_DEVICE_CLIENT_HANDLE_INVALID;
9D00967C  3C02A000   LUI V0, -24576
9D009680  244204CC   ADDIU V0, V0, 1228
9D009684  2403FFFF   ADDIU V1, ZERO, -1
9D009688  AC430004   SW V1, 4(V0)
9D00969C  AC430050   SW V1, 80(V0)
283:                         cdcInstanceObj->bulkInPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D00968C  AC430018   SW V1, 24(V0)
9D0096A0  AC430064   SW V1, 100(V0)
284:                         cdcInstanceObj->bulkOutPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D009690  AC43001C   SW V1, 28(V0)
9D0096A4  AC430068   SW V1, 104(V0)
285:                         cdcInstanceObj->interruptPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D009694  AC430020   SW V1, 32(V0)
9D0096A8  AC43006C   SW V1, 108(V0)
286:                         cdcInstanceObj->deviceObjHandle = USB_HOST_DEVICE_OBJ_HANDLE_INVALID;
9D009698  AC430008   SW V1, 8(V0)
9D0096AC  03E00008   JR RA
287:                     }
288:                 }
289:                 
290:                 // *****************************************************************************
291:                 /* Function:
292:                     void _USB_HOST_CDC_Deinitialize(void)
293:                 
294:                   Summary:
295:                     This function is called when the Host Layer is deinitializing.
296:                 
297:                   Description:
298:                     This function is called when the Host Layer is deinitializing.
299:                 
300:                   Remarks:
301:                     This is a local function and should not be called directly by the
302:                     application.
303:                 */
304:                 
305:                 void _USB_HOST_CDC_Deinitialize(void)
306:                 {
9D009B1C  03E00008   JR RA
307:                     /* This function is not implemented in this release of the USB Host stack */
308:                 }
309:                 
310:                 // *****************************************************************************
311:                 /* Function:
312:                     void _USB_HOST_CDC_Reinitialize(void)
313:                 
314:                   Summary:
315:                     This function is called when the Host Layer is reinitializing.
316:                 
317:                   Description:
318:                     This function is called when the Host Layer is reinitializing.
319:                 
320:                   Remarks:
321:                     This is a local function and should not be called directly by the
322:                     application.
323:                 */
324:                 
325:                 void _USB_HOST_CDC_Reinitialize(void * msdInitData)
326:                 {
9D009B24  03E00008   JR RA
327:                     /* This function is not implemented in this release of the driver */
328:                 }
329:                 
330:                 // *****************************************************************************
331:                 /* Function:
332:                     void _USB_HOST_CDC_DeviceAssign 
333:                     (
334:                         USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
335:                         USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle,
336:                         USB_DEVICE_DESCRIPTOR * deviceDescriptor
337:                     )
338:                  
339:                   Summary: 
340:                     This function is called when the host layer finds device level class
341:                     subclass protocol match.
342:                 
343:                   Description:
344:                     This function is called when the host layer finds device level class
345:                     subclass protocol match.
346:                 
347:                   Remarks:
348:                     This is a local function and should not be called directly by the
349:                     application.
350:                 */
351:                 
352:                 void _USB_HOST_CDC_DeviceAssign 
353:                 (
354:                     USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
355:                     USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle,
356:                     USB_DEVICE_DESCRIPTOR * deviceDescriptor
357:                 )
358:                 {
9D007FFC  27BDFFE8   ADDIU SP, SP, -24
9D008000  AFBF0014   SW RA, 20(SP)
9D008004  AFB00010   SW S0, 16(SP)
359:                     int iterator;
360:                     USB_HOST_CDC_INSTANCE_OBJ * cdcInstanceObj = NULL;
361:                 
362:                     /* If this function is being called, this means that a device class subclass
363:                      * protocol match was obtained.  Look for a free instance */
364:                 
365:                     for(iterator = 0; iterator < USB_HOST_CDC_INSTANCES_NUMBER; iterator ++)
9D00802C  00001021   ADDU V0, ZERO, ZERO
366:                     {
367:                         /* Search for an available CDC instance object */
368:                         if(!gUSBHostCDCObj[iterator].inUse)
9D008008  3C02A000   LUI V0, -24576
9D00800C  904204CC   LBU V0, 1228(V0)
9D008010  10400006   BEQ V0, ZERO, 0x9D00802C
9D008014  3C02A000   LUI V0, -24576
9D008018  90420518   LBU V0, 1304(V0)
9D00801C  14400015   BNE V0, ZERO, 0x9D008074
9D008020  24020001   ADDIU V0, ZERO, 1
9D008024  0B40200D   J 0x9D008034
9D008028  00023880   SLL A3, V0, 2
369:                         {
370:                             /* Allocate the object */
371:                             cdcInstanceObj = &gUSBHostCDCObj[iterator];
9D008030  00023880   SLL A3, V0, 2
9D008034  00021900   SLL V1, V0, 4
9D008038  00E31821   ADDU V1, A3, V1
9D00803C  00621023   SUBU V0, V1, V0
9D008040  00021080   SLL V0, V0, 2
9D008044  3C10A000   LUI S0, -24576
9D008048  261004CC   ADDIU S0, S0, 1228
9D00804C  02028021   ADDU S0, S0, V0
372:                             cdcInstanceObj->inUse = true;
9D008050  24020001   ADDIU V0, ZERO, 1
9D008054  A2020000   SB V0, 0(S0)
373:                             cdcInstanceObj->deviceObjHandle = deviceObjHandle;
9D008058  AE050008   SW A1, 8(S0)
374:                             cdcInstanceObj->deviceClientHandle = deviceHandle;
9D00805C  AE040004   SW A0, 4(S0)
375:                             break;
376:                         }
377:                     }
378:                 
379:                     if(cdcInstanceObj == NULL)
380:                     {
381:                         /* This means an instance could not be allocated. Return the device back
382:                          * to the host */
383:                         USB_HOST_DeviceRelease(deviceHandle);
9D008074  0F4022CA   JAL USB_HOST_DeviceRelease
9D008078  00000000   NOP
9D00807C  0B402028   J 0x9D0080A0
9D008080  8FBF0014   LW RA, 20(SP)
384:                     }
385:                     else
386:                     {
387:                         /* An instance object was allocated. Check if the device has any
388:                          * configurations */
389:                 
390:                         if(deviceDescriptor->bNumConfigurations > 0)
9D008060  90C20011   LBU V0, 17(A2)
9D008064  5040000C   BEQL V0, ZERO, 0x9D008098
9D008068  2402FFFF   ADDIU V0, ZERO, -1
9D00806C  0B402021   J 0x9D008084
9D008070  24020001   ADDIU V0, ZERO, 1
391:                         {
392:                             /* This means we have configurations. We can try setting the first 
393:                              * configuration. Also open the control pipe to the device. */
394:                             cdcInstanceObj->state = USB_HOST_CDC_STATE_SET_CONFIGURATION;
9D008084  AE020034   SW V0, 52(S0)
395:                             cdcInstanceObj->controlPipeHandle = USB_HOST_DeviceControlPipeOpen(deviceObjHandle);
9D008088  0F4024D1   JAL USB_HOST_DeviceControlPipeOpen
9D00808C  00A02021   ADDU A0, A1, ZERO
9D008090  0B402027   J 0x9D00809C
9D008094  AE020014   SW V0, 20(S0)
396:                         }
397:                         else
398:                         {
399:                             /* There are no configurations! Move to error state */
400:                             cdcInstanceObj->state = USB_HOST_CDC_STATE_ERROR;
9D008098  AE020034   SW V0, 52(S0)
401:                         }
402:                     }
403:                 }
9D00809C  8FBF0014   LW RA, 20(SP)
404:                  
405:                 // *****************************************************************************
406:                 /* Function:
407:                     void _USB_HOST_CDC_DeviceRelease 
408:                     (
409:                         USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle
410:                     )
411:                  
412:                   Summary: 
413:                     This function is called when the device is detached. 
414:                 
415:                   Description:
416:                     This function is called when the device is detached. 
417:                 
418:                   Remarks:
419:                     This is a local function and should not be called directly by the
420:                     application.
421:                 */
422:                 
423:                 void _USB_HOST_CDC_DeviceRelease
424:                 (
425:                     USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle
426:                 )
427:                 {
9D007470  27BDFFE8   ADDIU SP, SP, -24
9D007474  AFBF0014   SW RA, 20(SP)
428:                     int index;
429:                     USB_HOST_CDC_INSTANCE_OBJ * cdcInstance;
430:                 
431:                     /* Find the CDC instance object that owns this device */
432:                     index = _USB_HOST_CDC_DeviceHandleToInstance(deviceHandle);
9D007478  0F4025DE   JAL _USB_HOST_CDC_DeviceHandleToInstance
9D00747C  AFB00010   SW S0, 16(SP)
433:                 
434:                     if(index >= 0)
9D007480  0440002C   BLTZ V0, 0x9D007534
9D007484  00028080   SLL S0, V0, 2
435:                     {
436:                         cdcInstance = &gUSBHostCDCObj[index];
9D007488  00021900   SLL V1, V0, 4
9D00748C  02038021   ADDU S0, S0, V1
9D007490  02021023   SUBU V0, S0, V0
9D007494  00021080   SLL V0, V0, 2
9D007498  3C10A000   LUI S0, -24576
9D00749C  261004CC   ADDIU S0, S0, 1228
9D0074A0  02028021   ADDU S0, S0, V0
437:                         cdcInstance->inUse = false;
9D0074A4  A2000000   SB ZERO, 0(S0)
438:                 
439:                         if(cdcInstance->bulkInPipeHandle != USB_HOST_PIPE_HANDLE_INVALID)
9D0074A8  8E040018   LW A0, 24(S0)
9D0074AC  2402FFFF   ADDIU V0, ZERO, -1
9D0074B0  50820007   BEQL A0, V0, 0x9D0074D0
9D0074B4  8E04001C   LW A0, 28(S0)
440:                         {
441:                             /* Close the bulk in pipe and invalidate the pipe handle */
442:                             USB_HOST_DevicePipeClose(cdcInstance->bulkInPipeHandle);
9D0074B8  0F4020CD   JAL USB_HOST_DevicePipeClose
9D0074BC  00000000   NOP
443:                             cdcInstance->bulkInPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D0074C0  2402FFFF   ADDIU V0, ZERO, -1
9D0074C4  AE020018   SW V0, 24(S0)
444:                         }
445:                         
446:                         if(cdcInstance->bulkOutPipeHandle != USB_HOST_PIPE_HANDLE_INVALID)
9D0074C8  8E04001C   LW A0, 28(S0)
9D0074CC  2402FFFF   ADDIU V0, ZERO, -1
9D0074D0  50820006   BEQL A0, V0, 0x9D0074EC
9D0074D4  8E040020   LW A0, 32(S0)
447:                         {
448:                             /* Close the bulk Out pipe and invalidate the pipe handle */
449:                             USB_HOST_DevicePipeClose(cdcInstance->bulkOutPipeHandle);
9D0074D8  0F4020CD   JAL USB_HOST_DevicePipeClose
9D0074DC  00000000   NOP
450:                             cdcInstance->bulkOutPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D0074E0  2402FFFF   ADDIU V0, ZERO, -1
9D0074E4  AE02001C   SW V0, 28(S0)
451:                         }
452:                 
453:                         if(cdcInstance->interruptPipeHandle != USB_HOST_PIPE_HANDLE_INVALID)
9D0074E8  8E040020   LW A0, 32(S0)
9D0074EC  2402FFFF   ADDIU V0, ZERO, -1
9D0074F0  50820006   BEQL A0, V0, 0x9D00750C
9D0074F4  8E020030   LW V0, 48(S0)
454:                         {
455:                             /* Close the interruptPipeHandle pipe handle and invalidate the pipe
456:                              * handle */
457:                             USB_HOST_DevicePipeClose(cdcInstance->interruptPipeHandle);
9D0074F8  0F4020CD   JAL USB_HOST_DevicePipeClose
9D0074FC  00000000   NOP
458:                             cdcInstance->interruptPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D007500  2402FFFF   ADDIU V0, ZERO, -1
9D007504  AE020020   SW V0, 32(S0)
459:                         }
460:                 
461:                         if(cdcInstance->eventHandler != NULL)
9D007508  8E020030   LW V0, 48(S0)
9D00750C  10400005   BEQ V0, ZERO, 0x9D007524
9D007510  02002021   ADDU A0, S0, ZERO
462:                         {
463:                             /* Let the client know that the device is detached */
464:                             cdcInstance->eventHandler((USB_HOST_CDC_HANDLE)(cdcInstance), 
9D007514  24050007   ADDIU A1, ZERO, 7
9D007518  00003021   ADDU A2, ZERO, ZERO
9D00751C  0040F809   JALR V0
9D007520  8E07002C   LW A3, 44(S0)
465:                                     USB_HOST_CDC_EVENT_DEVICE_DETACHED,
466:                                     NULL, cdcInstance->context);
467:                         }
468:                 
469:                         /* Release the object */
470:                         cdcInstance->eventHandler = NULL;
9D007524  AE000030   SW ZERO, 48(S0)
471:                         cdcInstance->deviceObjHandle = USB_HOST_DEVICE_OBJ_HANDLE_INVALID;
9D007528  2402FFFF   ADDIU V0, ZERO, -1
9D00752C  AE020008   SW V0, 8(S0)
472:                         cdcInstance->deviceClientHandle = USB_HOST_DEVICE_CLIENT_HANDLE_INVALID;
9D007530  AE020004   SW V0, 4(S0)
473:                         
474:                     }
475:                 }
9D007534  8FBF0014   LW RA, 20(SP)
476:                 
477:                 // *****************************************************************************
478:                 /* Function:
479:                     void _USB_HOST_CDC_DeviceTasks 
480:                     (
481:                         USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle
482:                     )
483:                  
484:                   Summary: 
485:                     This function is called when the host layer want the device to update its
486:                     state. 
487:                 
488:                   Description:
489:                     This function is called when the host layer want the device to update its
490:                     state. 
491:                 
492:                   Remarks:
493:                     This is a local function and should not be called directly by the
494:                     application.
495:                 */
496:                 
497:                 void _USB_HOST_CDC_DeviceTasks
498:                 (
499:                     USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle
500:                 )
501:                 {
9D006760  27BDFFE0   ADDIU SP, SP, -32
9D006764  AFBF001C   SW RA, 28(SP)
502:                     int index, iterator;
503:                     USB_HOST_CDC_INSTANCE_OBJ * cdcInstance;
504:                     USB_HOST_RESULT result;
505:                     USB_HOST_REQUEST_HANDLE requestHandle;
506:                 
507:                     /* Get the index of the device instance */
508:                     index = _USB_HOST_CDC_DeviceHandleToInstance(deviceHandle);
9D006768  0F4025DE   JAL _USB_HOST_CDC_DeviceHandleToInstance
9D00676C  AFB00018   SW S0, 24(SP)
509:                 
510:                     if(index >= 0)
9D006770  0440003E   BLTZ V0, 0x9D00686C
9D006774  00028080   SLL S0, V0, 2
511:                     {
512:                         /* Get a pointer to the instance */
513:                         cdcInstance = &gUSBHostCDCObj[index];
9D006778  00021900   SLL V1, V0, 4
9D00677C  02038021   ADDU S0, S0, V1
9D006780  02021023   SUBU V0, S0, V0
9D006784  00021080   SLL V0, V0, 2
9D006788  3C10A000   LUI S0, -24576
9D00678C  261004CC   ADDIU S0, S0, 1228
9D006790  02028021   ADDU S0, S0, V0
514:                         
515:                         if(cdcInstance->inUse)
9D006794  92020000   LBU V0, 0(S0)
9D006798  10400034   BEQ V0, ZERO, 0x9D00686C
9D00679C  24030002   ADDIU V1, ZERO, 2
516:                         {
517:                             /* Instance is valid */
518:                             switch(cdcInstance->state)
9D0067A0  8E020034   LW V0, 52(S0)
9D0067A4  10430011   BEQ V0, V1, 0x9D0067EC
9D0067A8  24030003   ADDIU V1, ZERO, 3
9D0067AC  1043001A   BEQ V0, V1, 0x9D006818
9D0067B0  24030001   ADDIU V1, ZERO, 1
9D0067B4  1443002E   BNE V0, V1, 0x9D006870
9D0067B8  8FBF001C   LW RA, 28(SP)
519:                             {
520:                                 case USB_HOST_CDC_STATE_NOT_READY:
521:                 
522:                                     /* The instance is not ready. We dont do anything yet */
523:                                     break;
524:                 
525:                                 case USB_HOST_CDC_STATE_SET_CONFIGURATION:
526:                 
527:                                     /* The instance should set the configuration. We clear the
528:                                      * controlTransferDone flag. This will be set in the device
529:                                      * event handler when the configuration set event is received. */
530:                                     
531:                                     cdcInstance->hostRequestDone = false;
9D0067BC  A2000038   SB ZERO, 56(S0)
532:                                     result = USB_HOST_DeviceConfigurationSet(cdcInstance->deviceClientHandle, &requestHandle, 
9D0067C0  8E040004   LW A0, 4(S0)
9D0067C4  27A50010   ADDIU A1, SP, 16
9D0067C8  00003021   ADDU A2, ZERO, ZERO
9D0067CC  0F401DB8   JAL USB_HOST_DeviceConfigurationSet
9D0067D0  02003821   ADDU A3, S0, ZERO
533:                                             0, (uintptr_t)(cdcInstance));
534:                                     
535:                                     if(result == USB_HOST_RESULT_SUCCESS)
9D0067D4  24030001   ADDIU V1, ZERO, 1
9D0067D8  14430025   BNE V0, V1, 0x9D006870
9D0067DC  8FBF001C   LW RA, 28(SP)
536:                                     {
537:                                         /* The result was successful. Change state to wating for
538:                                          * configuration. */
539:                                         cdcInstance->state = USB_HOST_CDC_STATE_WAIT_FOR_CONFIGURATION_SET;
9D0067E0  24020002   ADDIU V0, ZERO, 2
9D0067E4  0B401A1B   J 0x9D00686C
9D0067E8  AE020034   SW V0, 52(S0)
540:                                     }
541:                                     break;
542:                 
543:                                 case USB_HOST_CDC_STATE_WAIT_FOR_CONFIGURATION_SET:
544:                 
545:                                     /* Here we are waiting for the configuration to be set */
546:                                     if(cdcInstance->hostRequestDone == true) 
9D0067EC  92020038   LBU V0, 56(S0)
9D0067F0  1040001E   BEQ V0, ZERO, 0x9D00686C
9D0067F4  24020001   ADDIU V0, ZERO, 1
547:                                     {
548:                                         if(cdcInstance->hostRequestResult == USB_HOST_RESULT_SUCCESS)
9D0067F8  8E03003C   LW V1, 60(S0)
9D0067FC  14620004   BNE V1, V0, 0x9D006810
9D006800  2402FFFF   ADDIU V0, ZERO, -1
549:                                         {
550:                                             /* The configuration has been set. Now wait for the host
551:                                              * layer to send the communication and the data
552:                                              * interface to the client driver */
553:                 
554:                                             cdcInstance->state = USB_HOST_CDC_STATE_WAIT_FOR_INTERFACES;
9D006804  24020003   ADDIU V0, ZERO, 3
9D006808  0B401A1B   J 0x9D00686C
9D00680C  AE020034   SW V0, 52(S0)
555:                                         }
556:                                         else
557:                                         {
558:                                             /* If we could not set the configuration, then state
559:                                              * instance state to error */
560:                                             cdcInstance->state = USB_HOST_CDC_STATE_ERROR;
9D006810  0B401A1B   J 0x9D00686C
9D006814  AE020034   SW V0, 52(S0)
561:                                         }
562:                                     }
563:                                     break;
564:                 
565:                                 case USB_HOST_CDC_STATE_WAIT_FOR_INTERFACES:
566:                 
567:                                     /* Here we wait for both the interfaces to get ready */
568:                                     if((cdcInstance->interruptPipeHandle != USB_HOST_PIPE_HANDLE_INVALID) &&
9D006818  8E030020   LW V1, 32(S0)
9D00681C  2402FFFF   ADDIU V0, ZERO, -1
9D006820  10620013   BEQ V1, V0, 0x9D006870
9D006824  8FBF001C   LW RA, 28(SP)
9D006828  8E030018   LW V1, 24(S0)
9D00682C  50620011   BEQL V1, V0, 0x9D006874
9D006830  8FB00018   LW S0, 24(SP)
569:                                             (cdcInstance->bulkInPipeHandle != USB_HOST_PIPE_HANDLE_INVALID) &&
9D006834  8E03001C   LW V1, 28(S0)
9D006838  1062000D   BEQ V1, V0, 0x9D006870
9D00683C  24020004   ADDIU V0, ZERO, 4
570:                                             (cdcInstance->bulkOutPipeHandle != USB_HOST_PIPE_HANDLE_INVALID))
571:                                     {
572:                                         /* Set the state to ready */
573:                                         cdcInstance->state = USB_HOST_CDC_STATE_READY;
9D006840  AE020034   SW V0, 52(S0)
574:                                         
575:                                         /* We know that the client driver is now ready. We can 
576:                                          * let all the listeners know that the device has been
577:                                          * attached */
578:                                         
579:                                         for(iterator = 0; iterator < USB_HOST_CDC_ATTACH_LISTENERS_NUMBER; iterator ++)
580:                                         {
581:                                             if(gUSBHostCDCAttachListener[iterator].inUse)
9D006844  3C02A000   LUI V0, -24576
9D006848  90420564   LBU V0, 1380(V0)
9D00684C  10400008   BEQ V0, ZERO, 0x9D006870
9D006850  8FBF001C   LW RA, 28(SP)
582:                                             {
583:                                                 /* Call the attach listener event handler 
584:                                                  * function. */
585:                                                 gUSBHostCDCAttachListener[iterator].eventHandler((USB_HOST_CDC_OBJ)(cdcInstance), 
9D006854  3C02A000   LUI V0, -24576
9D006858  24420564   ADDIU V0, V0, 1380
9D00685C  8C430004   LW V1, 4(V0)
9D006860  02002021   ADDU A0, S0, ZERO
9D006864  0060F809   JALR V1
9D006868  8C450008   LW A1, 8(V0)
586:                                                         gUSBHostCDCAttachListener[iterator].context);
587:                                             }
588:                                         }
589:                                     }
590:                                             
591:                                     break;
592:                                     
593:                                 case USB_HOST_CDC_STATE_READY:
594:                                     
595:                                     /* The CDC client driver is ready to be opened */
596:                                     break;
597:                 
598:                                 case USB_HOST_CDC_STATE_ERROR:
599:                 
600:                                     /* The instance is an error state. We dont do anything here */
601:                                     break;
602:                 
603:                             }
604:                         }
605:                     }
606:                 }
9D00686C  8FBF001C   LW RA, 28(SP)
607:                 
608:                 // *****************************************************************************
609:                 /* Function:
610:                     void _USB_HOST_CDC_InterfaceAssign 
611:                     (
612:                         USB_HOST_DEVICE_INTERFACE_HANDLE * interfaces,
613:                         USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle,
614:                         size_t nInterfaces,
615:                         uint8_t * descriptor
616:                     )
617:                 
618:                   Summary:
619:                     This function is called when the Host Layer attaches this driver to an
620:                     interface.
621:                 
622:                   Description:
623:                     This function is called when the Host Layer attaches this driver to an
624:                     interface.
625:                 
626:                   Remarks:
627:                     This is a local function and should not be called directly by the
628:                     application.
629:                 */
630:                 
631:                 void _USB_HOST_CDC_InterfaceAssign 
632:                 (
633:                     USB_HOST_DEVICE_INTERFACE_HANDLE * interfaces,
634:                     USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle,
635:                     size_t nInterfaces,
636:                     uint8_t * descriptor
637:                 )
638:                 {
9D001F84  27BDFFA0   ADDIU SP, SP, -96
9D001F88  AFBF005C   SW RA, 92(SP)
9D001F8C  AFB70058   SW S7, 88(SP)
9D001F90  AFB60054   SW S6, 84(SP)
9D001F94  AFB50050   SW S5, 80(SP)
9D001F98  AFB4004C   SW S4, 76(SP)
9D001F9C  AFB30048   SW S3, 72(SP)
9D001FA0  AFB20044   SW S2, 68(SP)
9D001FA4  AFB10040   SW S1, 64(SP)
9D001FA8  AFB0003C   SW S0, 60(SP)
9D001FAC  00808821   ADDU S1, A0, ZERO
639:                     int cdcInstanceIndex, iterator;
640:                     USB_HOST_CDC_INSTANCE_OBJ * cdcInstance = NULL;
641:                     USB_INTERFACE_DESCRIPTOR * interfaceDescriptor;
642:                     USB_ENDPOINT_DESCRIPTOR * endpointDescriptor;
643:                     USB_HOST_ENDPOINT_DESCRIPTOR_QUERY endpointDescriptorQuery;
644:                     USB_HOST_INTERFACE_DESCRIPTOR_QUERY interfaceDescriptorQuery; 
645:                 
646:                     /* This function will be called when there is an interface level match.
647:                      * There are two possible cases here. In case of a simple CDC device, the
648:                      * driver would have matched at the device level in which case the device Client
649:                      * handle will not be invalid. Or else this driver matched at the interface
650:                      * level because this is a composite device. */
651:                 
652:                     /* If the number of interfaces passed to this function is 1, then we know
653:                      * this is a single interface */
654:                 
655:                     if(nInterfaces == 1)
9D001FB0  24020001   ADDIU V0, ZERO, 1
9D001FB4  14C20063   BNE A2, V0, 0x9D002144
9D001FB8  00E09021   ADDU S2, A3, ZERO
656:                     {
657:                         /* One one interface was passed. This means there was device level class
658:                          * subclass protocol match. The device must aleady exist in the system */
659:                 
660:                         cdcInstanceIndex = _USB_HOST_CDC_DeviceObjHandleToInstance(deviceObjHandle);
9D001FBC  0F4025EA   JAL _USB_HOST_CDC_DeviceObjHandleToInstance
9D001FC0  00A02021   ADDU A0, A1, ZERO
661:                         if(cdcInstanceIndex >= 0)
9D001FC4  0440005B   BLTZ V0, 0x9D002134
9D001FC8  00022080   SLL A0, V0, 2
662:                         {
663:                             /* Found the instance index that owns this object */
664:                             cdcInstance = &gUSBHostCDCObj[cdcInstanceIndex];
9D001FCC  00021900   SLL V1, V0, 4
9D001FD0  00831821   ADDU V1, A0, V1
9D001FD4  00621023   SUBU V0, V1, V0
9D001FD8  00021080   SLL V0, V0, 2
9D001FDC  3C03A000   LUI V1, -24576
9D001FE0  246304CC   ADDIU V1, V1, 1228
9D001FE4  00628021   ADDU S0, V1, V0
665:                 
666:                             /* Get the interface descriptor. We know this is an interface
667:                              * descriptor because the number of interfaces is 1 */
668:                             interfaceDescriptor = (USB_INTERFACE_DESCRIPTOR *)descriptor;
669:                 
670:                             if((interfaceDescriptor->bInterfaceClass == USB_CDC_COMMUNICATIONS_INTERFACE_CLASS_CODE) &&
9D001FE8  92430005   LBU V1, 5(S2)
9D001FEC  24040002   ADDIU A0, ZERO, 2
9D001FF0  1464001E   BNE V1, A0, 0x9D00206C
9D001FF4  2402000A   ADDIU V0, ZERO, 10
9D001FF8  92430006   LBU V1, 6(S2)
9D001FFC  24020002   ADDIU V0, ZERO, 2
9D002000  14620048   BNE V1, V0, 0x9D002124
9D002004  24020001   ADDIU V0, ZERO, 1
671:                                     (interfaceDescriptor->bInterfaceSubClass == USB_CDC_SUBCLASS_ABSTRACT_CONTROL_MODEL) &&
9D002008  92430007   LBU V1, 7(S2)
9D00200C  14620045   BNE V1, V0, 0x9D002124
9D002010  00000000   NOP
672:                                     (interfaceDescriptor->bInterfaceProtocol == USB_CDC_PROTOCOL_AT_V250))
673:                             {
674:                                 /* This interface is the communications class interface. Get the
675:                                  * endpoint number */
676:                                 cdcInstance->communicationInterfaceHandle = interfaces[0];
9D002014  8E220000   LW V0, 0(S1)
9D002018  AE020010   SW V0, 16(S0)
677:                                 cdcInstance->commInterfaceNumber = interfaceDescriptor->bInterfaceNumber;
9D00201C  92420002   LBU V0, 2(S2)
9D002020  A2020048   SB V0, 72(S0)
678:                                 USB_HOST_DeviceEndpointQueryContextClear(&endpointDescriptorQuery);
9D002024  0F4026B0   JAL USB_HOST_DeviceEndpointQueryContextClear
9D002028  27A40010   ADDIU A0, SP, 16
679:                                 endpointDescriptorQuery.transferType = USB_TRANSFER_TYPE_INTERRUPT;
9D00202C  24020003   ADDIU V0, ZERO, 3
9D002030  AFA20014   SW V0, 20(SP)
680:                                 endpointDescriptorQuery.direction = USB_DATA_DIRECTION_DEVICE_TO_HOST;
9D002034  24020001   ADDIU V0, ZERO, 1
9D002038  AFA20018   SW V0, 24(SP)
681:                                 endpointDescriptorQuery.flags = USB_HOST_ENDPOINT_QUERY_BY_TRANSFER_TYPE|USB_HOST_ENDPOINT_QUERY_BY_DIRECTION;
9D00203C  24020006   ADDIU V0, ZERO, 6
9D002040  AFA2001C   SW V0, 28(SP)
682:                                 endpointDescriptor = USB_HOST_DeviceEndpointDescriptorQuery(interfaceDescriptor, &endpointDescriptorQuery);
9D002044  02402021   ADDU A0, S2, ZERO
9D002048  0F401518   JAL USB_HOST_DeviceEndpointDescriptorQuery
9D00204C  27A50010   ADDIU A1, SP, 16
683:                 
684:                                 /* Did we find the endpoint? */
685:                                 if(endpointDescriptor != NULL)
9D002050  104000DA   BEQ V0, ZERO, 0x9D0023BC
9D002054  8FBF005C   LW RA, 92(SP)
686:                                 {
687:                                     /* Found the endpoint. Open the pipe. If the pipe was not
688:                                      * opened, the device will never move to a ready state. */
689:                                     cdcInstance->interruptPipeHandle = USB_HOST_DevicePipeOpen(cdcInstance->communicationInterfaceHandle, endpointDescriptor->bEndpointAddress);
9D002058  8E040010   LW A0, 16(S0)
9D00205C  0F400F57   JAL USB_HOST_DevicePipeOpen
9D002060  90450002   LBU A1, 2(V0)
9D002064  0B4008EE   J 0x9D0023B8
9D002068  AE020020   SW V0, 32(S0)
690:                                 }
691:                             }
692:                             else if((interfaceDescriptor->bInterfaceClass == USB_CDC_DATA_INTERFACE_CLASS_CODE) &&
9D00206C  1462002D   BNE V1, V0, 0x9D002124
9D002070  00000000   NOP
9D002074  92420006   LBU V0, 6(S2)
9D002078  1440002A   BNE V0, ZERO, 0x9D002124
9D00207C  00000000   NOP
693:                                     (interfaceDescriptor->bInterfaceSubClass == 0x0) &&
9D002080  92420007   LBU V0, 7(S2)
9D002084  14400027   BNE V0, ZERO, 0x9D002124
9D002088  00000000   NOP
694:                                     (interfaceDescriptor->bInterfaceProtocol == USB_CDC_PROTOCOL_NO_CLASS_SPECIFIC))
695:                             {
696:                                 /* This is the data interface */
697:                                 cdcInstance->dataInterfaceHandle = interfaces[0];
9D00208C  8E220000   LW V0, 0(S1)
9D002090  AE02000C   SW V0, 12(S0)
698:                                 cdcInstance->dataInterfaceNumber = interfaceDescriptor->bInterfaceNumber;
9D002094  92420002   LBU V0, 2(S2)
9D002098  A2020049   SB V0, 73(S0)
699:                                 USB_HOST_DeviceEndpointQueryContextClear(&endpointDescriptorQuery);
9D00209C  0F4026B0   JAL USB_HOST_DeviceEndpointQueryContextClear
9D0020A0  27A40010   ADDIU A0, SP, 16
700:                                 endpointDescriptorQuery.transferType = USB_TRANSFER_TYPE_BULK;
9D0020A4  24020002   ADDIU V0, ZERO, 2
9D0020A8  AFA20014   SW V0, 20(SP)
701:                                 endpointDescriptorQuery.direction = USB_DATA_DIRECTION_DEVICE_TO_HOST;
9D0020AC  24020001   ADDIU V0, ZERO, 1
9D0020B0  AFA20018   SW V0, 24(SP)
702:                                 endpointDescriptorQuery.flags = USB_HOST_ENDPOINT_QUERY_BY_TRANSFER_TYPE|USB_HOST_ENDPOINT_QUERY_BY_DIRECTION;
9D0020B4  24020006   ADDIU V0, ZERO, 6
9D0020B8  AFA2001C   SW V0, 28(SP)
703:                                 endpointDescriptor = USB_HOST_DeviceEndpointDescriptorQuery(interfaceDescriptor, &endpointDescriptorQuery);
9D0020BC  02402021   ADDU A0, S2, ZERO
9D0020C0  0F401518   JAL USB_HOST_DeviceEndpointDescriptorQuery
9D0020C4  27A50010   ADDIU A1, SP, 16
704:                 
705:                                 /* Did we find the bulk in point */
706:                                 if(endpointDescriptor != NULL)
9D0020C8  10400005   BEQ V0, ZERO, 0x9D0020E0
9D0020CC  00000000   NOP
707:                                 {
708:                                     /* Yes we did. Open this pipe */
709:                                     cdcInstance->bulkInPipeHandle = USB_HOST_DevicePipeOpen(cdcInstance->dataInterfaceHandle, endpointDescriptor->bEndpointAddress);
9D0020D0  8E04000C   LW A0, 12(S0)
9D0020D4  0F400F57   JAL USB_HOST_DevicePipeOpen
9D0020D8  90450002   LBU A1, 2(V0)
9D0020DC  AE020018   SW V0, 24(S0)
710:                                 }
711:                 
712:                                 /* Bulk in pipe is opened. Now open the bulk out pipe */
713:                                 USB_HOST_DeviceEndpointQueryContextClear(&endpointDescriptorQuery);
9D0020E0  0F4026B0   JAL USB_HOST_DeviceEndpointQueryContextClear
9D0020E4  27A40010   ADDIU A0, SP, 16
714:                                 endpointDescriptorQuery.transferType = USB_TRANSFER_TYPE_BULK;
9D0020E8  24020002   ADDIU V0, ZERO, 2
9D0020EC  AFA20014   SW V0, 20(SP)
715:                                 endpointDescriptorQuery.direction = USB_DATA_DIRECTION_HOST_TO_DEVICE;
9D0020F0  AFA00018   SW ZERO, 24(SP)
716:                                 endpointDescriptorQuery.flags = USB_HOST_ENDPOINT_QUERY_BY_TRANSFER_TYPE|USB_HOST_ENDPOINT_QUERY_BY_DIRECTION;
9D0020F4  24020006   ADDIU V0, ZERO, 6
9D0020F8  AFA2001C   SW V0, 28(SP)
717:                                 endpointDescriptor = USB_HOST_DeviceEndpointDescriptorQuery(interfaceDescriptor, &endpointDescriptorQuery);
9D0020FC  02402021   ADDU A0, S2, ZERO
9D002100  0F401518   JAL USB_HOST_DeviceEndpointDescriptorQuery
9D002104  27A50010   ADDIU A1, SP, 16
718:                 
719:                                 /* Did we find the pipe */
720:                                 if(endpointDescriptor != NULL)
9D002108  104000AC   BEQ V0, ZERO, 0x9D0023BC
9D00210C  8FBF005C   LW RA, 92(SP)
721:                                 {
722:                                     /* Yes we did. Open this pipe */
723:                                     cdcInstance->bulkOutPipeHandle = USB_HOST_DevicePipeOpen(cdcInstance->dataInterfaceHandle, 
9D002110  8E04000C   LW A0, 12(S0)
9D002114  0F400F57   JAL USB_HOST_DevicePipeOpen
9D002118  90450002   LBU A1, 2(V0)
9D00211C  0B4008EE   J 0x9D0023B8
9D002120  AE02001C   SW V0, 28(S0)
724:                                             endpointDescriptor->bEndpointAddress);
725:                                 }
726:                             }
727:                             else
728:                             {
729:                                 /* Dont know what this interface is. Return it back */
730:                                 USB_HOST_DeviceInterfaceRelease(interfaces[0]);
9D002124  0F4021B9   JAL USB_HOST_DeviceInterfaceRelease
9D002128  8E240000   LW A0, 0(S1)
731:                             }
732:                         }
733:                         else
734:                         {
735:                             /* This is an error case. The instance should exist. We return this
736:                              * interface back to the host. */
737:                             USB_HOST_DeviceInterfaceRelease(interfaces[0]);
9D002134  0F4021B9   JAL USB_HOST_DeviceInterfaceRelease
9D002138  8E240000   LW A0, 0(S1)
738:                         }
739:                     }
740:                     else if(nInterfaces > 1)
9D002144  2CC20002   SLTIU V0, A2, 2
9D002148  1440009B   BNE V0, ZERO, 0x9D0023B8
9D00214C  3C02A000   LUI V0, -24576
741:                     {
742:                         /* Then this means that this is an IAD. We first assign a CDC instance
743:                          * to this device */
744:                 
745:                         for(iterator = 0; iterator < USB_HOST_CDC_INSTANCES_NUMBER; iterator ++)
746:                         {
747:                             if(!gUSBHostCDCObj[iterator].inUse)
9D002150  904204CC   LBU V0, 1228(V0)
9D002154  10400006   BEQ V0, ZERO, 0x9D002170
9D002158  3C02A000   LUI V0, -24576
9D00215C  90420518   LBU V0, 1304(V0)
9D002160  1440001A   BNE V0, ZERO, 0x9D0021CC
9D002164  24020001   ADDIU V0, ZERO, 1
9D002168  0B40085E   J 0x9D002178
9D00216C  00022080   SLL A0, V0, 2
9D002170  00001021   ADDU V0, ZERO, ZERO
748:                             {
749:                                 cdcInstance = &gUSBHostCDCObj[iterator];
9D002174  00022080   SLL A0, V0, 2
9D002178  00021900   SLL V1, V0, 4
9D00217C  00831821   ADDU V1, A0, V1
9D002180  00621023   SUBU V0, V1, V0
9D002184  00021080   SLL V0, V0, 2
9D002188  3C15A000   LUI S5, -24576
9D00218C  26B504CC   ADDIU S5, S5, 1228
9D002190  02A2A821   ADDU S5, S5, V0
750:                                 cdcInstance->inUse = true;
9D002194  24020001   ADDIU V0, ZERO, 1
9D002198  A2A20000   SB V0, 0(S5)
751:                                 break;
752:                             }
753:                         }
754:                 
755:                         if(cdcInstance == NULL)
756:                         {
757:                             /* This means we could not find an instance. Release all the
758:                              * interfaces in this group */
759:                 
760:                             for(iterator = 0; iterator < nInterfaces; iterator ++)
9D0021CC  10C0007A   BEQ A2, ZERO, 0x9D0023B8
9D0021D0  00C09021   ADDU S2, A2, ZERO
9D0021D4  00001021   ADDU V0, ZERO, ZERO
9D0021D8  00008021   ADDU S0, ZERO, ZERO
9D0021EC  26100001   ADDIU S0, S0, 1
9D0021F0  1612FFFA   BNE S0, S2, 0x9D0021DC
9D0021F4  02001021   ADDU V0, S0, ZERO
9D0021F8  0B4008EF   J 0x9D0023BC
9D0021FC  8FBF005C   LW RA, 92(SP)
761:                             {
762:                                 USB_HOST_DeviceInterfaceRelease(interfaces[iterator]);
9D0021DC  00021080   SLL V0, V0, 2
9D0021E0  02221021   ADDU V0, S1, V0
9D0021E4  0F4021B9   JAL USB_HOST_DeviceInterfaceRelease
9D0021E8  8C440000   LW A0, 0(V0)
763:                             }
764:                         }
765:                         else
766:                         {
767:                             /* Save the device object handle and open the control pipe */
768:                             cdcInstance->deviceObjHandle = deviceObjHandle;
9D00219C  AEA50008   SW A1, 8(S5)
769:                             cdcInstance->controlPipeHandle = USB_HOST_DeviceControlPipeOpen(deviceObjHandle);
9D0021A0  0F4024D1   JAL USB_HOST_DeviceControlPipeOpen
9D0021A4  00A02021   ADDU A0, A1, ZERO
9D0021A8  AEA20014   SW V0, 20(S5)
770:                 
771:                             /* An instance is assigned. The descriptor will be a pointer to the
772:                              * IAD. Lets get the first interface descriptor in the IAD group and
773:                              * see which interface this is. */ 
774:                 
775:                             USB_HOST_DeviceInterfaceQueryContextClear(&interfaceDescriptorQuery);
9D0021AC  0F4026B4   JAL USB_HOST_DeviceInterfaceQueryContextClear
9D0021B0  27A40024   ADDIU A0, SP, 36
776:                             interfaceDescriptorQuery.flags = USB_HOST_INTERFACE_QUERY_ANY;
9D0021B4  AFA0002C   SW ZERO, 44(SP)
777:                 
778:                             /* We know that we need two interfaces */
779:                             for(iterator = 0; iterator < 2; iterator ++)
9D0021B8  00009821   ADDU S3, ZERO, ZERO
9D00234C  26730001   ADDIU S3, S3, 1
9D002350  1674FFAB   BNE S3, S4, 0x9D002200
9D002354  26310004   ADDIU S1, S1, 4
780:                             {
781:                                 /* We need to search for two interface descriptors */
782:                                 interfaceDescriptor = USB_HOST_DeviceGeneralInterfaceDescriptorQuery
9D002200  02402021   ADDU A0, S2, ZERO
9D002204  0F4016D5   JAL USB_HOST_DeviceGeneralInterfaceDescriptorQuery
9D002208  27A50024   ADDIU A1, SP, 36
783:                                         ((USB_INTERFACE_ASSOCIATION_DESCRIPTOR *)(descriptor), &interfaceDescriptorQuery);
784:                                 
785:                                 /* If we have a valid interface descriptor find out its type */
786:                                 if(interfaceDescriptor != NULL)
9D00220C  1040004F   BEQ V0, ZERO, 0x9D00234C
9D002210  00408021   ADDU S0, V0, ZERO
787:                                 {
788:                                     if((interfaceDescriptor->bInterfaceClass == USB_CDC_COMMUNICATIONS_INTERFACE_CLASS_CODE) &&
9D0021BC  24140002   ADDIU S4, ZERO, 2
9D002214  90420005   LBU V0, 5(V0)
9D002218  1454001E   BNE V0, S4, 0x9D002294
9D00221C  00000000   NOP
9D002220  92020006   LBU V0, 6(S0)
9D002224  5454004A   BNEL V0, S4, 0x9D002350
9D002228  26730001   ADDIU S3, S3, 1
789:                                             (interfaceDescriptor->bInterfaceSubClass == USB_CDC_SUBCLASS_ABSTRACT_CONTROL_MODEL) &&
9D00222C  92020007   LBU V0, 7(S0)
9D002230  54400047   BNEL V0, ZERO, 0x9D002350
9D002234  26730001   ADDIU S3, S3, 1
790:                                             (interfaceDescriptor->bInterfaceProtocol == USB_CDC_PROTOCOL_NO_CLASS_SPECIFIC/*USB_CDC_PROTOCOL_AT_V250*/))
791:                                     {
792:                                         /* We found the communication class */
793:                                         cdcInstance->commInterfaceNumber = interfaceDescriptor->bInterfaceNumber;
9D002238  92020002   LBU V0, 2(S0)
9D00223C  A2A20048   SB V0, 72(S5)
794:                                         cdcInstance->communicationInterfaceHandle = interfaces[iterator];
9D002240  8E220000   LW V0, 0(S1)
9D002244  AEA20010   SW V0, 16(S5)
795:                 
796:                                         /* Create the endpoint query */
797:                                         USB_HOST_DeviceEndpointQueryContextClear(&endpointDescriptorQuery);
9D002248  0F4026B0   JAL USB_HOST_DeviceEndpointQueryContextClear
9D00224C  27A40010   ADDIU A0, SP, 16
798:                                         endpointDescriptorQuery.transferType = USB_TRANSFER_TYPE_INTERRUPT;
9D002250  24020003   ADDIU V0, ZERO, 3
9D002254  AFA20014   SW V0, 20(SP)
799:                                         endpointDescriptorQuery.direction = USB_DATA_DIRECTION_DEVICE_TO_HOST;
9D002258  AFB70018   SW S7, 24(SP)
800:                                         endpointDescriptorQuery.flags = USB_HOST_ENDPOINT_QUERY_BY_TRANSFER_TYPE|USB_HOST_ENDPOINT_QUERY_BY_DIRECTION;
9D00225C  24020006   ADDIU V0, ZERO, 6
9D002260  AFA2001C   SW V0, 28(SP)
801:                                         endpointDescriptor = USB_HOST_DeviceEndpointDescriptorQuery(interfaceDescriptor, &endpointDescriptorQuery);
9D002264  02002021   ADDU A0, S0, ZERO
9D002268  0F401518   JAL USB_HOST_DeviceEndpointDescriptorQuery
9D00226C  27A50010   ADDIU A1, SP, 16
802:                 
803:                                         if(endpointDescriptor != NULL)
9D002270  50400006   BEQL V0, ZERO, 0x9D00228C
9D002274  2402FFFF   ADDIU V0, ZERO, -1
804:                                         {
805:                                             /* Open the pipe */
806:                                             cdcInstance->interruptPipeHandle = USB_HOST_DevicePipeOpen(cdcInstance->communicationInterfaceHandle, 
9D002278  8EA40010   LW A0, 16(S5)
9D00227C  0F400F57   JAL USB_HOST_DevicePipeOpen
9D002280  90450002   LBU A1, 2(V0)
9D002284  0B4008D3   J 0x9D00234C
9D002288  AEA20020   SW V0, 32(S5)
807:                                                     endpointDescriptor->bEndpointAddress);
808:                                         }
809:                                         else
810:                                         {
811:                                             /* Make sure that the pipe handle stays invalid if
812:                                              * we could not open the pipe */
813:                                             cdcInstance->interruptPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D00228C  0B4008D3   J 0x9D00234C
9D002290  AEA20020   SW V0, 32(S5)
814:                                         }
815:                                     }
816:                                     else if ((interfaceDescriptor->bInterfaceClass == USB_CDC_DATA_INTERFACE_CLASS_CODE) && 
9D0021C0  2416000A   ADDIU S6, ZERO, 10
9D002294  5456002E   BNEL V0, S6, 0x9D002350
9D002298  26730001   ADDIU S3, S3, 1
9D00229C  92020006   LBU V0, 6(S0)
9D0022A0  5440002B   BNEL V0, ZERO, 0x9D002350
9D0022A4  26730001   ADDIU S3, S3, 1
817:                                             (interfaceDescriptor->bInterfaceSubClass == 0x00) && 
9D0022A8  92020007   LBU V0, 7(S0)
9D0022AC  54400028   BNEL V0, ZERO, 0x9D002350
9D0022B0  26730001   ADDIU S3, S3, 1
818:                                             (interfaceDescriptor->bInterfaceProtocol == USB_CDC_PROTOCOL_NO_CLASS_SPECIFIC))
819:                                     {
820:                                         /* We found the data class */
821:                 
822:                                         cdcInstance->dataInterfaceHandle = interfaces[iterator];
9D0022B4  8E220000   LW V0, 0(S1)
9D0022B8  AEA2000C   SW V0, 12(S5)
823:                                         cdcInstance->dataInterfaceNumber = interfaceDescriptor->bInterfaceNumber;
9D0022BC  92020002   LBU V0, 2(S0)
9D0022C0  A2A20049   SB V0, 73(S5)
824:                 
825:                                         /* Get the bulk in endpoint */ 
826:                                         USB_HOST_DeviceEndpointQueryContextClear(&endpointDescriptorQuery);
9D0022C4  0F4026B0   JAL USB_HOST_DeviceEndpointQueryContextClear
9D0022C8  27A40010   ADDIU A0, SP, 16
827:                                         endpointDescriptorQuery.transferType = USB_TRANSFER_TYPE_BULK;
9D0022CC  AFB40014   SW S4, 20(SP)
828:                                         endpointDescriptorQuery.direction = USB_DATA_DIRECTION_DEVICE_TO_HOST;
9D0021C4  0B400880   J 0x9D002200
9D0021C8  24170001   ADDIU S7, ZERO, 1
9D0022D0  AFB70018   SW S7, 24(SP)
829:                                         endpointDescriptorQuery.flags = USB_HOST_ENDPOINT_QUERY_BY_TRANSFER_TYPE|USB_HOST_ENDPOINT_QUERY_BY_DIRECTION;
9D0022D4  24020006   ADDIU V0, ZERO, 6
9D0022D8  AFA2001C   SW V0, 28(SP)
830:                                         endpointDescriptor = USB_HOST_DeviceEndpointDescriptorQuery(interfaceDescriptor, &endpointDescriptorQuery);
9D0022DC  02002021   ADDU A0, S0, ZERO
9D0022E0  0F401518   JAL USB_HOST_DeviceEndpointDescriptorQuery
9D0022E4  27A50010   ADDIU A1, SP, 16
831:                 
832:                                         if(endpointDescriptor != NULL)
9D0022E8  50400006   BEQL V0, ZERO, 0x9D002304
9D0022EC  2402FFFF   ADDIU V0, ZERO, -1
833:                                         {
834:                                             cdcInstance->bulkInPipeHandle = USB_HOST_DevicePipeOpen(cdcInstance->dataInterfaceHandle, 
9D0022F0  8EA4000C   LW A0, 12(S5)
9D0022F4  0F400F57   JAL USB_HOST_DevicePipeOpen
9D0022F8  90450002   LBU A1, 2(V0)
9D0022FC  0B4008C2   J 0x9D002308
9D002300  AEA20018   SW V0, 24(S5)
835:                                                     endpointDescriptor->bEndpointAddress);
836:                                         }
837:                                         else
838:                                         {
839:                                             /* Make the pipe handle invalid */
840:                                             cdcInstance->bulkInPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D002304  AEA20018   SW V0, 24(S5)
841:                                         }
842:                 
843:                                         /* Get the bulk in endpoint */ 
844:                                         USB_HOST_DeviceEndpointQueryContextClear(&endpointDescriptorQuery);
9D002308  0F4026B0   JAL USB_HOST_DeviceEndpointQueryContextClear
9D00230C  27A40010   ADDIU A0, SP, 16
845:                                         endpointDescriptorQuery.transferType = USB_TRANSFER_TYPE_BULK;
9D002310  AFB40014   SW S4, 20(SP)
846:                                         endpointDescriptorQuery.direction = USB_DATA_DIRECTION_HOST_TO_DEVICE;
9D002314  AFA00018   SW ZERO, 24(SP)
847:                                         endpointDescriptorQuery.flags = USB_HOST_ENDPOINT_QUERY_BY_TRANSFER_TYPE|USB_HOST_ENDPOINT_QUERY_BY_DIRECTION;
9D002318  24020006   ADDIU V0, ZERO, 6
9D00231C  AFA2001C   SW V0, 28(SP)
848:                                         endpointDescriptor = USB_HOST_DeviceEndpointDescriptorQuery(interfaceDescriptor, &endpointDescriptorQuery);
9D002320  02002021   ADDU A0, S0, ZERO
9D002324  0F401518   JAL USB_HOST_DeviceEndpointDescriptorQuery
9D002328  27A50010   ADDIU A1, SP, 16
849:                 
850:                                         if(endpointDescriptor != NULL)
9D00232C  50400006   BEQL V0, ZERO, 0x9D002348
9D002330  2402FFFF   ADDIU V0, ZERO, -1
851:                                         {
852:                                             cdcInstance->bulkOutPipeHandle = USB_HOST_DevicePipeOpen(cdcInstance->dataInterfaceHandle, 
9D002334  8EA4000C   LW A0, 12(S5)
9D002338  0F400F57   JAL USB_HOST_DevicePipeOpen
9D00233C  90450002   LBU A1, 2(V0)
9D002340  0B4008D3   J 0x9D00234C
9D002344  AEA2001C   SW V0, 28(S5)
853:                                                     endpointDescriptor->bEndpointAddress);
854:                                         }
855:                                         else
856:                                         {
857:                                             /* Make the pipe handle invalid */
858:                                             cdcInstance->bulkOutPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D002348  AEA2001C   SW V0, 28(S5)
859:                                         }
860:                 
861:                                     }
862:                                 }
863:                                 else
864:                                 {
865:                                     /* There have to be at least two interface descriptors */
866:                                 }
867:                             }
868:                 
869:                             /* Now check if we can move the host client driver instance to a
870:                              * ready state */
871:                 
872:                             if((cdcInstance->interruptPipeHandle != USB_HOST_PIPE_HANDLE_INVALID) &&
9D002358  8EA30020   LW V1, 32(S5)
9D00235C  2402FFFF   ADDIU V0, ZERO, -1
9D002360  50620015   BEQL V1, V0, 0x9D0023B8
9D002364  AEA20034   SW V0, 52(S5)
9D002368  8EA30018   LW V1, 24(S5)
9D00236C  50620012   BEQL V1, V0, 0x9D0023B8
9D002370  AEA20034   SW V0, 52(S5)
873:                                     (cdcInstance->bulkInPipeHandle != USB_HOST_PIPE_HANDLE_INVALID) &&
9D002374  8EA3001C   LW V1, 28(S5)
9D002378  5062000F   BEQL V1, V0, 0x9D0023B8
9D00237C  AEA20034   SW V0, 52(S5)
874:                                     (cdcInstance->bulkOutPipeHandle != USB_HOST_PIPE_HANDLE_INVALID))
875:                             {
876:                                 /* All the pipes are opened. The client driver is ready */
877:                                 cdcInstance->state = USB_HOST_CDC_STATE_READY;
9D002380  24020004   ADDIU V0, ZERO, 4
9D002384  AEA20034   SW V0, 52(S5)
878:                 
879:                                 /* We know that the client driver is now ready. We can 
880:                                  * let all the listeners know that the device has been
881:                                  * attached.  */
882:                 
883:                                 for(iterator = 0; iterator < USB_HOST_CDC_ATTACH_LISTENERS_NUMBER; iterator ++)
884:                                 {
885:                                     if(gUSBHostCDCAttachListener[iterator].inUse)
9D002388  3C02A000   LUI V0, -24576
9D00238C  90420564   LBU V0, 1380(V0)
9D002390  5040000A   BEQL V0, ZERO, 0x9D0023BC
9D002394  8FBF005C   LW RA, 92(SP)
886:                                     {
887:                                         /* Call the attach listener event handler 
888:                                          * function. */
889:                                         gUSBHostCDCAttachListener[iterator].eventHandler((USB_HOST_CDC_OBJ)(cdcInstance), 
9D002398  3C02A000   LUI V0, -24576
9D00239C  24420564   ADDIU V0, V0, 1380
9D0023A0  8C430004   LW V1, 4(V0)
9D0023A4  02A02021   ADDU A0, S5, ZERO
9D0023A8  0060F809   JALR V1
9D0023AC  8C450008   LW A1, 8(V0)
890:                                                 gUSBHostCDCAttachListener[iterator].context);
891:                                     }
892:                                 }
893:                             }
894:                             else
895:                             {
896:                                 /* Something went wrong. */
897:                                 cdcInstance->state = USB_HOST_CDC_STATE_ERROR;
898:                             }
899:                         }
900:                     }
901:                 }
9D00212C  0B4008EF   J 0x9D0023BC
9D002130  8FBF005C   LW RA, 92(SP)
9D00213C  0B4008EF   J 0x9D0023BC
9D002140  8FBF005C   LW RA, 92(SP)
9D0023B0  0B4008EF   J 0x9D0023BC
902:                 
903:                 // *****************************************************************************
904:                 /* Function:
905:                     USB_HOST_DEVICE_INTERFACE_EVENT_RESPONSE _USB_HOST_CDC_InterfaceEventHandler
906:                     (
907:                         USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle,
908:                         USB_HOST_DEVICE_INTERFACE_EVENT event,
909:                         void * eventData,
910:                         uintptr_t context
911:                     )
912:                 
913:                   Summary:
914:                     This function is called when the Host Layer generates interface level
915:                     events. 
916:                 
917:                   Description:
918:                     This function is called when the Host Layer generates interface level
919:                     events. 
920:                 
921:                   Remarks:
922:                     This is a local function and should not be called directly by the
923:                     application.
924:                 */
925:                 
926:                 USB_HOST_DEVICE_INTERFACE_EVENT_RESPONSE _USB_HOST_CDC_InterfaceEventHandler
927:                 (
928:                     USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle,
929:                     USB_HOST_DEVICE_INTERFACE_EVENT event,
930:                     void * eventData,
931:                     uintptr_t context
932:                 )
933:                 {
9D008298  27BDFFD0   ADDIU SP, SP, -48
9D00829C  AFBF002C   SW RA, 44(SP)
9D0082A0  AFB20028   SW S2, 40(SP)
9D0082A4  AFB10024   SW S1, 36(SP)
9D0082A8  AFB00020   SW S0, 32(SP)
9D0082AC  00A08821   ADDU S1, A1, ZERO
9D0082B0  00C08021   ADDU S0, A2, ZERO
934:                     int cdcIndex;
935:                     USB_HOST_CDC_INSTANCE_OBJ * cdcInstance;
936:                     USB_HOST_DEVICE_INTERFACE_EVENT_TRANSFER_COMPLETE_DATA * dataTransferEvent;
937:                     USB_HOST_CDC_EVENT cdcEvent;
938:                     USB_HOST_CDC_EVENT_WRITE_COMPLETE_DATA cdcTransferCompleteData;
939:                 
940:                     /* Find out to which CDC Instance this interface belongs */
941:                     cdcIndex = _USB_HOST_CDC_InterfaceHandleToInstance(interfaceHandle);
9D0082B4  0F4023CE   JAL _USB_HOST_CDC_InterfaceHandleToInstance
9D0082B8  00E09021   ADDU S2, A3, ZERO
942:                     cdcInstance = &gUSBHostCDCObj[cdcIndex];
9D0082C4  00021900   SLL V1, V0, 4
9D0082C8  02238821   ADDU S1, S1, V1
9D0082CC  02221023   SUBU V0, S1, V0
9D0082D0  00021080   SLL V0, V0, 2
9D0082D4  3C11A000   LUI S1, -24576
9D0082D8  263104CC   ADDIU S1, S1, 1228
9D0082DC  02228821   ADDU S1, S1, V0
943:                     cdcEvent = (USB_HOST_CDC_EVENT)(context); 
944:                 
945:                     switch(event)
9D0082BC  16200016   BNE S1, ZERO, 0x9D008318
9D0082C0  00028880   SLL S1, V0, 2
946:                     {
947:                         case USB_HOST_DEVICE_INTERFACE_EVENT_TRANSFER_COMPLETE:
948:                 
949:                             /* This means a data transfer has completed */
950:                             dataTransferEvent = (USB_HOST_DEVICE_INTERFACE_EVENT_TRANSFER_COMPLETE_DATA *)(eventData);
951:                             cdcTransferCompleteData.transferHandle = dataTransferEvent->transferHandle;
9D0082E0  8E020000   LW V0, 0(S0)
9D0082E4  AFA20010   SW V0, 16(SP)
952:                             cdcTransferCompleteData.result = _USB_HOST_CDC_HostResutlToCDCResultMap(dataTransferEvent->result);
9D0082E8  0F402456   JAL _USB_HOST_CDC_HostResutlToCDCResultMap
9D0082EC  8E040004   LW A0, 4(S0)
9D0082F0  AFA20014   SW V0, 20(SP)
953:                             cdcTransferCompleteData.length = dataTransferEvent->length;
9D0082F4  8E020008   LW V0, 8(S0)
9D0082F8  AFA20018   SW V0, 24(SP)
954:                 
955:                             if(cdcInstance->eventHandler != NULL)
9D0082FC  8E220030   LW V0, 48(S1)
9D008300  10400005   BEQ V0, ZERO, 0x9D008318
9D008304  02202021   ADDU A0, S1, ZERO
956:                             {
957:                                 cdcInstance->eventHandler((USB_HOST_CDC_HANDLE)(cdcInstance), cdcEvent, 
9D008308  02402821   ADDU A1, S2, ZERO
9D00830C  27A60010   ADDIU A2, SP, 16
9D008310  0040F809   JALR V0
9D008314  8E27002C   LW A3, 44(S1)
958:                                         &cdcTransferCompleteData, cdcInstance->context);
959:                             }
960:                 
961:                             break;
962:                 
963:                         default:
964:                             break;
965:                     }
966:                     
967:                     return(USB_HOST_DEVICE_INTERFACE_EVENT_RESPONSE_NONE);
968:                 }
9D008318  00001021   ADDU V0, ZERO, ZERO
969:                 
970:                 // *****************************************************************************
971:                 /* Function:
972:                     void USB_HOST_CDC_InterfaceTasks
973:                     (
974:                         USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
975:                     )
976:                 
977:                   Summary:
978:                     This function is called by the Host Layer to update the state of this
979:                     driver.
980:                 
981:                   Description:
982:                     This function is called by the Host Layer to update the state of this
983:                     driver.
984:                 
985:                   Remarks:
986:                     This is a local function and should not be called directly by the
987:                     application.
988:                 */
989:                 
990:                 void _USB_HOST_CDC_InterfaceTasks
991:                 (
992:                     USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
993:                 )
994:                 {
9D009B2C  03E00008   JR RA
995:                 }
996:                 
997:                 // *****************************************************************************
998:                 /* Function:
999:                     void USB_HOST_CDC_InterfaceRelease
1000:                    (
1001:                        USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
1002:                    )
1003:                
1004:                  Summary:
1005:                    This function is called when the Host Layer detaches this driver from an
1006:                    interface.
1007:                
1008:                  Description:
1009:                    This function is called when the Host Layer detaches this driver from an
1010:                    interface.
1011:                
1012:                  Remarks:
1013:                    This is a local function and should not be called directly by the
1014:                    application.
1015:                */
1016:                
1017:                void _USB_HOST_CDC_InterfaceRelease
1018:                (
1019:                    USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
1020:                )
1021:                {
9D0071E0  27BDFFE8   ADDIU SP, SP, -24
9D0071E4  AFBF0014   SW RA, 20(SP)
1022:                    int cdcIndex;
1023:                    USB_HOST_CDC_INSTANCE_OBJ * cdcInstance;
1024:                    
1025:                    /* Get the instance associated with this interface */
1026:                    cdcIndex = _USB_HOST_CDC_InterfaceHandleToInstance(interfaceHandle);
9D0071E8  0F4023CE   JAL _USB_HOST_CDC_InterfaceHandleToInstance
9D0071EC  AFB00010   SW S0, 16(SP)
1027:                    
1028:                    if(cdcIndex >= 0)
9D0071F0  0440002E   BLTZ V0, 0x9D0072AC
9D0071F4  00028080   SLL S0, V0, 2
1029:                    {
1030:                        /* Get the pointer to the instance object */
1031:                        cdcInstance = &gUSBHostCDCObj[cdcIndex];
9D0071F8  00021900   SLL V1, V0, 4
9D0071FC  02038021   ADDU S0, S0, V1
9D007200  02021023   SUBU V0, S0, V0
9D007204  00021080   SLL V0, V0, 2
9D007208  3C10A000   LUI S0, -24576
9D00720C  261004CC   ADDIU S0, S0, 1228
9D007210  02028021   ADDU S0, S0, V0
1032:                        
1033:                        if(cdcInstance->inUse)
9D007214  92020000   LBU V0, 0(S0)
9D007218  10400024   BEQ V0, ZERO, 0x9D0072AC
9D00721C  2402FFFF   ADDIU V0, ZERO, -1
1034:                        {
1035:                            cdcInstance->inUse = false;
9D007220  A2000000   SB ZERO, 0(S0)
1036:                
1037:                            if(cdcInstance->bulkInPipeHandle != USB_HOST_PIPE_HANDLE_INVALID)
9D007224  8E040018   LW A0, 24(S0)
9D007228  50820007   BEQL A0, V0, 0x9D007248
9D00722C  8E04001C   LW A0, 28(S0)
1038:                            {
1039:                                /* Close the bulk in pipe and invalidate the pipe handle */
1040:                                USB_HOST_DevicePipeClose(cdcInstance->bulkInPipeHandle);
9D007230  0F4020CD   JAL USB_HOST_DevicePipeClose
9D007234  00000000   NOP
1041:                                cdcInstance->bulkInPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D007238  2402FFFF   ADDIU V0, ZERO, -1
9D00723C  AE020018   SW V0, 24(S0)
1042:                            }
1043:                
1044:                            if(cdcInstance->bulkOutPipeHandle != USB_HOST_PIPE_HANDLE_INVALID)
9D007240  8E04001C   LW A0, 28(S0)
9D007244  2402FFFF   ADDIU V0, ZERO, -1
9D007248  50820006   BEQL A0, V0, 0x9D007264
9D00724C  8E040020   LW A0, 32(S0)
1045:                            {
1046:                                /* Close the bulk Out pipe and invalidate the pipe handle */
1047:                                USB_HOST_DevicePipeClose(cdcInstance->bulkOutPipeHandle);
9D007250  0F4020CD   JAL USB_HOST_DevicePipeClose
9D007254  00000000   NOP
1048:                                cdcInstance->bulkOutPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D007258  2402FFFF   ADDIU V0, ZERO, -1
9D00725C  AE02001C   SW V0, 28(S0)
1049:                            }
1050:                
1051:                            if(cdcInstance->interruptPipeHandle != USB_HOST_PIPE_HANDLE_INVALID)
9D007260  8E040020   LW A0, 32(S0)
9D007264  2402FFFF   ADDIU V0, ZERO, -1
9D007268  50820006   BEQL A0, V0, 0x9D007284
9D00726C  8E020030   LW V0, 48(S0)
1052:                            {
1053:                                /* Close the interruptPipeHandle pipe handle and invalidate the pipe
1054:                                 * handle */
1055:                                USB_HOST_DevicePipeClose(cdcInstance->interruptPipeHandle);
9D007270  0F4020CD   JAL USB_HOST_DevicePipeClose
9D007274  00000000   NOP
1056:                                cdcInstance->interruptPipeHandle = USB_HOST_PIPE_HANDLE_INVALID;
9D007278  2402FFFF   ADDIU V0, ZERO, -1
9D00727C  AE020020   SW V0, 32(S0)
1057:                            }
1058:                
1059:                            if(cdcInstance->eventHandler != NULL)
9D007280  8E020030   LW V0, 48(S0)
9D007284  10400005   BEQ V0, ZERO, 0x9D00729C
9D007288  02002021   ADDU A0, S0, ZERO
1060:                            {
1061:                                /* Let the client know that the device is detached */
1062:                                cdcInstance->eventHandler((USB_HOST_CDC_HANDLE)(cdcInstance), 
9D00728C  24050007   ADDIU A1, ZERO, 7
9D007290  00003021   ADDU A2, ZERO, ZERO
9D007294  0040F809   JALR V0
9D007298  8E07002C   LW A3, 44(S0)
1063:                                        USB_HOST_CDC_EVENT_DEVICE_DETACHED,
1064:                                        NULL, cdcInstance->context);
1065:                            }
1066:                
1067:                            /* Release the object */
1068:                            cdcInstance->eventHandler = NULL;
9D00729C  AE000030   SW ZERO, 48(S0)
1069:                            cdcInstance->deviceObjHandle = USB_HOST_DEVICE_OBJ_HANDLE_INVALID;
9D0072A0  2402FFFF   ADDIU V0, ZERO, -1
9D0072A4  AE020008   SW V0, 8(S0)
1070:                            cdcInstance->deviceClientHandle = USB_HOST_DEVICE_CLIENT_HANDLE_INVALID;
9D0072A8  AE020004   SW V0, 4(S0)
1071:                        }
1072:                    }
1073:                }
9D0072AC  8FBF0014   LW RA, 20(SP)
1074:                
1075:                // *****************************************************************************
1076:                /* Function:
1077:                    USB_HOST_DEVICE_INTERFACE_EVENT_RESPONSE _USB_HOST_CDC_DeviceEventHandler
1078:                    (
1079:                        USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
1080:                        USB_HOST_DEVICE_EVENT event,
1081:                        void * eventData,
1082:                        uintptr_t context
1083:                    )
1084:                
1085:                  Summary:
1086:                    This function is called when the Host Layer generates device level
1087:                    events. 
1088:                
1089:                  Description:
1090:                    This function is called when the Host Layer generates device level
1091:                    events. 
1092:                
1093:                  Remarks:
1094:                    This is a local function and should not be called directly by the
1095:                    application.
1096:                */
1097:                
1098:                USB_HOST_DEVICE_EVENT_RESPONSE _USB_HOST_CDC_DeviceEventHandler
1099:                (
1100:                    USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
1101:                    USB_HOST_DEVICE_EVENT event,
1102:                    void * eventData,
1103:                    uintptr_t context
1104:                )
1105:                {
1106:                    /* The event context is the pointer to the CDC Instance Object */
1107:                    USB_HOST_CDC_INSTANCE_OBJ * cdcInstance = (USB_HOST_CDC_INSTANCE_OBJ *)(context);
1108:                    USB_HOST_DEVICE_EVENT_CONFIGURATION_SET_DATA * configSetEventData;
1109:                
1110:                    switch(event)
9D009994  14A00005   BNE A1, ZERO, 0x9D0099AC
9D009998  00000000   NOP
1111:                    {
1112:                        case USB_HOST_DEVICE_EVENT_CONFIGURATION_SET:
1113:                
1114:                            /* This means the configuration was set. Update the instance
1115:                             * variables to let the main state machine know. */
1116:                            configSetEventData = (USB_HOST_DEVICE_EVENT_CONFIGURATION_SET_DATA *)(eventData);
1117:                            cdcInstance->hostRequestResult =  configSetEventData->result;
9D00999C  8CC20004   LW V0, 4(A2)
9D0099A0  ACE2003C   SW V0, 60(A3)
1118:                            cdcInstance->hostRequestDone = true;
9D0099A4  24020001   ADDIU V0, ZERO, 1
9D0099A8  A0E20038   SB V0, 56(A3)
1119:                            break;
1120:                
1121:                        case USB_HOST_DEVICE_EVENT_CONFIGURATION_DESCRIPTOR_GET_COMPLETE:
1122:                            break;
1123:                
1124:                        default:
1125:                            break;
1126:                    }
1127:                    
1128:                    return(USB_HOST_DEVICE_EVENT_RESPONSE_NONE);
1129:                }
9D0099AC  03E00008   JR RA
1130:                
1131:                // *****************************************************************************
1132:                // *****************************************************************************
1133:                // Public Functions
1134:                // *****************************************************************************
1135:                // *****************************************************************************
1136:                
1137:                // *****************************************************************************
1138:                // *****************************************************************************
1139:                // CDC Host Client Driver Public function
1140:                // *****************************************************************************
1141:                // *****************************************************************************
1142:                
1143:                // ****************************************************************************
1144:                /* Function:
1145:                    USB_HOST_CDC_RESULT USB_HOST_CDC_AttachEventHandlerSet
1146:                    (
1147:                        USB_HOST_CDC_ATTACH_EVENT_HANDLER eventHandler,
1148:                        uintptr_t context
1149:                    );
1150:                           
1151:                  Summary:
1152:                    This function will set an attach event handler.
1153:                
1154:                  Description:
1155:                    This function will set an attach event handler. The attach event handler
1156:                    will be called when a CDC device has been attached. The context will be
1157:                    returned in the event handler. This function should be called before the bus
1158:                    has been enabled.
1159:                
1160:                  Remarks:
1161:                    Refer to usb_host_cdc.h for usage information.
1162:                */
1163:                
1164:                USB_HOST_CDC_RESULT USB_HOST_CDC_AttachEventHandlerSet
1165:                (
1166:                    USB_HOST_CDC_ATTACH_EVENT_HANDLER eventHandler,
1167:                    uintptr_t context
1168:                )
1169:                {
1170:                    int iterator;
1171:                
1172:                    USB_HOST_CDC_RESULT result = USB_HOST_CDC_RESULT_FAILURE;
1173:                    USB_HOST_CDC_ATTACH_LISTENER_OBJ * attachListener;
1174:                    
1175:                    if(eventHandler == NULL)
9D0095C4  5080000D   BEQL A0, ZERO, 0x9D0095FC
9D0095C8  2402FFA3   ADDIU V0, ZERO, -93
1176:                    {
1177:                        result = USB_HOST_RESULT_PARAMETER_INVALID;
1178:                    }
1179:                    else
1180:                    {
1181:                        /* Search for free listener object */
1182:                        for(iterator = 0; iterator < USB_HOST_CDC_ATTACH_LISTENERS_NUMBER; iterator ++)
1183:                        {
1184:                            if(!gUSBHostCDCAttachListener[iterator].inUse)
9D0095CC  3C02A000   LUI V0, -24576
9D0095D0  90430564   LBU V1, 1380(V0)
9D0095D4  14600009   BNE V1, ZERO, 0x9D0095FC
9D0095D8  2402FF9C   ADDIU V0, ZERO, -100
1185:                            {
1186:                                /* Found a free object */
1187:                                attachListener = &gUSBHostCDCAttachListener[iterator];
1188:                                attachListener->inUse = true;
9D0095DC  3C02A000   LUI V0, -24576
9D0095E0  24030001   ADDIU V1, ZERO, 1
9D0095E4  A0430564   SB V1, 1380(V0)
1189:                                attachListener->eventHandler = eventHandler;
9D0095E8  24420564   ADDIU V0, V0, 1380
9D0095EC  AC440004   SW A0, 4(V0)
1190:                                attachListener->context = context;
9D0095F0  AC450008   SW A1, 8(V0)
1191:                                result = USB_HOST_CDC_RESULT_SUCCESS;
1192:                                break;
9D0095F4  03E00008   JR RA
9D0095F8  24020001   ADDIU V0, ZERO, 1
1193:                            }
1194:                        }
1195:                    }
1196:                
1197:                    return(result);
1198:                }
9D0095FC  03E00008   JR RA
1199:                
1200:                // ****************************************************************************
1201:                /* Function:
1202:                    USB_HOST_CDC_HANDLE USB_HOST_CDC_Open
1203:                    (
1204:                        USB_HOST_CDC_OBJ cdcDeviceObj
1205:                    );
1206:                           
1207:                  Summary:
1208:                    This function opens the specified CDC device.
1209:                
1210:                  Description:
1211:                    This function will open the specified CDC device. Once opened, the CDC
1212:                    device can be accessed via the handle which this function returns. The
1213:                    cdcDeviceObj parameter is the value returned in the
1214:                    USB_HOST_CDC_ATTACH_EVENT_HANDLER event handling function.
1215:                
1216:                  Remarks:
1217:                    Refer to usb_host_cdc.h for usage information.
1218:                */
1219:                
1220:                USB_HOST_CDC_HANDLE USB_HOST_CDC_Open
1221:                (
1222:                    USB_HOST_CDC_OBJ cdcDeviceObj
1223:                )
1224:                {
1225:                    USB_HOST_CDC_HANDLE result = USB_HOST_CDC_HANDLE_INVALID;
9D0096CC  38840004   XORI A0, A0, 4
9D0096D0  03E00008   JR RA
9D0096D4  0064100B   MOVN V0, V1, A0
9D0096D8  03E00008   JR RA
9D0096DC  2402FFFF   ADDIU V0, ZERO, -1
1226:                    USB_HOST_CDC_INSTANCE_OBJ * cdcInstance;
1227:                
1228:                    /* The present implementation is a single client implementation only */
1229:                
1230:                    if(cdcDeviceObj != 0)
9D0096B4  10800008   BEQ A0, ZERO, 0x9D0096D8
9D0096B8  00801021   ADDU V0, A0, ZERO
1231:                    {
1232:                        cdcInstance = (USB_HOST_CDC_INSTANCE_OBJ *)cdcDeviceObj;
1233:                        if((cdcInstance->inUse) && (cdcInstance->state == USB_HOST_CDC_STATE_READY))
9D0096BC  90830000   LBU V1, 0(A0)
9D0096C0  10600007   BEQ V1, ZERO, 0x9D0096E0
9D0096C4  2403FFFF   ADDIU V1, ZERO, -1
9D0096C8  8C840034   LW A0, 52(A0)
1234:                        {
1235:                            result = (USB_HOST_CDC_HANDLE)(cdcDeviceObj);
1236:                        }
1237:                    }
1238:                
1239:                    return(result);
1240:                }
9D0096E0  03E00008   JR RA
1241:                
1242:                // *****************************************************************************
1243:                /* Function:
1244:                    USB_HOST_CDC_RESULT USB_HOST_CDC_EventHandlerSet
1245:                    (
1246:                        USB_HOST_CDC_HANDLE handle,
1247:                        USB_HOST_CDC_EVENT_HANDLER eventHandler,
1248:                        uintptr_t context
1249:                    );
1250:                
1251:                  Summary:
1252:                    Registers an event handler with the CDC Host Client Driver.
1253:                
1254:                  Description:
1255:                    This function registers a client specific CDC Host Client Driver event
1256:                    handler. The CDC Host Client Driver will call this function with relevant
1257:                    event and assocaite event data, in response to command requests and data
1258:                    transfers that have been scheduled by the client.
1259:                
1260:                  Remarks:
1261:                    Refer to usb_host_cdc.h for usage information.
1262:                */
1263:                
1264:                USB_HOST_CDC_RESULT USB_HOST_CDC_EventHandlerSet
1265:                (
1266:                    USB_HOST_CDC_HANDLE handle,
1267:                    USB_HOST_CDC_EVENT_HANDLER eventHandler,
1268:                    uintptr_t context
1269:                )
1270:                {
1271:                    USB_HOST_CDC_RESULT result = USB_HOST_CDC_RESULT_HANDLE_INVALID;
1272:                    USB_HOST_CDC_INSTANCE_OBJ * cdcInstance = (USB_HOST_CDC_INSTANCE_OBJ *)(handle);
1273:                
1274:                    if(cdcInstance != NULL)
9D0099B4  10800005   BEQ A0, ZERO, 0x9D0099CC
9D0099B8  00000000   NOP
1275:                    {
1276:                        cdcInstance->eventHandler = eventHandler;
9D0099BC  AC850030   SW A1, 48(A0)
1277:                        cdcInstance->context = context;
9D0099C0  AC86002C   SW A2, 44(A0)
1278:                        result = USB_HOST_CDC_RESULT_SUCCESS;
9D0099C4  03E00008   JR RA
9D0099C8  24020001   ADDIU V0, ZERO, 1
1279:                    }
1280:                
1281:                    return(result);
1282:                }
9D0099CC  03E00008   JR RA
1283:                
1284:                // ****************************************************************************
1285:                /* Function:
1286:                    void USB_HOST_CDC_Close
1287:                    (
1288:                        USB_HOST_CDC_HANDLE cdcDeviceHandle
1289:                    );
1290:                           
1291:                  Summary:
1292:                    This function closes the CDC device.
1293:                
1294:                  Description:
1295:                    This function will close the open CDC device. This closes the association
1296:                    between the application entity that opened the device and device. The driver
1297:                    handle becomes invalid.
1298:                
1299:                  Remarks:
1300:                    None.
1301:                */
1302:                
1303:                void USB_HOST_CDC_Close
1304:                (
1305:                    USB_HOST_CDC_HANDLE cdcDeviceHandle
1306:                )
1307:                {
1308:                    USB_HOST_CDC_INSTANCE_OBJ * cdcInstance = (USB_HOST_CDC_INSTANCE_OBJ *)(cdcDeviceHandle);
1309:                
1310:                    if(cdcInstance != NULL)
1311:                    {
1312:                        /* In this release of the CDC driver, the close function does not do
1313:                         * much. If the client registered an event handler, then this is set to
1314:                         * NULL. */
1315:                
1316:                        cdcInstance->eventHandler = NULL;
1317:                    }
1318:                }
1319:                
1320:                // ****************************************************************************
1321:                /* Function:
1322:                    USB_HOST_CDC_RESULT USB_HOST_CDC_Write
1323:                    (
1324:                        USB_HOST_CDC_HANDLE handle,
1325:                        USB_HOST_CDC_TRANSFER_HANDLE * transferHandle,
1326:                        void * data,
1327:                        size_t size
1328:                    );
1329:                           
1330:                  Summary:
1331:                    This function will write data to the attached device.
1332:                
1333:                  Description:
1334:                    This function will write data to the attached CDC device. The function will
1335:                    write size amount of bytes. If the request was accepted, transferHandle will
1336:                    contain a valid transfer handle, else it will contain
1337:                    USB_HOST_CDC_TRANSFER_HANDLE_INVALID. The completion of the request will be
1338:                    indicated by the USB_HOST_CDC_EVENT_WRITE_COMPLETE event. The transfer
1339:                    handle will be returned in the event. 
1340:                
1341:                  Remarks:
1342:                    Refer to usb_host_cdc.h for usage information.
1343:                */
1344:                
1345:                USB_HOST_CDC_RESULT USB_HOST_CDC_Write
1346:                (
1347:                    USB_HOST_CDC_HANDLE handle,
1348:                    USB_HOST_CDC_TRANSFER_HANDLE * transferHandle,
1349:                    void * data,
1350:                    size_t size
1351:                )
1352:                {
9D008868  27BDFFD8   ADDIU SP, SP, -40
9D00886C  AFBF0024   SW RA, 36(SP)
1353:                    USB_HOST_CDC_INSTANCE_OBJ * cdcInstance;
1354:                    USB_HOST_CDC_TRANSFER_HANDLE * tempTransferHandle, localTransferHandle;
1355:                    USB_HOST_CDC_RESULT cdcResult = USB_HOST_CDC_RESULT_FAILURE;
1356:                    USB_HOST_RESULT hostResult;
1357:                
1358:                    cdcInstance = (USB_HOST_CDC_INSTANCE_OBJ *)handle;
1359:                
1360:                    if(cdcInstance == NULL)
9D008860  10800018   BEQ A0, ZERO, 0x9D0088C4
9D008864  00000000   NOP
1361:                    {
1362:                        /* This handle is not valid */
1363:                        cdcResult = USB_HOST_CDC_RESULT_HANDLE_INVALID;
1364:                    }
1365:                    else
1366:                    {
1367:                        /* Check if the specified transfer handle holder is NULL, if so use a local
1368:                         * transfer handle holder */
1369:                
1370:                        tempTransferHandle = (transferHandle == NULL) ? &localTransferHandle: transferHandle;
9D008870  27A20018   ADDIU V0, SP, 24
9D008874  0045280A   MOVZ A1, V0, A1
1371:                
1372:                        if(!cdcInstance->inUse)
9D008878  90820000   LBU V0, 0(A0)
9D00887C  10400013   BEQ V0, ZERO, 0x9D0088CC
9D008880  2402FFA0   ADDIU V0, ZERO, -96
1373:                        {
1374:                            /* This object is not valid */
1375:                            cdcResult = USB_HOST_CDC_RESULT_DEVICE_UNKNOWN;
1376:                        }
1377:                        else
1378:                        {
1379:                            if(cdcInstance->state != USB_HOST_CDC_STATE_READY)
9D008884  8C830034   LW V1, 52(A0)
9D008888  24020004   ADDIU V0, ZERO, 4
9D00888C  5462000F   BNEL V1, V0, 0x9D0088CC
9D008890  2402FF9D   ADDIU V0, ZERO, -99
1380:                            {
1381:                                /* The instance is not ready for requests */
1382:                                cdcResult = USB_HOST_CDC_RESULT_BUSY;
1383:                            }
1384:                            else
1385:                            {
1386:                                if((size != 0) && (data == NULL))
9D008894  50E00004   BEQL A3, ZERO, 0x9D0088A8
9D008898  8C84001C   LW A0, 28(A0)
9D00889C  50C0000B   BEQL A2, ZERO, 0x9D0088CC
9D0088A0  2402FF9F   ADDIU V0, ZERO, -97
1387:                                {
1388:                                    /* Input paramters are not valid */
1389:                                    cdcResult = USB_HOST_CDC_RESULT_INVALID_PARAMETER;
1390:                                }
1391:                                else
1392:                                {
1393:                                    /* The context for the transfer is the event that needs to
1394:                                     * be sent to the application. In this case the event to be
1395:                                     * sent to the application when the transfer completes is
1396:                                     * USB_HOST_CDC_EVENT_WRITE_COMPLETE */
1397:                                    
1398:                                    hostResult = USB_HOST_DeviceTransfer(cdcInstance->bulkOutPipeHandle, tempTransferHandle, data, size, (uintptr_t)(USB_HOST_CDC_EVENT_WRITE_COMPLETE));
9D0088A4  8C84001C   LW A0, 28(A0)
9D0088A8  24020001   ADDIU V0, ZERO, 1
9D0088AC  0F4010F1   JAL USB_HOST_DeviceTransfer
9D0088B0  AFA20010   SW V0, 16(SP)
1399:                                    cdcResult = _USB_HOST_CDC_HostResutlToCDCResultMap(hostResult);
9D0088B4  0F402456   JAL _USB_HOST_CDC_HostResutlToCDCResultMap
9D0088B8  00402021   ADDU A0, V0, ZERO
1400:                                }
1401:                            }
1402:                        }
1403:                    }
1404:                
1405:                    return(cdcResult);
1406:                }
9D0088BC  0B402234   J 0x9D0088D0
1407:                
1408:                // ****************************************************************************
1409:                /* Function:
1410:                    USB_HOST_CDC_RESULT USB_HOST_CDC_Read
1411:                    (
1412:                        USB_HOST_CDC_HANDLE handle,
1413:                        USB_HOST_CDC_TRANSFER_HANDLE * transferHandle,
1414:                        void * data,
1415:                        size_t size
1416:                    );
1417:                           
1418:                  Summary:
1419:                    This function will read data from the attached device.
1420:                
1421:                  Description:
1422:                    This function will read data from the attached CDC device. The function will
1423:                    try to read size amount of bytes but will stop reading when the device
1424:                    terminates the USB transfer (sends a short packet or a ZLP). If the request
1425:                    was accepted, transferHandle will contain a valid transfer handle, else it
1426:                    will contain USB_HOST_CDC_TRANSFER_HANDLE_INVALID. The completion of the
1427:                    request will be indicated by the USB_HOST_CDC_EVENT_READ_COMPLETE
1428:                    event. The transfer handle will be returned in the event. 
1429:                
1430:                  Remarks:
1431:                    None.
1432:                */
1433:                USB_HOST_CDC_RESULT USB_HOST_CDC_Read
1434:                (
1435:                    USB_HOST_CDC_HANDLE handle,
1436:                    USB_HOST_CDC_TRANSFER_HANDLE * transferHandle,
1437:                    void * data,
1438:                    size_t size
1439:                )
1440:                {
9D008ABC  27BDFFD8   ADDIU SP, SP, -40
9D008AC0  AFBF0024   SW RA, 36(SP)
1441:                    USB_HOST_CDC_INSTANCE_OBJ * cdcInstance;
1442:                    USB_HOST_CDC_TRANSFER_HANDLE * tempTransferHandle, localTransferHandle;
1443:                    USB_HOST_CDC_RESULT cdcResult = USB_HOST_CDC_RESULT_FAILURE;
1444:                    USB_HOST_RESULT hostResult;
1445:                
1446:                    cdcInstance = (USB_HOST_CDC_INSTANCE_OBJ *)handle;
1447:                
1448:                    if(cdcInstance == NULL)
9D008AB4  10800017   BEQ A0, ZERO, 0x9D008B14
9D008AB8  00000000   NOP
1449:                    {
1450:                        /* This handle is not valid */
1451:                        cdcResult = USB_HOST_CDC_RESULT_HANDLE_INVALID;
1452:                    }
1453:                    else
1454:                    {
1455:                        /* Check if the specified transfer handle holder is NULL, if so use a local
1456:                         * transfer handle holder */
1457:                
1458:                        tempTransferHandle = (transferHandle == NULL) ? &localTransferHandle: transferHandle;
9D008AC4  27A20018   ADDIU V0, SP, 24
9D008AC8  0045280A   MOVZ A1, V0, A1
1459:                
1460:                        if(!cdcInstance->inUse)
9D008ACC  90820000   LBU V0, 0(A0)
9D008AD0  10400012   BEQ V0, ZERO, 0x9D008B1C
9D008AD4  2402FFA0   ADDIU V0, ZERO, -96
1461:                        {
1462:                            /* This object is not valid */
1463:                            cdcResult = USB_HOST_CDC_RESULT_DEVICE_UNKNOWN;
1464:                        }
1465:                        else
1466:                        {
1467:                            if(cdcInstance->state != USB_HOST_CDC_STATE_READY)
9D008AD8  8C830034   LW V1, 52(A0)
9D008ADC  24020004   ADDIU V0, ZERO, 4
9D008AE0  5462000E   BNEL V1, V0, 0x9D008B1C
9D008AE4  2402FF9D   ADDIU V0, ZERO, -99
1468:                            {
1469:                                /* The instance is not ready for requests */
1470:                                cdcResult = USB_HOST_CDC_RESULT_BUSY;
1471:                            }
1472:                            else
1473:                            {
1474:                                if((size != 0) && (data == NULL))
9D008AE8  50E00004   BEQL A3, ZERO, 0x9D008AFC
9D008AEC  8C840018   LW A0, 24(A0)
9D008AF0  50C0000A   BEQL A2, ZERO, 0x9D008B1C
9D008AF4  2402FF9F   ADDIU V0, ZERO, -97
1475:                                {
1476:                                    /* Input paramters are not valid */
1477:                                    cdcResult = USB_HOST_CDC_RESULT_INVALID_PARAMETER;
1478:                                }
1479:                                else
1480:                                {
1481:                                    /* The context for the transfer is the event that needs to
1482:                                     * be sent to the application. In this case the event to be
1483:                                     * sent to the application when the transfer completes is
1484:                                     * USB_HOST_CDC_EVENT_READ_COMPLETE */
1485:                                    
1486:                                    hostResult = USB_HOST_DeviceTransfer(cdcInstance->bulkInPipeHandle, tempTransferHandle, data, size, (uintptr_t)(USB_HOST_CDC_EVENT_READ_COMPLETE));
9D008AF8  8C840018   LW A0, 24(A0)
9D008AFC  0F4010F1   JAL USB_HOST_DeviceTransfer
9D008B00  AFA00010   SW ZERO, 16(SP)
1487:                                    cdcResult = _USB_HOST_CDC_HostResutlToCDCResultMap(hostResult);
9D008B04  0F402456   JAL _USB_HOST_CDC_HostResutlToCDCResultMap
9D008B08  00402021   ADDU A0, V0, ZERO
1488:                                }
1489:                            }
1490:                        }
1491:                    }
1492:                
1493:                    return(cdcResult);
1494:                }
9D008B0C  0B4022C8   J 0x9D008B20
1495:                
1496:                // ****************************************************************************
1497:                /* Function:
1498:                    USB_HOST_CDC_RESULT USB_HOST_CDC_SerialStateNotificationGet
1499:                    (
1500:                        USB_HOST_CDC_HANDLE handle,
1501:                        USB_HOST_CDC_TRANSFER_HANDLE * transferHandle,
1502:                        USB_CDC_SERIAL_STATE * serialState
1503:                    );
1504:                           
1505:                  Summary:
1506:                    This function will request Serial State Notification from the attached
1507:                    device.
1508:                
1509:                  Description:
1510:                    This function will request Serial State Notification from the attached
1511:                    device. If the request was accepted, transferHandle will contain a valid
1512:                    transfer handle, else it will contain USB_HOST_CDC_TRANSFER_HANDLE_INVALID.
1513:                    The completion of the request will be indicated by the
1514:                    USB_HOST_CDC_EVENT_SERIAL_STATE_NOTIFICATION_RECEIVED event. The transfer
1515:                    handle will be returned in the event. 
1516:                
1517:                  Remarks:
1518:                    None.
1519:                */
1520:                
1521:                USB_HOST_CDC_RESULT USB_HOST_CDC_SerialStateNotificationGet
1522:                (
1523:                    USB_HOST_CDC_HANDLE handle,
1524:                    USB_HOST_CDC_TRANSFER_HANDLE * transferHandle,
1525:                    USB_CDC_SERIAL_STATE * serialState
1526:                )
1527:                {
1528:                    USB_HOST_CDC_INSTANCE_OBJ * cdcInstance;
1529:                    USB_HOST_CDC_TRANSFER_HANDLE * tempTransferHandle, localTransferHandle;
1530:                    USB_HOST_CDC_RESULT cdcResult = USB_HOST_CDC_RESULT_FAILURE;
1531:                    USB_HOST_RESULT hostResult;
1532:                
1533:                    cdcInstance = (USB_HOST_CDC_INSTANCE_OBJ *)handle;
1534:                
1535:                    if(cdcInstance == NULL)
1536:                    {
1537:                        /* This handle is not valid */
1538:                        cdcResult = USB_HOST_CDC_RESULT_HANDLE_INVALID;
1539:                    }
1540:                    else
1541:                    {
1542:                        /* Check if the specified transfer handle holder is NULL, if so use a local
1543:                         * transfer handle holder */
1544:                
1545:                        tempTransferHandle = (transferHandle == NULL) ? &localTransferHandle: transferHandle;
1546:                
1547:                        if(!cdcInstance->inUse)
1548:                        {
1549:                            /* This object is not valid */
1550:                            cdcResult = USB_HOST_CDC_RESULT_DEVICE_UNKNOWN;
1551:                        }
1552:                        else
1553:                        {
1554:                            if(cdcInstance->state != USB_HOST_CDC_STATE_READY)
1555:                            {
1556:                                /* The instance is not ready for requests */
1557:                                cdcResult = USB_HOST_CDC_RESULT_BUSY;
1558:                            }
1559:                            else
1560:                            {
1561:                                if(serialState == NULL)
1562:                                {
1563:                                    /* Input paramters are not valid */
1564:                                    cdcResult = USB_HOST_CDC_RESULT_INVALID_PARAMETER;
1565:                                }
1566:                                else
1567:                                {
1568:                                    /* The context for the transfer is the event that needs to
1569:                                     * be sent to the application. In this case the event to be
1570:                                     * sent to the application when the transfer completes is
1571:                                     * USB_HOST_CDC_EVENT_SERIAL_STATE_NOTIFICATION_RECEIVED */
1572:                                    
1573:                                    hostResult = USB_HOST_DeviceTransfer(cdcInstance->interruptPipeHandle, tempTransferHandle, serialState, sizeof(USB_CDC_SERIAL_STATE), 
1574:                                            (uintptr_t)(USB_HOST_CDC_EVENT_SERIAL_STATE_NOTIFICATION_RECEIVED));
1575:                                    cdcResult = _USB_HOST_CDC_HostResutlToCDCResultMap(hostResult);
1576:                                }
1577:                            }
1578:                        }
1579:                    }
1580:                
1581:                    return(cdcResult);
1582:                }
1583:                
1584:                
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/usb/src/dynamic/usb_host.c
1:                   /*******************************************************************************
2:                     USB Host Layer Implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       usb_host.c
9:                   
10:                    Summary:
11:                      This file contains implementations of both private and public functions
12:                      of the USB Host Layer.
13:                  
14:                    Description:
15:                      This file contains the USB host layer implementation. This file should be
16:                      included in the project if USB Host functionality is desired.
17:                  *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute Software
24:                  only when embedded on a Microchip microcontroller or digital  signal  controller
25:                  that is integrated into your product or third party  product  (pursuant  to  the
26:                  sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
32:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
36:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
38:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
39:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
41:                  *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  // *****************************************************************************
45:                  // *****************************************************************************
46:                  // Section: Included Files
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  #include <stdlib.h>
50:                  #include <stdint.h>
51:                  #include <stdbool.h>
52:                  #include "system_config.h"
53:                  #include "usb/usb_common.h"
54:                  #include "usb/usb_chapter_9.h"
55:                  #include "system/common/sys_module.h"
56:                  #include "usb/usb_host.h"
57:                  #include "usb/src/usb_host_local.h"
58:                  #include "driver/tmr/drv_tmr.h"
59:                  #include "system/tmr/sys_tmr.h"
60:                  #include "system/debug/sys_debug.h"
61:                  #include "usb/src/usb_host_hub_mapping.h"
62:                  #include "osal/osal.h"
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Global Data
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  /*******************************************************
71:                   * Host layer object. There is only such object because
72:                   * multiple host controller will be controlled by only
73:                   * one host layer.
74:                   *******************************************************/
75:                  static USB_HOST_OBJ  gUSBHostObj;
76:                  
77:                  /*************************************************************
78:                   * Host bus objects. One object per bus on in other words
79:                   * one object per host controller. The index of the bus object
80:                   * is also the bus number. Hence bus object at index 1 in this
81:                   * array will be bus 1.
82:                   *************************************************************/
83:                  static USB_HOST_BUS_OBJ  gUSBHostBusList[USB_HOST_CONTROLLERS_NUMBER];
84:                  
85:                  /************************************************************
86:                   * Host device Objects. One object per attached device. This
87:                   * array tracks the attached device. Additional device objects
88:                   * are needed for root hubs.
89:                   ************************************************************/
90:                  static USB_HOST_DEVICE_OBJ  gUSBHostDeviceList [ USB_HOST_CONTROLLERS_NUMBER + USB_HOST_DEVICES_NUMBER ];
91:                  
92:                  /************************************************************
93:                   * Array of Pipe Objects. These pipes will be used by all the
94:                   * client drivers that needs to access attached devices. This 
95:                   * array is a shared pool. Pipe object are assigned to client
96:                   * drivers when client driver open pipes.
97:                   ************************************************************/
98:                  static USB_HOST_PIPE_OBJ  gUSBHostPipeObj[ USB_HOST_PIPES_NUMBER ];
99:                  
100:                 /************************************************************
101:                  * Array of transfer object. Each object tracks one transfer.
102:                  * This array is a shared pool. Transfer objects are assigned
103:                  * to client driver transfer requests.
104:                  ************************************************************/
105:                 static USB_HOST_TRANSFER_OBJ gUSBHostTransferObj[ USB_HOST_TRANSFERS_NUMBER ];
106:                 
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 // Section: USB HOST Layer Local Functions
110:                 // *****************************************************************************
111:                 // *****************************************************************************
112:                 
113:                 // *****************************************************************************
114:                 /* Function:
115:                     void * _USB_HOST_TimerCallback
116:                     (
117:                        uint32_t context,
118:                        uint32_t currtick
119:                     )
120:                 
121:                   Summary:
122:                     Function is called when the SYS_TMR_CallbackSingle expires.
123:                 
124:                   Description:
125:                     Function is called when the SYS_TMR_CallbackSingle expires.
126:                 
127:                   Remarks:
128:                     This is a local function and should not be called directly by the
129:                     application.
130:                 */    
131:                 
132:                 void _USB_HOST_TimerCallback(uintptr_t context, uint32_t currtick)
133:                 {
134:                     USB_HOST_BUS_OBJ * busObj = ((USB_HOST_BUS_OBJ *)(context));
135:                     busObj->timerExpired = true;
9D009AF8  24020001   ADDIU V0, ZERO, 1
136:                 }
137:                 
138:                 // *****************************************************************************
139:                 /* Function:
140:                     void * _USB_HOST_FindEndOfDescriptor(void * descriptor) 
141:                 
142:                   Summary:
143:                     Function finds the end of descritor marker and returns the pointer to where
144:                     the marker has started.
145:                 
146:                   Description:
147:                     Function finds the end of descriptor marker and returns the pointer to where
148:                     the marker has started.
149:                 
150:                   Remarks:
151:                     This is a local function and should not be called directly by the
152:                     application.
153:                 */    
154:                 
155:                 void * _USB_HOST_FindEndOfDescriptor(void * descriptor) 
156:                 {
157:                     uint8_t * search;
158:                     void * result = NULL;
159:                     int foundMarkers = 0;
160:                 
161:                     if(descriptor == NULL) 
9D008ED8  10800010   BEQ A0, ZERO, 0x9D008F1C
9D008EDC  00801021   ADDU V0, A0, ZERO
9D008EE0  24830001   ADDIU V1, A0, 1
9D008EE4  00003021   ADDU A2, ZERO, ZERO
9D008EE8  00001021   ADDU V0, ZERO, ZERO
162:                     {
163:                         result = NULL;
164:                     }
165:                     else
166:                     {
167:                         search = (uint8_t *)(descriptor);
168:                         while(foundMarkers < 7)
9D008F14  14A0FFF9   BNE A1, ZERO, 0x9D008EFC
9D008F18  24630001   ADDIU V1, V1, 1
9D008F1C  03E00008   JR RA
9D008F20  00000000   NOP
169:                         {
170:                             if(*search == 0xFF)
9D008EEC  240400FF   ADDIU A0, ZERO, 255
9D008EFC  9065FFFF   LBU A1, -1(V1)
9D008F00  14A40008   BNE A1, A0, 0x9D008F24
9D008F04  2467FFFF   ADDIU A3, V1, -1
171:                             {
172:                                 /* Found a marker */
173:                                 foundMarkers ++;
9D008F08  24C60001   ADDIU A2, A2, 1
174:                                 if(foundMarkers == 1)
9D008EF0  0B4023BF   J 0x9D008EFC
9D008EF4  24080001   ADDIU T0, ZERO, 1
9D008EF8  24630001   ADDIU V1, V1, 1
9D008F0C  10C80008   BEQ A2, T0, 0x9D008F30
9D008F10  28C50007   SLTI A1, A2, 7
175:                                 {
176:                                     /* This is the first marker we found. Save the memory
177:                                      * location */
178:                                     result = search;
179:                                 }
180:                 
181:                             }
182:                             else
183:                             {
184:                                 /* Reset the result */
185:                                 foundMarkers = 0;
9D008F24  00003021   ADDU A2, ZERO, ZERO
186:                                 result = NULL;
9D008F28  0B4023BE   J 0x9D008EF8
187:                             }
188:                 
189:                             search ++;
190:                         }
191:                     }
192:                 
193:                     return(result);
194:                 }
195:                 
196:                 // *****************************************************************************
197:                 /* Function:
198:                     void _USB_HOST_RootHubEventDisable(void) 
199:                 
200:                   Summary:
201:                     Disables all root hub events.
202:                 
203:                   Description:
204:                     This function will disable all root hub events.
205:                 
206:                   Remarks:
207:                     This is a local function and should not be called directly by the
208:                     application.
209:                 */    
210:                 
211:                 void _USB_HOST_RootHubEventDisable(void)
212:                 {
9D009644  27BDFFE8   ADDIU SP, SP, -24
9D009648  AFBF0014   SW RA, 20(SP)
9D00964C  AFB00010   SW S0, 16(SP)
213:                     int iterator;
214:                     USB_HOST_BUS_OBJ * busObj;
215:                 
216:                     for(iterator = 0; iterator < USB_HOST_CONTROLLERS_NUMBER; iterator ++)
217:                     {
218:                         busObj = &gUSBHostBusList[iterator];
219:                         
220:                         /* Disable the event. Save the event status */
221:                         busObj->eventsStatusRestore = busObj->hcdInterface->hostEventsDisable(busObj->hcdHandle);
9D009650  3C02A000   LUI V0, -24576
9D009654  245066E8   ADDIU S0, V0, 26344
9D009658  8E03000C   LW V1, 12(S0)
9D00965C  8C630014   LW V1, 20(V1)
9D009660  0060F809   JALR V1
9D009664  8C4466E8   LW A0, 26344(V0)
9D009668  A202004A   SB V0, 74(S0)
222:                     } 
223:                 }
9D00966C  8FBF0014   LW RA, 20(SP)
224:                 
225:                 // *****************************************************************************
226:                 /* Function:
227:                     void _USB_HOST_RootHubEventEnable(void) 
228:                 
229:                   Summary:
230:                     Enables all root hub events.
231:                 
232:                   Description:
233:                     This function will enables all root hub events.
234:                 
235:                   Remarks:
236:                     This is a local function and should not be called directly by the
237:                     application.
238:                 */    
239:                 
240:                 void _USB_HOST_RootHubEventEnable(void)
241:                 {
9D009718  27BDFFE8   ADDIU SP, SP, -24
9D00971C  AFBF0014   SW RA, 20(SP)
242:                     int iterator;
243:                     USB_HOST_BUS_OBJ * busObj;
244:                 
245:                     for(iterator = 0; iterator < USB_HOST_CONTROLLERS_NUMBER; iterator ++)
246:                     {
247:                         busObj = &gUSBHostBusList[iterator];
248:                         
249:                         /* Restore the events to what their status was when they were disabled  */
250:                         busObj->hcdInterface->hostEventsEnable(busObj->hcdHandle, busObj->eventsStatusRestore);
9D009720  3C03A000   LUI V1, -24576
9D009724  246266E8   ADDIU V0, V1, 26344
9D009728  8C44000C   LW A0, 12(V0)
9D00972C  8C860018   LW A2, 24(A0)
9D009730  8C6466E8   LW A0, 26344(V1)
9D009734  00C0F809   JALR A2
9D009738  9045004A   LBU A1, 74(V0)
251:                     } 
252:                 }
9D00973C  8FBF0014   LW RA, 20(SP)
253:                 
254:                 // *****************************************************************************
255:                 /* Function:
256:                     bool _USB_HOST_NoInterfacesOwned
257:                     (
258:                         USB_HOST_DEVICE_OBJ * deviceObj,
259:                     );
260:                 
261:                   Summary:
262:                     This function will return true if no interface have been owned and search
263:                     has reach end of TPL.
264:                 
265:                   Description:
266:                     This function will return true if no interface have been owned and search
267:                     has reach end of TPL. It will return false if at least one interface is
268:                     claimed or if all the interfaces are empty.
269:                 
270:                   Remarks:
271:                     This is a local function and should not be called directly by the
272:                     application.
273:                 */    
274:                 
275:                 bool _USB_HOST_NoInterfacesOwned
276:                 (
277:                     USB_HOST_DEVICE_OBJ * deviceObj
278:                 )
279:                 {
280:                     bool result = false;
9D009000  00001021   ADDU V0, ZERO, ZERO
281:                     USB_HOST_INTERFACE_DESC_INFO * interfaceInfo;
282:                     int iterator;
283:                 
284:                     /* Check every interface in this device */
285:                     for(iterator = 0; iterator < USB_HOST_DEVICE_INTERFACES_NUMBER; iterator ++)
9D009030  1460FFF4   BNE V1, ZERO, 0x9D009004
9D009034  24840020   ADDIU A0, A0, 32
9D009038  03E00008   JR RA
9D00903C  00000000   NOP
286:                     {
287:                         interfaceInfo = &(deviceObj->configDescriptorInfo.interfaceInfo[iterator]);
288:                         if(interfaceInfo->interfaceDescriptor != NULL)
9D009004  8C850104   LW A1, 260(A0)
9D009008  50A00009   BEQL A1, ZERO, 0x9D009030
9D00900C  2463FFFF   ADDIU V1, V1, -1
289:                         {
290:                             /* Interface has valid interface descriptor. Check if is owned */
291:                             if((interfaceInfo->interfaceDriver == NULL) && (interfaceInfo->tplEntryMatched >= gUSBHostObj.nTPLEntries))
9D008FF4  3C02A000   LUI V0, -24576
9D008FF8  90476744   LBU A3, 26436(V0)
9D008FFC  24030005   ADDIU V1, ZERO, 5
9D009010  8C82010C   LW V0, 268(A0)
9D009014  1440000A   BNE V0, ZERO, 0x9D009040
9D009018  00000000   NOP
9D00901C  8C820118   LW V0, 280(A0)
9D009020  0047102A   SLT V0, V0, A3
9D009024  14400008   BNE V0, ZERO, 0x9D009048
9D009028  2463FFFF   ADDIU V1, V1, -1
292:                             {
293:                                 /* This means all the driver were tried and this interface was
294:                                  * not owned */
295:                                 result = true;
9D00902C  24020001   ADDIU V0, ZERO, 1
296:                             }
297:                             else
298:                             {
299:                                 /* Either the interface is claimed or all TPL entries have
300:                                  * not been searched */
301:                                 result = false;
9D009040  03E00008   JR RA
9D009044  00001021   ADDU V0, ZERO, ZERO
302:                                 break;
303:                             }
304:                         }
305:                     }
306:                     
307:                     return(result);
308:                 }
9D009048  03E00008   JR RA
309:                 
310:                 // *****************************************************************************
311:                 /* Function:
312:                     void _USB_HOST_UpdateInterfaceStatus
313:                     (
314:                         USB_HOST_DEVICE_OBJ * deviceObj,
315:                         int busIndex
316:                     );
317:                 
318:                   Summary:
319:                     This function will update status of the interfaces.
320:                 
321:                   Description:
322:                     This function will update the status of the interfaces. If a interface is
323:                     not assigned it is either assigned to the device level driver or it is
324:                     assigned to an interface driver. The function will call the tasks routines
325:                     of the interface driver. It checks if the all device is not owned at all
326:                     then it will move the device to an error state.
327:                 
328:                   Remarks:
329:                     This is a local function and should not be called directly by the
330:                     application.
331:                 */    
332:                 
333:                 void _USB_HOST_UpdateInterfaceStatus
334:                 (
335:                     USB_HOST_DEVICE_OBJ * deviceObj,
336:                     int busIndex
337:                 )
338:                 {
9D002A60  27BDFFB0   ADDIU SP, SP, -80
9D002A64  AFBF004C   SW RA, 76(SP)
9D002A68  AFB70048   SW S7, 72(SP)
9D002A6C  AFB60044   SW S6, 68(SP)
9D002A70  AFB50040   SW S5, 64(SP)
9D002A74  AFB4003C   SW S4, 60(SP)
9D002A78  AFB30038   SW S3, 56(SP)
9D002A7C  AFB20034   SW S2, 52(SP)
9D002A80  AFB10030   SW S1, 48(SP)
9D002A84  AFB0002C   SW S0, 44(SP)
339:                     USB_HOST_BUS_OBJ * busObj;
340:                     USB_HOST_INTERFACE_DESC_INFO * interfaceInfo, * interfaceInfoIterator;
341:                     USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandles[USB_HOST_DEVICE_INTERFACES_NUMBER];
342:                     USB_INTERFACE_DESCRIPTOR * interfaceDescriptor;
343:                     USB_INTERFACE_ASSOCIATION_DESCRIPTOR * interfaceAssociation;
344:                     int iterator, iadIterator;
345:                 
346:                     busObj = &(gUSBHostBusList[busIndex]);
347:                 
348:                     /* This redundant statement is added to avoid warning in a case where the
349:                      * debug messages are disabled. */
350:                     busObj = busObj;
351:                     
352:                     if((deviceObj->deviceState == USB_HOST_DEVICE_STATE_READY) && 
9D002A88  8C8300F0   LW V1, 240(A0)
9D002A8C  2402000F   ADDIU V0, ZERO, 15
9D002A90  146200AA   BNE V1, V0, 0x9D002D3C
9D002A94  00808821   ADDU S1, A0, ZERO
9D002A98  908201A5   LBU V0, 421(A0)
9D002A9C  2442FFFF   ADDIU V0, V0, -1
9D002AA0  304200FF   ANDI V0, V0, 255
9D002AA4  2C4200FE   SLTIU V0, V0, 254
9D002AA8  504000A5   BEQL V0, ZERO, 0x9D002D40
9D002AAC  8FBF004C   LW RA, 76(SP)
353:                             (deviceObj->configDescriptorInfo.configurationNumber > 0) &&
354:                             (deviceObj->configDescriptorInfo.configurationNumber != USB_HOST_CONFIGURATION_NUMBER_INVALID))
355:                     {
356:                         /* This means that the device is in a running state and the device is
357:                          * configured */
358:                         for(iterator = 0; iterator < deviceObj->nInterfaces ; iterator ++)
9D002AB0  908200D5   LBU V0, 213(A0)
9D002AB4  58400087   BLEZL V0, 0x9D002CD4
9D002AB8  8E2200E0   LW V0, 224(S1)
9D002ABC  24900104   ADDIU S0, A0, 260
9D002AC0  00009021   ADDU S2, ZERO, ZERO
9D002C4C  0B400B30   J 0x9D002CC0
9D002C50  26520001   ADDIU S2, S2, 1
9D002CBC  26520001   ADDIU S2, S2, 1
9D002CC0  922200D5   LBU V0, 213(S1)
9D002CC4  0242102A   SLT V0, S2, V0
9D002CC8  1440FF80   BNE V0, ZERO, 0x9D002ACC
9D002CCC  26100020   ADDIU S0, S0, 32
359:                         {
360:                             interfaceInfo = &deviceObj->configDescriptorInfo.interfaceInfo[iterator];
361:                 
362:                             if(interfaceInfo->interfaceDriver != NULL)
9D002ACC  8E020008   LW V0, 8(S0)
9D002AD0  10400006   BEQ V0, ZERO, 0x9D002AEC
9D002AD4  02009821   ADDU S3, S0, ZERO
363:                             {
364:                                 /* The interface is owned. Run the tasks routine of this driver */
365:                                 interfaceInfo->interfaceDriver->interfaceTasks(interfaceInfo->interfaceHandle);
9D002AD8  8C420028   LW V0, 40(V0)
9D002ADC  0040F809   JALR V0
9D002AE0  8E04000C   LW A0, 12(S0)
9D002AE4  0B400B30   J 0x9D002CC0
9D002AE8  26520001   ADDIU S2, S2, 1
366:                             }
367:                             else
368:                             {
369:                                 /* Driver is not assigned. Check if this device has a device
370:                                  * level driver and that this interface has not already been
371:                                  * tried with that driver */
372:                 
373:                                 if((deviceObj->deviceClientDriver != NULL) && (!interfaceInfo->wasTriedWithDeviceDriver))
9D002AEC  8E2200E0   LW V0, 224(S1)
9D002AF0  5040002B   BEQL V0, ZERO, 0x9D002BA0
9D002AF4  8E670014   LW A3, 20(S3)
9D002AF8  92030010   LBU V1, 16(S0)
9D002AFC  54600028   BNEL V1, ZERO, 0x9D002BA0
9D002B00  8E670014   LW A3, 20(S3)
374:                                 {
375:                                     /* The device is owned and the interface has not been tried
376:                                      * yet with the device driver. Call the interface assign
377:                                      * function of the device client driver */
378:                 
379:                                     if(interfaceInfo->interfaceAssociationDescriptor != NULL)
9D002B04  8E030004   LW V1, 4(S0)
9D002B08  50600019   BEQL V1, ZERO, 0x9D002B70
9D002B0C  8E070000   LW A3, 0(S0)
380:                                     {
381:                                         /* IAD Case. Prepare the table of interfaces and assign
382:                                          * all of them to the same driver */
383:                 
384:                                         interfaceInfoIterator = interfaceInfo;
385:                                         iadIterator = 0;
386:                                         while(interfaceInfoIterator != NULL)
9D002B10  1200000E   BEQ S0, ZERO, 0x9D002B4C
9D002B14  27A30010   ADDIU V1, SP, 16
9D002B18  02001021   ADDU V0, S0, ZERO
9D002B1C  00003021   ADDU A2, ZERO, ZERO
9D002B3C  1440FFF8   BNE V0, ZERO, 0x9D002B20
9D002B40  24630004   ADDIU V1, V1, 4
9D002B44  0B400AD5   J 0x9D002B54
9D002B48  8E2200E0   LW V0, 224(S1)
9D002B4C  00003021   ADDU A2, ZERO, ZERO
387:                                         {
388:                                             /* Add the handle of this interface to the interface
389:                                              * table. Assign the device level driver to all
390:                                              * interfaces. */
391:                                             interfaceHandles[iadIterator] = interfaceInfoIterator->interfaceHandle;
9D002B20  8C44000C   LW A0, 12(V0)
9D002B24  AC640000   SW A0, 0(V1)
392:                                             interfaceInfoIterator->interfaceDriver = deviceObj->deviceClientDriver;
9D002B28  8E2400E0   LW A0, 224(S1)
9D002B2C  AC440008   SW A0, 8(V0)
393:                                             interfaceInfoIterator->wasTriedWithDeviceDriver = true;
9D002B30  A0540010   SB S4, 16(V0)
394:                                             iadIterator ++;
9D002B34  24C60001   ADDIU A2, A2, 1
395:                                             interfaceInfoIterator = interfaceInfoIterator->nextInterface;
9D002B38  8C42001C   LW V0, 28(V0)
396:                                         }
397:                 
398:                                         /* Now the interfaceHandles table has the handles of all
399:                                          * the interfaces in this IAD. Call the device client
400:                                          * driver interface assign function with this table. */
401:                 
402:                                         SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Assigning IAD group to device driver", busIndex, deviceObj->deviceAddress);
403:                                         deviceObj->deviceClientDriver->interfaceAssign(interfaceHandles,
9D002B50  8E2200E0   LW V0, 224(S1)
9D002B54  8C42001C   LW V0, 28(V0)
9D002B58  27A40010   ADDIU A0, SP, 16
9D002B5C  8E25004C   LW A1, 76(S1)
9D002B60  0040F809   JALR V0
9D002B64  8E670004   LW A3, 4(S3)
9D002B68  0B400B30   J 0x9D002CC0
9D002B6C  26520001   ADDIU S2, S2, 1
404:                                                 deviceObj->deviceIdentifier, iadIterator, (uint8_t *)(interfaceInfo->interfaceAssociationDescriptor));
405:                                     }
406:                                     else if(interfaceInfo->interfaceDescriptor != NULL)
9D002B70  10E00052   BEQ A3, ZERO, 0x9D002CBC
9D002B74  27A40010   ADDIU A0, SP, 16
407:                                     {
408:                                         /* Non IAD case. Prepare the interface handle table. In
409:                                          * case of a non IAD this will be one interface and
410:                                          * hence one handle only. */
411:                 
412:                                         interfaceHandles[0] = interfaceInfo->interfaceHandle;
9D002B78  8E03000C   LW V1, 12(S0)
9D002B7C  AFA30010   SW V1, 16(SP)
413:                 
414:                                         /* We assign the driver before calling the
415:                                          * interfaceAssign function. This will allow the client
416:                                          * to release the interface if it chooses to and the host
417:                                          * will try re-matching the interface. */
418:                 
419:                                         SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Assigning interface to device driver", busIndex, deviceObj->deviceAddress);
420:                                         interfaceInfo->interfaceDriver = deviceObj->deviceClientDriver;
9D002B80  AE020008   SW V0, 8(S0)
421:                                         deviceObj->deviceClientDriver->interfaceAssign(interfaceHandles,
9D002B84  8E2200E0   LW V0, 224(S1)
9D002B88  8C42001C   LW V0, 28(V0)
9D002B8C  8E25004C   LW A1, 76(S1)
9D002B90  0040F809   JALR V0
9D002B94  24060001   ADDIU A2, ZERO, 1
422:                                                 deviceObj->deviceIdentifier, 1, (uint8_t *)(interfaceInfo->interfaceDescriptor));
423:                 
424:                                         /* Set the flag indicating this was tried with device
425:                                          * driver. */
426:                                         interfaceInfo->wasTriedWithDeviceDriver = true;
9D002AC8  24140001   ADDIU S4, ZERO, 1
9D002B98  0B400B2F   J 0x9D002CBC
9D002B9C  A2140010   SB S4, 16(S0)
427:                                     }
428:                                 }
429:                                 else
430:                                 {
431:                                     /* This means the interface driver is never assigned, or if
432:                                      * there is a client driver it has released the interface,
433:                                      * or there isn't a device level client driver. Check the
434:                                      * TPL for a match. Has this searched reached the end of the
435:                                      * TPL table */
436:                 
437:                                     if(interfaceInfo->tplEntryMatched < gUSBHostObj.nTPLEntries)
9D002AC4  3C15A000   LUI S5, -24576
9D002BA0  26A36738   ADDIU V1, S5, 26424
9D002BA4  9076000C   LBU S6, 12(V1)
9D002BA8  00F6182A   SLT V1, A3, S6
9D002BAC  50600044   BEQL V1, ZERO, 0x9D002CC0
9D002BB0  26520001   ADDIU S2, S2, 1
438:                                     {
439:                                         /* Not tried with all TPL entries */
440:                                         if(interfaceInfo->interfaceAssociationDescriptor != NULL)
9D002BB4  8E630004   LW V1, 4(S3)
9D002BB8  50600026   BEQL V1, ZERO, 0x9D002C54
9D002BBC  8E770000   LW S7, 0(S3)
441:                                         {
442:                                             /* IAD case */
443:                 
444:                                             USB_HOST_CLIENT_DRIVER * matchedClientDriver;
445:                                             int matchedTPLEntry;
446:                 
447:                                             /* Get the Interface association descriptor */
448:                                             interfaceAssociation = interfaceInfo->interfaceAssociationDescriptor;
449:                 
450:                                             /* Search the TPL for a driver */
451:                                             interfaceInfo->tplEntryMatched = _USB_HOST_FindClassSubClassProtocolDriver(interfaceAssociation->bFunctionClass,
9D002BC0  90640004   LBU A0, 4(V1)
9D002BC4  90650005   LBU A1, 5(V1)
9D002BC8  90660006   LBU A2, 6(V1)
9D002BCC  0F401E4F   JAL _USB_HOST_FindClassSubClassProtocolDriver
9D002BD0  24E70001   ADDIU A3, A3, 1
452:                                                     interfaceAssociation->bFunctionSubClass, interfaceAssociation->bFunctionProtocol, interfaceInfo->tplEntryMatched + 1);
453:                 
454:                                             /* Did we find a driver match */
455:                                             if(interfaceInfo->tplEntryMatched < gUSBHostObj.nTPLEntries)
9D002BD4  0056B02A   SLT S6, V0, S6
9D002BD8  12C00038   BEQ S6, ZERO, 0x9D002CBC
9D002BDC  AE620014   SW V0, 20(S3)
456:                                             {
457:                                                 /* Yes we did */
458:                                                 interfaceInfoIterator = interfaceInfo;
9D002C04  02601821   ADDU V1, S3, ZERO
459:                                                 iadIterator = 0;
9D002C08  00003021   ADDU A2, ZERO, ZERO
9D002C34  00003021   ADDU A2, ZERO, ZERO
460:                                                 matchedTPLEntry = interfaceInfo->tplEntryMatched;
461:                                                 matchedClientDriver = gUSBHostObj.tpl[interfaceInfo->tplEntryMatched].hostClientDriver;
9D002BE0  26A36738   ADDIU V1, S5, 26424
9D002BE4  8C640010   LW A0, 16(V1)
9D002BE8  00021880   SLL V1, V0, 2
9D002BEC  00022900   SLL A1, V0, 4
9D002BF0  00651821   ADDU V1, V1, A1
9D002BF4  00831821   ADDU V1, A0, V1
462:                 
463:                                                 while(interfaceInfoIterator != NULL)
9D002BF8  1260000E   BEQ S3, ZERO, 0x9D002C34
9D002BFC  8C670010   LW A3, 16(V1)
9D002C00  27A40010   ADDIU A0, SP, 16
9D002C24  1460FFF9   BNE V1, ZERO, 0x9D002C0C
9D002C28  24840004   ADDIU A0, A0, 4
9D002C2C  0B400B0F   J 0x9D002C3C
9D002C30  8CE2001C   LW V0, 28(A3)
464:                                                 {
465:                                                     /* Add the handle of this interface to the interface
466:                                                      * table. Assign the device level driver to all
467:                                                      * interfaces. */
468:                                                     interfaceHandles[iadIterator] = interfaceInfoIterator->interfaceHandle;
9D002C0C  8C65000C   LW A1, 12(V1)
9D002C10  AC850000   SW A1, 0(A0)
469:                                                     interfaceInfoIterator->interfaceDriver = matchedClientDriver;
9D002C14  AC670008   SW A3, 8(V1)
470:                                                     interfaceInfoIterator->tplEntryMatched = matchedTPLEntry;
9D002C18  AC620014   SW V0, 20(V1)
471:                                                     iadIterator ++;
9D002C1C  24C60001   ADDIU A2, A2, 1
472:                                                     interfaceInfoIterator = interfaceInfoIterator->nextInterface;
9D002C20  8C63001C   LW V1, 28(V1)
473:                                                 }
474:                 
475:                                                 /* Now the interfaceHandles table has the
476:                                                  * handles of all the interfaces in this IAD.
477:                                                  * Call the client driver interface assign
478:                                                  * function with this table. */
479:                                                 
480:                                                 SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Assigning IAD to TPL entry %d", busIndex, deviceObj->deviceAddress, matchedTPLEntry);
481:                                                 matchedClientDriver->interfaceAssign(interfaceHandles,
9D002C38  8CE2001C   LW V0, 28(A3)
9D002C3C  27A40010   ADDIU A0, SP, 16
9D002C40  8E25004C   LW A1, 76(S1)
9D002C44  0040F809   JALR V0
9D002C48  8E670004   LW A3, 4(S3)
482:                                                         deviceObj->deviceIdentifier, iadIterator, (uint8_t *)(interfaceInfo->interfaceAssociationDescriptor));
483:                                             }
484:                                         }
485:                                         else if(interfaceInfo->interfaceDescriptor != NULL)
9D002C54  52E0001A   BEQL S7, ZERO, 0x9D002CC0
9D002C58  26520001   ADDIU S2, S2, 1
486:                                         {
487:                                             /* Single interface case */
488:                                             interfaceDescriptor = (USB_INTERFACE_DESCRIPTOR *)(interfaceInfo->interfaceDescriptor);
489:                 
490:                                             /* Search for a driver */
491:                                             interfaceInfo->tplEntryMatched = _USB_HOST_FindClassSubClassProtocolDriver(interfaceDescriptor->bInterfaceClass,
9D002C5C  92E40005   LBU A0, 5(S7)
9D002C60  92E50006   LBU A1, 6(S7)
9D002C64  92E60007   LBU A2, 7(S7)
9D002C68  0F401E4F   JAL _USB_HOST_FindClassSubClassProtocolDriver
9D002C6C  24E70001   ADDIU A3, A3, 1
492:                                                     interfaceDescriptor->bInterfaceSubClass, interfaceDescriptor->bInterfaceProtocol, interfaceInfo->tplEntryMatched + 1);
493:                 
494:                                             /* Did we find a driver match */
495:                                             if(interfaceInfo->tplEntryMatched < gUSBHostObj.nTPLEntries)
9D002C70  0056B02A   SLT S6, V0, S6
9D002C74  12C00011   BEQ S6, ZERO, 0x9D002CBC
9D002C78  AE620014   SW V0, 20(S3)
496:                                             {
497:                                                 /* This means we found a match. Assign the
498:                                                  * driver. Create the interface table with one 
499:                                                  * interface handle. */
500:                                                 
501:                                                 SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Assigning Interface to TPL entry %d", busIndex, deviceObj->deviceAddress, interfaceInfo->tplEntryMatched);
502:                                                 interfaceHandles[0] = interfaceInfo->interfaceHandle;
9D002C7C  8E63000C   LW V1, 12(S3)
9D002C80  AFA30010   SW V1, 16(SP)
503:                                                 interfaceInfo->interfaceDriver = gUSBHostObj.tpl[interfaceInfo->tplEntryMatched].hostClientDriver;
9D002C84  26A36738   ADDIU V1, S5, 26424
9D002C88  8C630010   LW V1, 16(V1)
9D002C8C  00022080   SLL A0, V0, 2
9D002C90  00021100   SLL V0, V0, 4
9D002C94  00821021   ADDU V0, A0, V0
9D002C98  00621021   ADDU V0, V1, V0
9D002C9C  8C420010   LW V0, 16(V0)
9D002CA0  AE620008   SW V0, 8(S3)
504:                                                 interfaceInfo->interfaceDriver->interfaceAssign(interfaceHandles, 
9D002CA4  8C42001C   LW V0, 28(V0)
9D002CA8  27A40010   ADDIU A0, SP, 16
9D002CAC  8E25004C   LW A1, 76(S1)
9D002CB0  24060001   ADDIU A2, ZERO, 1
9D002CB4  0040F809   JALR V0
9D002CB8  02E03821   ADDU A3, S7, ZERO
505:                                                         deviceObj->deviceIdentifier, 1, (uint8_t *)(interfaceInfo->interfaceDescriptor));
506:                                             }
507:                                         }
508:                                     }
509:                                 }
510:                             }
511:                         }
512:                 
513:                         /* We have to keep check if all the interfaces and the device are
514:                          * owned. If we reach a point where none are owned and the search has
515:                          * reached the end of TPL, then we move the device to an error state.
516:                          * Moving the device to an error state will reduce the processing that
517:                          * the host has to do for this device */
518:                 
519:                         if((deviceObj->deviceClientDriver == NULL) &&
9D002CD0  8E2200E0   LW V0, 224(S1)
9D002CD4  1440001A   BNE V0, ZERO, 0x9D002D40
9D002CD8  8FBF004C   LW RA, 76(SP)
9D002CE4  8E2300E4   LW V1, 228(S1)
9D002CE8  0062102A   SLT V0, V1, V0
9D002CEC  54400015   BNEL V0, ZERO, 0x9D002D44
9D002CF0  8FB70048   LW S7, 72(SP)
520:                                 (deviceObj->tplEntryTried >= gUSBHostObj.nTPLEntries) &&
9D002CDC  3C02A000   LUI V0, -24576
9D002CE0  90426744   LBU V0, 26436(V0)
9D002CFC  10400010   BEQ V0, ZERO, 0x9D002D40
9D002D00  8FBF004C   LW RA, 76(SP)
521:                                 (_USB_HOST_NoInterfacesOwned(deviceObj)))
9D002CF4  0F4023FD   JAL _USB_HOST_NoInterfacesOwned
9D002CF8  02202021   ADDU A0, S1, ZERO
522:                         {
523:                             /* This means that no driver will match this device. Move this
524:                              * device to an error state */
525:                 
526:                             SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d not matched to any TPL entry", busIndex, deviceObj->deviceAddress);
527:                             deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D002D04  2402FFFF   ADDIU V0, ZERO, -1
9D002D08  AE2200F0   SW V0, 240(S1)
528:                             deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D002D0C  8E22006C   LW V0, 108(S1)
9D002D10  8C420020   LW V0, 32(V0)
9D002D14  0040F809   JALR V0
9D002D18  8E240058   LW A0, 88(S1)
529:                             if(gUSBHostObj.hostEventHandler != NULL)
9D002D1C  3C02A000   LUI V0, -24576
9D002D20  8C426738   LW V0, 26424(V0)
9D002D24  10400005   BEQ V0, ZERO, 0x9D002D3C
9D002D28  24040001   ADDIU A0, ZERO, 1
530:                             {
531:                                 /* Send an event to the application */
532:                                 gUSBHostObj.hostEventHandler(USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context);
9D002D2C  00002821   ADDU A1, ZERO, ZERO
9D002D30  3C03A000   LUI V1, -24576
9D002D34  0040F809   JALR V0
9D002D38  8C66673C   LW A2, 26428(V1)
533:                             }
534:                         }
535:                     }
536:                 }
9D002D3C  8FBF004C   LW RA, 76(SP)
537:                 
538:                 // *****************************************************************************
539:                 /* Function:
540:                     void _USB_HOST_ReleaseInterfaceDrivers
541:                     (
542:                         USB_HOST_DEVICE_OBJ * deviceObj,
543:                     );
544:                 
545:                   Summary:
546:                     This function will release all the loaded interface drivers.
547:                 
548:                   Description:
549:                     This function will release all the loaded interface drivers. The matching
550:                     driver index for each interface will be updated to indicate that the
551:                     matching should start at the top of the TPL table.
552:                 
553:                   Remarks:
554:                     This is a local function and should not be called directly by the
555:                     application.
556:                 */    
557:                 
558:                 void _USB_HOST_ReleaseInterfaceDrivers
559:                 (
560:                     USB_HOST_DEVICE_OBJ * deviceObj
561:                 )
562:                 {
9D008664  27BDFFD8   ADDIU SP, SP, -40
9D008668  AFBF0024   SW RA, 36(SP)
9D00866C  AFB40020   SW S4, 32(SP)
9D008670  AFB3001C   SW S3, 28(SP)
9D008674  AFB20018   SW S2, 24(SP)
9D008678  AFB10014   SW S1, 20(SP)
9D00867C  AFB00010   SW S0, 16(SP)
9D008680  00808021   ADDU S0, A0, ZERO
563:                     int iterator;
564:                     USB_HOST_INTERFACE_DESC_INFO * interfaceInfo;
565:                 
566:                     for(iterator = 0; iterator < USB_HOST_DEVICE_INTERFACES_NUMBER; iterator ++)
9D008684  00009021   ADDU S2, ZERO, ZERO
9D00868C  24130005   ADDIU S3, ZERO, 5
9D0086B8  26520001   ADDIU S2, S2, 1
9D0086BC  1653FFF4   BNE S2, S3, 0x9D008690
9D0086C0  26100020   ADDIU S0, S0, 32
567:                     {
568:                         interfaceInfo = &(deviceObj->configDescriptorInfo.interfaceInfo[iterator]);
569:                         if(interfaceInfo->interfaceDriver != NULL)
9D008690  8E02010C   LW V0, 268(S0)
9D008694  10400005   BEQ V0, ZERO, 0x9D0086AC
9D008698  02008821   ADDU S1, S0, ZERO
570:                         {
571:                             interfaceInfo->interfaceDriver->interfaceRelease(interfaceInfo->interfaceHandle);
9D00869C  8C420020   LW V0, 32(V0)
9D0086A0  0040F809   JALR V0
9D0086A4  8E040110   LW A0, 272(S0)
572:                             interfaceInfo->interfaceDriver = NULL;
9D0086A8  AE00010C   SW ZERO, 268(S0)
573:                         }
574:                 
575:                         /* Clear up the other interface members */
576:                         interfaceInfo->tplEntryMatched = -1;
9D008688  2414FFFF   ADDIU S4, ZERO, -1
9D0086AC  AE340118   SW S4, 280(S1)
577:                         interfaceInfo->interfaceDescriptor = NULL;
9D0086B0  AE200104   SW ZERO, 260(S1)
578:                         interfaceInfo->wasTriedWithDeviceDriver = false;
9D0086B4  A2200114   SB ZERO, 276(S1)
579:                     }
580:                 }
9D0086C4  8FBF0024   LW RA, 36(SP)
581:                 
582:                 // *****************************************************************************
583:                 /* Function:
584:                     void _USB_HOST_ConfigurationDescriptorParse
585:                     (
586:                         USB_HOST_DEVICE_OBJ * deviceObj,
587:                     );
588:                 
589:                   Summary:
590:                     This function will parse the configuration descriptor contained in the
591:                     configurationDescriptor of the configDescriptorInfo structure in deviceObj
592:                     and will populate the interface tables. If the configuration descriptor
593:                     contains IADs, it will then link the interfaces as defined by the IAD.
594:                 
595:                   Description:
596:                     This function will parse the configuration descriptor contained in the
597:                     configurationDescriptor of the configDescriptorInfo structure in deviceObj
598:                     and will populate the interface tables. If the configuration descriptor
599:                     contains IADs, it will then link the interfaces as defined by the IAD.
600:                 
601:                   Remarks:
602:                     This is a local function and should not be called directly by the
603:                     application.
604:                 */    
605:                 
606:                 bool _USB_HOST_ConfigurationDescriptorParse
607:                 (
608:                     USB_HOST_DEVICE_OBJ * deviceObj
609:                 )
610:                 {
9D0058A4  27BDFFB0   ADDIU SP, SP, -80
9D0058A8  AFBF004C   SW RA, 76(SP)
9D0058AC  AFB70048   SW S7, 72(SP)
9D0058B0  AFB60044   SW S6, 68(SP)
9D0058B4  AFB50040   SW S5, 64(SP)
9D0058B8  AFB4003C   SW S4, 60(SP)
9D0058BC  AFB30038   SW S3, 56(SP)
9D0058C0  AFB20034   SW S2, 52(SP)
9D0058C4  AFB10030   SW S1, 48(SP)
9D0058C8  AFB0002C   SW S0, 44(SP)
9D0058CC  00809021   ADDU S2, A0, ZERO
611:                     USB_HOST_INTERFACE_DESCRIPTOR_QUERY interfaceQueryObj;
612:                     USB_CONFIGURATION_DESCRIPTOR * configurationDescriptor;
613:                     USB_INTERFACE_DESCRIPTOR * interfaceDescriptor;
614:                     USB_INTERFACE_ASSOCIATION_DESCRIPTOR * interfaceAssociation;
615:                     USB_HOST_INTERFACE_DESC_INFO * interfaceDescInfo, * previousInterface;
616:                     USB_HOST_IAD_QUERY iadQueryObj;
617:                     bool result = true;
618:                     unsigned int iterator;
619:                     uint8_t bFirstInterface;
620:                     uint8_t bInterfaceCount;
621:                 
622:                     /* Get the device index and the pnp identifier. These are needed to form the
623:                      * interface handle */
624:                     unsigned int deviceIndex = USB_HOST_DEVICE_INDEX(deviceObj->deviceIdentifier);
9D0058D0  8C82004C   LW V0, 76(A0)
9D0058D4  304300FF   ANDI V1, V0, 255
625:                     unsigned int pnpIdentifier = USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier);
9D0058D8  00021402   SRL V0, V0, 16
626:                 
627:                     /* Get the configuration descriptor and the number of interfaces */
628:                     configurationDescriptor = deviceObj->configDescriptorInfo.configurationDescriptor;
9D0058DC  8C910100   LW S1, 256(A0)
629:                     int nInterfaces = configurationDescriptor->bNumInterfaces;
9D0058E0  92360004   LBU S6, 4(S1)
630:                 
631:                     /* Reset the interface query context. Set up the interface query to find 
632:                      * interface by number and alternate setting 0 */
633:                     USB_HOST_DeviceInterfaceQueryContextClear(&interfaceQueryObj);
634:                     interfaceQueryObj.flags = USB_HOST_INTERFACE_QUERY_BY_NUMBER|USB_HOST_INTERFACE_QUERY_ALT_SETTING;
9D0058E8  24040003   ADDIU A0, ZERO, 3
9D0058EC  AFA40018   SW A0, 24(SP)
635:                     interfaceQueryObj.bAlternateSetting = 0;
636:                 
637:                     for(iterator = 0; iterator < nInterfaces; iterator ++)
9D0058F0  12C0001A   BEQ S6, ZERO, 0x9D00595C
9D0058F4  A3A00011   SB ZERO, 17(SP)
9D0058F8  02C0B821   ADDU S7, S6, ZERO
9D005908  00009821   ADDU S3, ZERO, ZERO
9D005944  26730001   ADDIU S3, S3, 1
9D005948  0277102B   SLTU V0, S3, S7
9D00594C  1440FFF0   BNE V0, ZERO, 0x9D005910
9D005950  26100020   ADDIU S0, S0, 32
9D005954  0B401658   J 0x9D005960
9D005958  24100001   ADDIU S0, ZERO, 1
9D00595C  24100001   ADDIU S0, ZERO, 1
638:                     {
639:                         /* Search for interface descriptor */
640:                         interfaceQueryObj.bInterfaceNumber = iterator;
9D005910  A3B30010   SB S3, 16(SP)
641:                         interfaceDescriptor = USB_HOST_DeviceInterfaceDescriptorQuery(configurationDescriptor, &interfaceQueryObj);
9D005914  02202021   ADDU A0, S1, ZERO
9D005918  0F401680   JAL USB_HOST_DeviceInterfaceDescriptorQuery
9D00591C  27A50010   ADDIU A1, SP, 16
642:                         if(interfaceDescriptor == NULL)
9D005920  5040000F   BEQL V0, ZERO, 0x9D005960
9D005924  00008021   ADDU S0, ZERO, ZERO
643:                         {
644:                             /* This should never happen. The host will check a configuration
645:                              * descriptor for error before it allows the device to reach this
646:                              * stage. Cannot say why the interface descriptor was not found */
647:                             result = false;
648:                             break;
649:                         }
650:                 
651:                         /* Initialize the interface descriptor information object */
652:                         interfaceDescInfo = &(deviceObj->configDescriptorInfo.interfaceInfo[iterator]);
653:                         interfaceDescInfo->interfaceDescriptor = interfaceDescriptor;
9D005928  AE020104   SW V0, 260(S0)
654:                         interfaceDescInfo->interfaceAssociationDescriptor = NULL;
9D00592C  AE000108   SW ZERO, 264(S0)
655:                         interfaceDescInfo->currentAlternateSetting = 0;
9D005930  A200011C   SB ZERO, 284(S0)
656:                         interfaceDescInfo->interfaceHandle = _USB_HOST_DeviceInterfaceHandleGet(pnpIdentifier, iterator, deviceIndex);
9D0058FC  0002AC00   SLL S5, V0, 16
9D005900  02A3A825   OR S5, S5, V1
9D005904  02408021   ADDU S0, S2, ZERO
9D005934  00131200   SLL V0, S3, 8
9D005938  00551025   OR V0, V0, S5
9D00593C  AE020110   SW V0, 272(S0)
657:                         interfaceDescInfo->tplEntryMatched = -1;
9D00590C  2414FFFF   ADDIU S4, ZERO, -1
9D005940  AE140118   SW S4, 280(S0)
658:                     }
659:                 
660:                     /* Update the number of interfaces in the device object */
661:                     deviceObj->nInterfaces = nInterfaces;
9D005960  A25600D5   SB S6, 213(S2)
662:                 
663:                     /* Now we search the configuration descriptor for IADs. Clear the search
664:                      * context before we start the search. */
665:                     USB_HOST_DeviceIADQueryContextClear(&iadQueryObj);
666:                     
667:                     do
668:                     {
669:                         /* We will search for any IAD.  */
670:                         iadQueryObj.flags = USB_HOST_IAD_QUERY_FLAG_ANY;
9D005968  AFA00020   SW ZERO, 32(SP)
671:                 
672:                         /* Search for IAD */
673:                         interfaceAssociation = USB_HOST_DeviceIADQuery(configurationDescriptor, &iadQueryObj);
9D00596C  02202021   ADDU A0, S1, ZERO
9D005970  0F402055   JAL USB_HOST_DeviceIADQuery
9D005974  27A50020   ADDIU A1, SP, 32
674:                 
675:                         if(interfaceAssociation != NULL)
9D005978  50400016   BEQL V0, ZERO, 0x9D0059D4
9D00597C  02001021   ADDU V0, S0, ZERO
676:                         {
677:                             /* Get the starting interface and the number of contiguous
678:                              * interfaces */
679:                             bInterfaceCount = interfaceAssociation->bInterfaceCount;
680:                             bFirstInterface = interfaceAssociation->bFirstInterface;
9D005980  90450002   LBU A1, 2(V0)
681:                             previousInterface = NULL;
9D0059A0  00003021   ADDU A2, ZERO, ZERO
682:                 
683:                             for(iterator = bFirstInterface; iterator < (bFirstInterface + bInterfaceCount); iterator ++)
9D005984  90480003   LBU T0, 3(V0)
9D005988  00A84021   ADDU T0, A1, T0
9D00598C  00A8182B   SLTU V1, A1, T0
9D005990  1060FFF5   BEQ V1, ZERO, 0x9D005968
9D005994  00051940   SLL V1, A1, 5
9D005998  24630104   ADDIU V1, V1, 260
9D00599C  02431821   ADDU V1, S2, V1
9D0059C0  24A50001   ADDIU A1, A1, 1
9D0059C4  10A8FFE8   BEQ A1, T0, 0x9D005968
9D0059C8  24630020   ADDIU V1, V1, 32
9D0059CC  0B401669   J 0x9D0059A4
9D0059D0  00E03021   ADDU A2, A3, ZERO
684:                             {
685:                                 /* Get the pointer to the interface descriptor object for this
686:                                  * interface. Set the interfaceAssociationDescriptor member to
687:                                  * point to IAD. Set the next descriptor to point to the next
688:                                  * interface descriptor in the group. */
689:                                 interfaceDescInfo = &(deviceObj->configDescriptorInfo.interfaceInfo[iterator]);
9D0059A4  00603821   ADDU A3, V1, ZERO
690:                                 interfaceDescInfo->interfaceAssociationDescriptor = interfaceAssociation;
691:                 
692:                                 if(previousInterface == NULL)
9D0059A8  14C00003   BNE A2, ZERO, 0x9D0059B8
9D0059AC  AC620004   SW V0, 4(V1)
9D0059B0  0B401670   J 0x9D0059C0
9D0059B4  AC60001C   SW ZERO, 28(V1)
693:                                 {
694:                                     /* This is the first interface in this group. We set the
695:                                      * previous interface to the current interface. */
696:                                     previousInterface = interfaceDescInfo;
697:                                     previousInterface->nextInterface = NULL;
698:                                 }
699:                                 else
700:                                 {
701:                                     /* This is the not the first interface in the group. Set the
702:                                      * next interface of previous one to this one. Then set
703:                                      * previous to this interface. */
704:                                     previousInterface->nextInterface = interfaceDescInfo;
9D0059B8  ACC3001C   SW V1, 28(A2)
705:                                     interfaceDescInfo->nextInterface = NULL;
9D0059BC  AC60001C   SW ZERO, 28(V1)
706:                                     previousInterface = interfaceDescInfo;
707:                                 }
708:                             }
709:                         }
710:                         else
711:                         {
712:                             /* No more IAD in this configuration descriptor */
713:                         }
714:                     } while(interfaceAssociation != NULL);
715:                 
716:                     /* At this point, if there was an IAD, say 2 IAD with interface 0 and 1 and
717:                      * 2 and 3. The interfaceAssociationDescriptor of interfaceInfo[0] and
718:                      * interfaceInfo[1] will point to the parent IAD.
719:                      * interfaceInfo[0].nextInterface will point to interfaceInfo[1] and
720:                      * interfaceInfo[1].nextInterface will be NULL because it is the last
721:                      * interface in this group. Similarly interfaceAssociationDescriptor of
722:                      * interfaceInfo[2] and interfaceInfo[3] will point to the parent IAD.
723:                      * interfaceInfo[2].nextInterface will point to interfaceInfo[3] and
724:                      * interfaceInfo[3].nextInterface will be NULL because it is the last
725:                      * interface in this group. */
726:                     return(result);
727:                 }
9D0059D4  8FBF004C   LW RA, 76(SP)
728:                 
729:                 // *****************************************************************************
730:                 /* Function:
731:                     int _USB_HOST_FindClassSubClassProtocolDriver
732:                     (
733:                         uint8_t bDeviceClass,
734:                         uint8_t bDeviceSubClass,
735:                         uint8_t bDeviceProtocol,
736:                         int startPoint
737:                     );
738:                 
739:                   Summary:
740:                     This function will search for matching class subclass protocol driver in the
741:                     TPL table.
742:                 
743:                   Description:
744:                     This function will search for matching class subclass protocol driver in the
745:                     TPL table. If a driver was not found, the function will return the last
746:                     index of the TPL table + 1. The function will start searching from (and
747:                     including) startPoint.
748:                 
749:                   Remarks:
750:                     This is a local function and should not be called directly by the
751:                     application.
752:                 */    
753:                 
754:                 int _USB_HOST_FindClassSubClassProtocolDriver
755:                 (
756:                     uint8_t bDeviceClass,
757:                     uint8_t bDeviceSubClass,
758:                     uint8_t bDeviceProtocol,
759:                     int startPoint
760:                 )
761:                 {
762:                     USB_HOST_TPL_ENTRY * tpl;
763:                     int iterator;
764:                     USB_HOST_OBJ * hostObj = &gUSBHostObj;
765:                     unsigned int matched = 0;
9D007968  00001821   ADDU V1, ZERO, ZERO
766:                     unsigned int tplFlags;
767:                 
768:                     for(iterator = startPoint; iterator < hostObj->nTPLEntries; iterator ++)
9D00793C  3C03A000   LUI V1, -24576
9D007940  90696744   LBU T1, 26436(V1)
9D007944  00E9182A   SLT V1, A3, T1
9D007948  1060002C   BEQ V1, ZERO, 0x9D0079FC
9D00794C  00E01021   ADDU V0, A3, ZERO
9D007950  00071880   SLL V1, A3, 2
9D007954  00073900   SLL A3, A3, 4
9D007958  00671821   ADDU V1, V1, A3
9D00795C  3C07A000   LUI A3, -24576
9D007960  8CE86748   LW T0, 26440(A3)
9D007964  01034021   ADDU T0, T0, V1
9D0079EC  24420001   ADDIU V0, V0, 1
9D0079F0  0049382A   SLT A3, V0, T1
9D0079F4  14E0FFDD   BNE A3, ZERO, 0x9D00796C
9D0079F8  25080014   ADDIU T0, T0, 20
769:                     {
770:                         tpl = &hostObj->tpl[iterator];
771:                 
772:                         /* Check if this entry is a class subclass protocol entry */
773:                         if(tpl->tplFlags.driverType == TPL_FLAG_CLASS_SUBCLASS_PROTOCOL)
9D00796C  8D070008   LW A3, 8(T0)
9D007970  30E70001   ANDI A3, A3, 1
9D007974  54E0001E   BNEL A3, ZERO, 0x9D0079F0
9D007978  24420001   ADDIU V0, V0, 1
774:                         {
775:                             /* First we check if which field match */
776:                 
777:                             if(bDeviceClass == tpl->id.cl_sc_p.classCode)
9D00797C  910A0000   LBU T2, 0(T0)
778:                             {
779:                                 /* Class matched */
780:                                 matched |= 0x2;
9D007980  34670002   ORI A3, V1, 2
9D007984  01445026   XOR T2, T2, A0
9D007988  00EA180A   MOVZ V1, A3, T2
781:                             }
782:                 
783:                             if(bDeviceSubClass == tpl->id.cl_sc_p.subClassCode)
9D00798C  910A0001   LBU T2, 1(T0)
784:                             {
785:                                 /* Subclass matched */
786:                                 matched |= 0x4;
9D007990  34670004   ORI A3, V1, 4
9D007994  01455026   XOR T2, T2, A1
9D007998  00EA180A   MOVZ V1, A3, T2
787:                             }
788:                 
789:                             if(bDeviceProtocol == tpl->id.cl_sc_p.protocolCode)
9D00799C  910A0002   LBU T2, 2(T0)
790:                             {
791:                                 /* Protocol matched */
792:                                 matched |= 0x8;
9D0079A0  34670008   ORI A3, V1, 8
9D0079A4  01465026   XOR T2, T2, A2
9D0079A8  00EA180A   MOVZ V1, A3, T2
793:                             }
794:                 
795:                             tplFlags = (tpl->tplFlags.ignoreClass << 1) | (tpl->tplFlags.ignoreSubClass << 2) | (tpl->tplFlags.ignoreProtocol << 3);
9D0079AC  8D070008   LW A3, 8(T0)
9D0079B0  7CEB0080   EXT T3, A3, 2, 1
9D0079B4  000B5880   SLL T3, T3, 2
9D0079B8  7CEA0040   EXT T2, A3, 1, 1
9D0079BC  000A5040   SLL T2, T2, 1
9D0079C0  016A5025   OR T2, T3, T2
9D0079C4  7CE700C0   EXT A3, A3, 3, 1
9D0079C8  000738C0   SLL A3, A3, 3
9D0079CC  01473825   OR A3, T2, A3
796:                             matched = matched & (~(tplFlags & 0xE));
9D0079D0  30EA000E   ANDI T2, A3, 14
9D0079D4  000A5027   NOR T2, ZERO, T2
9D0079D8  006A1824   AND V1, V1, T2
797:                 
798:                             /* Now check if the criteria matches */
799:                             if((tplFlags & 0xE) == ((~matched) & 0xE))
9D0079DC  00035027   NOR T2, ZERO, V1
9D0079E0  314A000E   ANDI T2, T2, 14
9D0079E4  11470005   BEQ T2, A3, 0x9D0079FC
9D0079E8  00000000   NOP
800:                             {
801:                                 /* We found a match */
802:                                 break;
803:                             }
804:                         }
805:                     }
806:                 
807:                     return(iterator);
808:                 }
9D0079FC  03E00008   JR RA
809:                 
810:                 // *****************************************************************************
811:                 /* Function:
812:                     void _USB_HOST_UpdateConfigurationState
813:                     (
814:                         USB_HOST_DEVICE_OBJ * deviceObj,
815:                         int busIndex
816:                     );
817:                 
818:                   Summary:
819:                     This function will update the configuration state of the device.
820:                 
821:                   Description:
822:                     This function will check if the device configuration needs to be changed. If
823:                     so then it gets the configuration, parses the configuration, sets up the
824:                     interface tables and then sets the configuration.
825:                 
826:                   Remarks:
827:                     This is a local function and should not be called directly by the
828:                     application.
829:                 */    
830:                 
831:                 void _USB_HOST_UpdateConfigurationState
832:                 (
833:                     USB_HOST_DEVICE_OBJ * deviceObj,
834:                     int busIndex
835:                 )
836:                 {
9D0010B8  27BDFFD8   ADDIU SP, SP, -40
9D0010BC  AFBF0024   SW RA, 36(SP)
9D0010C0  AFB10020   SW S1, 32(SP)
9D0010C4  AFB0001C   SW S0, 28(SP)
837:                     USB_HOST_BUS_OBJ * busObj;
838:                     USB_CONFIGURATION_DESCRIPTOR * configurationDescriptor;
839:                     USB_HOST_DEVICE_EVENT_CONFIGURATION_SET_DATA eventData;
840:                     int iterator;
841:                     uint8_t isSelfPowered;
842:                 
843:                     busObj = &(gUSBHostBusList[busIndex]);
844:                     
845:                     /* This redundant statement is added to avoid warning in a case where the
846:                      * debug messages are disabled. */
847:                     busObj = busObj;
9D001214  00052980   SLL A1, A1, 6
9D001218  00451021   ADDU V0, V0, A1
848:                     
849:                     /* Only proceed if the device is in a ready state */
850:                     if(deviceObj->deviceState == USB_HOST_DEVICE_STATE_READY)
9D0010C8  8C8300F0   LW V1, 240(A0)
9D0010CC  2402000F   ADDIU V0, ZERO, 15
9D0010D0  1462014E   BNE V1, V0, 0x9D00160C
9D0010D4  00808021   ADDU S0, A0, ZERO
851:                     {
852:                         switch(deviceObj->configurationState)
9D0010D8  8C8201AC   LW V0, 428(A0)
9D0010DC  2C420008   SLTIU V0, V0, 8
9D0010E0  1040014A   BEQ V0, ZERO, 0x9D00160C
9D0010E4  3C029D00   LUI V0, -25344
9D0010E8  8C8301AC   LW V1, 428(A0)
9D0010EC  00031880   SLL V1, V1, 2
9D0010F0  24421104   ADDIU V0, V0, 4356
9D0010F4  00431021   ADDU V0, V0, V1
9D0010F8  8C420000   LW V0, 0(V0)
9D0010FC  00400008   JR V0
9D001100  00000000   NOP
853:                         {
854:                             case USB_HOST_DEVICE_CONFIG_STATE_READY_FOR_CONFIG:
855:                 
856:                                 /* We don't have to do anything here. The state indicates that
857:                                  * the device is ready for configuration, but somebody has to
858:                                  * set it */
859:                 
860:                                 break;
861:                 
862:                             case USB_HOST_DEVICE_CONFIG_STATE_START:
863:                 
864:                                 /* Start the process of setting the configuration. We first get
865:                                  * the configuration header. The requestedConfigurationNumber
866:                                  * member of deviceObj contains the index of the configuration to be
867:                                  * set */
868:                 
869:                                 _USB_HOST_FillSetupPacket(
9D001124  908200FC   LBU V0, 252(A0)
9D001128  24420200   ADDIU V0, V0, 512
9D00112C  3042FFFF   ANDI V0, V0, -1
9D001168  248200D6   ADDIU V0, A0, 214
870:                                         &(deviceObj->setupPacket),
871:                                         ( USB_SETUP_DIRN_DEVICE_TO_HOST |
872:                                           USB_SETUP_TYPE_STANDARD |
873:                                           USB_SETUP_RECIPIENT_DEVICE ),
874:                                         USB_REQUEST_GET_DESCRIPTOR,
875:                                         ( USB_DESCRIPTOR_CONFIGURATION << 8 )+ deviceObj->requestedConfigurationNumber , 0 , 9 ) ;
876:                 
877:                                 /* Fill IRP */
878:                                 deviceObj->controlTransferObj.controlIRP.data = ( void * )deviceObj->buffer;
9D001160  24820094   ADDIU V0, A0, 148
9D001164  AC820010   SW V0, 16(A0)
879:                                 deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket);
9D00116C  AC82000C   SW V0, 12(A0)
880:                                 deviceObj->controlTransferObj.controlIRP.size = 9;
9D001170  24020009   ADDIU V0, ZERO, 9
9D001174  AC820014   SW V0, 20(A0)
881:                                 deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D001178  AC800024   SW ZERO, 36(A0)
882:                 
883:                                 /* Set the next state */
884:                                 deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_WAIT_FOR_CONFIG_DESCRIPTOR_HEADER_GET;
9D00117C  24020003   ADDIU V0, ZERO, 3
9D001180  AC8201AC   SW V0, 428(A0)
885:                 
886:                                 /* Submit the IRP */
887:                                 if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, 
9D001184  8C82006C   LW V0, 108(A0)
9D001188  8C42000C   LW V0, 12(V0)
9D00118C  8C840058   LW A0, 88(A0)
9D001190  0040F809   JALR V0
9D001194  2605000C   ADDIU A1, S0, 12
9D001198  1040011D   BEQ V0, ZERO, 0x9D001610
9D00119C  8FBF0024   LW RA, 36(SP)
888:                                             &(deviceObj->controlTransferObj.controlIRP)))
889:                                 {
890:                                     /* We need to be able to send the IRP. We move the
891:                                      * device to an error state. Close the pipe and send
892:                                      * an event to the application. */
893:                                     SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Configuration Descriptor IRP failed. Device not supported.", 
894:                                             busIndex, deviceObj->deviceAddress);
895:                                     deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0011A0  2402FFFF   ADDIU V0, ZERO, -1
9D0011A4  AE0200F0   SW V0, 240(S0)
896:                                     deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0011A8  8E02006C   LW V0, 108(S0)
9D0011AC  8C420020   LW V0, 32(V0)
9D0011B0  0040F809   JALR V0
9D0011B4  8E040058   LW A0, 88(S0)
897:                                     if(gUSBHostObj.hostEventHandler != NULL)
9D0011B8  3C02A000   LUI V0, -24576
9D0011BC  8C426738   LW V0, 26424(V0)
9D0011C0  10400112   BEQ V0, ZERO, 0x9D00160C
9D0011C4  24040001   ADDIU A0, ZERO, 1
898:                                     {
899:                                         /* Send an event to the application */
900:                                         gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D0011C8  00002821   ADDU A1, ZERO, ZERO
9D0011CC  3C03A000   LUI V1, -24576
9D0011D0  0040F809   JALR V0
9D0011D4  8C66673C   LW A2, 26428(V1)
901:                                     }
902:                                 }
903:                 
904:                                 break;
905:                 
906:                             case USB_HOST_DEVICE_CONFIG_STATE_WAIT_FOR_CONFIG_DESCRIPTOR_HEADER_GET:
907:                 
908:                                 /* Here we are waiting for Get Short Configuration header to
909:                                  * complete */
910:                                 if (deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED)
9D0011E0  8C820018   LW V0, 24(A0)
9D0011E4  14400032   BNE V0, ZERO, 0x9D0012B0
9D0011E8  00000000   NOP
911:                                 {
912:                                     if (deviceObj->hubAddress == 0x00 )
9D0011EC  90820074   LBU V0, 116(A0)
9D0011F0  1440002D   BNE V0, ZERO, 0x9D0012A8
9D0011F4  24020004   ADDIU V0, ZERO, 4
913:                                     {
914:                                         /* Check if the device is a self powered or bus powered    */
915:                                         isSelfPowered =  ( (((USB_CONFIGURATION_DESCRIPTOR *) deviceObj->buffer)->bmAttributes) & USB_ATTRIBUTE_SELF_POWERED );
9D0011F8  9082009B   LBU V0, 155(A0)
9D0011FC  30420040   ANDI V0, V0, 64
916:                 
917:                                         if (isSelfPowered != USB_ATTRIBUTE_SELF_POWERED )
9D001200  304200FF   ANDI V0, V0, 255
9D001204  14400027   BNE V0, ZERO, 0x9D0012A4
9D001208  00051100   SLL V0, A1, 4
918:                                         {
919:                                             /* This means the device is bus powered. We should check
920:                                              * if this configuration requires more current than what
921:                                              * the root hub can provide. */
922:                 
923:                                             if ( ( 2 * (((USB_CONFIGURATION_DESCRIPTOR * ) deviceObj->buffer)->bMaxPower )) > busObj->rootHubInfo.power )
9D00120C  9083009C   LBU V1, 156(A0)
9D001210  00031840   SLL V1, V1, 1
9D00121C  3C04A000   LUI A0, -24576
9D001220  248466E8   ADDIU A0, A0, 26344
9D001224  00821021   ADDU V0, A0, V0
9D001228  8C420028   LW V0, 40(V0)
9D00122C  0043102B   SLTU V0, V0, V1
9D001230  1040001D   BEQ V0, ZERO, 0x9D0012A8
9D001234  24020004   ADDIU V0, ZERO, 4
924:                                             {
925:                                                 /* This means the device needs more power than what
926:                                                  * the root hub can provide. We cannot set this
927:                                                  * configuration. */
928:                 
929:                                                 if(deviceObj->deviceClientDriver != NULL)
9D001238  8E0200E0   LW V0, 224(S0)
9D00123C  1040000D   BEQ V0, ZERO, 0x9D001274
9D001240  2403FFA8   ADDIU V1, ZERO, -88
930:                                                 {
931:                                                     /* This means this device has device level
932:                                                      * driver and it is this driver that had
933:                                                      * requested for the configuration chanage.
934:                                                      * We let the driver know that the
935:                                                      * configuration cannot be set and then move
936:                                                      * the device to a ready but un-configured
937:                                                      * state.  This will allow the driver level
938:                                                      * driver to try setting another
939:                                                      * configuration. */
940:                 
941:                                                     eventData.result = USB_HOST_RESULT_FAILURE;
9D001244  AFA30014   SW V1, 20(SP)
942:                                                     deviceObj->deviceState = USB_HOST_DEVICE_STATE_READY;
9D001248  2403000F   ADDIU V1, ZERO, 15
9D00124C  AE0300F0   SW V1, 240(S0)
943:                                                     deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_READY_FOR_CONFIG;
9D001250  AE0001AC   SW ZERO, 428(S0)
944:                 
945:                                                     /* We should send an event to the client
946:                                                      * driver result is failure  */
947:                                                     deviceObj->deviceClientDriver->deviceEventHandler(deviceObj->deviceClientHandle,
9D001254  8C420018   LW V0, 24(V0)
9D001258  8E040050   LW A0, 80(S0)
9D00125C  00002821   ADDU A1, ZERO, ZERO
9D001260  27A60010   ADDIU A2, SP, 16
9D001264  0040F809   JALR V0
9D001268  8E070008   LW A3, 8(S0)
9D00126C  0B4004A0   J 0x9D001280
9D001270  3C02A000   LUI V0, -24576
948:                                                             USB_HOST_DEVICE_EVENT_CONFIGURATION_SET, &eventData, deviceObj->controlTransferObj.context);
949:                                                 }
950:                                                 else
951:                                                 {
952:                                                     /* The device does not have a devel lever
953:                                                      * client driver. This means the host layer
954:                                                      * owns the device. The host layer at this
955:                                                      * time cannot try any other configuration.
956:                                                      * The device must be moved to an
957:                                                      * in-operational state because of an
958:                                                      * over-current request. */
959:                 
960:                                                     deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D001274  2402FFFF   ADDIU V0, ZERO, -1
9D001278  AE0200F0   SW V0, 240(S0)
961:                                                 }
962:                 
963:                                                 /* We should send an event to the application */
964:                                                 if(gUSBHostObj.hostEventHandler != NULL)
9D00127C  3C02A000   LUI V0, -24576
9D001280  8C426738   LW V0, 26424(V0)
9D001284  104000E1   BEQ V0, ZERO, 0x9D00160C
9D001288  00002021   ADDU A0, ZERO, ZERO
965:                                                 {
966:                                                     gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_REJECTED_INSUFFICIENT_POWER, NULL, gUSBHostObj.context );
9D00128C  00002821   ADDU A1, ZERO, ZERO
9D001290  3C03A000   LUI V1, -24576
9D001294  0040F809   JALR V0
9D001298  8C66673C   LW A2, 26428(V1)
967:                 
968:                                                 }
969:                 
970:                                                 break;
971:                                             }
972:                 
973:                                         }
974:                                     }
975:                 
976:                                     /* IRP was successful. Go to the next state */
977:                                     SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Obtained Configuration Descriptor header", busIndex, deviceObj->deviceAddress);  
978:                                     deviceObj->configurationState =  USB_HOST_DEVICE_CONFIG_STATE_CONFIG_DESCRIPTOR_GET;
9D0012A4  24020004   ADDIU V0, ZERO, 4
9D0012A8  0B400583   J 0x9D00160C
9D0012AC  AE0201AC   SW V0, 428(S0)
979:                                 }
980:                                 else
981:                                 {
982:                                     /* The IRP did not complete successfully. */
983:                                     if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D0012B0  044100D7   BGEZ V0, 0x9D001610
9D0012B4  8FBF0024   LW RA, 36(SP)
984:                                     {
985:                                         /* Close the pipe */
986:                                         deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0012B8  8C82006C   LW V0, 108(A0)
9D0012BC  8C420020   LW V0, 32(V0)
9D0012C0  0040F809   JALR V0
9D0012C4  8C840058   LW A0, 88(A0)
987:                                         SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Error while obtaining Configuration Descriptor header",
988:                                                 busIndex, deviceObj->deviceAddress);  
989:                                         
990:                                         deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0012C8  2402FFFF   ADDIU V0, ZERO, -1
9D0012CC  AE0200F0   SW V0, 240(S0)
991:                 
992:                                         /* We should send an event to the application
993:                                          * and then wait for device attach */
994:                                         if(gUSBHostObj.hostEventHandler != NULL)
9D0012D0  3C02A000   LUI V0, -24576
9D0012D4  8C426738   LW V0, 26424(V0)
9D0012D8  104000CC   BEQ V0, ZERO, 0x9D00160C
9D0012DC  24040001   ADDIU A0, ZERO, 1
995:                                         {
996:                                             gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D0012E0  00002821   ADDU A1, ZERO, ZERO
9D0012E4  3C03A000   LUI V1, -24576
9D0012E8  0040F809   JALR V0
9D0012EC  8C66673C   LW A2, 26428(V1)
997:                                         }
998:                                     }
999:                                 }
1000:                                break;
1001:                
1002:                            case USB_HOST_DEVICE_CONFIG_STATE_CONFIG_DESCRIPTOR_GET:
1003:                
1004:                                /* Allocate memory and then get the entire configuration
1005:                                 * descriptor */
1006:                                if(deviceObj->configDescriptorInfo.configurationDescriptor != NULL)
9D0012F8  8C840100   LW A0, 256(A0)
9D0012FC  50800004   BEQL A0, ZERO, 0x9D001310
9D001300  92020096   LBU V0, 150(S0)
1007:                                {
1008:                                    USB_HOST_FREE(deviceObj->configDescriptorInfo.configurationDescriptor);
9D001304  0F4025F6   JAL free
9D001308  00000000   NOP
1009:                                }
1010:                
1011:                                /* Now allocate memory. While allocating the memory, we allocate
1012:                                 * 7 additional bytes to store the end of configuration
1013:                                 * descriptor memory configuration marker. This marker will
1014:                                 * allow the query functions to identify the end of the
1015:                                 * configuration descriptor */
1016:                
1017:                                configurationDescriptor = (USB_CONFIGURATION_DESCRIPTOR *)(deviceObj->buffer);
1018:                                deviceObj->configDescriptorInfo.configurationDescriptor = USB_HOST_MALLOC(configurationDescriptor->wTotalLength + 7);
9D00130C  92020096   LBU V0, 150(S0)
9D001310  92110097   LBU S1, 151(S0)
9D001314  00118A00   SLL S1, S1, 8
9D001318  02228825   OR S1, S1, V0
9D00131C  0F400E17   JAL malloc
9D001320  26240007   ADDIU A0, S1, 7
1019:                
1020:                                if(deviceObj->configDescriptorInfo.configurationDescriptor == NULL)
9D001324  14400011   BNE V0, ZERO, 0x9D00136C
9D001328  AE020100   SW V0, 256(S0)
1021:                                {
1022:                                    /* The memory allocation failed. We need memory to continue.
1023:                                     * We have to stop here */
1024:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D00132C  2402FFFF   ADDIU V0, ZERO, -1
9D001330  AE0200F0   SW V0, 240(S0)
1025:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D001334  8E02006C   LW V0, 108(S0)
9D001338  8C420020   LW V0, 32(V0)
9D00133C  0040F809   JALR V0
9D001340  8E040058   LW A0, 88(S0)
1026:                                    if(gUSBHostObj.hostEventHandler != NULL)
9D001344  3C02A000   LUI V0, -24576
9D001348  8C426738   LW V0, 26424(V0)
9D00134C  104000AF   BEQ V0, ZERO, 0x9D00160C
9D001350  24040001   ADDIU A0, ZERO, 1
1027:                                    {
1028:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Could not allocate memory for Configuration Descriptor", busIndex, deviceObj->deviceAddress);
1029:                                        gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D001354  00002821   ADDU A1, ZERO, ZERO
9D001358  3C03A000   LUI V1, -24576
9D00135C  0040F809   JALR V0
9D001360  8C66673C   LW A2, 26428(V1)
1030:                                    }
1031:                                }
1032:                                else
1033:                                {
1034:                                    /* Place a request for the full configuration descriptor */
1035:                                    _USB_HOST_FillSetupPacket(
9D00136C  920300FC   LBU V1, 252(S0)
9D001370  24630200   ADDIU V1, V1, 512
9D001374  3063FFFF   ANDI V1, V1, -1
9D0013AC  260200D6   ADDIU V0, S0, 214
1036:                                            &(deviceObj->setupPacket), ( USB_SETUP_DIRN_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE ),
1037:                                            USB_REQUEST_GET_DESCRIPTOR, ( USB_DESCRIPTOR_CONFIGURATION << 8 ) + deviceObj->requestedConfigurationNumber,
1038:                                            0 ,configurationDescriptor->wTotalLength) ;
1039:                
1040:                                    /* Create the IRP */
1041:                                    deviceObj->controlTransferObj.controlIRP.data = deviceObj->configDescriptorInfo.configurationDescriptor;
9D0013A8  AE020010   SW V0, 16(S0)
1042:                                    deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket);
9D0013B0  AE02000C   SW V0, 12(S0)
1043:                                    deviceObj->controlTransferObj.controlIRP.size = configurationDescriptor->wTotalLength;
9D0013B4  AE110014   SW S1, 20(S0)
1044:                                    deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D0013B8  AE000024   SW ZERO, 36(S0)
1045:                                    deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_WAIT_FOR_CONFIG_DESCRIPTOR_GET;
9D0013BC  24020005   ADDIU V0, ZERO, 5
9D0013C0  AE0201AC   SW V0, 428(S0)
1046:                
1047:                                    /* Submit the IRP */
1048:                                    if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, 
9D0013C4  8E02006C   LW V0, 108(S0)
9D0013C8  8C42000C   LW V0, 12(V0)
9D0013CC  8E040058   LW A0, 88(S0)
9D0013D0  0040F809   JALR V0
9D0013D4  2605000C   ADDIU A1, S0, 12
9D0013D8  1040008D   BEQ V0, ZERO, 0x9D001610
9D0013DC  8FBF0024   LW RA, 36(SP)
1049:                                                &(deviceObj->controlTransferObj.controlIRP)))
1050:                                    {
1051:                                        /* We need to be able to send the IRP. We move the
1052:                                         * device to an error state. Close the pipe and send
1053:                                         * an event to the application. */
1054:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Configuration Descriptor IRP failed. Device not supported.", busIndex, deviceObj->deviceAddress);
1055:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0013E0  2402FFFF   ADDIU V0, ZERO, -1
9D0013E4  AE0200F0   SW V0, 240(S0)
1056:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0013E8  8E02006C   LW V0, 108(S0)
9D0013EC  8C420020   LW V0, 32(V0)
9D0013F0  0040F809   JALR V0
9D0013F4  8E040058   LW A0, 88(S0)
1057:                                        if(gUSBHostObj.hostEventHandler != NULL)
9D0013F8  3C02A000   LUI V0, -24576
9D0013FC  8C426738   LW V0, 26424(V0)
9D001400  10400082   BEQ V0, ZERO, 0x9D00160C
9D001404  24040001   ADDIU A0, ZERO, 1
1058:                                        {
1059:                                            /* Send an event to the application */
1060:                                            gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D001408  00002821   ADDU A1, ZERO, ZERO
9D00140C  3C03A000   LUI V1, -24576
9D001410  0040F809   JALR V0
9D001414  8C66673C   LW A2, 26428(V1)
1061:                                        }
1062:                                    }
1063:                                }
1064:                
1065:                                break;
1066:                
1067:                            case USB_HOST_DEVICE_CONFIG_STATE_WAIT_FOR_CONFIG_DESCRIPTOR_GET:
1068:                
1069:                                /* Here we check if we have received the configuration
1070:                                 * descriptor */
1071:                                if (deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED) 
9D001420  8C820018   LW V0, 24(A0)
9D001424  14400004   BNE V0, ZERO, 0x9D001438
9D001428  00000000   NOP
1072:                                {
1073:                                    /* We have received the configuration descriptor. 
1074:                                     * We can set this configuration. */
1075:                
1076:                                    deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_CONFIGURATION_SET;
9D00142C  24020006   ADDIU V0, ZERO, 6
9D001430  0B400583   J 0x9D00160C
9D001434  AC8201AC   SW V0, 428(A0)
1077:                                }
1078:                                else
1079:                                {
1080:                                    if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D001438  04410075   BGEZ V0, 0x9D001610
9D00143C  8FBF0024   LW RA, 36(SP)
1081:                                    {
1082:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Error while obtaining Configuration Descriptor.", busIndex, deviceObj->deviceAddress);  
1083:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D001440  8C82006C   LW V0, 108(A0)
9D001444  8C420020   LW V0, 32(V0)
9D001448  0040F809   JALR V0
9D00144C  8C840058   LW A0, 88(A0)
1084:                
1085:                                        /* Move the device to error state */
1086:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D001450  2402FFFF   ADDIU V0, ZERO, -1
9D001454  AE0200F0   SW V0, 240(S0)
1087:                                        
1088:                                        if(gUSBHostObj.hostEventHandler != NULL)
9D001458  3C02A000   LUI V0, -24576
9D00145C  8C426738   LW V0, 26424(V0)
9D001460  1040006A   BEQ V0, ZERO, 0x9D00160C
9D001464  24040001   ADDIU A0, ZERO, 1
1089:                                        {
1090:                                            gUSBHostObj.hostEventHandler(USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D001468  00002821   ADDU A1, ZERO, ZERO
9D00146C  3C03A000   LUI V1, -24576
9D001470  0040F809   JALR V0
9D001474  8C66673C   LW A2, 26428(V1)
1091:                                        }
1092:                                    }
1093:                                }
1094:                
1095:                                break;
1096:                
1097:                            case USB_HOST_DEVICE_CONFIG_STATE_CONFIGURATION_SET:
1098:                                 /* In this state, the host will set the configuration */
1099:                                _USB_HOST_FillSetupPacket(
9D001484  90420005   LBU V0, 5(V0)
9D0014B0  248200D6   ADDIU V0, A0, 214
1100:                                        &(deviceObj->setupPacket),
1101:                                        ( USB_SETUP_DIRN_HOST_TO_DEVICE |
1102:                                          USB_SETUP_TYPE_STANDARD |
1103:                                          USB_SETUP_RECIPIENT_DEVICE ),
1104:                                        USB_REQUEST_SET_CONFIGURATION,
1105:                                        deviceObj->configDescriptorInfo.configurationDescriptor->bConfigurationValue,
9D001480  8C820100   LW V0, 256(A0)
1106:                                        0 ,0 ) ;
1107:                
1108:                                /* Fill IRP */
1109:                                deviceObj->controlTransferObj.controlIRP.data = NULL;
9D0014AC  AC800010   SW ZERO, 16(A0)
1110:                                deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket);
9D0014B4  AC82000C   SW V0, 12(A0)
1111:                                deviceObj->controlTransferObj.controlIRP.size = 0;
9D0014B8  AC800014   SW ZERO, 20(A0)
1112:                                deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D0014BC  AC800024   SW ZERO, 36(A0)
1113:                                deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_WAIT_FOR_CONFIGURATION_SET;
9D0014C0  24020007   ADDIU V0, ZERO, 7
9D0014C4  AC8201AC   SW V0, 428(A0)
1114:                
1115:                                /* Submit the IRP */
1116:                                if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, 
9D0014C8  8C82006C   LW V0, 108(A0)
9D0014CC  8C42000C   LW V0, 12(V0)
9D0014D0  8C840058   LW A0, 88(A0)
9D0014D4  0040F809   JALR V0
9D0014D8  2605000C   ADDIU A1, S0, 12
9D0014DC  1040004C   BEQ V0, ZERO, 0x9D001610
9D0014E0  8FBF0024   LW RA, 36(SP)
1117:                                            &(deviceObj->controlTransferObj.controlIRP)))
1118:                                {
1119:                                    /* We need to be able to send the IRP. We move the
1120:                                     * device to an error state. Close the pipe and send
1121:                                     * an event to the application. */
1122:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Set Configuration IRP failed. Device not supported.", busIndex, deviceObj->deviceAddress);  
1123:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0014E4  2402FFFF   ADDIU V0, ZERO, -1
9D0014E8  AE0200F0   SW V0, 240(S0)
1124:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0014EC  8E02006C   LW V0, 108(S0)
9D0014F0  8C420020   LW V0, 32(V0)
9D0014F4  0040F809   JALR V0
9D0014F8  8E040058   LW A0, 88(S0)
1125:                                    if(gUSBHostObj.hostEventHandler != NULL)
9D0014FC  3C02A000   LUI V0, -24576
9D001500  8C426738   LW V0, 26424(V0)
9D001504  10400041   BEQ V0, ZERO, 0x9D00160C
9D001508  24040001   ADDIU A0, ZERO, 1
1126:                                    {
1127:                                        /* Send an event to the application */
1128:                                        gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D00150C  00002821   ADDU A1, ZERO, ZERO
9D001510  3C03A000   LUI V1, -24576
9D001514  0040F809   JALR V0
9D001518  8C66673C   LW A2, 26428(V1)
1129:                                    }
1130:                                }
1131:                
1132:                                break;
1133:                
1134:                            case USB_HOST_DEVICE_CONFIG_STATE_WAIT_FOR_CONFIGURATION_SET:
1135:                
1136:                                /* Here we check if the set configuration has completed */
1137:                                if (deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED) 
9D001524  8C820018   LW V0, 24(A0)
9D001528  14400028   BNE V0, ZERO, 0x9D0015CC
9D00152C  00000000   NOP
1138:                                {
1139:                                    /* The configuration set was successful. Unload the existing
1140:                                     * interface drivers */
1141:                
1142:                                    _USB_HOST_ReleaseInterfaceDrivers(deviceObj);
9D001530  0F402199   JAL _USB_HOST_ReleaseInterfaceDrivers
9D001534  00000000   NOP
1143:                
1144:                                    /* Insert the end of the configuration descriptor marker
1145:                                     * into the configuration */
1146:                                    configurationDescriptor = deviceObj->configDescriptorInfo.configurationDescriptor;
9D001538  8E030100   LW V1, 256(S0)
1147:                                    for(iterator = 0; iterator < 7; iterator ++)
9D00153C  00001021   ADDU V0, ZERO, ZERO
9D001544  24060007   ADDIU A2, ZERO, 7
9D001560  24420001   ADDIU V0, V0, 1
9D001564  1446FFF8   BNE V0, A2, 0x9D001548
9D001568  A0870000   SB A3, 0(A0)
1148:                                    {
1149:                                        /* The end of configuration descriptor is 7 bytes, each
1150:                                         * 0xFF */
1151:                                        ((uint8_t *)(configurationDescriptor))[configurationDescriptor->wTotalLength + iterator] = 0xFF;
9D001540  2407FFFF   ADDIU A3, ZERO, -1
9D001548  90650002   LBU A1, 2(V1)
9D00154C  90640003   LBU A0, 3(V1)
9D001550  00042200   SLL A0, A0, 8
9D001554  00852025   OR A0, A0, A1
9D001558  00622821   ADDU A1, V1, V0
9D00155C  00A42021   ADDU A0, A1, A0
1152:                                    }
1153:                                    
1154:                                    /* Parse the configuration descriptor and then update the
1155:                                     * interface tables. */
1156:                                    if(!_USB_HOST_ConfigurationDescriptorParse(deviceObj))
9D00156C  0F401629   JAL _USB_HOST_ConfigurationDescriptorParse
9D001570  02002021   ADDU A0, S0, ZERO
9D001574  54400004   BNEL V0, ZERO, 0x9D001588
9D001578  8E020100   LW V0, 256(S0)
1157:                                    {
1158:                                        /* The parsing failed */
1159:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Error in configuration desciptor", busIndex, deviceObj->deviceAddress);  
1160:                                        eventData.result = USB_HOST_RESULT_FAILURE;
9D00157C  2402FFA8   ADDIU V0, ZERO, -88
9D001580  0B400566   J 0x9D001598
9D001584  AFA20014   SW V0, 20(SP)
1161:                                    }
1162:                                    else
1163:                                    {
1164:                                        /* The parsing worked. Update the active configuration
1165:                                         * to indicate that the configuration has been set */
1166:                
1167:                                        deviceObj->configDescriptorInfo.configurationNumber = deviceObj->configDescriptorInfo.configurationDescriptor->bConfigurationValue;
9D001588  90420005   LBU V0, 5(V0)
9D00158C  A20201A5   SB V0, 421(S0)
1168:                                        eventData.result = USB_HOST_RESULT_SUCCESS;
9D001590  24020001   ADDIU V0, ZERO, 1
9D001594  AFA20014   SW V0, 20(SP)
1169:                                    }
1170:                
1171:                                    /* If there is device level client driver, then we let it
1172:                                     * know that the configuration has been set. */
1173:                
1174:                                    eventData.requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
9D001598  26020004   ADDIU V0, S0, 4
9D00159C  AFA20010   SW V0, 16(SP)
1175:                                    if(deviceObj->deviceClientDriver != NULL)
9D0015A0  8E0200E0   LW V0, 224(S0)
9D0015A4  10400006   BEQ V0, ZERO, 0x9D0015C0
9D0015A8  00002821   ADDU A1, ZERO, ZERO
1176:                                    {
1177:                                        deviceObj->deviceClientDriver->deviceEventHandler(deviceObj->deviceClientHandle,
9D0015AC  8C420018   LW V0, 24(V0)
9D0015B0  8E040050   LW A0, 80(S0)
9D0015B4  27A60010   ADDIU A2, SP, 16
9D0015B8  0040F809   JALR V0
9D0015BC  8E070008   LW A3, 8(S0)
1178:                                                USB_HOST_DEVICE_EVENT_CONFIGURATION_SET, &eventData, deviceObj->controlTransferObj.context);
1179:                                    }
1180:                
1181:                                    /* The configuration set is complete. We are ready to set
1182:                                     * another configuration if requested. Return the control
1183:                                     * transfer object back */
1184:                
1185:                                    deviceObj->controlTransferObj.inUse = false;
9D0015C0  A2000004   SB ZERO, 4(S0)
9D0015C4  0B400583   J 0x9D00160C
9D0015C8  AE0001AC   SW ZERO, 428(S0)
1186:                                    deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_READY_FOR_CONFIG;
1187:                                }
1188:                                else
1189:                                {
1190:                                    /* The set configuration request failed */
1191:                                    if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D0015CC  04410010   BGEZ V0, 0x9D001610
9D0015D0  8FBF0024   LW RA, 36(SP)
1192:                                    {
1193:                                        eventData.result = USB_HOST_RESULT_FAILURE;
9D0015D4  2402FFA8   ADDIU V0, ZERO, -88
9D0015D8  AFA20014   SW V0, 20(SP)
1194:                                        /* If there is device level client driver, then we let it
1195:                                         * know that the configuration has been set. */
1196:                                        
1197:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Could not set configuration.", busIndex, deviceObj->deviceAddress);  
1198:                
1199:                                        eventData.requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
9D0015DC  24820004   ADDIU V0, A0, 4
9D0015E0  AFA20010   SW V0, 16(SP)
1200:                                        if(deviceObj->deviceClientDriver != NULL)
9D0015E4  8C8200E0   LW V0, 224(A0)
9D0015E8  10400006   BEQ V0, ZERO, 0x9D001604
9D0015EC  00002821   ADDU A1, ZERO, ZERO
1201:                                        {
1202:                                            deviceObj->deviceClientDriver->deviceEventHandler(deviceObj->deviceClientHandle,
9D0015F0  8C420018   LW V0, 24(V0)
9D0015F4  8C840050   LW A0, 80(A0)
9D0015F8  27A60010   ADDIU A2, SP, 16
9D0015FC  0040F809   JALR V0
9D001600  8E070008   LW A3, 8(S0)
1203:                                                    USB_HOST_DEVICE_EVENT_CONFIGURATION_SET, &eventData, deviceObj->controlTransferObj.context);
1204:                                        }
1205:                                        deviceObj->controlTransferObj.inUse = false;
9D001604  A2000004   SB ZERO, 4(S0)
1206:                                        deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_READY_FOR_CONFIG;
9D001608  AE0001AC   SW ZERO, 428(S0)
1207:                
1208:                                    }
1209:                                }
1210:                                break;
1211:                
1212:                            default:
1213:                                break;
1214:                        }
1215:                    }
1216:                }
9D0011D8  0B400584   J 0x9D001610
9D0011DC  8FBF0024   LW RA, 36(SP)
9D00129C  0B400584   J 0x9D001610
9D0012A0  8FBF0024   LW RA, 36(SP)
9D0012F0  0B400584   J 0x9D001610
9D0012F4  8FBF0024   LW RA, 36(SP)
9D001364  0B400584   J 0x9D001610
9D001368  8FBF0024   LW RA, 36(SP)
9D001418  0B400584   J 0x9D001610
9D00141C  8FBF0024   LW RA, 36(SP)
9D001478  0B400584   J 0x9D001610
9D00147C  8FBF0024   LW RA, 36(SP)
9D00151C  0B400584   J 0x9D001610
9D001520  8FBF0024   LW RA, 36(SP)
9D00160C  8FBF0024   LW RA, 36(SP)
1217:                
1218:                // *****************************************************************************
1219:                /* Function:
1220:                    void _USB_HOST_UpdateDeviceOwnership
1221:                    (
1222:                        USB_HOST_DEVICE_OBJ * deviceObj,
1223:                        int busIndex
1224:                    );
1225:                
1226:                  Summary:
1227:                    This function will find a device level owner client driver.
1228:                
1229:                  Description:
1230:                    This function will find a device level client driver owner. If a VID PID
1231:                    level driver is not found then a device level class subclass protocol driver
1232:                    needs to be found. If device was released, then a new owner needs to be
1233:                    found. If the end of the TPL table is reached, then the stop searching and
1234:                    hand over ownership of the device to the host. If a driver is attached, the
1235:                    function will call the tasks routine of this driver.
1236:                
1237:                  Remarks:
1238:                    This is a local function and should not be called directly by the
1239:                    application.
1240:                */    
1241:                
1242:                void _USB_HOST_UpdateDeviceOwnership
1243:                (
1244:                    USB_HOST_DEVICE_OBJ * deviceObj,
1245:                    int busIndex
1246:                )
1247:                {
9D0035CC  27BDFFE0   ADDIU SP, SP, -32
9D0035D0  AFBF001C   SW RA, 28(SP)
9D0035D4  AFB20018   SW S2, 24(SP)
9D0035D8  AFB10014   SW S1, 20(SP)
9D0035DC  AFB00010   SW S0, 16(SP)
1248:                    int tplSearch;
1249:                    USB_HOST_TPL_ENTRY * tpl;
1250:                    USB_DEVICE_DESCRIPTOR * deviceDescriptor;
1251:                    USB_HOST_BUS_OBJ * busObj;
1252:                
1253:                    busObj = &(gUSBHostBusList[busIndex]);
1254:                
1255:                    /* This redundant statement is added to avoid warning in a case where the
1256:                     * debug messages are disabled. */
1257:                    busObj = busObj;
1258:                    
1259:                    /* Check if the device is in a ready state. */
1260:                    if(deviceObj->deviceState == USB_HOST_DEVICE_STATE_READY)
9D0035E0  8C8300F0   LW V1, 240(A0)
9D0035E4  2402000F   ADDIU V0, ZERO, 15
9D0035E8  14620096   BNE V1, V0, 0x9D003844
9D0035EC  00808021   ADDU S0, A0, ZERO
1261:                    {
1262:                        deviceDescriptor = &(deviceObj->deviceDescriptor);
1263:                
1264:                        if(deviceObj->deviceClientDriver != NULL)
9D0035F0  8C8200E0   LW V0, 224(A0)
9D0035F4  50400008   BEQL V0, ZERO, 0x9D003618
9D0035F8  8E1100E4   LW S1, 228(S0)
1265:                        {
1266:                            /* Run the tasks routine */
1267:                            deviceObj->deviceClientDriver->deviceTasks(deviceObj->deviceClientHandle);
9D0035FC  8C420014   LW V0, 20(V0)
9D003600  0040F809   JALR V0
9D003604  8C840050   LW A0, 80(A0)
1268:                        }
1269:                
1270:                        /* Matching is needed only if the device is not claimed and we have not
1271:                         * already reached the end of the table*/
1272:                
1273:                        if((deviceObj->deviceClientDriver == NULL) && (!(deviceObj->tplEntryTried >= gUSBHostObj.nTPLEntries)))
9D003608  8E0200E0   LW V0, 224(S0)
9D00360C  1440004D   BNE V0, ZERO, 0x9D003744
9D003610  3C02A000   LUI V0, -24576
9D003614  8E1100E4   LW S1, 228(S0)
9D003618  3C02A000   LUI V0, -24576
9D00361C  90526744   LBU S2, 26436(V0)
9D003620  0232102A   SLT V0, S1, S2
9D003624  5040004C   BEQL V0, ZERO, 0x9D003758
9D003628  8E0200E0   LW V0, 224(S0)
1274:                        {
1275:                            /* The initial value (on device connect) of tplEntryTried is -1. So then
1276:                             * the tplSearch will start matching from 0. If this is not the first
1277:                             * time matching, then matching will start from the next entry in the
1278:                             * TPL table */
1279:                
1280:                            SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d Looking for Device Level Driver.", busIndex, deviceObj->deviceAddress);
1281:                            for (tplSearch = (deviceObj->tplEntryTried + 1); tplSearch < gUSBHostObj.nTPLEntries; tplSearch ++)
9D00362C  26310001   ADDIU S1, S1, 1
9D003630  0232102A   SLT V0, S1, S2
9D003634  10400041   BEQ V0, ZERO, 0x9D00373C
9D003638  00111080   SLL V0, S1, 2
9D00363C  00111900   SLL V1, S1, 4
9D003640  00431021   ADDU V0, V0, V1
9D003644  3C03A000   LUI V1, -24576
9D003648  8C636748   LW V1, 26440(V1)
9D00364C  00621021   ADDU V0, V1, V0
9D003708  0232182A   SLT V1, S1, S2
9D00370C  1460FFD0   BNE V1, ZERO, 0x9D003650
9D003710  24420014   ADDIU V0, V0, 20
9D003714  0B400DD0   J 0x9D003740
9D003718  AE1100E4   SW S1, 228(S0)
1282:                            {
1283:                                tpl = &gUSBHostObj.tpl[tplSearch];
1284:                
1285:                                if(tpl->tplFlags.driverType == TPL_FLAG_VID_PID)
9D003650  8C430008   LW V1, 8(V0)
9D003654  30640001   ANDI A0, V1, 1
9D003658  5080002B   BEQL A0, ZERO, 0x9D003708
9D00365C  26310001   ADDIU S1, S1, 1
1286:                                {
1287:                                    /* This entry is a VID PID Entry */
1288:                
1289:                                    if(tpl->tplFlags.ignoreVIDPID)
9D003660  30640020   ANDI A0, V1, 32
9D003664  50800004   BEQL A0, ZERO, 0x9D003678
9D003668  30630010   ANDI V1, V1, 16
1290:                                    {
1291:                                        /* This means we should attach this driver as the entry says
1292:                                         * that ignore the VID PID and match */
1293:                
1294:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d matched entry %d in TPL table", 
1295:                                                busIndex, deviceObj->deviceAddress, tplSearch);
1296:                
1297:                                        deviceObj->deviceClientDriver = (USB_HOST_CLIENT_DRIVER *)(tpl->hostClientDriver);
9D00366C  8C420010   LW V0, 16(V0)
1298:                                        break;
9D003670  0B400DC7   J 0x9D00371C
9D003674  AE0200E0   SW V0, 224(S0)
1299:                                    }
1300:                                    else if(tpl->tplFlags.pidMasked)
9D003678  10600013   BEQ V1, ZERO, 0x9D0036C8
9D00367C  92060084   LBU A2, 132(S0)
1301:                                    {
1302:                                        /* This means we should apply the specified mask to the PID
1303:                                         * field and then compare. */
1304:                
1305:                                        if((deviceDescriptor->idVendor == tpl->id.vid_pid.vid) && 
9D003680  92030085   LBU V1, 133(S0)
9D003684  00031A00   SLL V1, V1, 8
9D003688  94440000   LHU A0, 0(V0)
9D00368C  00661825   OR V1, V1, A2
9D003690  5483001D   BNEL A0, V1, 0x9D003708
9D003694  26310001   ADDIU S1, S1, 1
9D0036AC  94440002   LHU A0, 2(V0)
9D0036B0  00C31824   AND V1, A2, V1
9D0036B4  54830014   BNEL A0, V1, 0x9D003708
9D0036B8  26310001   ADDIU S1, S1, 1
1306:                                                ((deviceDescriptor->idProduct & tpl->pidMask) == tpl->id.vid_pid.pid))
9D003698  92030086   LBU V1, 134(S0)
9D00369C  92060087   LBU A2, 135(S0)
9D0036A0  00063200   SLL A2, A2, 8
9D0036A4  00C33025   OR A2, A2, V1
9D0036A8  94430004   LHU V1, 4(V0)
1307:                                        {
1308:                                            /* Criteria matched */
1309:                                            SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d matched entry %d in TPL table", 
1310:                                                    busIndex, deviceObj->deviceAddress, tplSearch);
1311:                
1312:                                            deviceObj->deviceClientDriver = (USB_HOST_CLIENT_DRIVER *)(tpl->hostClientDriver);
9D0036BC  8C420010   LW V0, 16(V0)
1313:                                            break;
9D0036C0  0B400DC7   J 0x9D00371C
9D0036C4  AE0200E0   SW V0, 224(S0)
1314:                                        }
1315:                                    }
1316:                                    else if((deviceDescriptor->idVendor == tpl->id.vid_pid.vid) && 
9D0036C8  92030085   LBU V1, 133(S0)
9D0036CC  00031A00   SLL V1, V1, 8
9D0036D0  94440000   LHU A0, 0(V0)
9D0036D4  00661825   OR V1, V1, A2
9D0036D8  5483000B   BNEL A0, V1, 0x9D003708
9D0036DC  26310001   ADDIU S1, S1, 1
9D0036EC  94440002   LHU A0, 2(V0)
9D0036F0  00661825   OR V1, V1, A2
9D0036F4  54830004   BNEL A0, V1, 0x9D003708
9D0036F8  26310001   ADDIU S1, S1, 1
1317:                                            (deviceDescriptor->idProduct == tpl->id.vid_pid.pid))
9D0036E0  92060086   LBU A2, 134(S0)
9D0036E4  92030087   LBU V1, 135(S0)
9D0036E8  00031A00   SLL V1, V1, 8
1318:                                    {
1319:                                        /* Criteria matched */
1320:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d matched entry %d in TPL table", 
1321:                                                busIndex, deviceObj->deviceAddress, tplSearch);
1322:                                        deviceObj->deviceClientDriver = (USB_HOST_CLIENT_DRIVER *)(tpl->hostClientDriver);
9D0036FC  8C420010   LW V0, 16(V0)
1323:                                        break;
9D003700  0B400DC7   J 0x9D00371C
9D003704  AE0200E0   SW V0, 224(S0)
1324:                                    }
1325:                                }
1326:                            }
1327:                
1328:                            if(deviceObj->deviceClientDriver != NULL)
9D00371C  8E0200E0   LW V0, 224(S0)
9D003720  50400007   BEQL V0, ZERO, 0x9D003740
9D003724  AE1100E4   SW S1, 228(S0)
1329:                            {
1330:                                /* This means a driver was found. Call the driver assign function */
1331:                                SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Assigning device level driver to device %d", busIndex, deviceObj->deviceAddress);
1332:                                deviceObj->deviceClientDriver->deviceAssign(deviceObj->deviceClientHandle, deviceObj->deviceIdentifier, &(deviceObj->deviceDescriptor));
9D003728  8C42000C   LW V0, 12(V0)
9D00372C  8E040050   LW A0, 80(S0)
9D003730  8E05004C   LW A1, 76(S0)
9D003734  0040F809   JALR V0
9D003738  2606007C   ADDIU A2, S0, 124
1333:                            }
1334:                
1335:                            /* Irrespective of the search result, we keep track of where the search 
1336:                             * stopped. If the search stopped at the end and no driver was assigned
1337:                             * then we know there was no VID PID match for this device. */
1338:                            deviceObj->tplEntryTried = tplSearch;
9D00373C  AE1100E4   SW S1, 228(S0)
1339:                        }
1340:                        
1341:                        if((deviceObj->tplEntryTried >= gUSBHostObj.nTPLEntries ) && (deviceObj->deviceClientDriver == NULL))
9D003740  3C02A000   LUI V0, -24576
9D003744  90526744   LBU S2, 26436(V0)
9D003748  8E0200E4   LW V0, 228(S0)
9D00374C  0052102A   SLT V0, V0, S2
9D003750  1440001E   BNE V0, ZERO, 0x9D0037CC
9D003754  8E0200E0   LW V0, 224(S0)
9D003758  1440003B   BNE V0, ZERO, 0x9D003848
9D00375C  8FBF001C   LW RA, 28(SP)
1342:                        {
1343:                            /* This means VID PID matching failed and it has reached the end of
1344:                             * the TPL table. The device can be owned at a VID PID level or a
1345:                             * device class subclass protocol level. If the VID PID matching
1346:                             * reached the end of the table then we should check if device level
1347:                             * class subclass protocol can be matched. All this only if the
1348:                             * device specifies class subclass protocol at a device level and
1349:                             * the device level class subclass protocol matching has not reached
1350:                             * the end of the table */
1351:                
1352:                            if(deviceDescriptor->bDeviceClass != 0x0)
9D003760  92040080   LBU A0, 128(S0)
9D003764  1080001C   BEQ A0, ZERO, 0x9D0037D8
9D003768  3C02A000   LUI V0, -24576
1353:                            {
1354:                                /* This means the device level class, subclass and protocol can 
1355:                                 * be matched. Check if we have already tried this */
1356:                                if((deviceObj->deviceClScPTried < gUSBHostObj.nTPLEntries) && 
9D00376C  8E0700E8   LW A3, 232(S0)
9D003770  00F2102A   SLT V0, A3, S2
9D003774  10400018   BEQ V0, ZERO, 0x9D0037D8
9D003778  3C02A000   LUI V0, -24576
1357:                                        (deviceObj->deviceClientDriver == NULL))
1358:                                {
1359:                                    /* Search for match from the last match position. If the
1360:                                     * device was just connected */
1361:                
1362:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d Looking for Device Level CL SC P driver", busIndex, deviceObj->deviceAddress);
1363:                                    deviceObj->deviceClScPTried = _USB_HOST_FindClassSubClassProtocolDriver(deviceDescriptor->bDeviceClass,
9D00377C  92050081   LBU A1, 129(S0)
9D003780  92060082   LBU A2, 130(S0)
9D003784  0F401E4F   JAL _USB_HOST_FindClassSubClassProtocolDriver
9D003788  24E70001   ADDIU A3, A3, 1
1364:                                            deviceDescriptor->bDeviceSubClass, deviceDescriptor->bDeviceProtocol, deviceObj->deviceClScPTried + 1);
1365:                
1366:                                    if(deviceObj->deviceClScPTried < gUSBHostObj.nTPLEntries)
9D00378C  0052902A   SLT S2, V0, S2
9D003790  1240000D   BEQ S2, ZERO, 0x9D0037C8
9D003794  AE0200E8   SW V0, 232(S0)
1367:                                    {
1368:                                        /* This means we found a match. Assign the corresponding driver */
1369:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d. Assiging Device CL SC P Driver %d", 
1370:                                                busIndex, deviceObj->deviceAddress, deviceObj->deviceClScPTried);
1371:                                        deviceObj->deviceClientDriver = (USB_HOST_CLIENT_DRIVER *)(gUSBHostObj.tpl[deviceObj->deviceClScPTried].hostClientDriver);
9D003798  3C03A000   LUI V1, -24576
9D00379C  8C646748   LW A0, 26440(V1)
9D0037A0  24030014   ADDIU V1, ZERO, 20
9D0037A4  70432802   MUL A1, V0, V1
9D0037A8  00A41021   ADDU V0, A1, A0
9D0037AC  8C420010   LW V0, 16(V0)
9D0037B0  AE0200E0   SW V0, 224(S0)
1372:                                        deviceObj->deviceClientDriver->deviceAssign(deviceObj->deviceClientHandle, deviceObj->deviceIdentifier, &(deviceObj->deviceDescriptor));
9D0037B4  8C42000C   LW V0, 12(V0)
9D0037B8  8E040050   LW A0, 80(S0)
9D0037BC  8E05004C   LW A1, 76(S0)
9D0037C0  0040F809   JALR V0
9D0037C4  2606007C   ADDIU A2, S0, 124
1373:                                    }
1374:                                }
1375:                            }
1376:                        }
1377:                
1378:                
1379:                
1380:                        if(deviceObj->deviceClientDriver == NULL)
9D0037C8  8E0200E0   LW V0, 224(S0)
9D0037CC  1440001E   BNE V0, ZERO, 0x9D003848
9D0037D0  8FBF001C   LW RA, 28(SP)
1381:                        {
1382:                            /* The device is not owned. The host layer must try to set the
1383:                             * configuration */
1384:                
1385:                            if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexControlTransferObj), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1386:                            {
1387:                                if((deviceObj->configurationState == USB_HOST_DEVICE_CONFIG_STATE_READY_FOR_CONFIG)
9D0037F0  8E0201AC   LW V0, 428(S0)
9D0037F4  14400011   BNE V0, ZERO, 0x9D00383C
9D0037F8  24030001   ADDIU V1, ZERO, 1
1388:                                        && (deviceDescriptor->bNumConfigurations > 0)
9D0037FC  9202008D   LBU V0, 141(S0)
9D003800  1040000F   BEQ V0, ZERO, 0x9D003840
9D003804  3C02A000   LUI V0, -24576
1389:                                        && (deviceObj->configDescriptorInfo.configurationNumber == USB_HOST_CONFIGURATION_NUMBER_INVALID))
9D003808  920301A5   LBU V1, 421(S0)
9D00380C  240200FF   ADDIU V0, ZERO, 255
9D003810  1462000A   BNE V1, V0, 0x9D00383C
9D003814  24030001   ADDIU V1, ZERO, 1
1390:                                {
1391:                                    /* The device is not configured, is ready to be configured
1392:                                     * and has at least one configuration. Check if the control
1393:                                     * transfer object is available to implement this command.
1394:                                     * */
1395:                                    if(!deviceObj->controlTransferObj.inUse)
9D003818  92020004   LBU V0, 4(S0)
9D00381C  14400008   BNE V0, ZERO, 0x9D003840
9D003820  3C02A000   LUI V0, -24576
1396:                                    {
1397:                                        /* This means we can set the configuration. We set to the
1398:                                         * first configuration */
1399:                                        deviceObj->controlTransferObj.inUse = true;
9D003824  24020001   ADDIU V0, ZERO, 1
9D003828  A2020004   SB V0, 4(S0)
1400:                                        deviceObj->requestedConfigurationNumber = 0;
9D00382C  A20000FC   SB ZERO, 252(S0)
1401:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Bus %d Device %d Setting first configuration", busIndex, deviceObj->deviceAddress); 
1402:                                        deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_START;
9D003830  24020001   ADDIU V0, ZERO, 1
9D003834  AE0201AC   SW V0, 428(S0)
1403:                                    }
1404:                                }
1405:                
1406:                                OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexControlTransferObj));
1407:                            }
1408:                            else
1409:                            {
1410:                                SYS_DEBUG_PRINT(SYS_ERROR_INFO,"\r\nUSB Host Layer: Mutex Lock failed", busIndex, deviceObj->deviceAddress); 
1411:                                /* OSAL error must be handled here. This needs to be implemented
1412:                                 * */
1413:                            }
1414:                        }
1415:                    }
1416:                }
9D003844  8FBF001C   LW RA, 28(SP)
1417:                
1418:                // *****************************************************************************
1419:                /* Function:
1420:                    USB_HOST_RESULT USB_HOST_DeviceControlTransfer 
1421:                    ( 
1422:                        USB_HOST_CONTROL_PIPE_HANDLE pipeHandle
1423:                        USB_HOST_TRANSFER_HANDLE * transferHandle
1424:                        USB_SETUP_PACKET * setupPacket,
1425:                        void * data,
1426:                        USB_HOST_DEVICE_CONTROL_REQUEST_COMPLETE_CALLBACK callback,
1427:                        uintptr_t context
1428:                    );
1429:                
1430:                  Summary:
1431:                    Schedules a control transfer.
1432:                
1433:                  Description:
1434:                    This function schedules a control transfer. pipeHandle contains a handle to
1435:                    a control pipe obtained through the USB_HOST_DeviceControlPipeOpen() function.
1436:                    setupPacket points to the setup command to be sent in the Setup Stage of the
1437:                    control transfer. The size and the direction of the data stage is indicated
1438:                    by the setup packet. In case of control transfers where there is no data
1439:                    stage, data is ignored and can be NULL. In all other cases, data should point
1440:                    to the data to data be transferred in the data stage of the control
1441:                    transfer. 
1442:                    
1443:                    If the transfer was scheduled successfully, transferHandle will contain a
1444:                    transfer handle that uniquely identifies this transfer. If the transfer
1445:                    could not be scheduled successfully, transferHandle will contain
1446:                    USB_HOST_TRANSFER_HANDLE_INVALID.
1447:                
1448:                    When the control transfer completes, the host layer will call the specified
1449:                    callback function. The context parameter specified here will be returned in
1450:                    the callback.
1451:                
1452:                  Remarks:
1453:                    Refer to usb_host_client_driver.h for usage details.
1454:                */
1455:                
1456:                USB_HOST_RESULT USB_HOST_DeviceControlTransfer
1457:                (
1458:                    USB_HOST_CONTROL_PIPE_HANDLE pipeHandle,
1459:                    USB_HOST_TRANSFER_HANDLE * transferHandle,
1460:                    USB_SETUP_PACKET * setupPacket,
1461:                    void * data,
1462:                    USB_HOST_DEVICE_CONTROL_REQUEST_COMPLETE_CALLBACK callback,
1463:                    uintptr_t context
1464:                )
1465:                {
1466:                    USB_HOST_DEVICE_OBJ  *deviceObj;
1467:                    uint8_t deviceIndex ;
1468:                    uint16_t pnpIdentifier;
1469:                    USB_HOST_RESULT result = USB_HOST_RESULT_FAILURE;
1470:                
1471:                    if(transferHandle == NULL)
1472:                    {
1473:                        /* transferHandle cannot be NULL */
1474:                        result = USB_HOST_RESULT_PARAMETER_INVALID;
1475:                    }
1476:                    else
1477:                    {
1478:                        /* Set transfer handle to invalid as the default value */
1479:                        *transferHandle = USB_HOST_TRANSFER_HANDLE_INVALID;
1480:                
1481:                        if(pipeHandle == USB_HOST_CONTROL_PIPE_HANDLE_INVALID)
1482:                        {
1483:                            /* Pipe handle is not valid */
1484:                            result = USB_HOST_RESULT_PIPE_HANDLE_INVALID;
1485:                        }
1486:                        else if(setupPacket == NULL)
1487:                        {
1488:                            /* Required parameters are NULL */
1489:                            result = USB_HOST_RESULT_PARAMETER_INVALID;
1490:                        }
1491:                        else if((setupPacket->wLength != 0) && (data == NULL))
1492:                        {
1493:                            /* If this is not a zero data stage control transfer then data cannot
1494:                             * be NULL. */
1495:                            result = USB_HOST_RESULT_PARAMETER_INVALID;
1496:                        }
1497:                        else
1498:                        {
1499:                
1500:                            /* The control pipe handle is the same as the device object handle. We get
1501:                             * the index of the device object that owns this pipe. */
1502:                            deviceIndex =  USB_HOST_DEVICE_INDEX( pipeHandle );
1503:                
1504:                            /* PNP identifier is needed for the IRP user data */
1505:                            pnpIdentifier = USB_HOST_PNP_IDENTIFIER( pipeHandle );
1506:                
1507:                            /* Get a pointer to the device object */
1508:                            deviceObj = &gUSBHostDeviceList[deviceIndex];
1509:                
1510:                            /* Get a mutual exclusion lock as this is a global resource */
1511:                            if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexControlTransferObj), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1512:                            {
1513:                                if(!deviceObj->controlTransferObj.inUse)
1514:                                {
1515:                                    /* This means that there no control request in progress. We can assign
1516:                                     * request now. The transfer handle is updated to point to the device
1517:                                     * control transfer object. */
1518:                
1519:                                    deviceObj->controlTransferObj.inUse = true;
1520:                                    *transferHandle = (USB_HOST_TRANSFER_HANDLE)(&deviceObj->controlTransferObj);
1521:                                }
1522:                                else
1523:                                {
1524:                                    /* A control transfer is in progress. */
1525:                                    result = USB_HOST_RESULT_REQUEST_BUSY;
1526:                                }
1527:                
1528:                                /* Unlock the mutual exclusion */
1529:                                OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexControlTransferObj));
1530:                            }
1531:                            else
1532:                            {
1533:                                /* The mutual exclusion could not be obtained */
1534:                                result = USB_HOST_RESULT_REQUEST_BUSY;
1535:                            }
1536:                
1537:                            if(*transferHandle != USB_HOST_TRANSFER_HANDLE_INVALID)
1538:                            {
1539:                                /* Set up the control transfer object */
1540:                                deviceObj->controlTransferObj.requestType = USB_HOST_CONTROL_REQUEST_TYPE_CLIENT_DRIVER_SPECIFIC;
1541:                                deviceObj->controlTransferObj.controlIRP.data = data;
1542:                                deviceObj->controlTransferObj.controlIRP.setup = setupPacket;
1543:                                deviceObj->controlTransferObj.controlIRP.size = setupPacket->wLength;
1544:                                deviceObj->controlTransferObj.controlIRP.callback = _USB_HOST_DeviceControlTransferCallback;
1545:                                deviceObj->controlTransferObj.controlIRP.userData = _USB_HOST_ControlTransferIRPUserData(pnpIdentifier, 0, deviceIndex);
1546:                                deviceObj->controlTransferObj.context = context;
1547:                                deviceObj->controlTransferObj.callback = callback;
1548:                
1549:                                if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, &(deviceObj->controlTransferObj.controlIRP)))
1550:                                {
1551:                                    /* There was a problem while submitting the IRP. Update the result and
1552:                                     * the transfer handle. Return the control transfer object back to the
1553:                                     * device object */
1554:                
1555:                                    result = USB_HOST_RESULT_FAILURE;
1556:                                    deviceObj->controlTransferObj.inUse = false;
1557:                                    *transferHandle = USB_HOST_TRANSFER_HANDLE_INVALID;
1558:                                }
1559:                                else
1560:                                {
1561:                                    result = USB_HOST_RESULT_SUCCESS;
1562:                                }
1563:                            }
1564:                        }
1565:                    }
1566:                
1567:                    return result;
1568:                }
1569:                
1570:                // *****************************************************************************
1571:                /* Function:
1572:                    bool _USB_HOST_DeviceConfigurationDescriptorErrorCheck
1573:                    (
1574:                        USB_CONFIGURATION_DESCRIPTOR * configurationDescriptor
1575:                    );
1576:                
1577:                  Summary:
1578:                    This function checks the configuration descriptor for errors.
1579:                
1580:                  Description:
1581:                    This function checks the configuration descriptor for errors. The following
1582:                    errors are checked. The sizes reported by each descriptor headers are added
1583:                    up to check if this sum is equal to total configuration descriptor size
1584:                    reported in the configuration descriptor header, The number of endpoint
1585:                    descriptors in an interface match the endpoints specified in the interface
1586:                    descriptor and the number of interfaces mentioned in the configuration
1587:                    header match the number of descriptors found in the configuration
1588:                    descriptor.
1589:                
1590:                  Remarks:
1591:                    This is a local function and should not be called directly by the
1592:                    application.
1593:                */    
1594:                
1595:                bool _USB_HOST_DeviceConfigurationDescriptorErrorCheck
1596:                (
1597:                    USB_CONFIGURATION_DESCRIPTOR * configurationDescriptor
1598:                )
1599:                {
1600:                    uint8_t * search;
1601:                    bool result = false;
9D00533C  00001021   ADDU V0, ZERO, ZERO
9D005440  03E00008   JR RA
9D005444  00001021   ADDU V0, ZERO, ZERO
1602:                    uint8_t bNumInterfaces;
1603:                    uint8_t bNumEndpoints;
1604:                    int uniqueInterfaces = 0;
9D00535C  00002021   ADDU A0, ZERO, ZERO
1605:                    int nEndpointsFound = 0;
1606:                    uint8_t * endpointSearch;
1607:                    int currentInterfaceNumber = -1;
9D005358  2409FFFF   ADDIU T1, ZERO, -1
1608:                    USB_DESCRIPTOR_HEADER * descriptorHeader;
1609:                    USB_INTERFACE_DESCRIPTOR * interfaceDescriptor;
1610:                    uint16_t configDescriptorSize, analyzedSize = 0;
9D005314  00003021   ADDU A2, ZERO, ZERO
9D005338  00003021   ADDU A2, ZERO, ZERO
1611:                    
1612:                    /* This function checks the configuration descriptor for errors */
1613:                
1614:                    if(configurationDescriptor == NULL)
9D0052EC  10800054   BEQ A0, ZERO, 0x9D005440
9D0052F0  00000000   NOP
1615:                	{
1616:                        /* The input parameter is not valid. Note that the result is already 
1617:                         * false. */
1618:                	}
1619:                    else
1620:                    {
1621:                        configDescriptorSize = configurationDescriptor->wTotalLength;
9D0052F4  90820002   LBU V0, 2(A0)
9D0052F8  90870003   LBU A3, 3(A0)
9D0052FC  00073A00   SLL A3, A3, 8
9D005300  00E23825   OR A3, A3, V0
1622:                
1623:                        /* Check the size of each descriptor in the configuration descriptor and
1624:                         * make sure that the size adds up. */
1625:                
1626:                        search = (uint8_t *)(configurationDescriptor);
1627:                        while(search < ((uint8_t *)(configurationDescriptor) + configDescriptorSize))
9D005304  00872821   ADDU A1, A0, A3
9D005308  0085102B   SLTU V0, A0, A1
9D00530C  1040000A   BEQ V0, ZERO, 0x9D005338
9D005310  00801021   ADDU V0, A0, ZERO
9D005324  0045182B   SLTU V1, V0, A1
9D005328  1460FFFB   BNE V1, ZERO, 0x9D005318
9D00532C  30C6FFFF   ANDI A2, A2, -1
9D005330  0B4014D0   J 0x9D005340
9D005334  00001021   ADDU V0, ZERO, ZERO
1628:                        {
1629:                            /* Start adding the size of each descriptor */
1630:                            descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
1631:                            analyzedSize += descriptorHeader->size;
9D005318  90430000   LBU V1, 0(V0)
9D00531C  00C33021   ADDU A2, A2, V1
1632:                            search += descriptorHeader->size;
9D005320  00431021   ADDU V0, V0, V1
1633:                        }
1634:                
1635:                        /* Check if the analyzed matches the size reported in the configuration 
1636:                         * descriptor header */
1637:                
1638:                        if(analyzedSize != configDescriptorSize)
9D005340  14C70045   BNE A2, A3, 0x9D005458
9D005344  24860009   ADDIU A2, A0, 9
1639:                        {
1640:                            /* The size does not match. result is already false, so nothing to
1641:                             * do here. */
1642:                        }
1643:                        else
1644:                        {
1645:                            /* Now we check if the number of reported interface descriptors 
1646:                             * exist. Interfaces start with 0 */   
1647:                            
1648:                            search = (uint8_t *)(configurationDescriptor);
1649:                            
1650:                            /* Start the search after the configuration descriptor*/
1651:                            search += (sizeof(USB_CONFIGURATION_DESCRIPTOR)); 
9D005354  00C01021   ADDU V0, A2, ZERO
1652:                            bNumInterfaces = configurationDescriptor->bNumInterfaces;
1653:                            
1654:                            /* Keep searching till we have either reached the end of the 
1655:                             * configuration descriptor or till we have found all the 
1656:                             * interfaces. While searching we need to notes that interfaces can
1657:                             * have alternate settings. */
1658:                            
1659:                            while(search < ((uint8_t *)(configurationDescriptor) + configDescriptorSize))
9D005348  00C5102B   SLTU V0, A2, A1
9D00534C  10400015   BEQ V0, ZERO, 0x9D0053A4
9D005350  90870004   LBU A3, 4(A0)
9D005394  5460FFF4   BNEL V1, ZERO, 0x9D005368
9D005398  90430001   LBU V1, 1(V0)
9D00539C  03E00008   JR RA
9D0053A0  00001021   ADDU V0, ZERO, ZERO
9D0053A4  03E00008   JR RA
9D0053A8  28E20001   SLTI V0, A3, 1
1660:                            {
1661:                                descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
1662:                                if(descriptorHeader->descType == USB_DESCRIPTOR_INTERFACE)
9D005360  24080004   ADDIU T0, ZERO, 4
9D005364  90430001   LBU V1, 1(V0)
9D005368  54680006   BNEL V1, T0, 0x9D005384
9D00536C  90430000   LBU V1, 0(V0)
1663:                                {
1664:                                    /* We found an interface descriptor. We need to make sure
1665:                                     * that we have not found this before. */
1666:                                    interfaceDescriptor = (USB_INTERFACE_DESCRIPTOR *)(search);
1667:                                    if(currentInterfaceNumber != interfaceDescriptor->bInterfaceNumber)
9D005370  90430002   LBU V1, 2(V0)
9D005374  10690002   BEQ V1, T1, 0x9D005380
9D005378  00604821   ADDU T1, V1, ZERO
1668:                                    {
1669:                                        /* We have found an unique interface number */
1670:                                        currentInterfaceNumber = interfaceDescriptor->bInterfaceNumber;
1671:                                        uniqueInterfaces ++;
9D00537C  24840001   ADDIU A0, A0, 1
1672:                                    }
1673:                                }
1674:                
1675:                                search += descriptorHeader->size;
9D005380  90430000   LBU V1, 0(V0)
9D005384  00431021   ADDU V0, V0, V1
1676:                                if (uniqueInterfaces >= bNumInterfaces)
9D005388  0087182A   SLT V1, A0, A3
9D00538C  10600007   BEQ V1, ZERO, 0x9D0053AC
9D005390  0045182B   SLTU V1, V0, A1
1677:                                {
1678:                                    /* This means we have found all the interfaces. Don't bother
1679:                                     * searching any more. */
1680:                                    break;
1681:                                }
1682:                            }
1683:                
1684:                            if(uniqueInterfaces < bNumInterfaces)
1685:                            {
1686:                                /* This means the configuration descriptor does not contain all
1687:                                 * the interface descriptors. result is still false so nothing
1688:                                 * to do here. */
1689:                                
1690:                            }
1691:                            else
1692:                            {
1693:                                /* Now we make sure the number of descriptors in the endpoint 
1694:                                 * match what is reported in the endpoint. */
1695:                                search = (uint8_t *)(configurationDescriptor);
1696:                                
1697:                                /* Start the search after the configuration descriptor*/
1698:                                search += (sizeof(USB_CONFIGURATION_DESCRIPTOR)); 
1699:                                bNumInterfaces = configurationDescriptor->bNumInterfaces;
1700:                                
1701:                                /* The logic in the code below requires the default value of
1702:                                 * result to be true. */
1703:                                result = true;
1704:                                
1705:                                /* Locate an interface descriptor and then check the number of  
1706:                                 * endpoints it has. */ 
1707:                                while(search < ((uint8_t *)(configurationDescriptor) + configDescriptorSize))
9D00542C  00C5102B   SLTU V0, A2, A1
9D005430  5440FFE1   BNEL V0, ZERO, 0x9D0053B8
9D005434  90C20001   LBU V0, 1(A2)
9D005438  03E00008   JR RA
9D00543C  24020001   ADDIU V0, ZERO, 1
1708:                                {
1709:                                    descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
1710:                                    if(descriptorHeader->descType == USB_DESCRIPTOR_INTERFACE)
9D0053AC  24070004   ADDIU A3, ZERO, 4
9D0053B4  90C20001   LBU V0, 1(A2)
9D0053B8  1447001B   BNE V0, A3, 0x9D005428
9D0053BC  90C20000   LBU V0, 0(A2)
1711:                                    {
1712:                                        /* Found an interface descriptor. Now analyze the endpoints
1713:                                         * it contains. */
1714:                
1715:                                        nEndpointsFound = 0;
1716:                                        interfaceDescriptor = (USB_INTERFACE_DESCRIPTOR *)(search);
1717:                                        bNumEndpoints = interfaceDescriptor->bNumEndPoints;
1718:                                        endpointSearch = search + descriptorHeader->size;
9D0053C0  00C21021   ADDU V0, A2, V0
1719:                                        
1720:                                        /* Start another while loop to search for endpoints */
1721:                                        while(endpointSearch < ((uint8_t *)(configurationDescriptor) + configDescriptorSize)) 
9D0053C4  0045182B   SLTU V1, V0, A1
9D0053C8  10600013   BEQ V1, ZERO, 0x9D005418
9D0053CC  90C80004   LBU T0, 4(A2)
9D005408  5480FFF6   BNEL A0, ZERO, 0x9D0053E4
9D00540C  90440001   LBU A0, 1(V0)
1722:                                        {
1723:                                            descriptorHeader = (USB_DESCRIPTOR_HEADER *)(endpointSearch);
1724:                
1725:                                            /* Unless this is the last interface in the configuration
1726:                                             * descriptor,all endpoint belonging to an interface must
1727:                                             * be arranged in the descriptor between two interface
1728:                                             * descriptors. */
1729:                                            
1730:                                            if(descriptorHeader->descType == USB_DESCRIPTOR_INTERFACE)
9D0053D0  90440001   LBU A0, 1(V0)
9D0053D4  10870011   BEQ A0, A3, 0x9D00541C
9D0053D8  00001821   ADDU V1, ZERO, ZERO
9D0053E4  10870018   BEQ A0, A3, 0x9D005448
9D0053E8  00892026   XOR A0, A0, T1
1731:                                            {
1732:                                                /* This means we have reached another interface
1733:                                                 * descriptor but not the end of the configuration
1734:                                                 * descriptor. Stop searching and see how many
1735:                                                 * endpoints we found. */
1736:                                                break;
1737:                                            }
1738:                                            
1739:                                            if(descriptorHeader->descType == USB_DESCRIPTOR_ENDPOINT)
9D0053B0  24090005   ADDIU T1, ZERO, 5
1740:                                            {
1741:                                                /* We found an endpoint. Increment the count */
1742:                                                nEndpointsFound ++;
9D0053DC  0B4014FB   J 0x9D0053EC
9D0053E0  00892026   XOR A0, A0, T1
9D0053EC  2C840001   SLTIU A0, A0, 1
9D0053F0  00641821   ADDU V1, V1, A0
1743:                                            }
1744:                                            endpointSearch += descriptorHeader->size;
9D0053F4  90440000   LBU A0, 0(V0)
9D0053F8  00441021   ADDU V0, V0, A0
1745:                
1746:                                            if(nEndpointsFound >= bNumEndpoints)
9D0053FC  0068202A   SLT A0, V1, T0
9D005400  10800006   BEQ A0, ZERO, 0x9D00541C
9D005404  0045202B   SLTU A0, V0, A1
1747:                                            {
1748:                                                /* We found all the breakpoints that we were 
1749:                                                 * looking for. */
1750:                                                break;
1751:                                            }
1752:                                        }
1753:                
1754:                                        /* Did we find out all the endpoints */
1755:                                        if(nEndpointsFound != bNumEndpoints)
9D00541C  1503000C   BNE T0, V1, 0x9D005450
9D005420  00000000   NOP
1756:                                        {
1757:                                            /* No point in continuing */
1758:                                            result = false;
9D005410  03E00008   JR RA
9D005414  00001021   ADDU V0, ZERO, ZERO
9D005418  00001821   ADDU V1, ZERO, ZERO
9D005448  03E00008   JR RA
9D00544C  00001021   ADDU V0, ZERO, ZERO
9D005450  03E00008   JR RA
9D005454  00001021   ADDU V0, ZERO, ZERO
1759:                                            break;   
1760:                                        }
1761:                                    }
1762:                
1763:                                    /* Here if the descriptor was not an endpoint or if it was 
1764:                                     * an endpoint, then endpoint search was successful. */
1765:                
1766:                                    if(result == false)
1767:                                    {
1768:                                        /* Stop processing altogether because while processing
1769:                                         * and interface, there was an endpoint mismatch */
1770:                                        break;
1771:                                    }
1772:                                    else
1773:                                    {
1774:                                        /* Continue to process interface descriptors*/
1775:                                        search += ((USB_DESCRIPTOR_HEADER *)(search))->size;
9D005424  90C20000   LBU V0, 0(A2)
9D005428  00C23021   ADDU A2, A2, V0
1776:                                    }
1777:                                }
1778:                            }
1779:                        }
1780:                    }
1781:                
1782:                    return(result);
1783:                }
9D005458  03E00008   JR RA
1784:                
1785:                // *****************************************************************************
1786:                /* Function:
1787:                    uint8_t _USB_HOST_GetNewAddress( USB_HOST_BUS_OBJ *busObj )
1788:                
1789:                  Summary:
1790:                    Searches and allocates a new device address.
1791:                
1792:                  Description:
1793:                    This function searches and allocates a new device address.
1794:                
1795:                  Remarks:
1796:                    This is a local function and should not be called by the application
1797:                    directly.
1798:                */
1799:                
1800:                uint8_t _USB_HOST_GetNewAddress( USB_HOST_BUS_OBJ *busObj )
1801:                {
1802:                    uint8_t tempAddress;
1803:                
1804:                    /* Find Free address */
1805:                    for ( tempAddress = 1; tempAddress <= USB_HOST_DEVICES_NUMBER ; tempAddress++ )
1806:                    {
1807:                        if ((busObj->addressBits[ tempAddress / 8] & (1 << ( tempAddress % 8 ))) == 0)
9D009748  90820014   LBU V0, 20(A0)
9D00974C  7C420040   EXT V0, V0, 1, 1
1808:                        {
1809:                            break;
1810:                        }
1811:                    }
1812:                
1813:                    /*Mark for allocated address */
1814:                    busObj->addressBits[ tempAddress / 8] |= (1 << ( tempAddress % 8 ));
9D009750  24030001   ADDIU V1, ZERO, 1
9D009754  24050002   ADDIU A1, ZERO, 2
9D009758  00A2180B   MOVN V1, A1, V0
9D00975C  00601021   ADDU V0, V1, ZERO
9D009760  24030001   ADDIU V1, ZERO, 1
9D009764  00431804   SLLV V1, V1, V0
9D009768  90850014   LBU A1, 20(A0)
9D00976C  00651825   OR V1, V1, A1
1815:                    return tempAddress;
1816:                }
9D009770  03E00008   JR RA
1817:                
1818:                // *****************************************************************************
1819:                /* Function:
1820:                    void _USB_HOST_FillSetupPacket
1821:                    (
1822:                        USB_SETUP_PACKET *setupPacket ,
1823:                        uint8_t requestType,
1824:                        uint8_t request ,
1825:                        uint16_t value,
1826:                        uint16_t index,
1827:                        uint16_t length
1828:                    )
1829:                
1830:                  Summary:
1831:                    Helper function to create setup packet.
1832:                
1833:                  Description:
1834:                    Helper function to create setup packet
1835:                
1836:                  Remarks:
1837:                    This is a local function and should not be called by the application
1838:                    directly.
1839:                */
1840:                
1841:                void _USB_HOST_FillSetupPacket
1842:                (
1843:                    USB_SETUP_PACKET *setupPacket ,
1844:                    uint8_t requestType,
1845:                    uint8_t request ,
1846:                    uint16_t value,
1847:                    uint16_t index,
1848:                    uint16_t length
1849:                )
1850:                {
1851:                    setupPacket->bmRequestType = requestType;
9D000208  2403FF80   ADDIU V1, ZERO, -128
9D000350  A20000D6   SB ZERO, 214(S0)
9D000568  2403FF80   ADDIU V1, ZERO, -128
9D0006B4  2403FF80   ADDIU V1, ZERO, -128
9D000860  2404FF80   ADDIU A0, ZERO, -128
9D001130  2403FF80   ADDIU V1, ZERO, -128
9D001378  2404FF80   ADDIU A0, ZERO, -128
9D001488  A08000D6   SB ZERO, 214(A0)
1852:                    setupPacket->bRequest = request ;
9D000210  24030006   ADDIU V1, ZERO, 6
9D000354  24030005   ADDIU V1, ZERO, 5
9D000570  24030006   ADDIU V1, ZERO, 6
9D0006BC  24030006   ADDIU V1, ZERO, 6
9D000868  24040006   ADDIU A0, ZERO, 6
9D001138  24030006   ADDIU V1, ZERO, 6
9D001380  24040006   ADDIU A0, ZERO, 6
9D00148C  24030009   ADDIU V1, ZERO, 9
1853:                    setupPacket->wValue = value ;
9D000218  A20000D8   SB ZERO, 216(S0)
9D00035C  A20200D8   SB V0, 216(S0)
9D000578  A20000D8   SB ZERO, 216(S0)
9D0006C4  A20200D8   SB V0, 216(S0)
9D000870  A20300D8   SB V1, 216(S0)
9D001140  A08200D8   SB V0, 216(A0)
9D001388  A20300D8   SB V1, 216(S0)
9D001494  A08200D8   SB V0, 216(A0)
1854:                    setupPacket->wIndex = index ;
9D000224  A20000DA   SB ZERO, 218(S0)
9D000364  A20000DA   SB ZERO, 218(S0)
9D000584  A20000DA   SB ZERO, 218(S0)
9D0006D0  A20000DA   SB ZERO, 218(S0)
9D00087C  A20000DA   SB ZERO, 218(S0)
9D00114C  A08000DA   SB ZERO, 218(A0)
9D001394  A20000DA   SB ZERO, 218(S0)
9D00149C  A08000DA   SB ZERO, 218(A0)
1855:                    setupPacket->wLength = length;
9D00022C  24030008   ADDIU V1, ZERO, 8
9D00036C  A20000DC   SB ZERO, 220(S0)
9D00058C  A20200DC   SB V0, 220(S0)
9D0006D8  24020009   ADDIU V0, ZERO, 9
9D000884  A21200DC   SB S2, 220(S0)
9D001154  24020009   ADDIU V0, ZERO, 9
9D00139C  A21100DC   SB S1, 220(S0)
9D0014A4  A08000DC   SB ZERO, 220(A0)
1856:                }
1857:                
1858:                // *****************************************************************************
1859:                /* Function:
1860:                    void _USB_HOST_MakeDeviceReady
1861:                    ( 
1862:                        USB_HOST_DEVICE_OBJ * deviceObj, 
1863:                        int busIndex
1864:                    )
1865:                
1866:                  Summary:
1867:                    Maintains the state of the device at a device level.
1868:                
1869:                  Description:
1870:                    Maintains the state of the device at a device level. Moves the state of the
1871:                    device from attached to ready. It opens the control transfer pipe and checks
1872:                    configuration descriptors for errors.
1873:                
1874:                  Remarks:
1875:                    This is a local function and should not be called by the application
1876:                    directly.
1877:                */
1878:                
1879:                void _USB_HOST_MakeDeviceReady
1880:                (
1881:                    USB_HOST_DEVICE_OBJ *deviceObj, 
1882:                    int busIndex
1883:                )
1884:                {
9D000000  27BDFFC8   ADDIU SP, SP, -56
9D000004  AFBF0034   SW RA, 52(SP)
9D000008  AFB20030   SW S2, 48(SP)
9D00000C  AFB1002C   SW S1, 44(SP)
9D000010  AFB00028   SW S0, 40(SP)
1885:                    USB_HOST_BUS_OBJ * busObj;
1886:                    USB_CONFIGURATION_DESCRIPTOR * configurationDescriptor;
1887:                    bool interruptIsEnabled;
1888:                   
1889:                    busObj = &(gUSBHostBusList[busIndex]);
9D000020  00051100   SLL V0, A1, 4
9D000024  00052980   SLL A1, A1, 6
9D000028  00452821   ADDU A1, V0, A1
9D00002C  3C04A000   LUI A0, -24576
9D000030  248466E8   ADDIU A0, A0, 26344
1890:                    
1891:                    if(!deviceObj->inUse)
9D000014  90820000   LBU V0, 0(A0)
9D000018  1040029A   BEQ V0, ZERO, 0x9D000A84
9D00001C  00808021   ADDU S0, A0, ZERO
1892:                    {
1893:                        /* Although this should not happen, we make sure that we dont run tasks
1894:                         * for device object that is not valid */
1895:                    }
1896:                    else
1897:                    {
1898:                        switch (deviceObj->deviceState)
9D000034  8E0200F0   LW V0, 240(S0)
9D000038  24420001   ADDIU V0, V0, 1
9D00003C  2C430010   SLTIU V1, V0, 16
9D000040  10600290   BEQ V1, ZERO, 0x9D000A84
9D000044  00858821   ADDU S1, A0, A1
9D000048  00021080   SLL V0, V0, 2
9D00004C  3C039D00   LUI V1, -25344
9D000050  24630064   ADDIU V1, V1, 100
9D000054  00621021   ADDU V0, V1, V0
9D000058  8C420000   LW V0, 0(V0)
9D00005C  00400008   JR V0
9D000060  00000000   NOP
1899:                        {
1900:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION:
1901:                
1902:                                /* If another device is enumerating on the bus, then we don't do
1903:                                 * anything. Only one device can enumerate on the bus */
1904:                
1905:                                if(!busObj->deviceIsEnumerating)
9D0000A4  92220015   LBU V0, 21(S1)
9D0000A8  14400277   BNE V0, ZERO, 0x9D000A88
9D0000AC  8FBF0034   LW RA, 52(SP)
1906:                                {
1907:                                    /* Remember which device is enumerating */
1908:                                    busObj->enumeratingDeviceIdentifier = deviceObj->deviceIdentifier;
9D0000B0  8E02004C   LW V0, 76(S0)
9D0000B4  AE22004C   SW V0, 76(S1)
1909:                
1910:                                    /* Grab the flag */
1911:                                    busObj->deviceIsEnumerating = true;
9D0000B8  24020001   ADDIU V0, ZERO, 1
9D0000BC  A2220015   SB V0, 21(S1)
1912:                
1913:                                    /* Reset the device */
1914:                                    deviceObj->hubInterface->hubPortReset( deviceObj->hubHandle, deviceObj->devicePort );
9D0000C0  8E020070   LW V0, 112(S0)
9D0000C4  8C420000   LW V0, 0(V0)
9D0000C8  8E040068   LW A0, 104(S0)
9D0000CC  0040F809   JALR V0
9D0000D0  92050075   LBU A1, 117(S0)
1915:                
1916:                                    /* Change the device state */
1917:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_RESET_COMPLETE;
9D0000D4  24020001   ADDIU V0, ZERO, 1
9D0000D8  AE0200F0   SW V0, 240(S0)
1918:                
1919:                                    /* Check if the device object has any previous allocated memory. If
1920:                                     * so then free it up. Allocation is done for the
1921:                                     * configuration descriptor. */
1922:                                    if(deviceObj->configDescriptorInfo.configurationDescriptor != NULL)
9D0000DC  8E040100   LW A0, 256(S0)
9D0000E0  50800005   BEQL A0, ZERO, 0x9D0000F8
9D0000E4  8E040090   LW A0, 144(S0)
1923:                                    {
1924:                                        USB_HOST_FREE(deviceObj->configDescriptorInfo.configurationDescriptor);
9D0000E8  0F4025F6   JAL free
9D0000EC  00000000   NOP
1925:                                        deviceObj->configDescriptorInfo.configurationDescriptor = NULL;
9D0000F0  AE000100   SW ZERO, 256(S0)
1926:                                    }
1927:                
1928:                                    /* The holdingConfigurationDescriptor memory should be free
1929:                                     * but we double check this here just to be safe. */
1930:                                    if(deviceObj->holdingConfigurationDescriptor != NULL)
9D0000F4  8E040090   LW A0, 144(S0)
9D0000F8  10800263   BEQ A0, ZERO, 0x9D000A88
9D0000FC  8FBF0034   LW RA, 52(SP)
1931:                                    {
1932:                                        USB_HOST_FREE(deviceObj->holdingConfigurationDescriptor);
9D000100  0F4025F6   JAL free
9D000104  00000000   NOP
1933:                                        deviceObj->holdingConfigurationDescriptor = NULL;
9D000108  0B4002A1   J 0x9D000A84
9D00010C  AE000090   SW ZERO, 144(S0)
1934:                                    }
1935:                
1936:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device Attach detected. Starting Enumeration.", busIndex);
1937:                                }
1938:                                break;
1939:                
1940:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_RESET_COMPLETE:
1941:                
1942:                                /* Check if the reset has completed */
1943:                                if(deviceObj->hubInterface->hubPortResetIsComplete( deviceObj->hubHandle ,deviceObj->devicePort ))
9D000110  8E020070   LW V0, 112(S0)
9D000114  8C420004   LW V0, 4(V0)
9D000118  8E040068   LW A0, 104(S0)
9D00011C  0040F809   JALR V0
9D000120  92050075   LBU A1, 117(S0)
9D000124  10400258   BEQ V0, ZERO, 0x9D000A88
9D000128  8FBF0034   LW RA, 52(SP)
1944:                                {
1945:                                    /* The reset has completed. We can also obtain the speed of the
1946:                                     * device. We give a reset recovery delay to the device */
1947:                                    deviceObj->speed = deviceObj->hubInterface->hubPortSpeedGet(deviceObj->hubHandle, deviceObj->devicePort);
9D00012C  8E020070   LW V0, 112(S0)
9D000130  8C420010   LW V0, 16(V0)
9D000134  8E040068   LW A0, 104(S0)
9D000138  0040F809   JALR V0
9D00013C  92050075   LBU A1, 117(S0)
9D000140  AE020078   SW V0, 120(S0)
1948:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_START_RESET_SETTLING_DELAY;
9D000144  24020002   ADDIU V0, ZERO, 2
9D000148  0B4002A1   J 0x9D000A84
9D00014C  AE0200F0   SW V0, 240(S0)
1949:                                }
1950:                
1951:                                break;
1952:                
1953:                            case USB_HOST_DEVICE_STATE_START_RESET_SETTLING_DELAY:
1954:                
1955:                                /* In this state we start the Post Reset Settling delay */
1956:                                busObj->timerExpired = false;
9D000150  A220004B   SB ZERO, 75(S1)
1957:                                busObj->busOperationsTimerHandle = SYS_TMR_CallbackSingle(100, (uintptr_t ) busObj, _USB_HOST_TimerCallback);
9D000154  24040064   ADDIU A0, ZERO, 100
9D000158  02202821   ADDU A1, S1, ZERO
9D00015C  3C069D01   LUI A2, -25343
9D000160  0F402699   JAL SYS_TMR_CallbackSingle
9D000164  24C69AF8   ADDIU A2, A2, -25864
1958:                                if(SYS_TMR_HANDLE_INVALID != busObj->busOperationsTimerHandle)
9D000168  2403FFFF   ADDIU V1, ZERO, -1
9D00016C  10430245   BEQ V0, V1, 0x9D000A84
9D000170  AE220044   SW V0, 68(S1)
1959:                                {
1960:                                    /* Wait for the post bus reset to complete */
1961:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_RESET_SETTLING_DELAY_COMPLETE;
9D000174  24020003   ADDIU V0, ZERO, 3
9D000178  0B4002A1   J 0x9D000A84
9D00017C  AE0200F0   SW V0, 240(S0)
1962:                                }
1963:                                else
1964:                                {
1965:                                    /* Continue to stay in the state */
1966:                                }
1967:                                break;
1968:                
1969:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_RESET_SETTLING_DELAY_COMPLETE:
1970:                
1971:                                /* In this state we are waiting for the reset settling delay to
1972:                                 * complete. */
1973:                
1974:                                if(busObj->timerExpired)
9D000180  9222004B   LBU V0, 75(S1)
9D000184  10400240   BEQ V0, ZERO, 0x9D000A88
9D000188  8FBF0034   LW RA, 52(SP)
1975:                                {
1976:                                    busObj->busOperationsTimerHandle = SYS_TMR_HANDLE_INVALID;
9D00018C  2412FFFF   ADDIU S2, ZERO, -1
9D000190  AE320044   SW S2, 68(S1)
1977:                                    /* Settling delay has completed. Now we can open default address
1978:                                     * pipe and and get the configuration descriptor */
1979:                
1980:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device Reset Complete.", busIndex);
1981:                                    deviceObj->controlPipeHandle = deviceObj->hcdInterface->hostPipeSetup( deviceObj->hcdHandle,
9D000194  8E02006C   LW V0, 108(S0)
9D000198  8E040064   LW A0, 100(S0)
9D00019C  92070074   LBU A3, 116(S0)
9D0001A0  92030075   LBU V1, 117(S0)
9D0001A4  AFA30010   SW V1, 16(SP)
9D0001A8  AFA00014   SW ZERO, 20(SP)
9D0001AC  AFA00018   SW ZERO, 24(SP)
9D0001B0  24030008   ADDIU V1, ZERO, 8
9D0001B4  AFA3001C   SW V1, 28(SP)
9D0001B8  8E030078   LW V1, 120(S0)
9D0001BC  AFA30020   SW V1, 32(SP)
9D0001C0  8C42001C   LW V0, 28(V0)
9D0001C4  00002821   ADDU A1, ZERO, ZERO
9D0001C8  0040F809   JALR V0
9D0001CC  00003021   ADDU A2, ZERO, ZERO
1982:                                            USB_HOST_DEFAULT_ADDRESS , 0 /* Endpoint */, 
1983:                                            deviceObj->hubAddress /* Address of the hub */, 
1984:                                            deviceObj->devicePort /* Address of the port */, 
1985:                                            USB_TRANSFER_TYPE_CONTROL, /* Type of pipe to open */
1986:                                            0 /* bInterval */, 8 /* Endpoint Size */, deviceObj->speed );
1987:                
1988:                                    if(DRV_USB_HOST_PIPE_HANDLE_INVALID == deviceObj->controlPipeHandle)
9D0001D0  1452000D   BNE V0, S2, _USB_HOST_MakeDeviceReady::_USB_HOST_FillSetupPacket
9D0001D4  AE020058   SW V0, 88(S0)
1989:                                    {
1990:                                        /* We need a pipe else we cannot proceed */
1991:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Could not open control pipe. Device not supported.", busIndex);
1992:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0001D8  2402FFFF   ADDIU V0, ZERO, -1
9D0001DC  AE0200F0   SW V0, 240(S0)
1993:                                        if(gUSBHostObj.hostEventHandler != NULL)
9D0001E0  3C02A000   LUI V0, -24576
9D0001E4  8C426738   LW V0, 26424(V0)
9D0001E8  10400005   BEQ V0, ZERO, 0x9D000200
9D0001EC  24040001   ADDIU A0, ZERO, 1
1994:                                        {
1995:                                            /* Send an event to the application */
1996:                                            gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D0001F0  00002821   ADDU A1, ZERO, ZERO
9D0001F4  3C03A000   LUI V1, -24576
9D0001F8  0040F809   JALR V0
9D0001FC  8C66673C   LW A2, 26428(V1)
9D000200  0B4002A1   J 0x9D000A84
9D000204  A2200015   SB ZERO, 21(S1)
1997:                                        }
1998:                
1999:                                        /* Release the device is enumerating flag. Another
2000:                                         * device can start enumerating. */
2001:                                        busObj->deviceIsEnumerating = false;
2002:                                    }
2003:                                    else
2004:                                    {
2005:                                        /* Create a setup command to get the device descriptor */
2006:                                        _USB_HOST_FillSetupPacket(  &(deviceObj->setupPacket),
9D000248  260300D6   ADDIU V1, S0, 214
2007:                                                ( USB_SETUP_DIRN_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE ),
2008:                                                USB_REQUEST_GET_DESCRIPTOR, ( USB_DESCRIPTOR_DEVICE << 8 ), 0 , 8 ) ;
2009:                
2010:                                        /* Fill control IRP. Note the size of the control transfer data
2011:                                         * stage. We ask for the first 8 bytes of the device descriptor. */
2012:                
2013:                                        deviceObj->controlTransferObj.inUse = true;
9D000238  24030001   ADDIU V1, ZERO, 1
9D00023C  A2030004   SB V1, 4(S0)
2014:                                        deviceObj->controlTransferObj.controlIRP.data = (void *) &( deviceObj->deviceDescriptor );
9D000240  2603007C   ADDIU V1, S0, 124
9D000244  AE030010   SW V1, 16(S0)
2015:                                        deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket ) ;
9D00024C  AE03000C   SW V1, 12(S0)
2016:                                        deviceObj->controlTransferObj.controlIRP.size = 8 ;
9D000250  24030008   ADDIU V1, ZERO, 8
9D000254  AE030014   SW V1, 20(S0)
2017:                                        deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D000258  AE000024   SW ZERO, 36(S0)
2018:                
2019:                                        /* Change device state to next state */
2020:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_GET_DEVICE_DESCRIPTOR_SHORT;
9D00025C  24030004   ADDIU V1, ZERO, 4
9D000260  AE0300F0   SW V1, 240(S0)
2021:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Requesting Device Descriptor.", busIndex);
2022:                
2023:                                        /* Submit the IRP */
2024:                                        if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit(deviceObj->controlPipeHandle, 
9D000264  8E03006C   LW V1, 108(S0)
9D000268  8C63000C   LW V1, 12(V1)
9D00026C  00402021   ADDU A0, V0, ZERO
9D000270  0060F809   JALR V1
9D000274  2605000C   ADDIU A1, S0, 12
9D000278  10400203   BEQ V0, ZERO, 0x9D000A88
9D00027C  8FBF0034   LW RA, 52(SP)
2025:                                                    &(deviceObj->controlTransferObj.controlIRP)))
2026:                                        {
2027:                                            /* We need to be able to send the IRP. We move the
2028:                                             * device to an error state. Close the pipe and send
2029:                                             * an event to the application. */
2030:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device Descriptor IRP failed. Device not supported.", busIndex);
2031:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D000280  2402FFFF   ADDIU V0, ZERO, -1
9D000284  AE0200F0   SW V0, 240(S0)
2032:                                            deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D000288  8E02006C   LW V0, 108(S0)
9D00028C  8C420020   LW V0, 32(V0)
9D000290  0040F809   JALR V0
9D000294  8E040058   LW A0, 88(S0)
2033:                                            if(gUSBHostObj.hostEventHandler != NULL)
9D000298  3C02A000   LUI V0, -24576
9D00029C  8C426738   LW V0, 26424(V0)
9D0002A0  10400005   BEQ V0, ZERO, 0x9D0002B8
9D0002A4  24040001   ADDIU A0, ZERO, 1
2034:                                            {
2035:                                                /* Send an event to the application */
2036:                                                gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D0002A8  00002821   ADDU A1, ZERO, ZERO
9D0002AC  3C03A000   LUI V1, -24576
9D0002B0  0040F809   JALR V0
9D0002B4  8C66673C   LW A2, 26428(V1)
2037:                                            }
2038:                
2039:                                            /* Release the device is enumerating flag. Another
2040:                                             * device can start enumerating. */
2041:                                            busObj->deviceIsEnumerating = false;
9D0002B8  0B4002A1   J 0x9D000A84
9D0002BC  A2200015   SB ZERO, 21(S1)
2042:                                        }
2043:                                    }
2044:                                }
2045:                                break;
2046:                
2047:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_GET_DEVICE_DESCRIPTOR_SHORT:
2048:                
2049:                                /* Check if the Device Descriptor was obtained */
2050:                                if ( deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED )
9D0002C0  8E020018   LW V0, 24(S0)
9D0002C4  14400005   BNE V0, ZERO, 0x9D0002DC
9D0002C8  00000000   NOP
2051:                                {
2052:                                    /* The IRP completed. deviceObj->deviceDescriptor has the device
2053:                                     * descriptor. We can move to addressing state. */
2054:                
2055:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_SET_ADDRESS;
9D0002CC  24020005   ADDIU V0, ZERO, 5
9D0002D0  AE0200F0   SW V0, 240(S0)
9D0002D4  0B4002A1   J 0x9D000A84
9D0002D8  A20000F4   SB ZERO, 244(S0)
2056:                
2057:                                    /* Reset the enumeration failure count */
2058:                                    deviceObj->enumerationFailCount = 0;
2059:                
2060:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device Descriptor obtained. Setting device address.", busIndex);
2061:                
2062:                                }
2063:                                else if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D0002DC  044101EA   BGEZ V0, 0x9D000A88
9D0002E0  8FBF0034   LW RA, 52(SP)
2064:                                {
2065:                                    /* The IRP failed. We will either reset the device or place
2066:                                     * it in an error state. In either case the control pipe
2067:                                     * should be closed. */
2068:                
2069:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0002E4  8E02006C   LW V0, 108(S0)
9D0002E8  8C420020   LW V0, 32(V0)
9D0002EC  0040F809   JALR V0
9D0002F0  8E040058   LW A0, 88(S0)
2070:                
2071:                                    /* Release the device is enumerating flag. This will give
2072:                                     * another device the chance to start enumerating. The
2073:                                     * enumeration of this device will be re-attempted after
2074:                                     * the possible enumeration of the other device. */
2075:                                    busObj->deviceIsEnumerating = false;
9D0002F4  A2200015   SB ZERO, 21(S1)
2076:                
2077:                                    /* Check if we should retry the enumeration sequence */
2078:                                    if (deviceObj->enumerationFailCount < USB_HOST_ENUMERATION_RETRY_COUNT)
9D0002F8  920200F4   LBU V0, 244(S0)
9D0002FC  2C430003   SLTIU V1, V0, 3
9D000300  50600005   BEQL V1, ZERO, 0x9D000318
9D000304  2402FFFF   ADDIU V0, ZERO, -1
2079:                                    {
2080:                                        /* Yes we should retry. Update the retry count */
2081:                                        deviceObj->enumerationFailCount ++ ;
9D000308  24420001   ADDIU V0, V0, 1
9D00030C  A20200F4   SB V0, 244(S0)
9D000310  0B4002A1   J 0x9D000A84
9D000314  AE0000F0   SW ZERO, 240(S0)
2082:                
2083:                                        /* Set device state for reset */
2084:                                        deviceObj->deviceState =  USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION;
2085:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device Descriptor Request Failed. Trying again.", busIndex);
2086:                                    }
2087:                                    else
2088:                                    {
2089:                                        /* We tried three times but were not able to get a proper
2090:                                         * device response. Place the device in an error state. */
2091:                
2092:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D000318  AE0200F0   SW V0, 240(S0)
2093:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device Request Failed 3 times. Device not supported.", busIndex);
2094:                                        if(gUSBHostObj.hostEventHandler != NULL)
9D00031C  3C02A000   LUI V0, -24576
9D000320  8C426738   LW V0, 26424(V0)
9D000324  104001D7   BEQ V0, ZERO, 0x9D000A84
9D000328  24040001   ADDIU A0, ZERO, 1
2095:                                        {
2096:                                            /* Send an event to the application */
2097:                                            gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D00032C  00002821   ADDU A1, ZERO, ZERO
9D000330  3C03A000   LUI V1, -24576
9D000334  0040F809   JALR V0
9D000338  8C66673C   LW A2, 26428(V1)
2098:                                        }
2099:                                    }
2100:                                }
2101:                
2102:                                break;
2103:                
2104:                            case USB_HOST_DEVICE_STATE_SET_ADDRESS:
2105:                
2106:                                deviceObj->deviceAddress = _USB_HOST_GetNewAddress( busObj );
9D000344  0F4025D2   JAL _USB_HOST_GetNewAddress
9D000348  02202021   ADDU A0, S1, ZERO
9D00034C  A2020060   SB V0, 96(S0)
2107:                
2108:                                /* Create the setup request */
2109:                                _USB_HOST_FillSetupPacket(  &(deviceObj->setupPacket),
9D00037C  260200D6   ADDIU V0, S0, 214
2110:                                        ( USB_SETUP_DIRN_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE ),
2111:                                        USB_REQUEST_SET_ADDRESS , deviceObj->deviceAddress , 0 , 0 ) ;
2112:                
2113:                                /* Create the IRP packet */
2114:                                deviceObj->controlTransferObj.controlIRP.data = (void *) ( deviceObj->buffer );
9D000374  26020094   ADDIU V0, S0, 148
9D000378  AE020010   SW V0, 16(S0)
2115:                                deviceObj->controlTransferObj.controlIRP.setup = &( deviceObj->setupPacket ) ;
9D000380  AE02000C   SW V0, 12(S0)
2116:                                deviceObj->controlTransferObj.controlIRP.size = 0 ;
9D000384  AE000014   SW ZERO, 20(S0)
2117:                                deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D000388  AE000024   SW ZERO, 36(S0)
2118:                
2119:                                /* Set the next host layer state */
2120:                                deviceObj->deviceState = USB_HOST_DEVICE_STATE_WATING_FOR_SET_ADDRESS_COMPLETE;
9D00038C  24020006   ADDIU V0, ZERO, 6
9D000390  AE0200F0   SW V0, 240(S0)
2121:                                SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Setting Device Address to %d.", busIndex, deviceObj->deviceAddress);
2122:                
2123:                                /* Submit the IRP */
2124:                                if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, & (deviceObj->controlTransferObj.controlIRP)))
9D000394  8E02006C   LW V0, 108(S0)
9D000398  8C42000C   LW V0, 12(V0)
9D00039C  8E040058   LW A0, 88(S0)
9D0003A0  0040F809   JALR V0
9D0003A4  2605000C   ADDIU A1, S0, 12
9D0003A8  104001B7   BEQ V0, ZERO, 0x9D000A88
9D0003AC  8FBF0034   LW RA, 52(SP)
2125:                                {
2126:                                    /* We need to be able to send the IRP. We move the device to
2127:                                     * an error state. Close the pipe and send an event to the
2128:                                     * application. The assigned address will be released when
2129:                                     * the device in un-plugged. */
2130:                
2131:                                    SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Set Addres IRP failed. Device not supported.", busIndex);
2132:                
2133:                                    /* Move the device to error state */
2134:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0003B0  2402FFFF   ADDIU V0, ZERO, -1
9D0003B4  AE0200F0   SW V0, 240(S0)
2135:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0003B8  8E02006C   LW V0, 108(S0)
9D0003BC  8C420020   LW V0, 32(V0)
9D0003C0  0040F809   JALR V0
9D0003C4  8E040058   LW A0, 88(S0)
2136:                                    if(gUSBHostObj.hostEventHandler != NULL)
9D0003C8  3C02A000   LUI V0, -24576
9D0003CC  8C426738   LW V0, 26424(V0)
9D0003D0  10400005   BEQ V0, ZERO, 0x9D0003E8
9D0003D4  24040001   ADDIU A0, ZERO, 1
2137:                                    {
2138:                                        /* Send an event to the application */
2139:                                        gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D0003D8  00002821   ADDU A1, ZERO, ZERO
9D0003DC  3C03A000   LUI V1, -24576
9D0003E0  0040F809   JALR V0
9D0003E4  8C66673C   LW A2, 26428(V1)
2140:                                    }
2141:                
2142:                                    /* Release the device is enumerating flag. Another device
2143:                                     * can start enumerating. */
2144:                                    busObj->deviceIsEnumerating = false;
9D0003E8  0B4002A1   J 0x9D000A84
9D0003EC  A2200015   SB ZERO, 21(S1)
2145:                                }
2146:                
2147:                                break;
2148:                
2149:                            case USB_HOST_DEVICE_STATE_WATING_FOR_SET_ADDRESS_COMPLETE:
2150:                
2151:                                /* In this state the host is waiting for the set address request
2152:                                 * to complete */
2153:                                if ( deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED )
9D0003F0  8E020018   LW V0, 24(S0)
9D0003F4  1440002B   BNE V0, ZERO, 0x9D0004A4
9D0003F8  00000000   NOP
2154:                                {
2155:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Set Address complete", busIndex);
2156:                
2157:                                    /* This means the Set Address request completed
2158:                                     * successfully. Now we can open an addressed control
2159:                                     * transfer pipe. Close the current control pipe. This one
2160:                                     * is to device address 0 */
2161:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle); 
9D0003FC  8E02006C   LW V0, 108(S0)
9D000400  8C420020   LW V0, 32(V0)
9D000404  0040F809   JALR V0
9D000408  8E040058   LW A0, 88(S0)
2162:                
2163:                                    /* Reset the enumeration failure count */
2164:                                    deviceObj->enumerationFailCount = 0x00;
9D00040C  A20000F4   SB ZERO, 244(S0)
2165:                
2166:                                    /* Open the new addressed pipe */
2167:                                    deviceObj->controlPipeHandle = deviceObj->hcdInterface->hostPipeSetup( deviceObj->hcdHandle,
9D000410  8E02006C   LW V0, 108(S0)
9D000414  8E040064   LW A0, 100(S0)
9D000418  92050060   LBU A1, 96(S0)
9D00041C  92070074   LBU A3, 116(S0)
9D000420  92030075   LBU V1, 117(S0)
9D000424  AFA30010   SW V1, 16(SP)
9D000428  AFA00014   SW ZERO, 20(SP)
9D00042C  AFA00018   SW ZERO, 24(SP)
9D000430  92030083   LBU V1, 131(S0)
9D000434  AFA3001C   SW V1, 28(SP)
9D000438  8E030078   LW V1, 120(S0)
9D00043C  AFA30020   SW V1, 32(SP)
9D000440  8C42001C   LW V0, 28(V0)
9D000444  0040F809   JALR V0
9D000448  00003021   ADDU A2, ZERO, ZERO
2168:                                            deviceObj->deviceAddress, 0 /* Endpoint */, deviceObj->hubAddress, deviceObj->devicePort,
2169:                                            USB_TRANSFER_TYPE_CONTROL/* Pipe type */, 0, /* bInterval */
2170:                                            deviceObj->deviceDescriptor.bMaxPacketSize0, deviceObj->speed );
2171:                
2172:                                    if( DRV_USB_HOST_PIPE_HANDLE_INVALID == deviceObj->controlPipeHandle )
9D00044C  2403FFFF   ADDIU V1, ZERO, -1
9D000450  14430011   BNE V0, V1, 0x9D000498
9D000454  AE020058   SW V0, 88(S0)
2173:                                    {
2174:                                        /* The control pipe could not be opened. We cannot
2175:                                         * do anything. We cannot support the device.
2176:                                         * Release the device address */
2177:                
2178:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d. Could not open addressed control pipe. Device not supported", busIndex);
2179:                                        _USB_HOST_FreeAddress ( deviceObj->deviceIdentifier );
9D000458  0F402290   JAL _USB_HOST_FreeAddress
9D00045C  8E04004C   LW A0, 76(S0)
2180:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D000460  2402FFFF   ADDIU V0, ZERO, -1
9D000464  AE0200F0   SW V0, 240(S0)
2181:                
2182:                                        /* Send an event to the application */
2183:                                        if(gUSBHostObj.hostEventHandler == NULL)
9D000468  3C02A000   LUI V0, -24576
9D00046C  8C426738   LW V0, 26424(V0)
9D000470  54400184   BNEL V0, ZERO, 0x9D000A84
9D000474  A2200015   SB ZERO, 21(S1)
2184:                                        {
2185:                                            gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D000478  24040001   ADDIU A0, ZERO, 1
9D00047C  3C02A000   LUI V0, -24576
9D000480  8C46673C   LW A2, 26428(V0)
9D000484  00001021   ADDU V0, ZERO, ZERO
9D000488  0040F809   JALR V0
9D00048C  00002821   ADDU A1, ZERO, ZERO
9D000490  0B4002A1   J 0x9D000A84
9D000494  A2200015   SB ZERO, 21(S1)
2186:                                        }
2187:                
2188:                                        /* Release the device is enumerating flag. Another
2189:                                         * device can start enumerating. */
2190:                                        busObj->deviceIsEnumerating = false;
2191:                                    }
2192:                                    else
2193:                                    {
2194:                                        /* The pipe was opened and we can continue with the
2195:                                         * rest of the enumeration */
2196:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_POST_SET_ADDRESS_DELAY;
9D000498  24020007   ADDIU V0, ZERO, 7
9D00049C  0B4002A1   J 0x9D000A84
9D0004A0  AE0200F0   SW V0, 240(S0)
2197:                                    }
2198:                                }
2199:                                else
2200:                                {
2201:                                    if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D0004A4  04410178   BGEZ V0, 0x9D000A88
9D0004A8  8FBF0034   LW RA, 52(SP)
2202:                                    {
2203:                                        /* The Set Address Request failed. We should either
2204:                                         * retry or place the device in error state. In any case
2205:                                         * the the control pipe should be closed. */
2206:                
2207:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0004AC  8E02006C   LW V0, 108(S0)
9D0004B0  8C420020   LW V0, 32(V0)
9D0004B4  0040F809   JALR V0
9D0004B8  8E040058   LW A0, 88(S0)
2208:                
2209:                                        /* Release the device is enumerating flag. This will give
2210:                                         * another device the chance to start enumerating. The
2211:                                         * enumeration of this device will be re-attempted after
2212:                                         * the possible enumeration of the other device. */
2213:                                        busObj->deviceIsEnumerating = false;
9D0004BC  A2200015   SB ZERO, 21(S1)
2214:                
2215:                                        /* Should we retry? */
2216:                                        if (deviceObj-> enumerationFailCount < USB_HOST_ENUMERATION_RETRY_COUNT )
9D0004C0  920200F4   LBU V0, 244(S0)
9D0004C4  2C430003   SLTIU V1, V0, 3
9D0004C8  50600007   BEQL V1, ZERO, 0x9D0004E8
9D0004CC  2402FFFF   ADDIU V0, ZERO, -1
2217:                                        {
2218:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d. Set Address failed. Trying again.", busIndex);
2219:                
2220:                                            /* Yes we should. Increment the failure count */
2221:                                            deviceObj->enumerationFailCount ++ ;
9D0004D0  24420001   ADDIU V0, V0, 1
9D0004D4  A20200F4   SB V0, 244(S0)
2222:                
2223:                                            /* The device address must be released because this
2224:                                             * will be attempted again */
2225:                                            _USB_HOST_FreeAddress(deviceObj->deviceIdentifier);
9D0004D8  0F402290   JAL _USB_HOST_FreeAddress
9D0004DC  8E04004C   LW A0, 76(S0)
9D0004E0  0B4002A1   J 0x9D000A84
9D0004E4  AE0000F0   SW ZERO, 240(S0)
2226:                
2227:                                            /* Set device state for enumeration */
2228:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION; 
2229:                                        }
2230:                                        else
2231:                                        {
2232:                                            /* We have tried enumeration multiple times and
2233:                                             * failed. */
2234:                
2235:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d. Set Address failed 3 times. Device not supported.", busIndex);
2236:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0004E8  AE0200F0   SW V0, 240(S0)
2237:                                            if(gUSBHostObj.hostEventHandler != NULL)
9D0004EC  3C02A000   LUI V0, -24576
9D0004F0  8C426738   LW V0, 26424(V0)
9D0004F4  10400163   BEQ V0, ZERO, 0x9D000A84
9D0004F8  24040001   ADDIU A0, ZERO, 1
2238:                                            {
2239:                                                /* Send the event to the application */
2240:                                                gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D0004FC  00002821   ADDU A1, ZERO, ZERO
9D000500  3C03A000   LUI V1, -24576
9D000504  0040F809   JALR V0
9D000508  8C66673C   LW A2, 26428(V1)
2241:                                            }
2242:                                        }
2243:                                    }
2244:                                }
2245:                
2246:                                break;
2247:                
2248:                            case USB_HOST_DEVICE_STATE_POST_SET_ADDRESS_DELAY:
2249:                
2250:                                /* After the address has been set, we provide a delay of 50
2251:                                 * milliseconds */
2252:                                busObj->timerExpired = false;
9D000514  A220004B   SB ZERO, 75(S1)
2253:                                busObj->busOperationsTimerHandle = SYS_TMR_CallbackSingle( 50, (uintptr_t ) busObj, _USB_HOST_TimerCallback);;
9D000518  24040032   ADDIU A0, ZERO, 50
9D00051C  02202821   ADDU A1, S1, ZERO
9D000520  3C069D01   LUI A2, -25343
9D000524  0F402699   JAL SYS_TMR_CallbackSingle
9D000528  24C69AF8   ADDIU A2, A2, -25864
2254:                
2255:                                if(SYS_TMR_HANDLE_INVALID != busObj->busOperationsTimerHandle)
9D00052C  2403FFFF   ADDIU V1, ZERO, -1
9D000530  10430154   BEQ V0, V1, 0x9D000A84
9D000534  AE220044   SW V0, 68(S1)
2256:                                {
2257:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_POST_SET_ADDRESS_DELAY;
9D000538  24020008   ADDIU V0, ZERO, 8
9D00053C  0B4002A1   J 0x9D000A84
9D000540  AE0200F0   SW V0, 240(S0)
2258:                                }
2259:                                break;
2260:                
2261:                            case USB_HOST_DEVICE_STATE_WAITING_POST_SET_ADDRESS_DELAY:
2262:                
2263:                                /* Here we check if the post device set address delay has
2264:                                 * completed */
2265:                                if(busObj->timerExpired)
9D000544  9222004B   LBU V0, 75(S1)
9D000548  1040014F   BEQ V0, ZERO, 0x9D000A88
9D00054C  8FBF0034   LW RA, 52(SP)
2266:                                {
2267:                                    busObj->busOperationsTimerHandle = SYS_TMR_HANDLE_INVALID ;
9D000550  2402FFFF   ADDIU V0, ZERO, -1
9D000554  AE220044   SW V0, 68(S1)
2268:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Post Set Address Delay completed.", busIndex);
2269:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Requesting Full Device Descriptor.", busIndex, deviceObj->deviceAddress);
2270:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_GET_DEVICE_DESCRIPTOR_FULL;
9D000558  24020009   ADDIU V0, ZERO, 9
9D00055C  0B4002A1   J 0x9D000A84
9D000560  AE0200F0   SW V0, 240(S0)
2271:                                }
2272:                                break;
2273:                
2274:                            case USB_HOST_DEVICE_STATE_GET_DEVICE_DESCRIPTOR_FULL:
2275:                
2276:                                /* In the state the host layer requests for the full device
2277:                                 * descriptor. Create the setup packet. */
2278:                                _USB_HOST_FillSetupPacket( &(deviceObj->setupPacket), ( USB_SETUP_DIRN_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE ),
9D00059C  260300D6   ADDIU V1, S0, 214
2279:                                        USB_REQUEST_GET_DESCRIPTOR, ( USB_DESCRIPTOR_DEVICE << 8 ), 0 , deviceObj->deviceDescriptor.bLength ) ;
9D000564  9202007C   LBU V0, 124(S0)
2280:                
2281:                                /* Fill IRP */
2282:                                deviceObj->controlTransferObj.controlIRP.data = (void *) &( deviceObj->deviceDescriptor );
9D000594  2603007C   ADDIU V1, S0, 124
9D000598  AE030010   SW V1, 16(S0)
2283:                                deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket);
9D0005A0  AE03000C   SW V1, 12(S0)
2284:                                deviceObj->controlTransferObj.controlIRP.size = deviceObj->deviceDescriptor.bLength;
9D0005A4  AE020014   SW V0, 20(S0)
2285:                                deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D0005A8  AE000024   SW ZERO, 36(S0)
2286:                
2287:                                deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_GET_DEVICE_DESCRIPTOR_FULL;
9D0005AC  2402000A   ADDIU V0, ZERO, 10
9D0005B0  AE0200F0   SW V0, 240(S0)
2288:                
2289:                                /* Submit the IRP */
2290:                                if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, &(deviceObj->controlTransferObj.controlIRP)))
9D0005B4  8E02006C   LW V0, 108(S0)
9D0005B8  8C42000C   LW V0, 12(V0)
9D0005BC  8E040058   LW A0, 88(S0)
9D0005C0  0040F809   JALR V0
9D0005C4  2605000C   ADDIU A1, S0, 12
9D0005C8  1040012F   BEQ V0, ZERO, 0x9D000A88
9D0005CC  8FBF0034   LW RA, 52(SP)
2291:                                {
2292:                                    /* We need to be able to send the IRP. We move the device to
2293:                                     * an error state. Close the pipe and send an event to the
2294:                                     * application. */
2295:                
2296:                                    SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Device Descriptor IRP failed. Device not supported.", busIndex, deviceObj->deviceAddress);
2297:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0005D0  2402FFFF   ADDIU V0, ZERO, -1
9D0005D4  AE0200F0   SW V0, 240(S0)
2298:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0005D8  8E02006C   LW V0, 108(S0)
9D0005DC  8C420020   LW V0, 32(V0)
9D0005E0  0040F809   JALR V0
9D0005E4  8E040058   LW A0, 88(S0)
2299:                                    if(gUSBHostObj.hostEventHandler != NULL)
9D0005E8  3C02A000   LUI V0, -24576
9D0005EC  8C426738   LW V0, 26424(V0)
9D0005F0  10400005   BEQ V0, ZERO, 0x9D000608
9D0005F4  24040001   ADDIU A0, ZERO, 1
2300:                                    {
2301:                                        /* Send an event to the application */
2302:                                        gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D0005F8  00002821   ADDU A1, ZERO, ZERO
9D0005FC  3C03A000   LUI V1, -24576
9D000600  0040F809   JALR V0
9D000604  8C66673C   LW A2, 26428(V1)
2303:                                    }
2304:                
2305:                                    /* Release the device is enumerating flag. Another device
2306:                                     * can start enumerating. */
2307:                                    busObj->deviceIsEnumerating = false;
9D000608  0B4002A1   J 0x9D000A84
9D00060C  A2200015   SB ZERO, 21(S1)
2308:                                }
2309:                                break;
2310:                
2311:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_GET_DEVICE_DESCRIPTOR_FULL:
2312:                
2313:                                /* Here we are waiting for Get Full Device Descriptor to
2314:                                 * complete */
2315:                                if (deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED)
9D000610  8E020018   LW V0, 24(S0)
9D000614  14400008   BNE V0, ZERO, 0x9D000638
9D000618  00000000   NOP
2316:                                {
2317:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Full Device Descriptor obtained.", busIndex, deviceObj->deviceAddress);
2318:                
2319:                                    /* IRP was successful. Go to the next state */
2320:                                    deviceObj->deviceState =  USB_HOST_DEVICE_STATE_GET_CONFIGURATION_DESCRIPTOR_SHORT;
9D00061C  2402000B   ADDIU V0, ZERO, 11
9D000620  AE0200F0   SW V0, 240(S0)
2321:                
2322:                                    /* Reset the enumeration failure count */
2323:                                    deviceObj->enumerationFailCount = 0x00;
9D000624  A20000F4   SB ZERO, 244(S0)
2324:                
2325:                                    /* Update the number of configurations */
2326:                                    deviceObj->nConfiguration = deviceObj->deviceDescriptor.bNumConfigurations;
9D000628  9202008D   LBU V0, 141(S0)
9D00062C  A20200D4   SB V0, 212(S0)
9D000630  0B4002A1   J 0x9D000A84
9D000634  A20000F5   SB ZERO, 245(S0)
2327:                
2328:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d contains %d configurations.", busIndex, deviceObj->deviceAddress, deviceObj->nConfiguration);
2329:                
2330:                                    /* Reset the configuration check count to indicate that we are
2331:                                     * checking the first configuration */
2332:                                    deviceObj->configurationCheckCount = 0;
2333:                                }
2334:                                else
2335:                                {
2336:                                    /* The IRP did not complete successfully. */
2337:                                    if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D000638  04410113   BGEZ V0, 0x9D000A88
9D00063C  8FBF0034   LW RA, 52(SP)
2338:                                    {
2339:                                        /* Close the pipe */
2340:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D000640  8E02006C   LW V0, 108(S0)
9D000644  8C420020   LW V0, 32(V0)
9D000648  0040F809   JALR V0
9D00064C  8E040058   LW A0, 88(S0)
2341:                
2342:                                        /* Release the device is enumerating flag. This will give
2343:                                         * another device the chance to start enumerating. The
2344:                                         * enumeration of this device will be re-attempted after
2345:                                         * the possible enumeration of the other device. */
2346:                                        busObj->deviceIsEnumerating = false;
9D000650  A2200015   SB ZERO, 21(S1)
2347:                
2348:                                        /* Should we retry */
2349:                                        if (deviceObj->enumerationFailCount < USB_HOST_ENUMERATION_RETRY_COUNT )
9D000654  920200F4   LBU V0, 244(S0)
9D000658  2C430003   SLTIU V1, V0, 3
9D00065C  50600007   BEQL V1, ZERO, 0x9D00067C
9D000660  2402FFFF   ADDIU V0, ZERO, -1
2350:                                        {
2351:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Device Descriptor Request Failed. Trying again", busIndex, deviceObj->deviceAddress);
2352:                
2353:                                            /* Yes we should. Increment the enumeration
2354:                                             * count and reset the device */
2355:                                            deviceObj->enumerationFailCount ++ ;
9D000664  24420001   ADDIU V0, V0, 1
9D000668  A20200F4   SB V0, 244(S0)
2356:                
2357:                                            /* The device address must be release because the
2358:                                             * enumeration process will be repeated */
2359:                                            _USB_HOST_FreeAddress(deviceObj->deviceIdentifier);
9D00066C  0F402290   JAL _USB_HOST_FreeAddress
9D000670  8E04004C   LW A0, 76(S0)
9D000674  0B4002A1   J 0x9D000A84
9D000678  AE0000F0   SW ZERO, 240(S0)
2360:                
2361:                                            /* Set device state for enumeration */
2362:                                            deviceObj->deviceState =  USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION;
2363:                                        }
2364:                                        else
2365:                                        {
2366:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D00067C  AE0200F0   SW V0, 240(S0)
2367:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Device Request Failed 3 times. Device not supported.", busIndex, deviceObj->deviceAddress);
2368:                
2369:                                            /* We should send an event to the application and
2370:                                             * then wait for device attach */
2371:                                            if(gUSBHostObj.hostEventHandler != NULL)
9D000680  3C02A000   LUI V0, -24576
9D000684  8C426738   LW V0, 26424(V0)
9D000688  104000FE   BEQ V0, ZERO, 0x9D000A84
9D00068C  24040001   ADDIU A0, ZERO, 1
2372:                                            {
2373:                                                gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D000690  00002821   ADDU A1, ZERO, ZERO
9D000694  3C03A000   LUI V1, -24576
9D000698  0040F809   JALR V0
9D00069C  8C66673C   LW A2, 26428(V1)
2374:                                            }
2375:                                        }
2376:                                    }
2377:                                }
2378:                                break;
2379:                
2380:                            case USB_HOST_DEVICE_STATE_GET_CONFIGURATION_DESCRIPTOR_SHORT:
2381:                
2382:                                /* In this state the host will get the configuration descriptor
2383:                                 * header. This is needed so that we know what is the
2384:                                 * configuration descriptor size  */
2385:                
2386:                                _USB_HOST_FillSetupPacket( &(deviceObj->setupPacket), ( USB_SETUP_DIRN_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE ), USB_REQUEST_GET_DESCRIPTOR,
9D0006A8  920200F5   LBU V0, 245(S0)
9D0006AC  24420200   ADDIU V0, V0, 512
9D0006B0  3042FFFF   ANDI V0, V0, -1
9D0006EC  260200D6   ADDIU V0, S0, 214
2387:                                        ( USB_DESCRIPTOR_CONFIGURATION << 8 )+ deviceObj->configurationCheckCount , 0 , 9 ) ;
2388:                
2389:                                /* Fill IRP */
2390:                                deviceObj->controlTransferObj.controlIRP.data = ( void * )deviceObj->buffer;
9D0006E4  26020094   ADDIU V0, S0, 148
9D0006E8  AE020010   SW V0, 16(S0)
2391:                                deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket);
9D0006F0  AE02000C   SW V0, 12(S0)
2392:                                deviceObj->controlTransferObj.controlIRP.size = 9;
9D0006F4  24020009   ADDIU V0, ZERO, 9
9D0006F8  AE020014   SW V0, 20(S0)
2393:                                deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D0006FC  AE000024   SW ZERO, 36(S0)
2394:                
2395:                                deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_GET_CONFIGURATION_DESCRIPTOR_SHORT;
9D000700  2402000C   ADDIU V0, ZERO, 12
9D000704  AE0200F0   SW V0, 240(S0)
2396:                
2397:                                /* Submit the IRP */
2398:                                if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, 
9D000708  8E02006C   LW V0, 108(S0)
9D00070C  8C42000C   LW V0, 12(V0)
9D000710  8E040058   LW A0, 88(S0)
9D000714  0040F809   JALR V0
9D000718  2605000C   ADDIU A1, S0, 12
9D00071C  104000DA   BEQ V0, ZERO, 0x9D000A88
9D000720  8FBF0034   LW RA, 52(SP)
2399:                                            &(deviceObj->controlTransferObj.controlIRP)))
2400:                                {
2401:                                    /* We need to be able to send the IRP. We move the device to
2402:                                     * an error state. Close the pipe and send an event to the
2403:                                     * application. */
2404:                                    SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Configuration Descriptor IRP failed. Device not supported.", busIndex, deviceObj->deviceAddress);
2405:                
2406:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D000724  2402FFFF   ADDIU V0, ZERO, -1
9D000728  AE0200F0   SW V0, 240(S0)
2407:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D00072C  8E02006C   LW V0, 108(S0)
9D000730  8C420020   LW V0, 32(V0)
9D000734  0040F809   JALR V0
9D000738  8E040058   LW A0, 88(S0)
2408:                                    if(gUSBHostObj.hostEventHandler != NULL)
9D00073C  3C02A000   LUI V0, -24576
9D000740  8C426738   LW V0, 26424(V0)
9D000744  10400005   BEQ V0, ZERO, 0x9D00075C
9D000748  24040001   ADDIU A0, ZERO, 1
2409:                                    {
2410:                                        /* Send an event to the application */
2411:                                        gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D00074C  00002821   ADDU A1, ZERO, ZERO
9D000750  3C03A000   LUI V1, -24576
9D000754  0040F809   JALR V0
9D000758  8C66673C   LW A2, 26428(V1)
2412:                                    }
2413:                
2414:                                    /* Release the device is enumerating flag. Another
2415:                                     * device can start enumerating. */
2416:                                    busObj->deviceIsEnumerating = false;
9D00075C  0B4002A1   J 0x9D000A84
9D000760  A2200015   SB ZERO, 21(S1)
2417:                                }
2418:                
2419:                                break;
2420:                
2421:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_GET_CONFIGURATION_DESCRIPTOR_SHORT:
2422:                                /* Here we are waiting for Get Short Configuration Descriptor to
2423:                                 * complete */
2424:                                if (deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED)
9D000764  8E020018   LW V0, 24(S0)
9D000768  14400005   BNE V0, ZERO, 0x9D000780
9D00076C  00000000   NOP
2425:                                {
2426:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Short Configuration Descriptor Request passed.", busIndex, deviceObj->deviceAddress);
2427:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Getting Full Configuration Descriptor.", busIndex, deviceObj->deviceAddress);
2428:                
2429:                                    /* IRP was successful. Go to the next state */
2430:                                    deviceObj->deviceState =  USB_HOST_DEVICE_STATE_GET_CONFIGURATION_DESCRIPTOR_FULL;
9D000770  2402000D   ADDIU V0, ZERO, 13
9D000774  AE0200F0   SW V0, 240(S0)
9D000778  0B4002A1   J 0x9D000A84
9D00077C  A20000F4   SB ZERO, 244(S0)
2431:                
2432:                                    /* Reset the enumeration failure count */
2433:                                    deviceObj->enumerationFailCount = 0x00;
2434:                                }
2435:                                else
2436:                                {
2437:                                    /* The IRP did not complete successfully. */
2438:                                    if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D000780  044100C1   BGEZ V0, 0x9D000A88
9D000784  8FBF0034   LW RA, 52(SP)
2439:                                    {
2440:                                        /* Close the pipe */
2441:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D000788  8E02006C   LW V0, 108(S0)
9D00078C  8C420020   LW V0, 32(V0)
9D000790  0040F809   JALR V0
9D000794  8E040058   LW A0, 88(S0)
2442:                
2443:                                        /* Release the device is enumerating flag. This will give
2444:                                         * another device the chance to start enumerating. The
2445:                                         * enumeration of this device will be re-attempted after
2446:                                         * the possible enumeration of the other device. */
2447:                                        busObj->deviceIsEnumerating = false;
9D000798  A2200015   SB ZERO, 21(S1)
2448:                
2449:                                        /* Should we retry */
2450:                                        if (deviceObj->enumerationFailCount < USB_HOST_ENUMERATION_RETRY_COUNT )
9D00079C  920200F4   LBU V0, 244(S0)
9D0007A0  2C430003   SLTIU V1, V0, 3
9D0007A4  50600008   BEQL V1, ZERO, 0x9D0007C8
9D0007A8  2402FFFF   ADDIU V0, ZERO, -1
2451:                                        {
2452:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Configuration Descriptor Request Failed. Trying again", busIndex, deviceObj->deviceAddress);
2453:                
2454:                                            /* Yes we should. Increment the enumeration count
2455:                                             * and reset the device */
2456:                                            deviceObj->enumerationFailCount ++ ;
9D0007AC  24420001   ADDIU V0, V0, 1
9D0007B0  A20200F4   SB V0, 244(S0)
2457:                
2458:                                            /* Set device state for enumeration */
2459:                                            deviceObj->deviceState =  USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION;
9D0007B4  AE0000F0   SW ZERO, 240(S0)
2460:                
2461:                                            /* Release the device address */
2462:                                            _USB_HOST_FreeAddress(deviceObj->deviceIdentifier);
9D0007B8  0F402290   JAL _USB_HOST_FreeAddress
9D0007BC  8E04004C   LW A0, 76(S0)
9D0007C0  0B4002A2   J 0x9D000A88
9D0007C4  8FBF0034   LW RA, 52(SP)
2463:                                        }
2464:                                        else
2465:                                        {
2466:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Configuration Request Failed 3 times. Device not supported.", busIndex, deviceObj->deviceAddress);
2467:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0007C8  AE0200F0   SW V0, 240(S0)
2468:                
2469:                                            /* We should send an event to the application and
2470:                                             * then wait for device attach */
2471:                                            if(gUSBHostObj.hostEventHandler != NULL)
9D0007CC  3C02A000   LUI V0, -24576
9D0007D0  8C426738   LW V0, 26424(V0)
9D0007D4  104000AB   BEQ V0, ZERO, 0x9D000A84
9D0007D8  24040001   ADDIU A0, ZERO, 1
2472:                                            {
2473:                                                gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D0007DC  00002821   ADDU A1, ZERO, ZERO
9D0007E0  3C03A000   LUI V1, -24576
9D0007E4  0040F809   JALR V0
9D0007E8  8C66673C   LW A2, 26428(V1)
2474:                                            }
2475:                                        }
2476:                                    }
2477:                                }
2478:                                break;
2479:                
2480:                            case USB_HOST_DEVICE_STATE_GET_CONFIGURATION_DESCRIPTOR_FULL:
2481:                
2482:                                /* Here we will try to allocate memory for the full
2483:                                 * configuration descriptor and then get the full configuration
2484:                                 * descriptor. */  
2485:                
2486:                                configurationDescriptor = (USB_CONFIGURATION_DESCRIPTOR *)(deviceObj->buffer);
2487:                                deviceObj->holdingConfigurationDescriptor = USB_HOST_MALLOC(configurationDescriptor->wTotalLength);
9D0007F4  92020096   LBU V0, 150(S0)
9D0007F8  92120097   LBU S2, 151(S0)
9D0007FC  00129200   SLL S2, S2, 8
9D000800  02429025   OR S2, S2, V0
9D000804  0F400E17   JAL malloc
9D000808  02402021   ADDU A0, S2, ZERO
2488:                
2489:                                if(deviceObj->holdingConfigurationDescriptor == NULL)
9D00080C  14400011   BNE V0, ZERO, 0x9D000854
9D000810  AE020090   SW V0, 144(S0)
2490:                                {
2491:                                    /* The memory allocation failed. We need memory to continue.
2492:                                     * We have to stop here */
2493:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D000814  2402FFFF   ADDIU V0, ZERO, -1
9D000818  AE0200F0   SW V0, 240(S0)
2494:                                    deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D00081C  8E02006C   LW V0, 108(S0)
9D000820  8C420020   LW V0, 32(V0)
9D000824  0040F809   JALR V0
9D000828  8E040058   LW A0, 88(S0)
2495:                                    if(gUSBHostObj.hostEventHandler != NULL)
9D00082C  3C02A000   LUI V0, -24576
9D000830  8C426738   LW V0, 26424(V0)
9D000834  10400005   BEQ V0, ZERO, 0x9D00084C
9D000838  24040001   ADDIU A0, ZERO, 1
2496:                                    {
2497:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d. Insufficient memory for Configuration Descriptor", busIndex);
2498:                                        gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D00083C  00002821   ADDU A1, ZERO, ZERO
9D000840  3C03A000   LUI V1, -24576
9D000844  0040F809   JALR V0
9D000848  8C66673C   LW A2, 26428(V1)
9D00084C  0B4002A1   J 0x9D000A84
9D000850  A2200015   SB ZERO, 21(S1)
2499:                                    }
2500:                
2501:                                    /* Release the device is enumerating flag. Another
2502:                                     * device can start enumerating. */
2503:                                    busObj->deviceIsEnumerating = false;
2504:                                }
2505:                                else
2506:                                {
2507:                                    /* Place a request for the full configuration descriptor */
2508:                                    _USB_HOST_FillSetupPacket( &(deviceObj->setupPacket), ( USB_SETUP_DIRN_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE ),
9D000854  920300F5   LBU V1, 245(S0)
9D000858  24630200   ADDIU V1, V1, 512
9D00085C  3063FFFF   ANDI V1, V1, -1
9D000894  260200D6   ADDIU V0, S0, 214
2509:                                            USB_REQUEST_GET_DESCRIPTOR, ( USB_DESCRIPTOR_CONFIGURATION << 8 ) + deviceObj->configurationCheckCount ,
2510:                                            0 ,configurationDescriptor->wTotalLength) ;
2511:                
2512:                                    /* Create the IRP. Note that the configuration descriptor is
2513:                                     * read into the holding configuration descriptor. The
2514:                                     * holding configuration descriptor memory area is used as a
2515:                                     * temporary holding area only. The memory is freed once the
2516:                                     * configuration descriptor has been checked for errors */
2517:                
2518:                                    deviceObj->controlTransferObj.controlIRP.data = deviceObj->holdingConfigurationDescriptor;
9D000890  AE020010   SW V0, 16(S0)
2519:                                    deviceObj->controlTransferObj.controlIRP.setup = &(deviceObj->setupPacket);
9D000898  AE02000C   SW V0, 12(S0)
2520:                                    deviceObj->controlTransferObj.controlIRP.size = configurationDescriptor->wTotalLength;
9D00089C  AE120014   SW S2, 20(S0)
2521:                                    deviceObj->controlTransferObj.controlIRP.callback = NULL;
9D0008A0  AE000024   SW ZERO, 36(S0)
2522:                                    deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_GET_CONFIGURATION_DESCRIPTOR_FULL;
9D0008A4  2402000E   ADDIU V0, ZERO, 14
9D0008A8  AE0200F0   SW V0, 240(S0)
2523:                
2524:                                    /* Submit the IRP */
2525:                                    if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, 
9D0008AC  8E02006C   LW V0, 108(S0)
9D0008B0  8C42000C   LW V0, 12(V0)
9D0008B4  8E040058   LW A0, 88(S0)
9D0008B8  0040F809   JALR V0
9D0008BC  2605000C   ADDIU A1, S0, 12
9D0008C0  10400071   BEQ V0, ZERO, 0x9D000A88
9D0008C4  8FBF0034   LW RA, 52(SP)
2526:                                                &(deviceObj->controlTransferObj.controlIRP)))
2527:                                    {
2528:                                        /* We need to be able to send the IRP. We move the
2529:                                         * device to an error state. Close the pipe and send an
2530:                                         * event to the application. */
2531:                                        SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Configuration Request IRP failed. Device not supported.", busIndex, deviceObj->deviceAddress);
2532:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D0008C8  2402FFFF   ADDIU V0, ZERO, -1
9D0008CC  AE0200F0   SW V0, 240(S0)
2533:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0008D0  8E02006C   LW V0, 108(S0)
9D0008D4  8C420020   LW V0, 32(V0)
9D0008D8  0040F809   JALR V0
9D0008DC  8E040058   LW A0, 88(S0)
2534:                                        USB_HOST_FREE(deviceObj->holdingConfigurationDescriptor);
9D0008E0  0F4025F6   JAL free
9D0008E4  8E040090   LW A0, 144(S0)
2535:                                        deviceObj->holdingConfigurationDescriptor = NULL;
9D0008E8  AE000090   SW ZERO, 144(S0)
2536:                
2537:                                        if(gUSBHostObj.hostEventHandler != NULL)
9D0008EC  3C02A000   LUI V0, -24576
9D0008F0  8C426738   LW V0, 26424(V0)
9D0008F4  10400005   BEQ V0, ZERO, 0x9D00090C
9D0008F8  24040001   ADDIU A0, ZERO, 1
2538:                                        {
2539:                                            /* Send an event to the application */
2540:                                            gUSBHostObj.hostEventHandler( USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context );
9D0008FC  00002821   ADDU A1, ZERO, ZERO
9D000900  3C03A000   LUI V1, -24576
9D000904  0040F809   JALR V0
9D000908  8C66673C   LW A2, 26428(V1)
2541:                                        }
2542:                
2543:                                        /* Release the device is enumerating flag. Another
2544:                                         * device can start enumerating. */
2545:                                        busObj->deviceIsEnumerating = false;
9D00090C  0B4002A1   J 0x9D000A84
9D000910  A2200015   SB ZERO, 21(S1)
2546:                                    }
2547:                                }
2548:                
2549:                                break;
2550:                
2551:                            case USB_HOST_DEVICE_STATE_WAITING_FOR_GET_CONFIGURATION_DESCRIPTOR_FULL:
2552:                
2553:                                /* In this state we are waiting for the full configuration
2554:                                 * descriptor */
2555:                                if (deviceObj->controlTransferObj.controlIRP.status == USB_HOST_IRP_STATUS_COMPLETED)
9D000914  8E020018   LW V0, 24(S0)
9D000918  1440002F   BNE V0, ZERO, 0x9D0009D8
9D00091C  00000000   NOP
2556:                                {
2557:                                    SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d Get Full Configuration Descriptor Request passed.", busIndex, deviceObj->deviceAddress);
2558:                
2559:                                    /* Reset the failure counter */
2560:                                    deviceObj->enumerationFailCount = 0;
9D000920  A20000F4   SB ZERO, 244(S0)
2561:                
2562:                                    /* The configuration descriptor will be in
2563:                                     * holdingConfigurationDescriptor member of device object.
2564:                                     * Check it for errors */
2565:                
2566:                                    if(_USB_HOST_DeviceConfigurationDescriptorErrorCheck(deviceObj->holdingConfigurationDescriptor) &&
9D000924  8E120090   LW S2, 144(S0)
9D000928  0F4014BB   JAL _USB_HOST_DeviceConfigurationDescriptorErrorCheck
9D00092C  02402021   ADDU A0, S2, ZERO
9D000930  10400017   BEQ V0, ZERO, 0x9D000990
9D000934  2402FFFF   ADDIU V0, ZERO, -1
9D000938  92420004   LBU V0, 4(S2)
9D00093C  2C420006   SLTIU V0, V0, 6
9D000940  10400013   BEQ V0, ZERO, 0x9D000990
9D000944  2402FFFF   ADDIU V0, ZERO, -1
2567:                                            (deviceObj->holdingConfigurationDescriptor->bNumInterfaces <= USB_HOST_DEVICE_INTERFACES_NUMBER))
2568:                                    {
2569:                                        /* This means there are no errors in the configuration
2570:                                         * descriptor. Have we checked all configuration
2571:                                         * descriptors. Update the configurationCheckCount
2572:                                         * variable */
2573:                
2574:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Device %d No errors detected in Configuration Descriptor %d.", 
2575:                                                busIndex, deviceObj->deviceAddress, deviceObj->configurationCheckCount);
2576:                
2577:                                        deviceObj->configurationCheckCount ++;
9D000948  920200F5   LBU V0, 245(S0)
9D00094C  24420001   ADDIU V0, V0, 1
9D000950  304200FF   ANDI V0, V0, 255
9D000954  A20200F5   SB V0, 245(S0)
2578:                
2579:                                        if(deviceObj->configurationCheckCount >= deviceObj->nConfiguration)
9D000958  920300D4   LBU V1, 212(S0)
9D00095C  0043102B   SLTU V0, V0, V1
9D000960  14400006   BNE V0, ZERO, 0x9D00097C
9D000964  2402000B   ADDIU V0, ZERO, 11
2580:                                        {
2581:                                            /* This means we have checked all the configurations
2582:                                             * and there are no errors. We are okay to move the
2583:                                             * device to the ready state */
2584:                
2585:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_READY;
9D000968  2402000F   ADDIU V0, ZERO, 15
9D00096C  AE0200F0   SW V0, 240(S0)
2586:                
2587:                                            /* Release the control transfer object */
2588:                                            deviceObj->controlTransferObj.inUse = false;
9D000970  A2000004   SB ZERO, 4(S0)
9D000974  0B400260   J 0x9D000980
9D000978  A2200015   SB ZERO, 21(S1)
2589:                
2590:                                            /* Release the device is enumerating flag. Another
2591:                                             * device can start enumerating. */
2592:                                            busObj->deviceIsEnumerating = false;
2593:                                        }
2594:                                        else
2595:                                        {
2596:                                            /* Check the next configuration specified by
2597:                                             * configurationCheckCount */
2598:                
2599:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_GET_CONFIGURATION_DESCRIPTOR_SHORT;
9D00097C  AE0200F0   SW V0, 240(S0)
2600:                                        }
2601:                
2602:                                        /* Free up the allocated memory */
2603:                                        USB_HOST_FREE(deviceObj->holdingConfigurationDescriptor);
9D000980  0F4025F6   JAL free
9D000984  8E040090   LW A0, 144(S0)
2604:                                        deviceObj->holdingConfigurationDescriptor = NULL;
9D000988  0B4002A1   J 0x9D000A84
9D00098C  AE000090   SW ZERO, 144(S0)
2605:                                    }
2606:                                    else
2607:                                    {
2608:                                        /* The configuration check failed. Either there was an
2609:                                         * error in the configuration or the configuration has
2610:                                         * too many interfaces. We cannot use this
2611:                                         * device */
2612:                
2613:                                        deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D000990  AE0200F0   SW V0, 240(S0)
2614:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D000994  8E02006C   LW V0, 108(S0)
9D000998  8C420020   LW V0, 32(V0)
9D00099C  0040F809   JALR V0
9D0009A0  8E040058   LW A0, 88(S0)
2615:                                        USB_HOST_FREE(deviceObj->holdingConfigurationDescriptor);
9D0009A4  0F4025F6   JAL free
9D0009A8  8E040090   LW A0, 144(S0)
2616:                                        deviceObj->holdingConfigurationDescriptor = NULL;
9D0009AC  AE000090   SW ZERO, 144(S0)
2617:                                        if(gUSBHostObj.hostEventHandler != NULL)
9D0009B0  3C02A000   LUI V0, -24576
9D0009B4  8C426738   LW V0, 26424(V0)
9D0009B8  10400005   BEQ V0, ZERO, 0x9D0009D0
9D0009BC  24040001   ADDIU A0, ZERO, 1
2618:                                        {
2619:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Errors detected in Configuration Descriptor %d. Device not supported", busIndex, deviceObj->deviceAddress, deviceObj->configurationCheckCount);
2620:                
2621:                                            gUSBHostObj.hostEventHandler(USB_HOST_EVENT_DEVICE_UNSUPPORTED, NULL, gUSBHostObj.context);
9D0009C0  00002821   ADDU A1, ZERO, ZERO
9D0009C4  3C03A000   LUI V1, -24576
9D0009C8  0040F809   JALR V0
9D0009CC  8C66673C   LW A2, 26428(V1)
2622:                                        }
2623:                
2624:                                        /* Release the device is enumerating flag. Another
2625:                                         * device can start enumerating. */
2626:                                        busObj->deviceIsEnumerating = false;
9D0009D0  0B4002A1   J 0x9D000A84
9D0009D4  A2200015   SB ZERO, 21(S1)
2627:                                    }
2628:                                }
2629:                                else
2630:                                {
2631:                                    if ( deviceObj->controlTransferObj.controlIRP.status < USB_HOST_IRP_STATUS_COMPLETED )
9D0009D8  0441002B   BGEZ V0, 0x9D000A88
9D0009DC  8FBF0034   LW RA, 52(SP)
2632:                                    {
2633:                                        deviceObj->hcdInterface->hostPipeClose(deviceObj->controlPipeHandle);
9D0009E0  8E02006C   LW V0, 108(S0)
9D0009E4  8C420020   LW V0, 32(V0)
9D0009E8  0040F809   JALR V0
9D0009EC  8E040058   LW A0, 88(S0)
2634:                
2635:                                        /* Release the device is enumerating flag. This will give
2636:                                         * another device the chance to start enumerating. The
2637:                                         * enumeration of this device will be re-attempted after
2638:                                         * the possible enumeration of the other device. */
2639:                                        busObj->deviceIsEnumerating = false;
9D0009F0  A2200015   SB ZERO, 21(S1)
2640:                                        USB_HOST_FREE(deviceObj->holdingConfigurationDescriptor);
9D0009F4  0F4025F6   JAL free
9D0009F8  8E040090   LW A0, 144(S0)
2641:                                        deviceObj->holdingConfigurationDescriptor = NULL;
9D0009FC  AE000090   SW ZERO, 144(S0)
2642:                
2643:                                        if (deviceObj->enumerationFailCount < USB_HOST_ENUMERATION_RETRY_COUNT )
9D000A00  920200F4   LBU V0, 244(S0)
9D000A04  2C430003   SLTIU V1, V0, 3
9D000A08  50600008   BEQL V1, ZERO, 0x9D000A2C
9D000A0C  2402FFFF   ADDIU V0, ZERO, -1
2644:                                        {
2645:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Get Configuration Descriptor Request failed. Trying again", busIndex, deviceObj->deviceAddress);
2646:                
2647:                                            /* Increment the failure count */
2648:                                            deviceObj->enumerationFailCount ++ ;
9D000A10  24420001   ADDIU V0, V0, 1
9D000A14  A20200F4   SB V0, 244(S0)
2649:                
2650:                                            /* Set device state for enumeration */
2651:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION;
9D000A18  AE0000F0   SW ZERO, 240(S0)
2652:                
2653:                                            /* Release allocated device address */
2654:                                            _USB_HOST_FreeAddress(deviceObj->deviceIdentifier);
9D000A1C  0F402290   JAL _USB_HOST_FreeAddress
9D000A20  8E04004C   LW A0, 76(S0)
9D000A24  0B4002A2   J 0x9D000A88
9D000A28  8FBF0034   LW RA, 52(SP)
2655:                                        }
2656:                                        else
2657:                                        {
2658:                                            /* Move the device to error state */
2659:                                            deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR;
9D000A2C  AE0200F0   SW V0, 240(S0)
2660:                                            SYS_DEBUG_PRINT(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Bus %d Device %d Get Configuration Descriptor Request failed 3 times. Device not supported", busIndex, deviceObj->deviceAddress);
2661:                                            if(gUSBHostObj.hostEventHandler != NULL)
9D000A30  3C02A000   LUI V0, -24576
9D000A34  8C426738   LW V0, 26424(V0)
9D000A38  10400012   BEQ V0, ZERO, 0x9D000A84
9D000A3C  24040001   ADDIU A0, ZERO, 1
2662:                                            {
2663:                                                gUSBHostObj.hostEventHandler(USB_HOST_EVENT_DEVICE_UNSUPPORTED , NULL, gUSBHostObj.context );
9D000A40  00002821   ADDU A1, ZERO, ZERO
9D000A44  3C03A000   LUI V1, -24576
9D000A48  0040F809   JALR V0
9D000A4C  8C66673C   LW A2, 26428(V1)
2664:                                            }
2665:                                        }
2666:                                    }
2667:                                }
2668:                                break;
2669:                                
2670:                            case USB_HOST_DEVICE_STATE_ERROR:
2671:                                
2672:                                /* The device has entered an error state.  The control pipe
2673:                                 * should have been closed already.  We will only assign an
2674:                                 * invalid value to the pipe handle.  Note that we are doing
2675:                                 * this in an atomically, just to be safe.  The device then
2676:                                 * enters the Error holding state. In this state, the device
2677:                                 * must be detached. */
2678:                                
2679:                                interruptIsEnabled = SYS_INT_Disable();
9D000A58  0F40265D   JAL SYS_INT_Disable
9D000A5C  00000000   NOP
2680:                                
2681:                                deviceObj->controlPipeHandle = DRV_USB_HOST_PIPE_HANDLE_INVALID;
9D000A60  2403FFFF   ADDIU V1, ZERO, -1
2682:                                
2683:                                if(interruptIsEnabled)
9D000A64  10400005   BEQ V0, ZERO, 0x9D000A7C
9D000A68  AE030058   SW V1, 88(S0)
2684:                                {
2685:                                    SYS_INT_Enable();
9D000A6C  40026000   MFC0 V0, Status
9D000A70  34420001   ORI V0, V0, 1
9D000A74  40826000   MTC0 V0, Status
9D000A78  000000C0   EHB
2686:                                }
2687:                                
2688:                                deviceObj->deviceState = USB_HOST_DEVICE_STATE_ERROR_HOLDING;
9D000A7C  2402FFFE   ADDIU V0, ZERO, -2
9D000A80  AE0200F0   SW V0, 240(S0)
2689:                                break;
2690:                                
2691:                            case USB_HOST_DEVICE_STATE_ERROR_HOLDING:
2692:                                
2693:                                break;
2694:                
2695:                            case USB_HOST_DEVICE_STATE_READY:
2696:                
2697:                                /* This means the device state is ready for further processing.
2698:                                 * The host layer will now try to match the device to the
2699:                                 * client driver. The client driver can start interacting with
2700:                                 * the device */
2701:                                break;
2702:                            default:
2703:                                break;
2704:                        }
2705:                    }
2706:                }
9D00033C  0B4002A2   J 0x9D000A88
9D000340  8FBF0034   LW RA, 52(SP)
9D00050C  0B4002A2   J 0x9D000A88
9D000510  8FBF0034   LW RA, 52(SP)
9D0006A0  0B4002A2   J 0x9D000A88
9D0006A4  8FBF0034   LW RA, 52(SP)
9D0007EC  0B4002A2   J 0x9D000A88
9D0007F0  8FBF0034   LW RA, 52(SP)
9D000A50  0B4002A2   J 0x9D000A88
9D000A54  8FBF0034   LW RA, 52(SP)
9D000A84  8FBF0034   LW RA, 52(SP)
2707:                
2708:                // *****************************************************************************
2709:                /* Function:
2710:                    void _USB_HOST_UpdateDeviceTask(int busIndex)
2711:                
2712:                  Summary:
2713:                    This function maintains the state of each device on the bus.
2714:                
2715:                  Description:
2716:                    This function maintains the state of each device on the bus.
2717:                
2718:                  Remarks:
2719:                    This is a local function and should not be called directly by the 
2720:                    application.
2721:                */
2722:                
2723:                void _USB_HOST_UpdateDeviceTask(int busIndex)
2724:                {
9D0084D4  27BDFFE0   ADDIU SP, SP, -32
9D0084D8  AFBF001C   SW RA, 28(SP)
9D0084DC  AFB10018   SW S1, 24(SP)
9D0084E0  AFB00014   SW S0, 20(SP)
2725:                    USB_HOST_BUS_OBJ * busObj;
2726:                    USB_HOST_DEVICE_OBJ * deviceObj = NULL ;
2727:                
2728:                    busObj = &(gUSBHostBusList[busIndex]);
9D0084E4  00041900   SLL V1, A0, 4
9D0084E8  00041180   SLL V0, A0, 6
9D0084EC  00621821   ADDU V1, V1, V0
2729:                
2730:                    /* The first device on the bus is the root hub. We don't maintain the state
2731:                     * of the root hub. So get the next device on the bus. */
2732:                    deviceObj = busObj->busDeviceList;
9D0084F0  3C02A000   LUI V0, -24576
9D0084F4  244266E8   ADDIU V0, V0, 26344
9D0084F8  00431021   ADDU V0, V0, V1
9D0084FC  8C420010   LW V0, 16(V0)
2733:                    deviceObj = deviceObj->nextDeviceObj;
9D008500  8C5001A8   LW S0, 424(V0)
2734:                
2735:                    while(deviceObj != NULL)
9D008504  12000010   BEQ S0, ZERO, 0x9D008548
9D008508  00808821   ADDU S1, A0, ZERO
9D008540  1600FFF3   BNE S0, ZERO, 0x9D008510
9D008544  02002021   ADDU A0, S0, ZERO
2736:                    {
2737:                        /* Check if the device is addressed, get the device descriptor, check
2738:                         * all the configuration descriptors and move the device to the ready
2739:                         * state */
2740:                        _USB_HOST_MakeDeviceReady(deviceObj, busIndex);
9D00850C  02002021   ADDU A0, S0, ZERO
9D008510  0F400000   JAL _USB_HOST_MakeDeviceReady
9D008514  02202821   ADDU A1, S1, ZERO
2741:                
2742:                        /* If the device is not owned then find a driver that can own it */
2743:                        _USB_HOST_UpdateDeviceOwnership (deviceObj, busIndex);
9D008518  02002021   ADDU A0, S0, ZERO
9D00851C  0F400D73   JAL _USB_HOST_UpdateDeviceOwnership
9D008520  02202821   ADDU A1, S1, ZERO
2744:                        
2745:                        /* If the configuration needs to be set, then set the configuration */
2746:                        _USB_HOST_UpdateConfigurationState(deviceObj, busIndex);
9D008524  02002021   ADDU A0, S0, ZERO
9D008528  0F40042E   JAL _USB_HOST_UpdateConfigurationState
9D00852C  02202821   ADDU A1, S1, ZERO
2747:                        
2748:                        /* If the device is configured, update the state of the interfaces */
2749:                        _USB_HOST_UpdateInterfaceStatus(deviceObj, busIndex);
9D008530  02002021   ADDU A0, S0, ZERO
9D008534  0F400A98   JAL _USB_HOST_UpdateInterfaceStatus
9D008538  02202821   ADDU A1, S1, ZERO
2750:                
2751:                        //_USB_HOST_UpdateClientDriverState ( deviceObj );
2752:                
2753:                        deviceObj =   deviceObj->nextDeviceObj ;
9D00853C  8E1001A8   LW S0, 424(S0)
2754:                    }
2755:                }
9D008548  8FBF001C   LW RA, 28(SP)
2756:                
2757:                // *****************************************************************************
2758:                /* Function:
2759:                    void _USB_HOST_FreeAddress ( USB_HOST_DEVICE_OBJ_HANDLE deviceIdentifier)
2760:                
2761:                  Summary:
2762:                    Frees up the address bit assigned to this device hence making the address 
2763:                    available.
2764:                
2765:                  Description:
2766:                    This function frees up the address bit assigned to this device hence making 
2767:                    the address available.
2768:                
2769:                  Remarks:
2770:                    This is a local function and should not be called directly by the 
2771:                    application.
2772:                */
2773:                
2774:                void _USB_HOST_FreeAddress ( USB_HOST_DEVICE_OBJ_HANDLE deviceIdentifier  )
2775:                {
2776:                    uint8_t busNumber;
2777:                    int deviceIndex;
2778:                    uint8_t deviceAddress;
2779:                    USB_HOST_BUS_OBJ *busObj;
2780:                    USB_HOST_DEVICE_OBJ *deviceObj;
2781:                
2782:                    /* Get the device array index and the bus number from the device object
2783:                     * handle */
2784:                    deviceIndex = USB_HOST_DEVICE_INDEX (deviceIdentifier);
9D008A40  308300FF   ANDI V1, A0, 255
2785:                    busNumber = USB_HOST_BUS_NUMBER (deviceIdentifier);
2786:                    
2787:                    busObj =  &( gUSBHostBusList[busNumber]);
9D008A70  00041900   SLL V1, A0, 4
9D008A74  00042180   SLL A0, A0, 6
9D008A78  00642021   ADDU A0, V1, A0
9D008A7C  3C03A000   LUI V1, -24576
9D008A80  246366E8   ADDIU V1, V1, 26344
9D008A84  00641821   ADDU V1, V1, A0
2788:                    deviceObj = &( gUSBHostDeviceList [ deviceIndex ]);
9D008A44  00032900   SLL A1, V1, 4
9D008A48  00031180   SLL V0, V1, 6
9D008A4C  00451023   SUBU V0, V0, A1
9D008A50  000218C0   SLL V1, V0, 3
9D008A54  00431021   ADDU V0, V0, V1
2789:                    deviceAddress = deviceObj->deviceAddress;
9D008A58  3C03A000   LUI V1, -24576
9D008A5C  24636388   ADDIU V1, V1, 25480
9D008A60  00621021   ADDU V0, V1, V0
9D008A64  90420060   LBU V0, 96(V0)
2790:                    
2791:                    if(deviceAddress == 0)
9D008A68  10400010   BEQ V0, ZERO, 0x9D008AAC
9D008A6C  7C843A00   EXT A0, A0, 8, 8
2792:                    {
2793:                        /* Don't do anything */
2794:                    }
2795:                    else
2796:                    {
2797:                        /* The address is no longer being used. Clear up the bit assigned to this
2798:                         * device address. Address now becomes available. */
2799:                        busObj->addressBits[ deviceAddress/ 8 ] &= ~(1 << ( deviceAddress % 8));
9D008A88  000228C2   SRL A1, V0, 3
2800:                    }
2801:                }
2802:                
2803:                // *****************************************************************************
2804:                /* Function:
2805:                    USB_HOST_RESULT _USB_HOST_IRPResultToHostResult( USB_HOST_IRP * irp )
2806:                 
2807:                  Summary:
2808:                    This function maps the IRP completion result to a USB_HOST_RESULT type.
2809:                
2810:                  Description:
2811:                    This function maps the IRP completion result to a USB_HOST_RESULT type.
2812:                
2813:                  Remarks
2814:                    This is a local function and should not be called directly by the
2815:                    application.
2816:                */
2817:                
2818:                USB_HOST_RESULT _USB_HOST_IRPResultToHostResult(USB_HOST_IRP * irp)
2819:                {
2820:                    USB_HOST_RESULT result;
2821:                    switch(irp->status)
9D0092F8  8C83000C   LW V1, 12(A0)
9D0092FC  2402FFFF   ADDIU V0, ZERO, -1
9D009300  5062000E   BEQL V1, V0, 0x9D00933C
9D009304  2402FF9F   ADDIU V0, ZERO, -97
9D009308  04630006   BGEZL V1, 0x9D009324
9D00930C  28630002   SLTI V1, V1, 2
9D009310  2404FFFB   ADDIU A0, ZERO, -5
9D009314  10640009   BEQ V1, A0, 0x9D00933C
9D009318  2402FF9E   ADDIU V0, ZERO, -98
9D009324  10600003   BEQ V1, ZERO, 0x9D009334
9D009328  00000000   NOP
2822:                    {
2823:                        case USB_HOST_IRP_STATUS_ABORTED:
2824:                            /* IRP was terminated by the application */
2825:                            result = USB_HOST_RESULT_TRANSFER_ABORTED;
2826:                            break; 
2827:                
2828:                        case USB_HOST_IRP_STATUS_ERROR_STALL:
2829:                            /* IRP was terminated because of a STALL */
2830:                            result = USB_HOST_RESULT_REQUEST_STALLED;
2831:                            break;
2832:                
2833:                        case USB_HOST_IRP_STATUS_COMPLETED:
2834:                        case USB_HOST_IRP_STATUS_COMPLETED_SHORT:
2835:                            /* IRP has been completed */
2836:                            result = USB_HOST_RESULT_SUCCESS;
2837:                            break;
9D00932C  03E00008   JR RA
9D009330  24020001   ADDIU V0, ZERO, 1
2838:                
2839:                        case USB_HOST_IRP_STATUS_ERROR_UNKNOWN: 
2840:                        case USB_HOST_IRP_STATUS_ERROR_BUS: 
2841:                        case USB_HOST_IRP_STATUS_ERROR_DATA: 
2842:                        case USB_HOST_IRP_STATUS_ERROR_NAK_TIMEOUT:
2843:                        default:
2844:                            result = USB_HOST_RESULT_FAILURE;
9D00931C  03E00008   JR RA
9D009320  2402FFA8   ADDIU V0, ZERO, -88
2845:                            break;
9D009334  03E00008   JR RA
9D009338  2402FFA8   ADDIU V0, ZERO, -88
2846:                    }
2847:                    return (result);
2848:                }
9D00933C  03E00008   JR RA
2849:                
2850:                // *****************************************************************************
2851:                /* Function:
2852:                    void _USB_HOST_DataTransferIRPCallback( USB_HOST_IRP * irp )
2853:                 
2854:                  Summary:
2855:                    This is the callback for IRPs submitted through the
2856:                    USB_HOST_DeviceTransfer() function.
2857:                
2858:                  Description:
2859:                    This is the callback function for IRPs submitted through the
2860:                    USB_HOST_DeviceTransfer() function. The function will get the
2861:                    USB_HOST_TRANSFER_OBJ object associated with this IRP, find out the
2862:                    interface on which the transfer took place and then call the
2863:                    interfaceEventHandler function of the client driver that owns this
2864:                    interface.
2865:                
2866:                  Remarks
2867:                    This is a local function and should not be called directly by the
2868:                    application.
2869:                */
2870:                
2871:                void _USB_HOST_DataTransferIRPCallback( USB_HOST_IRP * irp )
2872:                {
9D00844C  27BDFFD0   ADDIU SP, SP, -48
9D008450  AFBF002C   SW RA, 44(SP)
9D008454  AFB20028   SW S2, 40(SP)
9D008458  AFB10024   SW S1, 36(SP)
9D00845C  AFB00020   SW S0, 32(SP)
2873:                    USB_HOST_TRANSFER_OBJ * transferObj;
2874:                    USB_HOST_INTERFACE_DESC_INFO * interfaceInfo;
2875:                    USB_HOST_CLIENT_DRIVER * clientDriver;
2876:                    
2877:                    USB_HOST_DEVICE_INTERFACE_EVENT_TRANSFER_COMPLETE_DATA eventData;
2878:                
2879:                    /* The user data field of the IRP contains the address of the transfer
2880:                     * object the own this IRP. */
2881:                    transferObj = (USB_HOST_TRANSFER_OBJ *)(irp->userData);
9D008460  8C900014   LW S0, 20(A0)
2882:                
2883:                    /* The transfer object contains the reference to the interface object */
2884:                    interfaceInfo = transferObj->interfaceInfoObj;
9D008464  8E110040   LW S1, 64(S0)
2885:                
2886:                    /* Get a pointer to the client driver than owns this interface */
2887:                    clientDriver = interfaceInfo->interfaceDriver;
9D008468  8E320008   LW S2, 8(S1)
2888:                
2889:                    /* Set up the event data object */
2890:                    eventData.length = irp->size;
9D00846C  8C820008   LW V0, 8(A0)
9D008470  AFA20018   SW V0, 24(SP)
2891:                    eventData.transferHandle = (USB_HOST_TRANSFER_HANDLE)(transferObj);
2892:                
2893:                    /* We need to map IRP completion status to event data completion status */
2894:                    eventData.result = _USB_HOST_IRPResultToHostResult(irp);
9D008474  0F4024BE   JAL _USB_HOST_IRPResultToHostResult
9D008478  AFB00010   SW S0, 16(SP)
9D00847C  AFA20014   SW V0, 20(SP)
2895:                    
2896:                    /* If the the USB_HOST_DeviceTransfer function will be called, it should 
2897:                     * know that the host layer is in an interrupt context */
2898:                    gUSBHostObj.isInInterruptContext = true;
9D008480  24030001   ADDIU V1, ZERO, 1
9D008484  3C02A000   LUI V0, -24576
9D008488  24426738   ADDIU V0, V0, 26424
9D00848C  A0430017   SB V1, 23(V0)
2899:                    
2900:                    /* We need to make sure that the interface is owned because the device could
2901:                     * have been detached between the time that this transfer was submitted
2902:                     * and the callback arrived */
2903:                    
2904:                    if(clientDriver != NULL)
9D008490  12400006   BEQ S2, ZERO, 0x9D0084AC
9D008494  00002821   ADDU A1, ZERO, ZERO
2905:                    {
2906:                        clientDriver->interfaceEventHandler(interfaceInfo->interfaceHandle, 
9D008498  8E420024   LW V0, 36(S2)
9D00849C  8E24000C   LW A0, 12(S1)
9D0084A0  27A60010   ADDIU A2, SP, 16
9D0084A4  0040F809   JALR V0
9D0084A8  8E070004   LW A3, 4(S0)
2907:                                USB_HOST_DEVICE_INTERFACE_EVENT_TRANSFER_COMPLETE, &eventData, transferObj->context);
2908:                    }
2909:                    
2910:                    gUSBHostObj.isInInterruptContext = false;
9D0084AC  3C02A000   LUI V0, -24576
9D0084B0  24426738   ADDIU V0, V0, 26424
9D0084B4  A0400017   SB ZERO, 23(V0)
2911:                
2912:                    /* Deallocate the transfer object */
2913:                    transferObj->inUse = false;
9D0084B8  A2000000   SB ZERO, 0(S0)
2914:                }
9D0084BC  8FBF002C   LW RA, 44(SP)
2915:                
2916:                // *****************************************************************************
2917:                /* Function:
2918:                    void _USB_HOST_DeviceControlTransferCallback( USB_HOST_IRP * irp )
2919:                 
2920:                  Summary:
2921:                    This is the callback for control IRPs submitted through the
2922:                    USB_HOST_DeviceControlTransfer() function.
2923:                
2924:                  Description:
2925:                    This is the callback function for control IRPs submitted through the
2926:                    USB_HOST_DeviceControlTransfer() function. The function will get the
2927:                    USB_HOST_CONTROL_TRANSFER_OBJ object associated with this IRP, find out the
2928:                    type of control request call the callback function associated with the
2929:                    control transfer.
2930:                
2931:                  Remarks
2932:                    This is a local function and should not be called directly by the
2933:                    application.
2934:                */
2935:                
2936:                void  _USB_HOST_DeviceControlTransferCallback( USB_HOST_IRP * irp )
2937:                {
2938:                    int deviceIndex;
2939:                    int interfaceIndex;
2940:                    USB_HOST_DEVICE_OBJ * deviceObj;
2941:                    USB_HOST_CONTROL_TRANSFER_OBJ * controlTransferObj;
2942:                    USB_HOST_INTERFACE_DESC_INFO * interfaceInfo;
2943:                    USB_HOST_RESULT result;
2944:                    USB_HOST_DEVICE_INTERFACE_EVENT_PIPE_HALT_CLEAR_COMPLETE_DATA pipeHaltEventData;
2945:                    USB_HOST_DEVICE_INTERFACE_EVENT_SET_INTERFACE_COMPLETE_DATA interfaceCompleteData;
2946:                    USB_HOST_DEVICE_EVENT_CONFIGURATION_DESCRIPTOR_GET_COMPLETE_DATA configurationGetCompleteData;
2947:                
2948:                    /* The userData field of the IRP will be a bit map that contains the pnp
2949:                     * identifier, the control transfer object index and the index of the device
2950:                     * object that submitted this control transfer. */
2951:                
2952:                    deviceIndex = USB_HOST_DEVICE_INDEX(irp->userData);
2953:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
2954:                
2955:                    controlTransferObj = &deviceObj->controlTransferObj;
2956:                
2957:                    /* Map the IRP result to USB_HOST_RESULT */
2958:                    result = _USB_HOST_IRPResultToHostResult(irp); 
2959:                
2960:                    switch ( controlTransferObj->requestType )
2961:                    {
2962:                        case USB_HOST_CONTROL_REQUEST_TYPE_CLIENT_DRIVER_SPECIFIC:
2963:                
2964:                            /* This was a client driver specific control request. Call the
2965:                             * register callback */
2966:                
2967:                            if(controlTransferObj->callback != NULL)
2968:                            {
2969:                                ((USB_HOST_DEVICE_CONTROL_REQUEST_COMPLETE_CALLBACK)(controlTransferObj->callback))(deviceObj->deviceIdentifier, 
2970:                                (USB_HOST_REQUEST_HANDLE)(controlTransferObj), result, irp->size, controlTransferObj->context );
2971:                            }
2972:                            break;
2973:                
2974:                        case USB_HOST_CONTROL_REQUEST_TYPE_PIPE_HALT_CLEAR:
2975:                
2976:                            /* This is standard control transfer request. Send the event to
2977:                             * the client driver that requested this. The IRP user data in this
2978:                             * case will also contain the interface index. */
2979:                
2980:                            interfaceIndex = USB_HOST_INTERFACE_INDEX(irp->userData);
2981:                            interfaceInfo = &deviceObj->configDescriptorInfo.interfaceInfo[interfaceIndex];
2982:                
2983:                            /* Prepare the event data */
2984:                            pipeHaltEventData.result = result;
2985:                            pipeHaltEventData.requestHandle = (USB_HOST_REQUEST_HANDLE)(controlTransferObj);
2986:                
2987:                            /* Send the event to the interface event handler */
2988:                            if((interfaceInfo->interfaceDriver != NULL) && 
2989:                                    (interfaceInfo->interfaceDriver->interfaceEventHandler != NULL))
2990:                            {
2991:                                interfaceInfo->interfaceDriver->interfaceEventHandler(interfaceInfo->interfaceHandle,
2992:                                        USB_HOST_DEVICE_INTERFACE_EVENT_PIPE_HALT_CLEAR_COMPLETE, &pipeHaltEventData, controlTransferObj->context);
2993:                            }
2994:                
2995:                            break;
2996:                
2997:                        case USB_HOST_CONTROL_REQUEST_TYPE_INTERFACE_SET:
2998:                
2999:                            /* This is standard control transfer request. Send the event to
3000:                             * the client driver that requested this. The IRP user data in this
3001:                             * case will also contain the interface index. */
3002:                
3003:                            interfaceIndex = USB_HOST_INTERFACE_INDEX(irp->userData);
3004:                            interfaceInfo = &deviceObj->configDescriptorInfo.interfaceInfo[interfaceIndex];
3005:                
3006:                            /* Prepare the event data */
3007:                            interfaceCompleteData.result = result;
3008:                            interfaceCompleteData.requestHandle = (USB_HOST_REQUEST_HANDLE)(controlTransferObj);
3009:                
3010:                            if(result == USB_HOST_RESULT_SUCCESS)
3011:                            {
3012:                                /* This means the alternate setting request was successful. We
3013:                                 * should updated the current alternate setting on this
3014:                                 * interface */
3015:                                interfaceInfo->currentAlternateSetting = deviceObj->requestedAlternateSetting;
3016:                            }
3017:                
3018:                            /* Send the event to the interface event handler */
3019:                            if((interfaceInfo->interfaceDriver != NULL) && 
3020:                                    (interfaceInfo->interfaceDriver->interfaceEventHandler != NULL))
3021:                            {
3022:                                interfaceInfo->interfaceDriver->interfaceEventHandler(interfaceInfo->interfaceHandle,
3023:                                        USB_HOST_DEVICE_INTERFACE_EVENT_SET_INTERFACE_COMPLETE, &interfaceCompleteData, controlTransferObj->context);
3024:                            }
3025:                
3026:                            break;
3027:                
3028:                        case USB_HOST_CONTROL_REQUEST_TYPE_STRING_DESCRIPTOR:
3029:                
3030:                            /* This request originated from the application. The context and the
3031:                             * callback field of the control transfer object contain callback
3032:                             * and context specified by the application. */
3033:                
3034:                            if(controlTransferObj->callback != NULL)
3035:                            {
3036:                                /* This means we have a callback that we can call */
3037:                                if(result == USB_HOST_RESULT_SUCCESS)
3038:                                {
3039:                                    ((USB_HOST_STRING_REQUEST_COMPLETE_CALLBACK)(controlTransferObj->callback))
3040:                                        ((USB_HOST_REQUEST_HANDLE)controlTransferObj, irp->size, controlTransferObj->context);
3041:                
3042:                                }
3043:                                else
3044:                                {
3045:                                    /* The string descriptor request failed. Invoke the callback
3046:                                     * with string size as 0 */
3047:                                    ((USB_HOST_STRING_REQUEST_COMPLETE_CALLBACK)(controlTransferObj->callback))
3048:                                        ((USB_HOST_REQUEST_HANDLE)controlTransferObj, irp->size, controlTransferObj->context);
3049:                                }
3050:                            }
3051:                
3052:                            break;
3053:                
3054:                        case USB_HOST_CONTROL_REQUEST_TYPE_CONFIGURATION_DESCRIPTOR_GET:
3055:                
3056:                            /* This request originated from the client driver. An event should
3057:                             * be sent to the device level event handler. Populate the event
3058:                             * data. */
3059:                
3060:                            configurationGetCompleteData.requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
3061:                            configurationGetCompleteData.result = result; 
3062:                            
3063:                            if(deviceObj->deviceClientDriver != NULL)
3064:                            {
3065:                                deviceObj->deviceClientDriver->deviceEventHandler(deviceObj->deviceClientHandle,
3066:                                        USB_HOST_DEVICE_EVENT_CONFIGURATION_DESCRIPTOR_GET_COMPLETE, &configurationGetCompleteData, 
3067:                                        deviceObj->controlTransferObj.context);
3068:                            }
3069:                
3070:                
3071:                        default:
3072:                            break;
3073:                    }
3074:                
3075:                    /* Release the control transfer object back */
3076:                    controlTransferObj->inUse = false;
3077:                }
3078:                
3079:                // *****************************************************************************
3080:                // *****************************************************************************
3081:                // Section: USB HOST Layer System Interface Implementations
3082:                // *****************************************************************************
3083:                // *****************************************************************************
3084:                
3085:                // *****************************************************************************
3086:                /* Function:
3087:                    SYS_MODULE_OBJ USB_HOST_Initialize
3088:                    (
3089:                       const SYS_MODULE_INIT * const init
3090:                   )
3091:                
3092:                  Summary:
3093:                    Initializes the USB Host layer instance specified by the index.
3094:                
3095:                  Description:
3096:                    This routine initializes the USB Host Layer. This function must be called
3097:                    before any other Host layer function can be called. The initialization data
3098:                    is specified by the init parameter.  This function is typically called in
3099:                    the SYS_Initialize() function. The initialization completion may require the
3100:                    USB_HOST_Tasks() routine to execute.  The initialization function does not
3101:                    start the operation of the Host on the USB.  This must be done explicitly
3102:                    via the USB_HOST_BusEnable() function.
3103:                
3104:                  Remarks:
3105:                    Refer to usb_host.h for usage information.
3106:                */
3107:                
3108:                SYS_MODULE_OBJ  USB_HOST_Initialize
3109:                (
3110:                    const SYS_MODULE_INIT * initData
3111:                )
3112:                {
9D0066D4  27BDFFD8   ADDIU SP, SP, -40
9D0066D8  AFBF0024   SW RA, 36(SP)
9D0066DC  AFB30020   SW S3, 32(SP)
9D0066E0  AFB2001C   SW S2, 28(SP)
9D0066E4  AFB10018   SW S1, 24(SP)
9D0066E8  AFB00014   SW S0, 20(SP)
3113:                    int hcCount;
3114:                    SYS_MODULE_OBJ result;
3115:                    uint32_t tplEntryCount;
3116:                    USB_HOST_BUS_OBJ *busObj;
3117:                    USB_HOST_TPL_ENTRY *tplEntry;
3118:                    USB_HOST_INIT *hostInit = NULL;
3119:                    USB_HOST_OBJ *hostObj = &(gUSBHostObj);
3120:                
3121:                    /* Typecast the initialization data parameter and check if it is NULL. The
3122:                     * host layer cannot be initialized if the initialization data structure is
3123:                     * NULL. */
3124:                
3125:                    hostInit = ( USB_HOST_INIT * ) initData ;
3126:                    result =SYS_MODULE_OBJ_INVALID;
9D006734  03E00008   JR RA
9D006738  2402FFFF   ADDIU V0, ZERO, -1
3127:                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Host Layer: Entering USB_HOST_Initialize().");
3128:                
3129:                    if(NULL  == hostInit )
9D006644  1080003B   BEQ A0, ZERO, 0x9D006734
9D006648  3C03A000   LUI V1, -24576
3130:                    {
3131:                        SYS_DEBUG_MESSAGE( SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Initialization data is NULL is USB_HOST_Initialize().");
3132:                    }
3133:                    else
3134:                    {
3135:                        if(OSAL_RESULT_TRUE != OSAL_MUTEX_Create(&(gUSBHostObj.mutexControlTransferObj)))
3136:                        {
3137:                            /* Could not create the mutual exclusion */
3138:                            SYS_DEBUG_MESSAGE(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Could not create Control Transfer Mutex in USB_HOST_Initialize().");
3139:                        }
3140:                        else
3141:                        {
3142:                            if(OSAL_RESULT_TRUE != OSAL_MUTEX_Create(&(gUSBHostObj.mutexPipeObj)))
3143:                            {
3144:                                /* Could not create the mutual exclusion*/
3145:                                SYS_DEBUG_MESSAGE(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Could not create Pipe Object Mutex in USB_HOST_Initialize().");
3146:                            }
3147:                            else
3148:                            {
3149:                                if(OSAL_RESULT_TRUE != OSAL_MUTEX_Create(&(gUSBHostObj.mutexTransferObj)))
3150:                                {
3151:                                    /* Could not create the mutual exclusion */
3152:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Could not create Transfer Object Mutex in USB_HOST_Initialize().");
3153:                                }
3154:                                else
3155:                                {
3156:                                    /* Initialize the bus objects */
3157:                                    for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
3158:                                    {
3159:                                        busObj  = &(gUSBHostBusList[hcCount]);
3160:                
3161:                                        /* Update the Host Controller Driver. This index will be used
3162:                                         * when the Host Layer opens the driver (at root hub enumeration
3163:                                         * time). */
3164:                                        busObj->hcdIndex = hostInit->hostControllerDrivers[hcCount].drvIndex;
9D006660  8C820008   LW V0, 8(A0)
9D006664  94450000   LHU A1, 0(V0)
9D006668  3C06A000   LUI A2, -24576
9D00666C  24C266E8   ADDIU V0, A2, 26344
9D006670  A4450004   SH A1, 4(V0)
3165:                
3166:                                        /* By default bus state is disabled */
3167:                                        busObj->state = USB_HOST_BUS_STATE_DISABLED ;
9D006674  AC400008   SW ZERO, 8(V0)
3168:                
3169:                                        /* Pointer to the HCD interface */
3170:                                        busObj->hcdInterface = ( DRV_USB_HOST_INTERFACE * ) ( hostInit->hostControllerDrivers [hcCount]).hcdInterface ;
9D006678  8C850008   LW A1, 8(A0)
9D00667C  8CA50004   LW A1, 4(A1)
9D006680  AC45000C   SW A1, 12(V0)
3171:                
3172:                                        /* Attached Device list will be NULL*/
3173:                                        busObj->busDeviceList = NULL ;
9D006684  AC400010   SW ZERO, 16(V0)
3174:                
3175:                                        /* Initialize HCD handle to invalid */
3176:                                        busObj->hcdHandle   = DRV_HANDLE_INVALID ;
9D006688  2405FFFF   ADDIU A1, ZERO, -1
9D00668C  ACC566E8   SW A1, 26344(A2)
3177:                
3178:                                        /* This flag is set when any device is enumerating on the bus. 
3179:                                         * Initialize as false. */
3180:                                        busObj->deviceIsEnumerating = false ;
9D006690  A0400015   SB ZERO, 21(V0)
3181:                
3182:                                        /* Initialize handle of the system timer that this bus object will use */
3183:                                        busObj->busOperationsTimerHandle = SYS_TMR_HANDLE_INVALID;
9D006694  AC450044   SW A1, 68(V0)
3184:                
3185:                                        /* Bus bandwidth constants */
3186:                                        busObj->totalBandwidth = 1000;
9D006698  240503E8   ADDIU A1, ZERO, 1000
9D00669C  AC450018   SW A1, 24(V0)
3187:                                        busObj->availableBandwidth = 1000;
9D0066A0  AC45001C   SW A1, 28(V0)
3188:                
3189:                                        /* Device Plug and Play identifier */
3190:                                        busObj->pnpIdentifier = 0x00;
9D0066A4  A4400048   SH ZERO, 72(V0)
3191:                
3192:                                        /* Device address " 0 " for newly connected device 
3193:                                           Device address is " 1 " for reserved for RootHUB 
3194:                                           Mark there as reserved  */
3195:                                        busObj->addressBits[0] = ( uint8_t ) 0x03;
9D0066A8  24050003   ADDIU A1, ZERO, 3
9D0066AC  A0450014   SB A1, 20(V0)
3196:                                    }
3197:                
3198:                                    /* The host layer is now ready */
3199:                                    hostObj->status = SYS_STATUS_READY;
9D0066B0  24020002   ADDIU V0, ZERO, 2
9D0066B4  AC620008   SW V0, 8(V1)
3200:                
3201:                                    /* Get the pointer to the Host TPL and the
3202:                                     * number of entries in the TPL table. */
3203:                
3204:                                    hostObj->tpl = hostInit->tplList ;
9D0066B8  8C820004   LW V0, 4(A0)
9D0066BC  AC620010   SW V0, 16(V1)
3205:                                    hostObj->nTPLEntries = hostInit->nTPLEntries;
9D0066C0  8C820000   LW V0, 0(A0)
9D0066C4  A062000C   SB V0, 12(V1)
3206:                
3207:                                    /* Initialize all drivers in TPL List */
3208:                                    for ( tplEntryCount = 0 ; tplEntryCount < hostObj->nTPLEntries ; tplEntryCount++ )
9D0066C8  304200FF   ANDI V0, V0, 255
9D0066CC  10400022   BEQ V0, ZERO, 0x9D006758
9D0066D0  3C02A000   LUI V0, -24576
9D0066EC  00008821   ADDU S1, ZERO, ZERO
9D0066F0  00008021   ADDU S0, ZERO, ZERO
9D006714  26100001   ADDIU S0, S0, 1
9D006718  9242000C   LBU V0, 12(S2)
9D00671C  0202102B   SLTU V0, S0, V0
9D006720  1440FFF5   BNE V0, ZERO, 0x9D0066F8
9D006724  26310014   ADDIU S1, S1, 20
3209:                                    {
3210:                                        tplEntry = &(hostObj->tpl[tplEntryCount]);
9D0066F4  3C13A000   LUI S3, -24576
9D0066F8  26726738   ADDIU S2, S3, 26424
9D0066FC  8E420010   LW V0, 16(S2)
9D006700  00511021   ADDU V0, V0, S1
3211:                                        (( USB_HOST_CLIENT_DRIVER *)tplEntry->hostClientDriver)->initialize( tplEntry->hostClientDriverInitData );
9D006704  8C430010   LW V1, 16(V0)
9D006708  8C630000   LW V1, 0(V1)
9D00670C  0060F809   JALR V1
9D006710  8C44000C   LW A0, 12(V0)
3212:                                    }
3213:                
3214:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Host Layer: Exiting USB_HOST_Initialize() successfully.");
3215:                                    result = ((SYS_MODULE_OBJ)hostObj);
9D006728  3C02A000   LUI V0, -24576
9D00672C  0B4019CF   J 0x9D00673C
9D006730  24426738   ADDIU V0, V0, 26424
3216:                                }
3217:                            }
3218:                        }
3219:                    }
3220:                
3221:                    return(result);
3222:                }
9D00673C  8FBF0024   LW RA, 36(SP)
3223:                
3224:                // *****************************************************************************
3225:                /* Function:
3226:                    SYS_STATUS USB_HOST_Status( SYS_MODULE_OBJ object )
3227:                
3228:                  Summary:
3229:                    Dynamic implementation of USB_HOST_Status system interface function.
3230:                
3231:                  Description:
3232:                    This is the dynamic implementation of USB_HOST_Status system interface
3233:                    function.
3234:                
3235:                  Remarks:
3236:                    See usb_host.h for usage information.
3237:                */
3238:                
3239:                SYS_STATUS USB_HOST_Status (SYS_MODULE_OBJ usbHostObject)
3240:                {
3241:                    USB_HOST_OBJ * hostObj =  (USB_HOST_OBJ *)usbHostObject;
3242:                    SYS_STATUS result = SYS_STATUS_UNINITIALIZED;
3243:                
3244:                    /* Check if we have a valid object */
3245:                    if(NULL ==  hostObj)
3246:                    {
3247:                        SYS_DEBUG_MESSAGE(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Invalid System Module Object in USB_HOST_Status().");
3248:                    }
3249:                    else
3250:                    {
3251:                        /* Return the system status of the Host Layer */
3252:                        result = hostObj->status;
3253:                    }
3254:                
3255:                    return(result);
3256:                }
3257:                
3258:                // *****************************************************************************
3259:                /* Function:
3260:                    void USB_HOST_Deinitialize ( SYS_MODULE_OBJ usbHostObject )
3261:                
3262:                  Summary:
3263:                    Dynamic implementation of USB_HOST_Deinitialize system interface function.
3264:                
3265:                  Description:
3266:                    This is the dynamic implementation of USB_HOST_Deinitialize system interface
3267:                    function.
3268:                
3269:                  Remarks:
3270:                    See usb_host.h for usage information.
3271:                */
3272:                
3273:                void USB_HOST_Deinitialize ( SYS_MODULE_OBJ usbHostObject )
3274:                {
3275:                    /* Host object */
3276:                    USB_HOST_OBJ * hostObj =  (USB_HOST_OBJ *)usbHostObject;
3277:                
3278:                    /* Check for NULL pointer */
3279:                    if(NULL == hostObj )
3280:                    {
3281:                        SYS_DEBUG_MESSAGE(SYS_ERROR_DEBUG, "\r\nUSB Host Layer: Invalid System Module Object in USB_HOST_Deinitialize().");
3282:                    }
3283:                    else
3284:                    {
3285:                        /* Set the instance status to de-initialized */
3286:                        hostObj->status =  SYS_STATUS_UNINITIALIZED ;
3287:                    }
3288:                }
3289:                
3290:                // *****************************************************************************
3291:                // *****************************************************************************
3292:                // Section: USB HOST Layer Client Interface Implementations
3293:                // *****************************************************************************
3294:                // *****************************************************************************
3295:                
3296:                // *****************************************************************************
3297:                /* Function:
3298:                    USB_HOST_RESULT USB_HOST_DeviceGetFirst 
3299:                    (
3300:                        USB_HOST_BUS bus, 
3301:                        USB_HOST_DEVICE_INFO * deviceInfo
3302:                    );
3303:                
3304:                  Summary:
3305:                    Returns information about the first attached device on the bus.
3306:                
3307:                  Description:
3308:                    This function returns information about the first attached device on the
3309:                    specified bus. The USB_HOST_DeviceGetNext() function can be used to get the
3310:                    reference to the next attached device on the bus. The USB_HOST_DEVICE_INFO
3311:                    object is provided by the application.The device information will be
3312:                    populated into this object. If there are no devices attached on the bus, the
3313:                    function will set the deviceObjHandle parameter, in the USB_HOST_DEVICE_INFO
3314:                    object, to USB_HOST_DEVICE_OBJ_HANDLE INVALID. 
3315:                    
3316:                  Remarks:
3317:                    None.
3318:                */
3319:                
3320:                USB_HOST_RESULT USB_HOST_DeviceGetFirst 
3321:                (
3322:                    USB_HOST_BUS bus, 
3323:                    USB_HOST_DEVICE_INFO * deviceInfo
3324:                )
3325:                {
3326:                    USB_HOST_RESULT result = USB_HOST_RESULT_SUCCESS;
3327:                
3328:                    USB_HOST_BUS_OBJ * busObj;
3329:                    USB_HOST_DEVICE_OBJ * deviceObj, * rootHub;
3330:                
3331:                    if(bus >= USB_HOST_CONTROLLERS_NUMBER)
3332:                    {
3333:                        /* This is an invalid bus */
3334:                        result = USB_HOST_RESULT_BUS_UNKNOWN;
3335:                    }
3336:                    else if (NULL == deviceInfo)
3337:                    {
3338:                        /* Parameter is not valid */
3339:                        result = USB_HOST_RESULT_PARAMETER_INVALID;
3340:                    }
3341:                    else 
3342:                    {
3343:                        /* Get a pointer to the bus object */
3344:                        busObj = &gUSBHostBusList[bus];
3345:                
3346:                        /* Set the initial value of the device Info object to invalid incase we
3347:                         * have to exit with a failure */
3348:                        deviceInfo->deviceObjHandle = USB_HOST_DEVICE_OBJ_HANDLE_INVALID;
3349:                
3350:                        if(busObj->state < USB_HOST_BUS_STATE_ENABLED)
3351:                        {
3352:                            /* Bus is not enabled */
3353:                            result = USB_HOST_RESULT_BUS_NOT_ENABLED;
3354:                        }
3355:                        else 
3356:                        {
3357:                            /* Get the pointer to the first attached device. This will be the
3358:                             * root hub. The next device after the root hub is the device
3359:                             * attached to the bus.  */
3360:                
3361:                            rootHub = busObj->busDeviceList;
3362:                            deviceObj = rootHub->nextDeviceObj;
3363:                            result = USB_HOST_RESULT_END_OF_DEVICE_LIST;
3364:                
3365:                            while(deviceObj != NULL)
3366:                            {
3367:                                /* A device can be reported only if it is ready for interaction
3368:                                 * with the application. If we come across a device which is not
3369:                                 * ready, then we skip it */
3370:                                if(deviceObj->deviceState == USB_HOST_DEVICE_STATE_READY)
3371:                                {
3372:                                    /* We have a device connected on the bus. Populate the device
3373:                                     * info object with details about this device */
3374:                                    deviceInfo->deviceObjHandle = deviceObj->deviceIdentifier;
3375:                                    deviceInfo->deviceAddress = deviceObj->deviceAddress;
3376:                                    deviceInfo->bus = USB_HOST_BUS_NUMBER(deviceObj->deviceIdentifier); 
3377:                                    result = USB_HOST_RESULT_SUCCESS;
3378:                                    break;
3379:                                }
3380:                                else
3381:                                {
3382:                                    deviceObj = deviceObj->nextDeviceObj;
3383:                                }
3384:                            }
3385:                        }
3386:                    }
3387:                    
3388:                    return(result);
3389:                }
3390:                
3391:                // *****************************************************************************
3392:                /* Function:
3393:                    USB_HOST_RESULT USB_HOST_DeviceGetNext (USB_HOST_DEVICE_INFO * deviceInfo);
3394:                
3395:                  Summary:
3396:                    Returns information about the next device on the bus.
3397:                
3398:                  Description:
3399:                    This function returns information of the next device attached on the bus.
3400:                    The  USB_HOST_DeviceGetFirst() function should have been called at least once
3401:                    on the deviceInfo object.  Then calling this function repeatedly on the
3402:                    deviceInfo object will return information about the next attached device on
3403:                    the bus. When there are no more attached devices to report, the function
3404:                    returns USB_HOST_RESULT_END_OF_DEVICE_LIST.
3405:                
3406:                    Calling the USB_HOST_DeviceGetFirst() function on the deviceInfo object
3407:                    after the USB_HOST_DeviceGetNext() function has been called will cause the
3408:                    host to reset the deviceInfo object to point to the first attached device.
3409:                
3410:                  Remarks:
3411:                    None.
3412:                */
3413:                
3414:                USB_HOST_RESULT USB_HOST_DeviceGetNext (USB_HOST_DEVICE_INFO * deviceInfo)
3415:                {
3416:                    USB_HOST_RESULT result = USB_HOST_RESULT_SUCCESS;
3417:                    USB_HOST_DEVICE_OBJ * deviceObj = NULL;
3418:                    unsigned int index = 0;
3419:                
3420:                    if(NULL == deviceInfo)
3421:                    {
3422:                        result = USB_HOST_RESULT_PARAMETER_INVALID;
3423:                    }
3424:                    else
3425:                    {
3426:                        /* Get the device index */
3427:                        index = USB_HOST_DEVICE_INDEX(deviceInfo->deviceObjHandle);
3428:                
3429:                        if(USB_HOST_DEVICES_NUMBER <= index)
3430:                        {
3431:                            /* Index is not valid. This should not happen unless the deviceInfo
3432:                             * has bee tampered with. */
3433:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
3434:                        }
3435:                        else
3436:                        {
3437:                            /* Get a pointer to the device object */
3438:                            deviceObj = &gUSBHostDeviceList[index];
3439:                
3440:                            /* Cross the PNP identifier against the PNP identifier of the device
3441:                             * that is in the device list. If they don't match then this means
3442:                             * that device was unplugged and another device has been connected
3443:                             * */
3444:                
3445:                            if(USB_HOST_PNP_IDENTIFIER(deviceInfo->deviceObjHandle) != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
3446:                            {
3447:                                result = USB_HOST_RESULT_DEVICE_UNKNOWN;
3448:                            }
3449:                            else 
3450:                            {
3451:                                /* Set default result */
3452:                                result = USB_HOST_RESULT_END_OF_DEVICE_LIST;
3453:                                deviceObj = deviceObj->nextDeviceObj;
3454:                                while(deviceObj != NULL)
3455:                                {
3456:                
3457:                                    if(deviceObj->deviceState == USB_HOST_DEVICE_STATE_READY)
3458:                                    {
3459:                                        deviceInfo->deviceObjHandle = deviceObj->deviceIdentifier;
3460:                                        deviceInfo->bus = USB_HOST_BUS_NUMBER(deviceObj->deviceIdentifier);
3461:                                        deviceInfo->deviceAddress = deviceObj->deviceAddress;
3462:                                        result = USB_HOST_RESULT_SUCCESS;
3463:                                        break;
3464:                                    }
3465:                                    else
3466:                                    {
3467:                                        deviceObj = deviceObj->nextDeviceObj;
3468:                                    }
3469:                                }
3470:                            }
3471:                        }
3472:                    }
3473:                
3474:                    return(result);
3475:                }
3476:                
3477:                // *****************************************************************************
3478:                /* Function:
3479:                    USB_HOST_RESULT USB_HOST_EventHandlerSet
3480:                    (
3481:                        USB_HOST_EVENT_HANDLER * eventHandler,
3482:                        uintptr_t context
3483:                    )
3484:                
3485:                  Summary:
3486:                    USB Host Layer Event Handler Callback Function set function.
3487:                
3488:                  Description:
3489:                    This is the USB Host Layer Event Handler Callback Set function. An
3490:                    application can receive USB Host Layer events by using this function to
3491:                    register and event handler callback function. The application can
3492:                    additionally specify a specific context which will returned with the event
3493:                    handler callback function. The event handler must be set (this function must
3494:                    be called) before any of the USB buses are enabled.
3495:                
3496:                  Remarks:
3497:                    See usb_host.h for usage information.
3498:                */
3499:                
3500:                USB_HOST_RESULT USB_HOST_EventHandlerSet
3501:                (
3502:                    USB_HOST_EVENT_HANDLER  eventHandler,
3503:                    uintptr_t context
3504:                )
3505:                {
3506:                    /* Assign the event handler. The event handler can be NULL in which case the
3507:                     * host layer will not generate events. The context is returned along with
3508:                     * the event */
3509:                
3510:                    gUSBHostObj.hostEventHandler = eventHandler ;
3511:                    gUSBHostObj.context = context ;
3512:                    return (USB_HOST_RESULT_SUCCESS);
3513:                }
3514:                
3515:                // *****************************************************************************
3516:                /* Function:
3517:                    USB_HOST_RESULT USB_HOST_DeviceSpeedGet 
3518:                    (
3519:                        USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle, 
3520:                        USB_SPEED * speed
3521:                    )
3522:                
3523:                  Summary:
3524:                    Returns the speed at which this device is operating.
3525:                
3526:                  Description:
3527:                    This function returns the speed at which this device is operating.
3528:                
3529:                  Precondition:
3530:                    The USB_HOST_Initialize() function should have been called. 
3531:                
3532:                  Parameters:
3533:                    deviceObjHandle - handle to the device whose speed is required.
3534:                
3535:                    speed - output parameter. Will contain the speed of the device if the
3536:                    function was successful.
3537:                    
3538:                  Returns:
3539:                    USB_HOST_RESULT_SUCCESS - The function was successful. speed will contain
3540:                    the speed of the device.
3541:                    USB_HOST_RESULT_DEVICE_UNKNOWN - The device does not exist in the system.
3542:                    speed will contain USB_SPEED_ERROR. 
3543:                    USB_HOST_RESULT_FAILURE - an unknown error occurred.
3544:                
3545:                  Example:
3546:                    <code>
3547:                    </code>
3548:                
3549:                  Remarks:
3550:                    None.
3551:                */
3552:                
3553:                USB_HOST_RESULT USB_HOST_DeviceSpeedGet 
3554:                ( 
3555:                    USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle, 
3556:                    USB_SPEED * speed
3557:                )
3558:                {
3559:                    USB_HOST_RESULT  result = USB_HOST_RESULT_SUCCESS;
3560:                    unsigned int index = 0;
3561:                    USB_HOST_DEVICE_OBJ * deviceObj = NULL;
3562:                
3563:                    /* Check if the parameter is NULL */
3564:                    if(NULL == speed)
3565:                    {
3566:                       result = USB_HOST_RESULT_PARAMETER_INVALID;
3567:                    }
3568:                    else
3569:                    {
3570:                       /* Check if the device index is valid */
3571:                        index = USB_HOST_DEVICE_INDEX(deviceObjHandle);
3572:                        if( ( USB_HOST_DEVICES_NUMBER + USB_HOST_CONTROLLERS_NUMBER ) <  index) 
3573:                        {
3574:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
3575:                        }
3576:                        else
3577:                        {
3578:                            /* Get the pointer to the device object */
3579:                            deviceObj = &gUSBHostDeviceList[index];
3580:                
3581:                            /* Validate the plug and play identifier */
3582:                            if(USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier ) != USB_HOST_PNP_IDENTIFIER(deviceObjHandle))
3583:                            {
3584:                                /* The device handle is pointing to a device that does not exist
3585:                                 * in the system */
3586:                                result = USB_HOST_RESULT_DEVICE_UNKNOWN;
3587:                            }
3588:                            else
3589:                            {
3590:                                /* Everything checks out. Return the device speed */
3591:                                *speed = deviceObj->speed;
3592:                            }
3593:                        }
3594:                    }
3595:                
3596:                    return(result);
3597:                }
3598:                
3599:                // *****************************************************************************
3600:                /* Function:
3601:                    USB_HOST_RESULT USB_HOST_BusEnable(USB_HOST_BUS bus)
3602:                
3603:                  Summary:
3604:                    Starts host operations.
3605:                
3606:                  Description:
3607:                    The function starts the operation of the USB Host Bus. It enables the root
3608:                    hub associated with specified bus and starts the process of detecting
3609:                    attached devices and enumerating them. The USB_HOST_EventHandlerSet()
3610:                    function should have been called to register an application host layer event
3611:                    handler before the Host layer is enabled (before the USB_HOST_BusEnable()
3612:                    function is called).  This will ensure that the application does not miss
3613:                    any host events.
3614:                
3615:                  Remarks:
3616:                    See usb_host.h for usage information.
3617:                */
3618:                
3619:                USB_HOST_RESULT USB_HOST_BusEnable(USB_HOST_BUS bus)
3620:                {
3621:                    USB_HOST_BUS_OBJ        *busObj;
3622:                    int                      hcCount;
3623:                    USB_HOST_RESULT          status = USB_HOST_RESULT_FALSE ;
3624:                
3625:                    /* Note that this function only sets the state of the bus object
3626:                     * to indicate that the bus needs will be enabled. The actual enabling is
3627:                     * performed in the USB Host Layer Tasks Routine. */
3628:                
3629:                    if ( bus == USB_HOST_BUS_ALL )
9D008E14  240200FF   ADDIU V0, ZERO, 255
9D008E18  14820009   BNE A0, V0, 0x9D008E40
9D008E1C  3C02A000   LUI V0, -24576
3630:                    {
3631:                        for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
3632:                        {
3633:                            busObj  = &(gUSBHostBusList[hcCount]);
3634:                
3635:                            if(busObj->state < USB_HOST_BUS_STATE_ENABLING)
9D008E20  8C4266F0   LW V0, 26352(V0)
9D008E24  2C420002   SLTIU V0, V0, 2
9D008E28  10400003   BEQ V0, ZERO, 0x9D008E38
9D008E2C  24030002   ADDIU V1, ZERO, 2
3636:                            {
3637:                                /* This means the bus is not enabled. Set the state to enable
3638:                                 * the bus. */
3639:                                busObj->state = USB_HOST_BUS_STATE_ENABLING ;
9D008E30  3C02A000   LUI V0, -24576
9D008E34  AC4366F0   SW V1, 26352(V0)
9D008E38  03E00008   JR RA
9D008E3C  24020001   ADDIU V0, ZERO, 1
3640:                                SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d About to Open Root Hub Driver.", hcCount);
3641:                            }
3642:                            status  =   USB_HOST_RESULT_SUCCESS ;
3643:                        }
3644:                    }
3645:                    /* Enable specific bus */
3646:                    else
3647:                    {
3648:                        /* Validate bus number */
3649:                        if( bus < 0 || bus >= USB_HOST_CONTROLLERS_NUMBER )
9D008E40  5480000B   BNEL A0, ZERO, 0x9D008E70
9D008E44  2402FFA6   ADDIU V0, ZERO, -90
3650:                        {
3651:                            status = USB_HOST_RESULT_BUS_UNKNOWN;
3652:                        }
3653:                        else
3654:                        {
3655:                            busObj  = &(gUSBHostBusList[bus]);
3656:                            if(busObj->state < USB_HOST_BUS_STATE_ENABLING)
9D008E48  3C02A000   LUI V0, -24576
9D008E4C  8C4366F0   LW V1, 26352(V0)
9D008E50  2C630002   SLTIU V1, V1, 2
9D008E54  10600006   BEQ V1, ZERO, 0x9D008E70
9D008E58  24020001   ADDIU V0, ZERO, 1
3657:                            {
3658:                                /* This means the bus is not enabled. Set the state to enable
3659:                                 * the bus. */
3660:                                busObj->state = USB_HOST_BUS_STATE_ENABLING ;
9D008E5C  24030002   ADDIU V1, ZERO, 2
9D008E60  3C02A000   LUI V0, -24576
9D008E64  AC4366F0   SW V1, 26352(V0)
3661:                                SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d About to Open Root Hub Driver.", bus);
3662:                            }
3663:                            status = USB_HOST_RESULT_SUCCESS;
9D008E68  03E00008   JR RA
9D008E6C  24020001   ADDIU V0, ZERO, 1
3664:                        }
3665:                    }
3666:                
3667:                    return ( status );
3668:                }
9D008E70  03E00008   JR RA
3669:                
3670:                USB_HOST_RESULT USB_HOST_BusDisable(USB_HOST_BUS bus)
3671:                {
3672:                    USB_HOST_BUS_OBJ        *busObj;
3673:                    int                      hcCount;
3674:                    USB_HOST_RESULT          status = USB_HOST_RESULT_FALSE ;
3675:                
3676:                    /* Note that this function only sets the state of the bus object
3677:                     * to indicate that the bus needs will be enabled. The actual enabling is
3678:                     * performed in the USB Host Layer Tasks Routine. */
3679:                
3680:                    if ( bus == USB_HOST_BUS_ALL )
3681:                    {
3682:                        for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
3683:                        {
3684:                            busObj  = &(gUSBHostBusList[hcCount]);
3685:                
3686:                            if(busObj->state >= USB_HOST_BUS_STATE_ENABLED)
3687:                            {
3688:                                /* This means the bus is not enabled. Set the state to disable 
3689:                                 * the bus. */
3690:                                busObj->state = USB_HOST_BUS_STATE_DISABLING ;
3691:                            }
3692:                            status  =   USB_HOST_RESULT_SUCCESS ;
3693:                        }
3694:                    }
3695:                    /* Enable specific bus */
3696:                    else
3697:                    {
3698:                        /* Validate bus number */
3699:                        if( bus < 0 || bus >= USB_HOST_CONTROLLERS_NUMBER )
3700:                        {
3701:                            status = USB_HOST_RESULT_BUS_UNKNOWN;
3702:                        }
3703:                        else
3704:                        {
3705:                            busObj  = &(gUSBHostBusList[bus]);
3706:                            if(busObj->state >= USB_HOST_BUS_STATE_ENABLED)
3707:                            {
3708:                                /* This means the bus is not enabled. Set the state to enable
3709:                                 * the bus. */
3710:                                busObj->state = USB_HOST_BUS_STATE_DISABLING ;
3711:                            }
3712:                            status = USB_HOST_RESULT_SUCCESS;
3713:                        }
3714:                    }
3715:                
3716:                    return ( status );
3717:                }
3718:                
3719:                // *****************************************************************************
3720:                /* Function:
3721:                    USB_HOST_RESULT USB_HOST_BusIsEnabled(USB_HOST_BUS bus)
3722:                
3723:                  Summary:
3724:                    Checks if the bus is enabled.
3725:                
3726:                  Description:
3727:                    The function returns the enable status of the bus. It can be called after
3728:                    the USB_HOST_BusEnable() function is called, to check if the bus has been
3729:                    enabled yet. If the bus parameter is set to USB_HOST_BUS_ALL, then the
3730:                    function will check the enable status of all the busses and will return true
3731:                    only if all the busses are enabled.
3732:                
3733:                     Remarks:
3734:                    See usb_host.h for usage information.
3735:                
3736:                  Remarks:
3737:                    None.
3738:                */
3739:                
3740:                USB_HOST_RESULT USB_HOST_BusIsEnabled(USB_HOST_BUS bus)
3741:                {
3742:                    USB_HOST_BUS_OBJ        *busObj;
3743:                    int                      hcCount;
3744:                    USB_HOST_RESULT          status = USB_HOST_RESULT_TRUE ;
3745:                
3746:                    if ( bus == USB_HOST_BUS_ALL )
3747:                    {
3748:                        for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
3749:                        {
3750:                            busObj  = &(gUSBHostBusList[hcCount]);
3751:                            if(busObj->state <= USB_HOST_BUS_STATE_WAIT_FOR_ENABLE_COMPLETE)
3752:                            {
3753:                                /* This means at least one bus is being enabled. And so all
3754:                                 * buses are not enabled yet. */
3755:                                status = USB_HOST_RESULT_FALSE;
3756:                                break;
3757:                            }
3758:                            else
3759:                            {
3760:                                /* The default value of status is USB_HOST_RESULT_TRUE */
3761:                            }
3762:                        }
3763:                    }
3764:                    else
3765:                    {
3766:                        /* Validate bus number */
3767:                        if( bus < 0 || bus >= USB_HOST_CONTROLLERS_NUMBER )
3768:                        {
3769:                            status = USB_HOST_RESULT_BUS_UNKNOWN;
3770:                        }
3771:                        else
3772:                        {
3773:                            busObj  = &(gUSBHostBusList[bus]);
3774:                            if(busObj->state < USB_HOST_BUS_STATE_ENABLED)
3775:                            {
3776:                                /* The bus is in the process of being enabled or is not enabled
3777:                                 * at all. */
3778:                                status = USB_HOST_RESULT_FALSE;
3779:                            }
3780:                            else
3781:                            {
3782:                                /* The default value of status is USB_HOST_RESULT_TRUE */
3783:                            }
3784:                        }
3785:                    }
3786:                
3787:                    return ( status );
3788:                }
3789:                
3790:                USB_HOST_RESULT USB_HOST_BusIsDisabled(USB_HOST_BUS bus)
3791:                {
3792:                    USB_HOST_BUS_OBJ        *busObj;
3793:                    int                      hcCount;
3794:                    USB_HOST_RESULT          status = USB_HOST_RESULT_TRUE ;
3795:                
3796:                    if ( bus == USB_HOST_BUS_ALL )
3797:                    {
3798:                        for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
3799:                        {
3800:                            busObj  = &(gUSBHostBusList[hcCount]);
3801:                            if(busObj->state != USB_HOST_BUS_STATE_DISABLED)
3802:                            {
3803:                                /* This means at least one bus is being enabled. And so all
3804:                                 * buses are not enabled yet. */
3805:                                status = USB_HOST_RESULT_FALSE;
3806:                                break;
3807:                            }
3808:                            else
3809:                            {
3810:                                /* The default value of status is USB_HOST_RESULT_TRUE */
3811:                            }
3812:                        }
3813:                    }
3814:                    else
3815:                    {
3816:                        /* Validate bus number */
3817:                        if( bus < 0 || bus >= USB_HOST_CONTROLLERS_NUMBER )
3818:                        {
3819:                            status = USB_HOST_RESULT_BUS_UNKNOWN;
3820:                        }
3821:                        else
3822:                        {
3823:                            busObj  = &(gUSBHostBusList[bus]);
3824:                            if(busObj->state != USB_HOST_BUS_STATE_DISABLED)
3825:                            {
3826:                                /* The bus is in process of being disabled or is not disabled
3827:                                 * at all. */
3828:                                status = USB_HOST_RESULT_FALSE;
3829:                            }
3830:                            else
3831:                            {
3832:                                /* The default value of status is USB_HOST_RESULT_TRUE */
3833:                            }
3834:                        }
3835:                    }
3836:                
3837:                    return ( status );
3838:                }
3839:                
3840:                // *****************************************************************************
3841:                /* Function:
3842:                    USB_HOST_RESULT USB_HOST_BusSuspend (USB_HOST_BUS bus);
3843:                
3844:                  Summary:
3845:                    Suspends the bus.
3846:                
3847:                  Description:
3848:                    The function suspends the bus. All devices on the bus will be suspended. If
3849:                    bus  is specified as USB_HOST_BUS_ALL, all the buses managed by this host
3850:                    will be suspended.
3851:                
3852:                  Precondition:
3853:                    The USB_HOST_BusEnable() function should have been called to enable the bus.
3854:                
3855:                  Remarks:
3856:                    See usb_host.h for usage information.
3857:                */
3858:                
3859:                USB_HOST_RESULT USB_HOST_BusSuspend (USB_HOST_BUS bus)
3860:                {
3861:                    USB_HOST_BUS_OBJ        *busObj;
3862:                    int                     hcCount;
3863:                    USB_HOST_RESULT         status = USB_HOST_RESULT_SUCCESS ;
3864:                
3865:                    if ( bus == USB_HOST_BUS_ALL )
3866:                    {
3867:                        /* Suspend all USB busses in the system */
3868:                        for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
3869:                        {
3870:                            busObj  = &(gUSBHostBusList[hcCount]);
3871:                
3872:                            if( busObj->state < USB_HOST_BUS_STATE_ENABLED )
3873:                            {
3874:                                /* This means the bus is not enabled yet */
3875:                                status = USB_HOST_RESULT_BUS_NOT_ENABLED;
3876:                                break;
3877:                            }
3878:                            else if(busObj->state > USB_HOST_BUS_STATE_ENABLED)
3879:                            {
3880:                                /* This means the bus is already being suspended or is in a
3881:                                 * suspended state. */
3882:                            }
3883:                            else 
3884:                            {
3885:                                /* This means the bus is in enabled state. Set the state to
3886:                                 * suspending */
3887:                                busObj->state = USB_HOST_BUS_STATE_SUSPENDING;
3888:                            }
3889:                        }
3890:                    }
3891:                    else
3892:                    {
3893:                        /* Suspend a specific bus. Validate bus number */
3894:                        if( bus < 0 || bus >= USB_HOST_CONTROLLERS_NUMBER )
3895:                        {
3896:                            status = USB_HOST_RESULT_BUS_UNKNOWN;
3897:                        }
3898:                        else
3899:                        {   /* Set a state for enabling will be in task routine */
3900:                            busObj  = &(gUSBHostBusList[bus]);
3901:                
3902:                            if( busObj->state < USB_HOST_BUS_STATE_ENABLED )
3903:                            {
3904:                                /* This means the bus is not enabled yet */
3905:                                status = USB_HOST_RESULT_BUS_NOT_ENABLED;
3906:                            }
3907:                            else if(busObj->state > USB_HOST_BUS_STATE_ENABLED)
3908:                            {
3909:                                /* This means the bus is already being suspended or is in a
3910:                                 * suspended state. */
3911:                            }
3912:                            else 
3913:                            {
3914:                                /* This means the bus is in enabled state. Set the state to
3915:                                 * suspending */
3916:                                busObj->state = USB_HOST_BUS_STATE_SUSPENDING;
3917:                            }
3918:                        }
3919:                    }
3920:                
3921:                    return ( status );
3922:                }
3923:                
3924:                // *****************************************************************************
3925:                /* Function:
3926:                    USB_HOST_RESULT USB_HOST_BusIsSuspended (USB_HOST_BUS bus)
3927:                
3928:                  Summary:
3929:                    Returns the suspend status of the bus.
3930:                
3931:                  Description:
3932:                    This function returns suspend status of the specified USB bus. This function
3933:                    can be used to check the completion of the Resume operation started by using
3934:                    the USB_HOST_BusResume() function. If the Resume signaling has completed,
3935:                    the USB_HOST_BusIsSuspended() function would return USB_HOST_RESULT_FALSE
3936:                    indicating that the bus is not suspended.  Calling the
3937:                    USB_HOST_BusIsSuspended() with bus specified as USB_HOST_BUS_ALL returns the
3938:                    suspend status of the all USB segments that are managed by the host layer.
3939:                    The function would return USB_HOST_RESULT_TRUE only if all the bus are in a
3940:                    suspended state.
3941:                
3942:                Remarks:
3943:                    See usb_host.h for usage information.
3944:                */
3945:                
3946:                USB_HOST_RESULT USB_HOST_BusIsSuspended (USB_HOST_BUS bus)
3947:                {
3948:                    USB_HOST_BUS_OBJ    *busObj;
3949:                    int                 hcCount;
3950:                    USB_HOST_RESULT     status = USB_HOST_RESULT_SUCCESS ;
3951:                
3952:                    if ( bus == USB_HOST_BUS_ALL )
3953:                    {
3954:                        /* Check if all USB busses are suspended */
3955:                        for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
3956:                        {
3957:                            busObj  = &(gUSBHostBusList[hcCount]);
3958:                            if( busObj->state < USB_HOST_BUS_STATE_ENABLED)
3959:                            {
3960:                                /* Bus is not enabled yet */
3961:                                status = USB_HOST_RESULT_BUS_NOT_ENABLED ;
3962:                                break;
3963:                            }
3964:                            else if(busObj->state <= USB_HOST_BUS_STATE_SUSPENDING)
3965:                            {
3966:                                /* Bus is not suspended */
3967:                                status = USB_HOST_RESULT_FALSE;
3968:                                break;
3969:                            }
3970:                            else
3971:                            {
3972:                                /* No action required */
3973:                            }
3974:                        }
3975:                    }
3976:                    else
3977:                    {
3978:                        /* Check if this bus is suspended. Validate the bus number */
3979:                        if ( bus < 0 || bus >= USB_HOST_CONTROLLERS_NUMBER )
3980:                        {
3981:                            status = USB_HOST_RESULT_BUS_UNKNOWN ;
3982:                        }
3983:                        else
3984:                        {
3985:                            busObj  = &(gUSBHostBusList[bus]);
3986:                            if( busObj->state < USB_HOST_BUS_STATE_ENABLED)
3987:                            {
3988:                                /* Bus is not enabled yet */
3989:                                status = USB_HOST_RESULT_BUS_NOT_ENABLED ;
3990:                            }
3991:                            else if(busObj->state < USB_HOST_BUS_STATE_SUSPENDED)
3992:                            {
3993:                                /* Bus is not suspended */
3994:                                status = USB_HOST_RESULT_FALSE;
3995:                            }
3996:                            else
3997:                            {
3998:                                /* No action required */
3999:                            }
4000:                        }
4001:                    }
4002:                
4003:                    return ( status );
4004:                }
4005:                
4006:                // *****************************************************************************
4007:                /* Function:
4008:                    USB_HOST_RESULT USB_HOST_BusResume (USB_HOST_BUS bus);
4009:                
4010:                  Summary:
4011:                    Resumes the bus.
4012:                
4013:                  Description:
4014:                    The function resumes the bus. All devices on the bus will be receive resume
4015:                    signaling. If bus is specified as USB_HOST_BUS_ALL, all the buses managed by
4016:                    this host will be resumed.
4017:                
4018:                  Remarks:
4019:                    See usb_host.h for usage information.
4020:                */
4021:                
4022:                USB_HOST_RESULT USB_HOST_BusResume (USB_HOST_BUS bus)
4023:                {
4024:                    /* This function is not implemented in this release of the USB Host Layer */
4025:                
4026:                    USB_HOST_RESULT status = USB_HOST_RESULT_FAILURE ;
4027:                
4028:                    return status;
4029:                }
4030:                
4031:                // *****************************************************************************
4032:                /* Function:
4033:                    USB_HOST_DEVICE_OBJ_HANDLE USB_HOST_DeviceEnumerate
4034:                    (
4035:                        USB_HOST_DEVICE_OBJ_HANDLE parentHubObjHandle, 
4036:                        uint8_t port 
4037:                    );
4038:                
4039:                  Summary:
4040:                    This function will request the host layer to enumerate an attached device.
4041:                
4042:                  Description:
4043:                    This function will request the host layer to enumerate an attached device.
4044:                    It is called by the hub driver or the root hub when a device is attached.The
4045:                    function will return a device object handle to the caller. The caller must
4046:                    specify this handle when the device is detached.
4047:                
4048:                  Remarks:
4049:                    Refer to usb_host_client_driver.h for usage information.
4050:                */
4051:                
4052:                USB_HOST_DEVICE_OBJ_HANDLE USB_HOST_DeviceEnumerate
4053:                (
4054:                    USB_HOST_DEVICE_OBJ_HANDLE parentDeviceIdentifier, 
4055:                    uint8_t port
4056:                )
4057:                {
9D0045C8  27BDFFD0   ADDIU SP, SP, -48
9D0045CC  AFBF002C   SW RA, 44(SP)
9D0045D0  AFB50028   SW S5, 40(SP)
9D0045D4  AFB40024   SW S4, 36(SP)
9D0045D8  AFB30020   SW S3, 32(SP)
9D0045DC  AFB2001C   SW S2, 28(SP)
9D0045E0  AFB10018   SW S1, 24(SP)
9D0045E4  AFB00014   SW S0, 20(SP)
9D0045E8  00808021   ADDU S0, A0, ZERO
4058:                    bool pnpIsUnique;
4059:                    uint32_t busNumber;
4060:                    uint32_t deviceCount = USB_HOST_CONTROLLERS_NUMBER;
4061:                    USB_HOST_BUS_OBJ * busObj;
4062:                    uint8_t parentDeviceNumber;
4063:                    USB_HOST_DEVICE_OBJ * newDeviceObj = NULL,* parentDeviceObj;
9D004644  00003821   ADDU A3, ZERO, ZERO
4064:                    USB_HOST_DEVICE_OBJ  * deviceObj;
4065:                    bool interruptWasEnabled;
4066:                    USB_HOST_DEVICE_OBJ_HANDLE result = USB_HOST_DEVICE_OBJ_HANDLE_INVALID;
9D00479C  2402FFFF   ADDIU V0, ZERO, -1
4067:                    USB_CONFIGURATION_DESCRIPTOR * configurationDescriptor = NULL;
9D004640  00008821   ADDU S1, ZERO, ZERO
4068:                
4069:                    /* Get the bus number and the device object index of the parent device. This
4070:                     * is needed to get the bus object and the parent device object */
4071:                
4072:                    busNumber =  USB_HOST_BUS_NUMBER(parentDeviceIdentifier ); 
4073:                    parentDeviceNumber = USB_HOST_DEVICE_INDEX(parentDeviceIdentifier );
4074:                    parentDeviceObj =  & gUSBHostDeviceList [ parentDeviceNumber ];
9D00466C  00041100   SLL V0, A0, 4
9D004670  00041980   SLL V1, A0, 6
9D004674  00621823   SUBU V1, V1, V0
9D004678  000310C0   SLL V0, V1, 3
9D00467C  00621821   ADDU V1, V1, V0
9D004680  3C02A000   LUI V0, -24576
9D004684  24426388   ADDIU V0, V0, 25480
9D004688  00431821   ADDU V1, V0, V1
4075:                    busObj  = &(gUSBHostBusList[busNumber]);
9D00468C  000A2100   SLL A0, T2, 4
9D004690  000A1180   SLL V0, T2, 6
9D004694  00821021   ADDU V0, A0, V0
9D004698  3C06A000   LUI A2, -24576
9D00469C  24C666E8   ADDIU A2, A2, 26344
9D0046A0  00C23021   ADDU A2, A2, V0
4076:                
4077:                    /* We disable all interrupts here. When a hub is attached, this function 
4078:                     * will be called from the IRP callback of the hub driver status IRP. This
4079:                     * callback runs in an interrupt context. We want the process of assigning
4080:                     * a device object to be atomic */
4081:                
4082:                    interruptWasEnabled = SYS_INT_Disable();
9D0045EC  0F40265D   JAL SYS_INT_Disable
9D0045F0  00A09021   ADDU S2, A1, ZERO
9D0045F4  00409821   ADDU S3, V0, ZERO
4083:                
4084:                    /* Now search for a free device object. The search must start from the
4085:                     * USB_HOST_CONTROLLER_NUMBERS because the first set of device objects in
4086:                     * the device object array are reserved for root hub devices. */
4087:                
4088:                    for (deviceCount = USB_HOST_CONTROLLERS_NUMBER; 
4089:                            deviceCount < (USB_HOST_DEVICES_NUMBER + USB_HOST_CONTROLLERS_NUMBER); deviceCount ++ )
4090:                    {
4091:                        if (gUSBHostDeviceList[deviceCount].inUse == false )
9D0045F8  3C02A000   LUI V0, -24576
9D0045FC  90426538   LBU V0, 25912(V0)
9D004600  5440000F   BNEL V0, ZERO, 0x9D004640
9D004604  240B0002   ADDIU T3, ZERO, 2
4092:                        {
4093:                            /* This means we found a new object. Grab it and stop the search */
4094:                            newDeviceObj = &gUSBHostDeviceList[deviceCount];
4095:                
4096:                            /* Before we reset this object to zero, we must make a backup of the
4097:                             * configuration descriptor pointer, so that we can free this memory
4098:                             * before we start the enumeration process. The memory cannot be
4099:                             * freed here because this function is called in an interrupt
4100:                             * function. */
4101:                
4102:                            configurationDescriptor = newDeviceObj->configDescriptorInfo.configurationDescriptor;
9D004608  3C15A000   LUI S5, -24576
9D00460C  26B56388   ADDIU S5, S5, 25480
9D004610  8EB102B0   LW S1, 688(S5)
4103:                
4104:                            /* Completely clear up this object */
4105:                            memset (newDeviceObj, 0, sizeof(USB_HOST_DEVICE_OBJ));
9D004614  3C14A000   LUI S4, -24576
9D004618  26946538   ADDIU S4, S4, 25912
9D00461C  02802021   ADDU A0, S4, ZERO
9D004620  00002821   ADDU A1, ZERO, ZERO
9D004624  0F40202B   JAL memset
9D004628  240601B0   ADDIU A2, ZERO, 432
4106:                
4107:                            /* Grab this object */
4108:                            newDeviceObj->inUse  = true;
9D00462C  24020001   ADDIU V0, ZERO, 1
9D004630  A2A201B0   SB V0, 432(S5)
4109:                            break;
9D004634  240B0001   ADDIU T3, ZERO, 1
9D004638  0B401192   J 0x9D004648
9D00463C  02803821   ADDU A3, S4, ZERO
4110:                        }
4111:                    }
4112:                
4113:                    /* We can now enable the interrupts */
4114:                    if(interruptWasEnabled)
9D004648  12600005   BEQ S3, ZERO, 0x9D004660
9D00464C  00000000   NOP
4115:                    {
4116:                        SYS_INT_Enable();
9D004650  40026000   MFC0 V0, Status
9D004654  34420001   ORI V0, V0, 1
9D004658  40826000   MTC0 V0, Status
9D00465C  000000C0   EHB
4117:                    }
4118:                
4119:                    if(newDeviceObj != NULL)
9D004660  10E0004E   BEQ A3, ZERO, 0x9D00479C
9D004664  7E0A3A00   EXT T2, S0, 8, 8
9D004668  320400FF   ANDI A0, S0, 255
4120:                    {
4121:                        /* This means we found a device object. Initialize the new device
4122:                         * object. The HCD interface will be always the HCD interface of the
4123:                         * parent */
4124:                
4125:                        newDeviceObj->hcdInterface = parentDeviceObj->hcdInterface;
9D0046A4  8C62006C   LW V0, 108(V1)
9D0046A8  ACE2006C   SW V0, 108(A3)
4126:                        newDeviceObj->devicePort = port; 
9D0046AC  A0F20075   SB S2, 117(A3)
4127:                        if (parentDeviceObj->deviceAddress == USB_HOST_ROOT_HUB_ADDRESS )
9D0046B0  90640060   LBU A0, 96(V1)
9D0046B4  24020001   ADDIU V0, ZERO, 1
9D0046B8  54820008   BNEL A0, V0, 0x9D0046DC
9D0046BC  ACE00070   SW ZERO, 112(A3)
4128:                        {
4129:                            /* If the parent device is the root hub, the hub interface for
4130:                             * the device should be root hub interface */
4131:                            newDeviceObj->hubInterface = &(parentDeviceObj->hcdInterface->rootHubInterface.rootHubPortInterface);
9D0046C0  8C62006C   LW V0, 108(V1)
9D0046C4  2442003C   ADDIU V0, V0, 60
9D0046C8  ACE20070   SW V0, 112(A3)
4132:                            newDeviceObj->hubAddress = 0;
9D0046CC  A0E00074   SB ZERO, 116(A3)
4133:                            newDeviceObj->hubHandle = busObj->hcdHandle;
9D0046D0  8CC20000   LW V0, 0(A2)
9D0046D4  0B4011BA   J 0x9D0046E8
9D0046D8  ACE20068   SW V0, 104(A3)
4134:                
4135:                        }
4136:                        else
4137:                        {
4138:                            /* If the parent device is a hub, then the hub interface for the
4139:                             * device should be the external hub interface */
4140:                
4141:                            newDeviceObj->hubInterface = USB_HOST_HUB_INTERFACE;
4142:                            newDeviceObj->hubAddress = parentDeviceObj->deviceAddress;
9D0046DC  90620060   LBU V0, 96(V1)
9D0046E0  A0E20074   SB V0, 116(A3)
4143:                            newDeviceObj->hubHandle = parentDeviceIdentifier;
9D0046E4  ACF00068   SW S0, 104(A3)
4144:                        }
4145:                
4146:                        /* These members of the device object need to be initialized to specific
4147:                         * values */
4148:                        newDeviceObj->parentDeviceIdentifier = parentDeviceIdentifier;
9D0046E8  ACF00054   SW S0, 84(A3)
4149:                        newDeviceObj->hcdHandle = busObj->hcdHandle;
9D0046EC  8CC20000   LW V0, 0(A2)
9D0046F0  ACE20064   SW V0, 100(A3)
4150:                        newDeviceObj->deviceAddress = USB_HOST_DEFAULT_ADDRESS ;
9D0046F4  A0E00060   SB ZERO, 96(A3)
4151:                        newDeviceObj->deviceState = USB_HOST_DEVICE_STATE_WAITING_FOR_ENUMERATION;
9D0046F8  ACE000F0   SW ZERO, 240(A3)
4152:                        newDeviceObj->tplEntryTried = -1;
9D0046FC  2403FFFF   ADDIU V1, ZERO, -1
9D004700  ACE300E4   SW V1, 228(A3)
4153:                        newDeviceObj->deviceClScPTried = -1;
9D004704  ACE300E8   SW V1, 232(A3)
4154:                        newDeviceObj->configDescriptorInfo.configurationNumber = USB_HOST_CONFIGURATION_NUMBER_INVALID;
9D004708  A0E301A5   SB V1, 421(A3)
4155:                
4156:                        /* Note that this memory address that is being assigned here will be
4157:                         * freed up before the enumeration process starts. */
4158:                        newDeviceObj->configDescriptorInfo.configurationDescriptor = configurationDescriptor;
9D00470C  ACF10100   SW S1, 256(A3)
4159:                
4160:                        /* Allocate a Plug N Play identifier. This identifier will be unique
4161:                         * to the attached device. It counts upwards and only repeats after
4162:                         * 0xFFFE. */
4163:                
4164:                        do
4165:                        {
4166:                            /* Increment the pnpIdentifier. */
4167:                            busObj->pnpIdentifier ++;
9D00471C  94C20048   LHU V0, 72(A2)
9D004720  24420001   ADDIU V0, V0, 1
9D004724  3042FFFF   ANDI V0, V0, -1
4168:                
4169:                            if(busObj->pnpIdentifier == 0xFFFE)
9D004714  3408FFFE   ORI T0, ZERO, -2
9D004728  50480002   BEQL V0, T0, 0x9D004734
9D00472C  A4C90048   SH T1, 72(A2)
9D004730  A4C20048   SH V0, 72(A2)
4170:                            {
4171:                                /* Rollover to start from 1 */
4172:                                busObj->pnpIdentifier = 1;
9D004718  24090001   ADDIU T1, ZERO, 1
4173:                            }
4174:                
4175:                            /* Check if this identifier is used by any device on this bus
4176:                             * */
4177:                
4178:                            deviceObj = busObj->busDeviceList;
9D004710  8CC50010   LW A1, 16(A2)
4179:                            pnpIsUnique = true;
4180:                            while(deviceObj != NULL)
9D004734  50A0000D   BEQL A1, ZERO, 0x9D00476C
9D004738  8CA201A8   LW V0, 424(A1)
9D004760  5440FFFC   BNEL V0, ZERO, 0x9D004754
9D004764  9443004E   LHU V1, 78(V0)
4181:                            {
4182:                                if(USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier) == busObj->pnpIdentifier)
9D00473C  94C40048   LHU A0, 72(A2)
9D004740  94A2004E   LHU V0, 78(A1)
9D004744  1044FFF5   BEQ V0, A0, 0x9D00471C
9D004748  00A01021   ADDU V0, A1, ZERO
9D004754  5064FFF2   BEQL V1, A0, 0x9D004720
9D004758  94C20048   LHU V0, 72(A2)
4183:                                {
4184:                                    /* The proposed PNP is already in use. Stop scanning */
4185:                                    pnpIsUnique = false;
4186:                                    break;
4187:                                }
4188:                                else
4189:                                {
4190:                                    /* Get the next device */
4191:                                    deviceObj = deviceObj->nextDeviceObj;
9D00474C  0B4011D8   J 0x9D004760
9D004750  8C4201A8   LW V0, 424(V0)
9D00475C  8C4201A8   LW V0, 424(V0)
4192:                                }
4193:                            }
4194:                        } while(pnpIsUnique == false);
4195:                
4196:                        /* Add this object to the bus device list */
4197:                        deviceObj = busObj->busDeviceList;
4198:                
4199:                        /* Get to the end of the list */
4200:                        while( deviceObj->nextDeviceObj != NULL )
9D004768  8CA201A8   LW V0, 424(A1)
9D00476C  50400003   BEQL V0, ZERO, 0x9D00477C
9D004770  ACA701A8   SW A3, 424(A1)
4201:                        {
4202:                            deviceObj = deviceObj->nextDeviceObj;
9D004774  0B4011DA   J 0x9D004768
9D004778  00402821   ADDU A1, V0, ZERO
4203:                        }
4204:                
4205:                        /* Add the object */
4206:                        deviceObj->nextDeviceObj = newDeviceObj;
4207:                
4208:                        /* Create the device object handle */
4209:                        newDeviceObj->deviceIdentifier = _USB_HOST_DeviceObjHandleGet(busObj->pnpIdentifier, busNumber, deviceCount);
9D00477C  000A5200   SLL T2, T2, 8
9D004780  94C20048   LHU V0, 72(A2)
9D004784  00021400   SLL V0, V0, 16
9D004788  01421025   OR V0, T2, V0
9D00478C  004B1025   OR V0, V0, T3
9D004790  ACE2004C   SW V0, 76(A3)
9D004794  0B4011E8   J 0x9D0047A0
9D004798  ACE20050   SW V0, 80(A3)
4210:                        newDeviceObj->deviceClientHandle = newDeviceObj->deviceIdentifier;
4211:                
4212:                        /* Update result */
4213:                        result = newDeviceObj->deviceIdentifier;
4214:                    }
4215:                    else
4216:                    {
4217:                        /* We could not find a spare device object */
4218:                        SYS_DEBUG_MESSAGE( SYS_ERROR_INFO , "USB_HOST_DeviceEnumerate : Max Devices connected  \r\n");
4219:                    }
4220:                
4221:                    return(result);
4222:                }
9D0047A0  8FBF002C   LW RA, 44(SP)
4223:                
4224:                // *****************************************************************************
4225:                /* Function:
4226:                    void USB_HOST_DeviceDenumerate
4227:                    ( 
4228:                        USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle
4229:                    );
4230:                
4231:                  Summary:
4232:                    De-enumerates an attached device.
4233:                
4234:                  Description:
4235:                    This function de-enumerates an attached device. This function is called by the
4236:                    USB_HOST_DeviceDenumerate() function which in turn is called by the root hub
4237:                    or the external hub when a device is detached. The deviceObjHandle is the
4238:                    handle of the device that was detached. This is the same handle that was
4239:                    returned by the USB_HOST_DeviceEnumerate() function. This function will
4240:                    release the device and interface level drivers. It will then remove the
4241:                    object from the bus list and will deallocate the device object.
4242:                
4243:                    If the object to be removed is a hub, the hub driver will call the
4244:                    USB_HOST_DeviceDenumerate() function for all its ports. This function will
4245:                    not search for child devices when a parent is removed.
4246:                
4247:                  Remarks:
4248:                    This is a local function and should not be called directly by the
4249:                    application.
4250:                */
4251:                
4252:                void USB_HOST_DeviceDenumerate( USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle )
4253:                {
9D005740  27BDFFD8   ADDIU SP, SP, -40
9D005744  AFBF0024   SW RA, 36(SP)
9D005748  AFB30020   SW S3, 32(SP)
9D00574C  AFB2001C   SW S2, 28(SP)
9D005750  AFB10018   SW S1, 24(SP)
9D005754  AFB00014   SW S0, 20(SP)
4254:                    USB_HOST_DEVICE_OBJ  * prevDeviceObj, * deviceObj, * deleteDeviceObj;
4255:                    USB_HOST_BUS_OBJ * busObj;
4256:                    USB_HOST_CONFIGURATION_INFO * configurationInfo;
4257:                    int index, busIndex;
4258:                    bool interruptIsEnabled;
4259:                    
4260:                    /* Check if the device object handle is valid. */
4261:                    if(deviceObjHandle != USB_HOST_DEVICE_OBJ_HANDLE_INVALID)
9D005758  2402FFFF   ADDIU V0, ZERO, -1
9D00575C  1082004A   BEQ A0, V0, 0x9D005888
9D005760  00808821   ADDU S1, A0, ZERO
4262:                    {
4263:                        /* Get the device index from the device object handle */
4264:                        index = USB_HOST_DEVICE_INDEX(deviceObjHandle);
9D005764  308300FF   ANDI V1, A0, 255
4265:                        deviceObj = &gUSBHostDeviceList[index];
9D005768  00032100   SLL A0, V1, 4
9D00576C  00031180   SLL V0, V1, 6
9D005770  00441023   SUBU V0, V0, A0
9D005774  000280C0   SLL S0, V0, 3
9D005778  00501021   ADDU V0, V0, S0
9D00577C  3C10A000   LUI S0, -24576
9D005780  26106388   ADDIU S0, S0, 25480
4266:                
4267:                        /* It is possible that this function can be called from two paths. The
4268:                         * main is the device detach path. The other path is the device
4269:                         * malfunction (possibly due to over current). The device malfunction
4270:                         * path will be detected in the Host Task routine context. But the
4271:                         * device detach path occurs in an interrupt context. We cannot allow
4272:                         * multiple entries on the same device. This may occur especially in the
4273:                         * case of a root hub, where the root hub driver will disable the power
4274:                         * to the device when it detects an overcurrent situation, but disabling
4275:                         * the power which may also cause a device detach interrupt, in which
4276:                         * case this function will re-enter with the same device object handle.
4277:                         * Hence we make this a critical section */
4278:                
4279:                        interruptIsEnabled = SYS_INT_Disable();
9D005784  0F40265D   JAL SYS_INT_Disable
9D005788  02028021   ADDU S0, S0, V0
9D00578C  00409021   ADDU S2, V0, ZERO
4280:                        
4281:                        if(deviceObj->inUse)
9D005790  92020000   LBU V0, 0(S0)
9D005794  10400036   BEQ V0, ZERO, 0x9D005870
9D005798  7E223A00   EXT V0, S1, 8, 8
4282:                        {
4283:                            busIndex = USB_HOST_BUS_NUMBER(deviceObjHandle);
4284:                            busObj = &gUSBHostBusList[busIndex];
9D00579C  00029900   SLL S3, V0, 4
9D0057A0  00021180   SLL V0, V0, 6
9D0057A4  02621021   ADDU V0, S3, V0
9D0057A8  3C13A000   LUI S3, -24576
9D0057AC  267366E8   ADDIU S3, S3, 26344
9D0057B0  02629821   ADDU S3, S3, V0
4285:                            deleteDeviceObj = deviceObj;
4286:                
4287:                            /* If there is device level client driver, then release the client driver */
4288:                            if(deviceObj->deviceClientDriver != NULL )
9D0057B4  8E0200E0   LW V0, 224(S0)
9D0057B8  50400005   BEQL V0, ZERO, 0x9D0057D0
9D0057BC  8E020100   LW V0, 256(S0)
4289:                            {
4290:                                deviceObj->deviceClientDriver->deviceRelease( deviceObj->deviceClientHandle);
9D0057C0  8C420010   LW V0, 16(V0)
9D0057C4  0040F809   JALR V0
9D0057C8  8E040050   LW A0, 80(S0)
4291:                            }
4292:                
4293:                            /* Get the configuration information */
4294:                            configurationInfo = &(deviceObj->configDescriptorInfo);
4295:                
4296:                            if(configurationInfo->configurationDescriptor != NULL)
9D0057CC  8E020100   LW V0, 256(S0)
9D0057D0  50400004   BEQL V0, ZERO, 0x9D0057E4
9D0057D4  8E02006C   LW V0, 108(S0)
4297:                            {
4298:                                /* For each interface in the configuration, if the interface is assigned to
4299:                                 * client driver, then release these client drivers. */
4300:                
4301:                                _USB_HOST_ReleaseInterfaceDrivers(deviceObj); 
9D0057D8  0F402199   JAL _USB_HOST_ReleaseInterfaceDrivers
9D0057DC  02002021   ADDU A0, S0, ZERO
4302:                            }
4303:                
4304:                            /* Close the control pipe */
4305:                            deviceObj->hcdInterface->hostPipeClose ( deviceObj->controlPipeHandle );
9D0057E0  8E02006C   LW V0, 108(S0)
9D0057E4  8C420020   LW V0, 32(V0)
9D0057E8  0040F809   JALR V0
9D0057EC  8E040058   LW A0, 88(S0)
4306:                            deviceObj->controlPipeHandle  = DRV_USB_HOST_PIPE_HANDLE_INVALID;
9D0057F0  2402FFFF   ADDIU V0, ZERO, -1
9D0057F4  AE020058   SW V0, 88(S0)
4307:                
4308:                            /* Release address */
4309:                            _USB_HOST_FreeAddress (deviceObj->deviceIdentifier);
9D0057F8  0F402290   JAL _USB_HOST_FreeAddress
9D0057FC  8E04004C   LW A0, 76(S0)
4310:                
4311:                            /* Any dynamic memory that is allocated to the device is released
4312:                             * when the device object is used again. The denumerate function
4313:                             * which could be called from an interrupt context is really a bad
4314:                             * place to free up memory. */
4315:                
4316:                            /* If this device was enumerating then release the enumeration flag */
4317:                            if((busObj->deviceIsEnumerating) && (busObj->enumeratingDeviceIdentifier == deviceObjHandle))
9D005800  92620015   LBU V0, 21(S3)
9D005804  50400005   BEQL V0, ZERO, 0x9D00581C
9D005808  8E620010   LW V0, 16(S3)
9D00580C  8E62004C   LW V0, 76(S3)
9D005810  50510001   BEQL V0, S1, 0x9D005818
9D005814  A2600015   SB ZERO, 21(S3)
4318:                            {
4319:                                /* Clear the enumerating flag, so that we can let other device
4320:                                 * enumerate */
4321:                                busObj->deviceIsEnumerating = false;
4322:                            }
4323:                
4324:                            /* The device needs to be removed from the bus list. The first device in the
4325:                             * bus list is the root hub. So prevDeviceObj here is the root hub device.
4326:                             * */ 
4327:                            prevDeviceObj = busObj->busDeviceList;
9D005818  8E620010   LW V0, 16(S3)
9D005830  0B401612   J 0x9D005848
9D005834  00402821   ADDU A1, V0, ZERO
4328:                
4329:                            /* The device connect to the root hub is the device attached to the bus. */
4330:                            deviceObj = prevDeviceObj->nextDeviceObj;
9D00581C  8C4501A8   LW A1, 424(V0)
4331:                
4332:                            while(deviceObj != NULL)
9D005820  10A00012   BEQ A1, ZERO, 0x9D00586C
9D005824  00A01821   ADDU V1, A1, ZERO
9D00585C  1460FFF6   BNE V1, ZERO, 0x9D005838
9D005860  00000000   NOP
4333:                            {
4334:                                /* Check if this is the object to delete */
4335:                                if ( deleteDeviceObj == deviceObj  )
9D005828  5605000C   BNEL S0, A1, 0x9D00585C
9D00582C  8CA301A8   LW V1, 424(A1)
9D005838  52030004   BEQL S0, V1, 0x9D00584C
9D00583C  8C6201A8   LW V0, 424(V1)
4336:                                {
4337:                                    /* Remove this device from the linked list */
4338:                                    prevDeviceObj->nextDeviceObj = deviceObj->nextDeviceObj ;
9D005848  8C6201A8   LW V0, 424(V1)
9D00584C  ACA201A8   SW V0, 424(A1)
4339:                
4340:                                    /* Clear the nextDeviceObj of the deleted device object */
4341:                                    deleteDeviceObj->nextDeviceObj = NULL;
4342:                                    break;
9D005850  0B40161B   J 0x9D00586C
9D005854  AE0001A8   SW ZERO, 424(S0)
4343:                                }
4344:                                else
4345:                                {
4346:                                    /* Else continue search till we have reached end of the list */
4347:                                    prevDeviceObj = deviceObj;
4348:                                    deviceObj = deviceObj->nextDeviceObj;
9D005840  0B401616   J 0x9D005858
9D005844  00602821   ADDU A1, V1, ZERO
9D005858  8CA301A8   LW V1, 424(A1)
4349:                                }
4350:                            }
4351:                
4352:                            /* Deallocate the device object */
4353:                            deviceObj->inUse = false;
9D005864  0B40161C   J 0x9D005870
9D005868  A0600000   SB ZERO, 0(V1)
9D00586C  A0600000   SB ZERO, 0(V1)
4354:                        }
4355:                        else
4356:                        {
4357:                            /* This means this object is not valid any more. We should not have
4358:                             * to do anything */
4359:                        }
4360:                        
4361:                        if(interruptIsEnabled)
9D005870  12400006   BEQ S2, ZERO, 0x9D00588C
9D005874  8FBF0024   LW RA, 36(SP)
4362:                        {
4363:                            SYS_INT_Enable();
9D005878  40026000   MFC0 V0, Status
9D00587C  34420001   ORI V0, V0, 1
9D005880  40826000   MTC0 V0, Status
9D005884  000000C0   EHB
4364:                        }
4365:                    }
4366:                    else
4367:                    {
4368:                        /* The device object handle is not valid. We don't have to do anything */
4369:                    }
4370:                }
9D005888  8FBF0024   LW RA, 36(SP)
4371:                
4372:                // *****************************************************************************
4373:                /* Function:
4374:                    void USB_HOST_Tasks (SYS_MODULE_OBJ object );
4375:                
4376:                  Summary:
4377:                    Maintains the USB Host Layer state machine.
4378:                
4379:                  Description:
4380:                    This routine maintains the USB Host layer state machine. It must be called
4381:                    frequently to ensure proper operation of the USB. This function should be
4382:                    called from the SYS_Tasks function.
4383:                
4384:                 Remarks:
4385:                    See usb_host.h for usage information.
4386:                */
4387:                
4388:                void USB_HOST_Tasks ( SYS_MODULE_OBJ usbHostObject )
4389:                {
9D003F88  27BDFFE0   ADDIU SP, SP, -32
9D003F8C  AFBF001C   SW RA, 28(SP)
9D003F90  AFB10018   SW S1, 24(SP)
9D003F94  AFB00014   SW S0, 20(SP)
4390:                    /* Host object */
4391:                    USB_HOST_OBJ            *hostObj =  (USB_HOST_OBJ *)usbHostObject;
4392:                    USB_HOST_BUS_OBJ        *busObj;
4393:                    USB_HOST_DEVICE_OBJ     *rootHubDevice;
4394:                    uint32_t                rootHubUHD;
4395:                    int                     hcCount;
4396:                 
4397:                    /* Check if the host layer is ready. We do not run the tasks routine
4398:                     * otherwise */
4399:                    if ( hostObj->status != SYS_STATUS_READY)
9D003F98  8C830008   LW V1, 8(A0)
9D003F9C  24020002   ADDIU V0, ZERO, 2
9D003FA0  5462007D   BNEL V1, V0, 0x9D004198
9D003FA4  8FBF001C   LW RA, 28(SP)
4400:                    {
4401:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSB Host Layer: Not ready in USB_HOST_Tasks().");
4402:                    }
4403:                    else
4404:                    {
4405:                        /* Maintain the state of each bus in the system */
4406:                        for ( hcCount = 0 ; hcCount < USB_HOST_CONTROLLERS_NUMBER ; hcCount++ )
4407:                        {
4408:                            busObj  = &(gUSBHostBusList[hcCount]);
4409:                
4410:                            switch ( busObj->state)
9D003FA8  3C02A000   LUI V0, -24576
9D003FAC  8C4266F0   LW V0, 26352(V0)
9D003FB0  24030002   ADDIU V1, ZERO, 2
9D003FB4  1043000E   BEQ V0, V1, 0x9D003FF0
9D003FB8  2C430003   SLTIU V1, V0, 3
9D003FBC  10600006   BEQ V1, ZERO, 0x9D003FD8
9D003FC0  24030003   ADDIU V1, ZERO, 3
9D003FC4  24030001   ADDIU V1, ZERO, 1
9D003FC8  1043006B   BEQ V0, V1, 0x9D004178
9D003FCC  3C02A000   LUI V0, -24576
9D003FD8  10430057   BEQ V0, V1, 0x9D004138
9D003FDC  24030004   ADDIU V1, ZERO, 4
9D003FE0  10430061   BEQ V0, V1, 0x9D004168
9D003FE4  00000000   NOP
4411:                            {
4412:                                case USB_HOST_BUS_STATE_DISABLED:
4413:                                    /* No action required */
4414:                                    break;
4415:                
4416:                                case USB_HOST_BUS_STATE_ENABLING:
4417:                                    
4418:                                    if(busObj->hcdHandle == DRV_HANDLE_INVALID)
9D003FF0  3C02A000   LUI V0, -24576
9D003FF4  8C4466E8   LW A0, 26344(V0)
9D003FF8  2402FFFF   ADDIU V0, ZERO, -1
9D003FFC  14820046   BNE A0, V0, 0x9D004118
9D004000  3C10A000   LUI S0, -24576
4419:                                    {
4420:                                        /* The bus is being enabled. Try opening the HCD */
4421:                                        busObj->hcdHandle = busObj->hcdInterface->open(busObj->hcdIndex, DRV_IO_INTENT_EXCLUSIVE | 
9D004004  260266E8   ADDIU V0, S0, 26344
9D004008  8C43000C   LW V1, 12(V0)
9D00400C  8C630000   LW V1, 0(V1)
9D004010  94440004   LHU A0, 4(V0)
9D004014  0060F809   JALR V1
9D004018  2405000F   ADDIU A1, ZERO, 15
4422:                                                DRV_IO_INTENT_NONBLOCKING | DRV_IO_INTENT_READWRITE );
4423:                
4424:                                        /* Validate the Open function status */
4425:                                        if (DRV_HANDLE_INVALID == busObj->hcdHandle )
9D00401C  2403FFFF   ADDIU V1, ZERO, -1
9D004020  1043005C   BEQ V0, V1, 0x9D004194
9D004024  AE0266E8   SW V0, 26344(S0)
4426:                                        {
4427:                                            /* The driver may not open the first time. This is okay. We
4428:                                             * should try opening it again. The state of bus is not
4429:                                             * changed. */
4430:                                        }
4431:                                        else
4432:                                        {
4433:                                            /* Update the bus root hub information with the
4434:                                             * details of the controller. Get the bus speed, number of
4435:                                             * ports, the maximum current that the HCD can supply,
4436:                                             * pointer to the root hub port functions. */
4437:                
4438:                                            SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Root Hub Driver Opened.",hcCount);
4439:                                            busObj->rootHubInfo.speed =  busObj->hcdInterface->rootHubInterface.rootHubSpeedGet(busObj->hcdHandle);
9D004028  02008821   ADDU S1, S0, ZERO
9D00402C  261066E8   ADDIU S0, S0, 26344
9D004030  8E03000C   LW V1, 12(S0)
9D004034  8C630024   LW V1, 36(V1)
9D004038  0060F809   JALR V1
9D00403C  00402021   ADDU A0, V0, ZERO
9D004040  AE020024   SW V0, 36(S0)
4440:                                            busObj->rootHubInfo.ports = busObj->hcdInterface->rootHubInterface.rootHubPortNumbersGet(busObj->hcdHandle);
9D004044  8E02000C   LW V0, 12(S0)
9D004048  8C420028   LW V0, 40(V0)
9D00404C  0040F809   JALR V0
9D004050  8E2466E8   LW A0, 26344(S1)
9D004054  A2020020   SB V0, 32(S0)
4441:                                            busObj->rootHubInfo.power =  busObj->hcdInterface->rootHubInterface.rootHubMaxCurrentGet(busObj->hcdHandle);
9D004058  8E02000C   LW V0, 12(S0)
9D00405C  8C42002C   LW V0, 44(V0)
9D004060  0040F809   JALR V0
9D004064  8E2466E8   LW A0, 26344(S1)
9D004068  AE020028   SW V0, 40(S0)
4442:                                            busObj->rootHubInfo.rootHubPortInterface = busObj->hcdInterface->rootHubInterface.rootHubPortInterface;
9D00406C  8E03000C   LW V1, 12(S0)
9D004070  8C67003C   LW A3, 60(V1)
9D004074  8C660040   LW A2, 64(V1)
9D004078  8C650044   LW A1, 68(V1)
9D00407C  8C640048   LW A0, 72(V1)
9D004080  8C62004C   LW V0, 76(V1)
9D004084  AE07002C   SW A3, 44(S0)
9D004088  AE060030   SW A2, 48(S0)
9D00408C  AE050034   SW A1, 52(S0)
9D004090  AE040038   SW A0, 56(S0)
9D004094  AE02003C   SW V0, 60(S0)
4443:                
4444:                                            /* We need to add the root hub as a device in the device
4445:                                             * list. In the gUSBHostDeviceList, the first
4446:                                             * USB_HOST_CONTROLLER_NUMBERS of objects is reserved for
4447:                                             * root hubs. Device Object 0 for root hub 0 and so on. We
4448:                                             * simply grab the device object reserved for the bus root
4449:                                             * hub that we processing and then initialize it. */
4450:                
4451:                                            rootHubDevice = &(gUSBHostDeviceList[hcCount]);
4452:                                            rootHubDevice->inUse = true;
9D004098  3C02A000   LUI V0, -24576
9D00409C  24060001   ADDIU A2, ZERO, 1
9D0040A0  A0466388   SB A2, 25480(V0)
4453:                
4454:                                            /* The plug and play identifier is a unique ID that gets
4455:                                             * incremented when a new device is attached to the bus. We
4456:                                             * consider the root hub enumeration as a new device */
4457:                
4458:                                            busObj->pnpIdentifier = busObj->pnpIdentifier + 1 ;
9D0040A4  96050048   LHU A1, 72(S0)
9D0040A8  24A50001   ADDIU A1, A1, 1
9D0040AC  30A5FFFF   ANDI A1, A1, -1
9D0040B0  A6050048   SH A1, 72(S0)
4459:                
4460:                                            /* The UHD for the root hub can now be formed. It is
4461:                                             * combination of the the PNP identifier, the
4462:                                             * gUSBHostDeviceList index and the bus number */
4463:                
4464:                                            rootHubUHD =  _USB_HOST_DeviceObjHandleGet(busObj->pnpIdentifier, hcCount, hcCount);  
9D0040B4  00052C00   SLL A1, A1, 16
4465:                
4466:                                            /* Root hub has  device identifier and parent device
4467:                                             * identifier same. The hub interface is the HCD root hub
4468:                                             * interface. Each of these device object is a linked list
4469:                                             * node. We set the next object to NULL. */
4470:                
4471:                                            rootHubDevice->deviceIdentifier = rootHubUHD ;
9D0040B8  24426388   ADDIU V0, V0, 25480
9D0040BC  AC45004C   SW A1, 76(V0)
4472:                                            rootHubDevice->parentDeviceIdentifier = rootHubUHD;
9D0040C0  AC450054   SW A1, 84(V0)
4473:                                            rootHubDevice->hcdHandle = busObj->hcdHandle ;
9D0040C4  8E2466E8   LW A0, 26344(S1)
9D0040C8  AC440064   SW A0, 100(V0)
4474:                                            rootHubDevice->deviceAddress = USB_HOST_ROOT_HUB_ADDRESS ;
9D0040CC  A0460060   SB A2, 96(V0)
4475:                                            rootHubDevice->deviceState = USB_HOST_DEVICE_STATE_READY ;
9D0040D0  2406000F   ADDIU A2, ZERO, 15
9D0040D4  AC4600F0   SW A2, 240(V0)
4476:                                            rootHubDevice->hcdInterface = busObj->hcdInterface;
9D0040D8  AC43006C   SW V1, 108(V0)
4477:                                            rootHubDevice->hubInterface = (USB_HUB_INTERFACE *) & ( busObj->hcdInterface->rootHubInterface);
9D0040DC  24660024   ADDIU A2, V1, 36
9D0040E0  AC460070   SW A2, 112(V0)
4478:                                            rootHubDevice->nextDeviceObj = NULL;
9D0040E4  AC4001A8   SW ZERO, 424(V0)
4479:                
4480:                                            /* The first device in the bus is the root hub */
4481:                                            busObj->busDeviceList = rootHubDevice ;
9D0040E8  AE020010   SW V0, 16(S0)
4482:                
4483:                                            /* Initialize the root hub. The device identifier passed to
4484:                                             * the initialize function is returned as the parent ID when
4485:                                             * the root hub request for device attach. We then enable
4486:                                             * the root hub operation. The root hub operation enable
4487:                                             * function does not enable the root hub immediately. So we
4488:                                             * will have to continue checking the progress of the enable
4489:                                             * operation in another state. */
4490:                                            busObj->hcdInterface->rootHubInterface.rootHubInitialize( busObj->hcdHandle , rootHubDevice->deviceIdentifier );
9D0040EC  8C620038   LW V0, 56(V1)
9D0040F0  0040F809   JALR V0
9D0040F4  00000000   NOP
4491:                                            busObj->hcdInterface->rootHubInterface.rootHubOperationEnable( busObj->hcdHandle , true );
9D0040F8  8E02000C   LW V0, 12(S0)
9D0040FC  8C420030   LW V0, 48(V0)
9D004100  8E2466E8   LW A0, 26344(S1)
9D004104  0040F809   JALR V0
9D004108  24050001   ADDIU A1, ZERO, 1
4492:                                            SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Enabling Root Hub operation.",hcCount);
4493:                                            busObj->state = USB_HOST_BUS_STATE_WAIT_FOR_ENABLE_COMPLETE ;
9D00410C  24020003   ADDIU V0, ZERO, 3
9D004110  0B401065   J 0x9D004194
9D004114  AE020008   SW V0, 8(S0)
4494:                                        }
4495:                                    }
4496:                                    else
4497:                                    {
4498:                                        busObj->hcdInterface->rootHubInterface.rootHubOperationEnable( busObj->hcdHandle , true );
9D004118  261066E8   ADDIU S0, S0, 26344
9D00411C  8E02000C   LW V0, 12(S0)
9D004120  8C420030   LW V0, 48(V0)
9D004124  0040F809   JALR V0
9D004128  24050001   ADDIU A1, ZERO, 1
4499:                                        busObj->state = USB_HOST_BUS_STATE_WAIT_FOR_ENABLE_COMPLETE ;
9D00412C  24020003   ADDIU V0, ZERO, 3
9D004130  0B401065   J 0x9D004194
9D004134  AE020008   SW V0, 8(S0)
4500:                                    }
4501:                
4502:                                    break;
4503:                
4504:                                case USB_HOST_BUS_STATE_WAIT_FOR_ENABLE_COMPLETE:
4505:                
4506:                                    /* Check if the root hub operation enable function has
4507:                                     * completed. If yes, then the bus enable routine has completed
4508:                                     * and we can update the bus state */
4509:                
4510:                                    if(busObj->hcdInterface->rootHubInterface.rootHubOperationIsEnabled(busObj->hcdHandle))
9D004138  3C02A000   LUI V0, -24576
9D00413C  244366E8   ADDIU V1, V0, 26344
9D004140  8C63000C   LW V1, 12(V1)
9D004144  8C630034   LW V1, 52(V1)
9D004148  0060F809   JALR V1
9D00414C  8C4466E8   LW A0, 26344(V0)
9D004150  10400011   BEQ V0, ZERO, 0x9D004198
9D004154  8FBF001C   LW RA, 28(SP)
4511:                                    {
4512:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Root Hub Operation Enabled.",hcCount);
4513:                                        SYS_DEBUG_PRINT(SYS_ERROR_INFO, "\r\nUSB Host Layer: Bus %d Updating Attached Device states.",hcCount);
4514:                                        busObj->state = USB_HOST_BUS_STATE_ENABLED;
9D004158  24030004   ADDIU V1, ZERO, 4
9D00415C  3C02A000   LUI V0, -24576
9D004160  0B401065   J 0x9D004194
9D004164  AC4366F0   SW V1, 26352(V0)
4515:                                    }
4516:                                    break;
4517:                
4518:                                case USB_HOST_BUS_STATE_ENABLED:
4519:                
4520:                                    /* Now that the bus is enabled, we can update the state of every
4521:                                     * device that is attached on this bus. */
4522:                
4523:                                    _USB_HOST_UpdateDeviceTask(hcCount);
9D004168  0F402135   JAL _USB_HOST_UpdateDeviceTask
9D00416C  00002021   ADDU A0, ZERO, ZERO
4524:                                    break;
9D004170  0B401066   J 0x9D004198
9D004174  8FBF001C   LW RA, 28(SP)
4525:                
4526:                                case USB_HOST_BUS_STATE_DISABLING:
4527:                
4528:                                    busObj->hcdInterface->rootHubInterface.rootHubOperationEnable( busObj->hcdHandle , false );
9D004178  245066E8   ADDIU S0, V0, 26344
9D00417C  8E03000C   LW V1, 12(S0)
9D004180  8C630030   LW V1, 48(V1)
9D004184  8C4466E8   LW A0, 26344(V0)
9D004188  0060F809   JALR V1
9D00418C  00002821   ADDU A1, ZERO, ZERO
4529:                                    busObj->state = USB_HOST_BUS_STATE_DISABLED;
9D004190  AE000008   SW ZERO, 8(S0)
4530:                                    
4531:                                    break;
4532:                
4533:                                case USB_HOST_BUS_STATE_SUSPENDING:
4534:                
4535:                                    break;
4536:                
4537:                                case USB_HOST_BUS_STATE_SUSPENDED:
4538:                
4539:                                    break;
4540:                
4541:                                default :
4542:                                    break;
4543:                            }
4544:                        }
4545:                    }
4546:                }
9D003FD0  0B401066   J 0x9D004198
9D003FD4  8FBF001C   LW RA, 28(SP)
9D003FE8  0B401066   J 0x9D004198
9D003FEC  8FBF001C   LW RA, 28(SP)
9D004194  8FBF001C   LW RA, 28(SP)
4547:                
4548:                // *****************************************************************************
4549:                /* Function:
4550:                    USB_ENDPOINT_DESCRIPTOR * USB_HOST_DeviceEndpointDescriptorQuery
4551:                    (
4552:                        USB_INTERFACE_DESCRIPTOR * interface
4553:                        USB_HOST_DESCRIPTOR_QUERY * query 
4554:                    );
4555:                
4556:                  Summary:
4557:                    Queries the configuration for the specified endpoint type and returns a
4558:                    pointer to the endpoint descriptor if found.
4559:                
4560:                  Description:
4561:                  This function queries the specified configuration for the specified endpoint
4562:                    type and returns a pointer to the endpoint descriptor if found. The return
4563:                    pointer will point to the standard endpoint descriptor and class specific
4564:                    endpoint descriptors for that endpoint. The search criteria can specified by
4565:                    using the flags. 
4566:                    
4567:                    In a case where there are multiple endpoints in the interface, the function
4568:                    can be called repetitively to continue the search till the end of the
4569:                    interface descriptor is reached or till the search fails.  The query object
4570:                    maintains the last point where the search was successful and continues the
4571:                    search from that point onwards. Resetting the query object (through the
4572:                    USB_HOST_DeviceEndpointQueryClear) function will reset the search object and
4573:                    cause the search to start from the top of the interface descriptor..
4574:                
4575:                  Remarks:
4576:                    This function is available in the PIC32 implementation of the USB Host.
4577:                */
4578:                
4579:                USB_ENDPOINT_DESCRIPTOR * USB_HOST_DeviceEndpointDescriptorQuery
4580:                (
4581:                    USB_INTERFACE_DESCRIPTOR * interface,
4582:                    USB_HOST_ENDPOINT_DESCRIPTOR_QUERY * query 
4583:                )
4584:                {
9D005460  27BDFFD8   ADDIU SP, SP, -40
9D005464  AFBF0024   SW RA, 36(SP)
9D005468  AFB30020   SW S3, 32(SP)
9D00546C  AFB2001C   SW S2, 28(SP)
9D005470  AFB10018   SW S1, 24(SP)
9D005474  AFB00014   SW S0, 20(SP)
4585:                    USB_ENDPOINT_DESCRIPTOR * result = NULL;
4586:                    USB_ENDPOINT_DESCRIPTOR * matchDescriptor = NULL;
4587:                    uint8_t * search;
4588:                    int bNumEndPoints, iterator;
4589:                    USB_DESCRIPTOR_HEADER * descriptorHeader;
4590:                    USB_HOST_ENDPOINT_QUERY_FLAG matchedCriteria = 0;
4591:                    uint8_t * lastLocation;
4592:                
4593:                    /* Validate input parameters */
4594:                
4595:                    if((interface == NULL) || (query == NULL))
9D005478  1080004A   BEQ A0, ZERO, 0x9D0055A4
9D00547C  00809821   ADDU S3, A0, ZERO
9D005480  10A0004A   BEQ A1, ZERO, 0x9D0055AC
9D005484  00A08821   ADDU S1, A1, ZERO
4596:                    {
4597:                        result = NULL;
9D0055A4  0B40156E   J 0x9D0055B8
9D0055A8  00001021   ADDU V0, ZERO, ZERO
9D0055AC  0B40156E   J 0x9D0055B8
9D0055B0  00001021   ADDU V0, ZERO, ZERO
9D0055B4  00001021   ADDU V0, ZERO, ZERO
4598:                    }
4599:                    else
4600:                    {
4601:                        /* Get the number of endpoints in this interface. If the context is
4602:                         * already equal pointing to the last endpoint in this interface then
4603:                         * we don't have anything to search. */
4604:                
4605:                        bNumEndPoints = interface->bNumEndPoints;
9D005488  90900004   LBU S0, 4(A0)
4606:                        if(bNumEndPoints == query->context)
9D00548C  8CB20010   LW S2, 16(A1)
9D005490  52120049   BEQL S0, S2, 0x9D0055B8
9D005494  00001021   ADDU V0, ZERO, ZERO
4607:                        {
4608:                            result = NULL;
4609:                        }
4610:                        else
4611:                        {
4612:                            /* This means parameters are valid. Irrespective of the context we
4613:                             * always start the search from the start of the interface descriptor. 
4614:                             * The lastLocation will contain the end of the configuration
4615:                             * descriptor address. */
4616:                
4617:                            search = (uint8_t *)(interface);
4618:                            lastLocation = (uint8_t *)(_USB_HOST_FindEndOfDescriptor(search));
9D005498  0F4023B6   JAL _USB_HOST_FindEndOfDescriptor
9D00549C  00000000   NOP
9D0054A0  00402821   ADDU A1, V0, ZERO
4619:                            search += sizeof(USB_INTERFACE_DESCRIPTOR);
4620:                            for(iterator = 0; iterator < bNumEndPoints; iterator++) 
9D0054A4  1A000043   BLEZ S0, 0x9D0055B4
9D0054A8  26620009   ADDIU V0, S3, 9
9D0054AC  00003021   ADDU A2, ZERO, ZERO
9D00558C  24C60001   ADDIU A2, A2, 1
9D005590  00D0182A   SLT V1, A2, S0
9D005594  1460FFC9   BNE V1, ZERO, 0x9D0054BC
9D005598  0045182B   SLTU V1, V0, A1
9D00559C  0B40156E   J 0x9D0055B8
9D0055A0  00001021   ADDU V0, ZERO, ZERO
4621:                            {
4622:                                if(search < lastLocation)
9D0054B8  0045182B   SLTU V1, V0, A1
9D0054BC  50600034   BEQL V1, ZERO, 0x9D005590
9D0054C0  24C60001   ADDIU A2, A2, 1
4623:                                {
4624:                                    /* Clear the matched criteria for  fresh search */
4625:                                    matchedCriteria = 0;
9D0054B4  24090004   ADDIU T1, ZERO, 4
9D005544  01073826   XOR A3, T0, A3
9D005548  00004021   ADDU T0, ZERO, ZERO
9D00554C  0127400A   MOVZ T0, T1, A3
9D005550  01003821   ADDU A3, T0, ZERO
4626:                
4627:                                    descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
4628:                                    while(descriptorHeader->descType != USB_DESCRIPTOR_ENDPOINT)
9D0054B0  24040005   ADDIU A0, ZERO, 5
9D0054C4  90430001   LBU V1, 1(V0)
9D0054C8  10640006   BEQ V1, A0, 0x9D0054E4
9D0054CC  00000000   NOP
9D0054D8  90430001   LBU V1, 1(V0)
9D0054DC  5464FFFD   BNEL V1, A0, 0x9D0054D4
9D0054E0  90430000   LBU V1, 0(V0)
4629:                                    {
4630:                                        /* This means we have found not found an endpoint descriptor
4631:                                         * yet. Continue searching. */
4632:                
4633:                                        search += descriptorHeader->size;
9D0054D0  90430000   LBU V1, 0(V0)
9D0054D4  00431021   ADDU V0, V0, V1
4634:                                        descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
4635:                                    }
4636:                
4637:                                    /* This means we have found an endpoint descriptor */
4638:                                    matchDescriptor = (USB_ENDPOINT_DESCRIPTOR *)(search);
4639:                
4640:                                    /* Check if the query object already covered this in the
4641:                                     * previous search. We will know about this through the context
4642:                                     * */
4643:                
4644:                                    if((query->context > 0) && (iterator <= query->context))
9D0054E4  52400006   BEQL S2, ZERO, 0x9D005500
9D0054E8  8E23000C   LW V1, 12(S1)
9D0054EC  0246182B   SLTU V1, S2, A2
9D0054F0  54600003   BNEL V1, ZERO, 0x9D005500
9D0054F4  8E23000C   LW V1, 12(S1)
4645:                                    {
4646:                                        /* This means this endpoint was searched previously. Update
4647:                                         * search to point to the next descriptor. We should
4648:                                         * continue the search. */
4649:                
4650:                                        search += sizeof(USB_ENDPOINT_DESCRIPTOR);
4651:                                        continue;
9D0054F8  0B401563   J 0x9D00558C
9D0054FC  24420007   ADDIU V0, V0, 7
4652:                
4653:                                    }
4654:                
4655:                                    /* Now check for matching criteria */
4656:                                    if(query->flags & USB_HOST_ENDPOINT_QUERY_BY_ENDPOINT_ADDRESS)
9D005500  30670001   ANDI A3, V1, 1
9D005504  10E0000A   BEQ A3, ZERO, 0x9D005530
9D005508  30680004   ANDI T0, V1, 4
4657:                                    {
4658:                                        /* Check if the endpoint address matches the address */
4659:                                        if(matchDescriptor->bEndpointAddress == query->endpointAddress)
9D00550C  90470002   LBU A3, 2(V0)
9D005510  92230000   LBU V1, 0(S1)
9D005514  54E30004   BNEL A3, V1, 0x9D005528
9D005518  90430000   LBU V1, 0(V0)
4660:                                        {
4661:                                            /* This is a match. Update the context to remember on
4662:                                             * which iteration we matched. End the search. */
4663:                                            query->context = iterator + 1;
9D00551C  24C60001   ADDIU A2, A2, 1
4664:                                            result = matchDescriptor;
4665:                                            break;
9D005520  0B40156E   J 0x9D0055B8
9D005524  AE260010   SW A2, 16(S1)
9D005528  0B401563   J 0x9D00558C
9D00552C  00431021   ADDU V0, V0, V1
4666:                                        }
4667:                                        else
4668:                                        {
4669:                                            search += descriptorHeader->size;
4670:                                        }
4671:                                    }
4672:                                    else
4673:                                    {
4674:                                        if(query->flags & USB_HOST_ENDPOINT_QUERY_BY_DIRECTION)
9D005530  11000008   BEQ T0, ZERO, 0x9D005554
9D005534  00003821   ADDU A3, ZERO, ZERO
4675:                                        {
4676:                                            /* Check if the endpoint direction matches */
4677:                                            if(query->direction == matchDescriptor->dirn)
9D005538  90470002   LBU A3, 2(V0)
9D00553C  7CE701C0   EXT A3, A3, 7, 1
9D005540  8E280008   LW T0, 8(S1)
4678:                                            {
4679:                                                /* Update matchedCriteria. This will help us check
4680:                                                 * if all the query specified criteria have been
4681:                                                 * satisfied. */
4682:                                                matchedCriteria |= USB_HOST_ENDPOINT_QUERY_BY_DIRECTION;
4683:                                            }
4684:                                        }
4685:                
4686:                                        if(query->flags & USB_HOST_ENDPOINT_QUERY_BY_TRANSFER_TYPE)
9D005554  30680002   ANDI T0, V1, 2
9D005558  11000006   BEQ T0, ZERO, 0x9D005574
9D00555C  34E80002   ORI T0, A3, 2
4687:                                        {
4688:                                            /* Check if the endpoint direction matches */
4689:                                            if(query->transferType == matchDescriptor->transferType)
9D005560  904A0003   LBU T2, 3(V0)
9D005564  314A0003   ANDI T2, T2, 3
9D005568  8E2B0004   LW T3, 4(S1)
4690:                                            {
4691:                                                /* Update matchedCriteria. This will help us check
4692:                                                 * if all the query specified criteria have been
4693:                                                 * satisfied. */
4694:                                                matchedCriteria |= USB_HOST_ENDPOINT_QUERY_BY_TRANSFER_TYPE;
9D00556C  016A5026   XOR T2, T3, T2
9D005570  010A380A   MOVZ A3, T0, T2
4695:                                            }
4696:                                        }          
4697:                
4698:                                        if(matchedCriteria == query->flags)
9D005574  54E30004   BNEL A3, V1, 0x9D005588
9D005578  90430000   LBU V1, 0(V0)
4699:                                        {
4700:                                            /* This means all the criteria matched. We can end the
4701:                                             * search. */
4702:                
4703:                                            query->context = iterator + 1;
9D00557C  24C60001   ADDIU A2, A2, 1
4704:                                            result = matchDescriptor;
4705:                                            break;
9D005580  0B40156E   J 0x9D0055B8
9D005584  AE260010   SW A2, 16(S1)
4706:                                        }
4707:                                        else
4708:                                        {
4709:                                            /* This is not the endpoint descriptor. Advance the 
4710:                                             * search. */
4711:                                            search += descriptorHeader->size;
9D005588  00431021   ADDU V0, V0, V1
4712:                                        }
4713:                                    }
4714:                                }
4715:                                else
4716:                                {
4717:                                    /* This means we have reached the end of the descriptor. The
4718:                                     * search should stop. */
4719:                                }
4720:                            }
4721:                        } 
4722:                    }
4723:                    
4724:                    return(result);
4725:                }
9D0055B8  8FBF0024   LW RA, 36(SP)
4726:                
4727:                // *****************************************************************************
4728:                /* Function:
4729:                    USB_INTERFACE_DESCRIPTOR * USB_HOST_DeviceInterfaceDescriptorQuery
4730:                    (
4731:                        USB_CONFIGURATION_DESCRIPTOR * configuration
4732:                        USB_HOST_DESCRIPTOR_QUERY * query,
4733:                    );
4734:                
4735:                  Summary:
4736:                    Queries the active configuration for the specified interface.
4737:                
4738:                  Description:
4739:                    This function queries the active configuration for the specified interface
4740:                    and returns a pointer to the interface descriptor if found. The return
4741:                    pointer will point to the standard interface descriptor and class specific
4742:                    interface descriptors for that interface. The search criteria can specified
4743:                    by using the flags. 
4744:                    
4745:                    In a case where the interface has more than one alternate settings, the
4746:                    function can be called repetitively to continue the search till the end of the
4747:                    configuration descriptor is reached or till the search fails. The query flag
4748:                    in such should be set to ignore the alternate setting field.  The query
4749:                    object maintains the last point where the search was successful and
4750:                    continues the search from that point onwards. Resetting the query object
4751:                    (through the USB_HOST_QueryClear) function will reset the search object and
4752:                    cause the search to start from the top of the configuration descriptor.
4753:                
4754:                  Remarks:
4755:                    Refer to usb_host_client_driver.h for usage information.
4756:                */
4757:                
4758:                
4759:                USB_INTERFACE_DESCRIPTOR * USB_HOST_DeviceInterfaceDescriptorQuery
4760:                (
4761:                    USB_CONFIGURATION_DESCRIPTOR * configuration,
4762:                    USB_HOST_INTERFACE_DESCRIPTOR_QUERY * query
4763:                )
4764:                {
4765:                    USB_INTERFACE_DESCRIPTOR * result = NULL;
9D005B2C  03E00008   JR RA
9D005B30  00001021   ADDU V0, ZERO, ZERO
9D005B34  03E00008   JR RA
9D005B38  00001021   ADDU V0, ZERO, ZERO
4766:                    USB_INTERFACE_DESCRIPTOR * matchedInterface;
4767:                    USB_DESCRIPTOR_HEADER * descriptorHeader;
4768:                    uint16_t wTotalLength; 
4769:                    uint8_t * search;
4770:                
4771:                    USB_HOST_INTERFACE_QUERY_FLAG matchedCriteria = 0;
4772:                
4773:                    if((NULL == configuration) || (NULL == query))
9D005A00  1080004A   BEQ A0, ZERO, 0x9D005B2C
9D005A04  00000000   NOP
9D005A08  10A0004A   BEQ A1, ZERO, 0x9D005B34
9D005A0C  24060004   ADDIU A2, ZERO, 4
4774:                    {
4775:                        /* Input parameter are NULL. Nothing to do here as the result is already
4776:                         * set to NULL. */
4777:                    }
4778:                    else
4779:                    {
4780:                        /* Input parameters are valid. Get the number of interfaces in this
4781:                         * configuration. This number does not include number of alternate
4782:                         * settings. The search must start after the configuration descriptor
4783:                         * header. */
4784:                
4785:                        wTotalLength = configuration->wTotalLength;
9D005A10  90820002   LBU V0, 2(A0)
9D005A14  90830003   LBU V1, 3(A0)
9D005A18  00031A00   SLL V1, V1, 8
9D005A1C  00621825   OR V1, V1, V0
4786:                        search = (uint8_t *)(configuration) + sizeof(USB_CONFIGURATION_DESCRIPTOR);
9D005A20  24820009   ADDIU V0, A0, 9
4787:                
4788:                        /* Keep searching till we have reached the end of the configuration
4789:                         * descriptor or we have found a match */
4790:                        while(search < ((uint8_t *)(configuration) + wTotalLength))
9D005A24  0B4016C6   J 0x9D005B18
9D005A28  00832021   ADDU A0, A0, V1
9D005B18  0044182B   SLTU V1, V0, A0
9D005B1C  1060000B   BEQ V1, ZERO, 0x9D005B4C
9D005B20  00000000   NOP
4791:                        {
4792:                            /* Search for an interface descriptor */
4793:                            descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
4794:                            
4795:                            /* The matchedCriteria bitmap must be cleared before every search */
4796:                            matchedCriteria = 0;
4797:                            
4798:                            while(descriptorHeader->descType != USB_DESCRIPTOR_INTERFACE)
9D005A3C  90430001   LBU V1, 1(V0)
9D005A40  5466FFFA   BNEL V1, A2, 0x9D005A2C
9D005A44  90430000   LBU V1, 0(V0)
9D005B24  0B401690   J 0x9D005A40
9D005B28  90430001   LBU V1, 1(V0)
4799:                            {
4800:                                search += descriptorHeader->size;
9D005A2C  00431021   ADDU V0, V0, V1
4801:                                descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
4802:                                
4803:                                /* Its possible we may reach the end of the configuration 
4804:                                 * descriptor here. So lets check to make sure we have a
4805:                                 * bounded check. */
4806:                                
4807:                                if(search >= ((uint8_t *)(configuration) + wTotalLength))
9D005A30  0044182B   SLTU V1, V0, A0
9D005A34  10600041   BEQ V1, ZERO, 0x9D005B3C
9D005A38  00000000   NOP
4808:                                {
4809:                                    /* We are at the end of the configuration descriptor. */
4810:                                    search = NULL;
4811:                                    break;
4812:                                }
4813:                            }
4814:                            
4815:                            if(search == NULL)
9D005A48  1040003E   BEQ V0, ZERO, 0x9D005B44
9D005A4C  00403821   ADDU A3, V0, ZERO
4816:                            {
4817:                                /* This means the above search loop reached the end of the 
4818:                                 * configuration descriptor. */
4819:                                result = NULL;
9D005B3C  03E00008   JR RA
9D005B40  00001021   ADDU V0, ZERO, ZERO
9D005B44  03E00008   JR RA
9D005B48  00000000   NOP
4820:                                break;
4821:                            }
4822:                
4823:                            /* This means we have found an interface descriptor. If the
4824:                             * query context (which is the location of the last search) is
4825:                             * greater than the current search location, this means this
4826:                             * interface was already covered in the previous search */
4827:                
4828:                            if(search <= (uint8_t *)(query->context))
9D005A50  8CA3000C   LW V1, 12(A1)
9D005A54  0062182B   SLTU V1, V1, V0
9D005A58  54600004   BNEL V1, ZERO, 0x9D005A6C
9D005A5C  8CA80008   LW T0, 8(A1)
4829:                            {
4830:                                /* This result was already obtained in the previous search. We
4831:                                 * must continue the search. */
4832:                
4833:                                search += descriptorHeader->size;
9D005A60  90420000   LBU V0, 0(V0)
4834:                                continue;
9D005A64  0B4016C6   J 0x9D005B18
9D005A68  00E21021   ADDU V0, A3, V0
4835:                            }
4836:                
4837:                            /* We can now start match the interface to the query */
4838:                            matchedInterface = (USB_INTERFACE_DESCRIPTOR *)(search);
4839:                
4840:                            if(query->flags & USB_HOST_INTERFACE_QUERY_BY_NUMBER)
9D005A6C  31090001   ANDI T1, T0, 1
9D005A70  11200005   BEQ T1, ZERO, 0x9D005A88
9D005A74  00001821   ADDU V1, ZERO, ZERO
4841:                            {
4842:                                /* Check if the interface number matches the specified interface
4843:                                 * number */
4844:                                if(matchedInterface->bInterfaceNumber == query->bInterfaceNumber)
9D005A78  90490002   LBU T1, 2(V0)
9D005A7C  90A30000   LBU V1, 0(A1)
9D005A80  01231826   XOR V1, T1, V1
9D005A84  2C630001   SLTIU V1, V1, 1
4845:                                {
4846:                                    matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_NUMBER;
4847:                                }
4848:                            }
4849:                
4850:                            if(query->flags & USB_HOST_INTERFACE_QUERY_ALT_SETTING)
9D005A88  31090002   ANDI T1, T0, 2
9D005A8C  11200007   BEQ T1, ZERO, 0x9D005AAC
9D005A90  31090004   ANDI T1, T0, 4
4851:                            {
4852:                                /* Check if the alternate number matches the specified alternate
4853:                                 * setting */
4854:                                if(matchedInterface->bAlternateSetting == query->bAlternateSetting)
9D005A94  90EB0003   LBU T3, 3(A3)
9D005A98  90AA0001   LBU T2, 1(A1)
4855:                                {
4856:                                    matchedCriteria |= USB_HOST_INTERFACE_QUERY_ALT_SETTING;
9D005A9C  34690002   ORI T1, V1, 2
9D005AA0  016A5026   XOR T2, T3, T2
9D005AA4  012A180A   MOVZ V1, T1, T2
4857:                                }
4858:                            }
4859:                
4860:                            if(query->flags & USB_HOST_INTERFACE_QUERY_BY_CLASS)
9D005AA8  31090004   ANDI T1, T0, 4
9D005AAC  11200007   BEQ T1, ZERO, 0x9D005ACC
9D005AB0  31090008   ANDI T1, T0, 8
4861:                            {
4862:                                /* Check if the class of the interface matches the specified
4863:                                 * class. */
4864:                                 if(query->bInterfaceClass == matchedInterface->bInterfaceClass)
9D005AB4  90AB0002   LBU T3, 2(A1)
9D005AB8  90EA0005   LBU T2, 5(A3)
4865:                                 {
4866:                                     matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_CLASS;
9D005ABC  34690004   ORI T1, V1, 4
9D005AC0  016A5026   XOR T2, T3, T2
9D005AC4  012A180A   MOVZ V1, T1, T2
4867:                                 }
4868:                            }
4869:                
4870:                            if(query->flags & USB_HOST_INTERFACE_QUERY_BY_SUBCLASS)
9D005AC8  31090008   ANDI T1, T0, 8
9D005ACC  11200007   BEQ T1, ZERO, 0x9D005AEC
9D005AD0  31090010   ANDI T1, T0, 16
4871:                            {
4872:                                /* Check if the interface subclass matches the specified
4873:                                 * interface subclass */
4874:                                if(matchedInterface->bInterfaceSubClass == query->bInterfaceSubClass)
9D005AD4  90EB0006   LBU T3, 6(A3)
9D005AD8  90AA0003   LBU T2, 3(A1)
4875:                                {
4876:                                    matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_SUBCLASS;
9D005ADC  34690008   ORI T1, V1, 8
9D005AE0  016A5026   XOR T2, T3, T2
9D005AE4  012A180A   MOVZ V1, T1, T2
4877:                                }
4878:                            }
4879:                
4880:                            if(query->flags & USB_HOST_INTERFACE_QUERY_BY_PROTOCOL)
9D005AE8  31090010   ANDI T1, T0, 16
9D005AEC  11200005   BEQ T1, ZERO, 0x9D005B04
9D005AF0  34690010   ORI T1, V1, 16
4881:                            {
4882:                                /* Check if the interface protocol matches the specified
4883:                                 * interface protocol. */
4884:                                if(matchedInterface->bInterfaceProtocol == query->bInterfaceProtocol)
9D005AF4  90EB0007   LBU T3, 7(A3)
9D005AF8  90AA0004   LBU T2, 4(A1)
4885:                                {
4886:                                    matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_PROTOCOL;
9D005AFC  016A5026   XOR T2, T3, T2
9D005B00  012A180A   MOVZ V1, T1, T2
4887:                                }
4888:                            }
4889:                
4890:                            if(matchedCriteria == query->flags)
9D005B04  54680003   BNEL V1, T0, 0x9D005B14
9D005B08  90E20000   LBU V0, 0(A3)
4891:                            {
4892:                                /* This means we have matched the specified criteria. Save the
4893:                                 * location of the match and then stop searching. */
4894:                                
4895:                                query->context = (uintptr_t)(search);
4896:                                result = matchedInterface;
4897:                                break;
9D005B0C  03E00008   JR RA
9D005B10  ACA2000C   SW V0, 12(A1)
4898:                            }
4899:                            else
4900:                            {
4901:                                /* Did not match the query criteria. */
4902:                                search += descriptorHeader->size;
9D005B14  00E21021   ADDU V0, A3, V0
4903:                                continue;
4904:                            }
4905:                        }
4906:                    }
4907:                    
4908:                    return(result);
4909:                }
9D005B4C  03E00008   JR RA
4910:                
4911:                // *****************************************************************************
4912:                /* Function:
4913:                    void USB_HOST_DeviceEndpointQueryClear
4914:                    (
4915:                        USB_HOST_INTERFACE_DESCRIPTOR_QUERY * query
4916:                    );
4917:                
4918:                  Summary:
4919:                    Clear the query object.
4920:                
4921:                  Description:
4922:                    This function clears the query object context. Using the query after it has
4923:                    been clear will cause the USB_HOST_DeviceEndpointDescriptorQuery() and
4924:                    function to reset the search location to the start of the configuration
4925:                    descriptor.
4926:                
4927:                  Remarks
4928:                    Refer to usb_host_client_driver.h for usage details.
4929:                */
4930:                
4931:                void USB_HOST_DeviceEndpointQueryContextClear
4932:                (
4933:                    USB_HOST_ENDPOINT_DESCRIPTOR_QUERY * query
4934:                )
4935:                {
4936:                    if(NULL != query)
9D009AC0  54800001   BNEL A0, ZERO, 0x9D009AC8
4937:                    {
4938:                        /* Reset the context to 0 */
4939:                        query->context = 0;
9D003DE0  AFA00038   SW ZERO, 56(SP)
4940:                    }
4941:                }
4942:                
4943:                // *****************************************************************************
4944:                /* Function:
4945:                    void USB_HOST_DeviceInterfaceQueryContextClear
4946:                    (
4947:                        USB_HOST_INTERFACE_DESCRIPTOR_QUERY * query
4948:                    );
4949:                
4950:                  Summary:
4951:                    Clear the query object.
4952:                
4953:                  Description:
4954:                    This function clears the query object context. Using the query after it has
4955:                    been clear will cause the USB_HOST_DeviceInterfaceDescriptorQuery() and
4956:                    function to reset the search location to the start of the configuration
4957:                    descriptor.
4958:                
4959:                  Remarks:
4960:                    Refer to usb_host_client_driver.h for usage details.
4961:                */    
4962:                
4963:                void USB_HOST_DeviceInterfaceQueryContextClear
4964:                (
4965:                    USB_HOST_INTERFACE_DESCRIPTOR_QUERY * query
4966:                )
4967:                {
4968:                    if(NULL != query)
9D009AD0  54800001   BNEL A0, ZERO, 0x9D009AD8
4969:                    {
4970:                        /* Reset the context to 0 */
4971:                        query->context = 0;
9D003DB4  AFA00048   SW ZERO, 72(SP)
9D0058E4  AFA0001C   SW ZERO, 28(SP)
4972:                    }
4973:                } 
4974:                
4975:                // *****************************************************************************
4976:                /* Function:
4977:                    USB_HOST_CONTROL_PIPE_HANDLE USB_HOST_DeviceControlPipeOpen
4978:                    (
4979:                        USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle
4980:                    );
4981:                
4982:                  Summary:
4983:                    Open a control transfer pipe to the device.
4984:                
4985:                  Description:
4986:                    This function opens a control transfer pipe to the device. The return control
4987:                    pipe handle can be used in the USB_HOST_DeviceControlTransfer() function to
4988:                    schedule control transfers to the device.
4989:                
4990:                  Remarks:
4991:                    Refer to usb_host_client_driver.h for usage information.
4992:                */
4993:                
4994:                USB_HOST_CONTROL_PIPE_HANDLE USB_HOST_DeviceControlPipeOpen
4995:                (
4996:                    USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle
4997:                )
4998:                {
9D009344  308300FF   ANDI V1, A0, 255
4999:                    uint8_t deviceIndex ;
5000:                    uint16_t pnpIdentifier;
5001:                    USB_HOST_DEVICE_OBJ  * deviceObj;
5002:                    USB_HOST_CONTROL_PIPE_HANDLE  controlPipeHandle = USB_HOST_CONTROL_PIPE_HANDLE_INVALID;
9D00937C  00042402   SRL A0, A0, 16
9D009380  2403FFFF   ADDIU V1, ZERO, -1
9D009384  0064100B   MOVN V0, V1, A0
5003:                
5004:                    /* Get the device object index from the device object handle */
5005:                    deviceIndex =  USB_HOST_DEVICE_INDEX( deviceObjHandle );
5006:                
5007:                    /* Get a pointer to the device object */
5008:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
9D009348  00032900   SLL A1, V1, 4
9D00934C  00031180   SLL V0, V1, 6
9D009350  00451023   SUBU V0, V0, A1
9D009354  000218C0   SLL V1, V0, 3
9D009358  00431021   ADDU V0, V0, V1
9D00935C  3C03A000   LUI V1, -24576
9D009360  24636388   ADDIU V1, V1, 25480
9D009364  00621821   ADDU V1, V1, V0
5009:                
5010:                    if(deviceObj->inUse)
9D009368  90650000   LBU A1, 0(V1)
9D00936C  10A00006   BEQ A1, ZERO, 0x9D009388
9D009370  2402FFFF   ADDIU V0, ZERO, -1
5011:                    {
5012:                        /* This means the device object is valid. Now check the plugNplay
5013:                         * identifier to make sure that device object handle is not stale */
5014:                
5015:                        pnpIdentifier = USB_HOST_PNP_IDENTIFIER(deviceObjHandle);
5016:                
5017:                        if(pnpIdentifier == USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
9D009374  8C62004C   LW V0, 76(V1)
9D009378  00442026   XOR A0, V0, A0
5018:                        {
5019:                            /* The plugNplay identifier matches the one that device object
5020:                             * contains. The control pipe handle is the same as the device
5021:                             * object handle */
5022:                
5023:                            controlPipeHandle = (USB_HOST_CONTROL_PIPE_HANDLE)(deviceObj->deviceIdentifier);
5024:                        }
5025:                    }
5026:                
5027:                    return controlPipeHandle;
5028:                }
9D009388  03E00008   JR RA
5029:                
5030:                // *****************************************************************************
5031:                /* Function:
5032:                    USB_HOST_RESULT USB_HOST_DeviceInterfaceRelease
5033:                    (
5034:                        USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle,
5035:                    );
5036:                
5037:                  Summary:
5038:                    Releases an interface on the specified device.
5039:                
5040:                  Description:
5041:                    This function allows the application to release a claimed interface on the
5042:                    specified device and within the selected configuration on that device.
5043:                
5044:                  Remarks:
5045:                    Refer to usb_host_client_driver.h for usage information.
5046:                 */
5047:                
5048:                USB_HOST_RESULT USB_HOST_DeviceInterfaceRelease
5049:                (
5050:                    USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle
5051:                )
5052:                {
5053:                    int deviceIndex;
5054:                    int interfaceIndex;
5055:                    unsigned int pnpIdentifier;
5056:                    USB_HOST_RESULT result;
5057:                    USB_HOST_DEVICE_OBJ * deviceObj;
5058:                    USB_HOST_INTERFACE_DESC_INFO * interfaceInfo;
5059:                   
5060:                    
5061:                    deviceIndex = USB_HOST_DEVICE_INDEX(interfaceHandle);
9D0086EC  308400FF   ANDI A0, A0, 255
5062:                    interfaceIndex = USB_HOST_INTERFACE_INDEX(interfaceHandle);
9D0086E4  7C863A00   EXT A2, A0, 8, 8
5063:                    pnpIdentifier = USB_HOST_PNP_IDENTIFIER(interfaceHandle);
9D0086E8  00042C02   SRL A1, A0, 16
5064:                    
5065:                    /* Get the device object */
5066:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
9D0086F0  00041900   SLL V1, A0, 4
9D0086F4  00042180   SLL A0, A0, 6
9D0086F8  00832023   SUBU A0, A0, V1
9D0086FC  000410C0   SLL V0, A0, 3
9D008700  00822021   ADDU A0, A0, V0
9D008704  3C02A000   LUI V0, -24576
9D008708  24426388   ADDIU V0, V0, 25480
9D00870C  00441021   ADDU V0, V0, A0
5067:                    
5068:                    if(!deviceObj->inUse)
9D008710  90430000   LBU V1, 0(V0)
9D008714  1060000D   BEQ V1, ZERO, 0x9D00874C
9D008718  00000000   NOP
5069:                    {
5070:                        /* This device object is not in use. May have been disconnected */
5071:                        result = USB_HOST_RESULT_DEVICE_UNKNOWN;
9D00874C  03E00008   JR RA
9D008750  2402FFA7   ADDIU V0, ZERO, -89
5072:                    }
5073:                    else 
5074:                    {
5075:                        if(pnpIdentifier != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
9D00871C  9443004E   LHU V1, 78(V0)
9D008720  1465000C   BNE V1, A1, 0x9D008754
9D008724  24C60008   ADDIU A2, A2, 8
5076:                        {
5077:                            /* This device is not the same that client driver thinks it is */
5078:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
9D008754  03E00008   JR RA
9D008758  2402FFA7   ADDIU V0, ZERO, -89
5079:                        }
5080:                        else
5081:                        {
5082:                            interfaceInfo = &deviceObj->configDescriptorInfo.interfaceInfo[interfaceIndex];
9D008728  00063140   SLL A2, A2, 5
9D00872C  00461021   ADDU V0, V0, A2
9D008730  24430004   ADDIU V1, V0, 4
5083:                            if(interfaceInfo->interfaceDescriptor == NULL)
9D008734  8C420004   LW V0, 4(V0)
9D008738  10400008   BEQ V0, ZERO, 0x9D00875C
9D00873C  00000000   NOP
5084:                            {
5085:                                /* This means that the interface is not valid */
5086:                                result = USB_HOST_RESULT_INTERFACE_UNKNOWN;
5087:                            }
5088:                            else
5089:                            {
5090:                                /* Release the interface */
5091:                                interfaceInfo->interfaceDriver = NULL;
9D008740  AC600008   SW ZERO, 8(V1)
5092:                                result = USB_HOST_RESULT_SUCCESS;
9D008744  03E00008   JR RA
9D008748  24020001   ADDIU V0, ZERO, 1
5093:                            }
5094:                        }
5095:                    }    
5096:                        
5097:                    return(result);
5098:                }
9D00875C  03E00008   JR RA
5099:                
5100:                // *****************************************************************************
5101:                /* Function:
5102:                    void USB_HOST_DeviceTransfer
5103:                    ( 
5104:                        USB_HOST_PIPE_HANDLE pipeHandle
5105:                        USB_HOST_TRANSFER_HANDLE * transferHandle,
5106:                        void * data,
5107:                        size_t size,
5108:                        uintptr_t context
5109:                    );
5110:                
5111:                  Summary:
5112:                    Schedules a bulk, interrupt or isochronous transfer.
5113:                
5114:                  Description:
5115:                    This function schedules a bulk, interrupt or isochronous. pipeHandle
5116:                    contains a handle to a bulk, interrupt or isochronous pipe obtained through
5117:                    the USB_HOST_DevicePipeOpen() function .
5118:                    
5119:                    If the transfer was scheduled successfully, transferHandle will contain a
5120:                    transfer handle that uniquely identifies this transfer. If the transfer
5121:                    could not be scheduled successfully, transferHandle will contain
5122:                    USB_HOST_TRANSFER_HANDLE_INVALID.  
5123:                
5124:                    Multiple transfers can be queued. These transfers will be processed in the
5125:                    order they were scheduled. The host layer will called the interfaceEvent
5126:                    event handler with USB_HOST_DEVICE_INTERFACE_EVENT_TRANSFER_COMPLETE_DATA
5127:                    when the transfer completes.
5128:                
5129:                  Remarks
5130:                    Refer to usb_host_client_driver.h for usage information.
5131:                */
5132:                
5133:                USB_HOST_RESULT USB_HOST_DeviceTransfer
5134:                (
5135:                    USB_HOST_PIPE_HANDLE pipeHandle,
5136:                    USB_HOST_TRANSFER_HANDLE * transferHandle,
5137:                    void * data,
5138:                    size_t size,
5139:                    uintptr_t context
5140:                )
5141:                {
9D0043C4  27BDFFD0   ADDIU SP, SP, -48
9D0043C8  AFBF002C   SW RA, 44(SP)
9D0043CC  AFB60028   SW S6, 40(SP)
9D0043D0  AFB50024   SW S5, 36(SP)
9D0043D4  AFB40020   SW S4, 32(SP)
9D0043D8  AFB3001C   SW S3, 28(SP)
9D0043DC  AFB20018   SW S2, 24(SP)
9D0043E0  AFB10014   SW S1, 20(SP)
9D0043E4  AFB00010   SW S0, 16(SP)
5142:                    uint8_t deviceIndex;
5143:                    uint8_t interfaceIndex;
5144:                    USB_HOST_DEVICE_OBJ *deviceObj;
5145:                    USB_HOST_TRANSFER_OBJ * transferObj = NULL;
9D0044CC  0000B021   ADDU S6, ZERO, ZERO
5146:                    USB_HOST_PIPE_OBJ *pipeObj;
5147:                    DRV_USB_HOST_PIPE_HANDLE drvPipeHandle;
5148:                    USB_HOST_INTERFACE_DESC_INFO *interfaceInfo;
5149:                    USB_HOST_RESULT result = USB_HOST_RESULT_SUCCESS ;
5150:                    OSAL_RESULT osalResult;
5151:                    USB_HOST_OBJ * hostObj;
5152:                    int search;
5153:                
5154:                    if(NULL == transferHandle)
9D0043E8  10A0005C   BEQ A1, ZERO, 0x9D00455C
9D0043EC  00A08021   ADDU S0, A1, ZERO
5155:                    {
5156:                        /* transferHandle cannot be NULL */
5157:                        result = USB_HOST_RESULT_PARAMETER_INVALID;
9D00455C  0B401167   J 0x9D00459C
9D004560  2403FFA3   ADDIU V1, ZERO, -93
5158:                    }
5159:                    else
5160:                    {
5161:                        /* Initialize transfer handle in anticipation of an error */
5162:                        *transferHandle = USB_HOST_TRANSFER_HANDLE_INVALID;
9D0043F0  2402FFFF   ADDIU V0, ZERO, -1
5163:                
5164:                        if(USB_HOST_PIPE_HANDLE_INVALID == pipeHandle)
9D0043F4  1082005B   BEQ A0, V0, 0x9D004564
9D0043F8  ACA20000   SW V0, 0(A1)
9D0043FC  00C09821   ADDU S3, A2, ZERO
5165:                        {
5166:                            /* Pipe handle is not valid */
5167:                            result = USB_HOST_RESULT_PIPE_HANDLE_INVALID;
9D004564  0B401167   J 0x9D00459C
9D004568  2403FFA0   ADDIU V1, ZERO, -96
5168:                        }
5169:                        else if ((size != 0) && (NULL == data))
9D004400  10E00003   BEQ A3, ZERO, 0x9D004410
9D004404  00E08821   ADDU S1, A3, ZERO
9D004408  10C00064   BEQ A2, ZERO, 0x9D00459C
9D00440C  2403FFA3   ADDIU V1, ZERO, -93
5170:                        {
5171:                            /* If size is greater than 0, then data cannot be NULL */
5172:                            result = USB_HOST_RESULT_PARAMETER_INVALID;
5173:                        }
5174:                        else
5175:                        {
5176:                            /* Pointer to the host layer object */
5177:                            hostObj = &gUSBHostObj;
5178:                
5179:                            /* pipeHandle is pointer to the pipe object */
5180:                            pipeObj = (USB_HOST_PIPE_OBJ *)(pipeHandle);
5181:                
5182:                            /* The pipeObj contains the handle to the interface that this pipe
5183:                             * belongs to. The interface handle contains the index of the owner
5184:                             * device. We need this owner device index so that we can get the
5185:                             * pointer to the HCD functions. */
5186:                
5187:                            deviceIndex =  USB_HOST_DEVICE_INDEX( pipeObj->interfaceHandle );
9D004410  8C820004   LW V0, 4(A0)
9D004414  304500FF   ANDI A1, V0, 255
5188:                            interfaceIndex =  USB_HOST_INTERFACE_INDEX ( pipeObj->interfaceHandle );
5189:                            deviceObj = &gUSBHostDeviceList[deviceIndex];
9D004418  00053100   SLL A2, A1, 4
9D00441C  00051980   SLL V1, A1, 6
9D004420  00661823   SUBU V1, V1, A2
9D004424  000390C0   SLL S2, V1, 3
9D004428  00721821   ADDU V1, V1, S2
9D00442C  3C12A000   LUI S2, -24576
9D004430  26526388   ADDIU S2, S2, 25480
9D004434  02439021   ADDU S2, S2, V1
9D004438  7C543A00   EXT S4, V0, 8, 8
5190:                            interfaceInfo = &(deviceObj->configDescriptorInfo.interfaceInfo[interfaceIndex]);
9D00443C  26940008   ADDIU S4, S4, 8
9D004440  0014A140   SLL S4, S4, 5
9D004444  0254A021   ADDU S4, S2, S4
9D004448  26940004   ADDIU S4, S4, 4
5191:                
5192:                            /* Get the driver pipe handle */
5193:                            drvPipeHandle = pipeObj->pipeHandle ;
9D00444C  8C950008   LW S5, 8(A0)
5194:                
5195:                            /* We need to now search for a free transfer object. It is possible that
5196:                             * the USB_HOST_DeviceTransfer() function will be called from the
5197:                             * transfer event. It is also possible that this function is called from
5198:                             * another thread. We will use a mutual exclusion to protect the transfer
5199:                             * object pool. But the mutual exclusion should be take only if the host if
5200:                             * this function is not being called in an interrupt context.*/
5201:                
5202:                            if(!hostObj->isInInterruptContext)
9D004450  3C02A000   LUI V0, -24576
9D004454  24426738   ADDIU V0, V0, 26424
9D004458  90420017   LBU V0, 23(V0)
9D00445C  304200FF   ANDI V0, V0, 255
9D004460  14400044   BNE V0, ZERO, 0x9D004574
9D004464  3C02A000   LUI V0, -24576
5203:                            {
5204:                                /* We can take mutual exclusion only if we are not in interrupt context */
5205:                                osalResult = OSAL_MUTEX_Lock(&hostObj->mutexTransferObj, OSAL_WAIT_FOREVER);
5206:                            }
5207:                            else
5208:                            {
5209:                                /* We are in interrupt context. So the rest of the code flow
5210:                                 * should continue. */
5211:                                osalResult = OSAL_RESULT_TRUE;
5212:                            }
5213:                
5214:                            /* The execution reaches this point (in an RTOS setting) if the
5215:                             * mutual exclusion lock was taken, or if the mutual exclusion failed. We must disable all
5216:                             * root hub events so this operation is atomic */
5217:                            
5218:                            if(osalResult == OSAL_RESULT_TRUE)
5219:                            {
5220:                                _USB_HOST_RootHubEventDisable();
9D004574  0F402591   JAL _USB_HOST_RootHubEventDisable
9D004578  00000000   NOP
5221:                                
5222:                                for(search = 0; search < USB_HOST_TRANSFERS_NUMBER; search ++)
9D004498  00001021   ADDU V0, ZERO, ZERO
9D0044C4  1444FFEF   BNE V0, A0, 0x9D004484
9D0044C8  24630044   ADDIU V1, V1, 68
9D004590  24020001   ADDIU V0, ZERO, 1
9D004594  0B401121   J 0x9D004484
9D004598  2404000A   ADDIU A0, ZERO, 10
5223:                                {
5224:                                    if(!gUSBHostTransferObj[search].inUse)
9D004484  90680000   LBU T0, 0(V1)
9D004488  5500000E   BNEL T0, ZERO, 0x9D0044C4
9D00448C  24420001   ADDIU V0, V0, 1
9D00457C  3C02A000   LUI V0, -24576
9D004580  90426040   LBU V0, 24640(V0)
9D004584  1040FFC4   BEQ V0, ZERO, 0x9D004498
9D004588  3C03A000   LUI V1, -24576
9D00458C  24636084   ADDIU V1, V1, 24708
5225:                                    {
5226:                                        /* We found a transfer object. Allocate it and then update
5227:                                         * the transfer handle. */
5228:                
5229:                                        transferObj = &gUSBHostTransferObj[search];
9D004490  0B401128   J 0x9D0044A0
9D004494  0002B080   SLL S6, V0, 2
9D00449C  0002B080   SLL S6, V0, 2
9D0044A0  00021180   SLL V0, V0, 6
9D0044A4  02C21021   ADDU V0, S6, V0
9D0044A8  3C16A000   LUI S6, -24576
9D0044AC  26D66040   ADDIU S6, S6, 24640
9D0044B0  02C2B021   ADDU S6, S6, V0
5230:                                        transferObj->inUse = true;
9D0044B4  24020001   ADDIU V0, ZERO, 1
9D0044B8  A2C20000   SB V0, 0(S6)
5231:                                        *transferHandle = (USB_HOST_TRANSFER_HANDLE)(transferObj);
5232:                                            break;
9D0044BC  0B401134   J 0x9D0044D0
9D0044C0  AE160000   SW S6, 0(S0)
5233:                                    }
5234:                                }
5235:                                
5236:                                _USB_HOST_RootHubEventEnable();
9D0044D0  0F4025C6   JAL _USB_HOST_RootHubEventEnable
9D0044D4  00000000   NOP
5237:                
5238:                                /* Return the mutual exclusion */
5239:                                if(!hostObj->isInInterruptContext)
9D0044D8  3C02A000   LUI V0, -24576
9D0044DC  24426738   ADDIU V0, V0, 26424
9D0044E0  90420017   LBU V0, 23(V0)
9D0044E4  304200FF   ANDI V0, V0, 255
9D0044E8  54400005   BNEL V0, ZERO, 0x9D004500
9D0044EC  8E030000   LW V1, 0(S0)
5240:                                {
5241:                                    OSAL_MUTEX_Unlock(&(hostObj->mutexTransferObj));
5242:                                }
5243:                
5244:                                if(*transferHandle == USB_HOST_TRANSFER_HANDLE_INVALID)
9D0044FC  8E030000   LW V1, 0(S0)
9D004500  2402FFFF   ADDIU V0, ZERO, -1
9D004504  10620019   BEQ V1, V0, 0x9D00456C
9D004508  3C029D01   LUI V0, -25343
5245:                                {
5246:                                    /* This means we did not find a transfer object */
5247:                                    result = USB_HOST_RESULT_REQUEST_BUSY;
9D00456C  0B401167   J 0x9D00459C
9D004570  2403FF9C   ADDIU V1, ZERO, -100
5248:                                }
5249:                                else
5250:                                {
5251:                                    /* We have found a transfer object. Initialize it */
5252:                
5253:                                    transferObj->irp.data = (void *)data;
9D00450C  AED3000C   SW S3, 12(S6)
5254:                                    transferObj->irp.size = size ;
9D004510  AED10010   SW S1, 16(S6)
5255:                                    transferObj->irp.userData = (uintptr_t)(transferObj);
9D004514  AED6001C   SW S6, 28(S6)
5256:                                    transferObj->irp.callback = _USB_HOST_DataTransferIRPCallback;
9D004518  2442844C   ADDIU V0, V0, -31668
9D00451C  AEC20020   SW V0, 32(S6)
5257:                                    transferObj->context = context;
9D004520  8FA20040   LW V0, 64(SP)
9D004524  AEC20004   SW V0, 4(S6)
5258:                                    transferObj->interfaceInfoObj = interfaceInfo;
9D004528  AED40040   SW S4, 64(S6)
5259:                
5260:                                    /* Try submitting the IRP */
5261:                                    if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( drvPipeHandle, & (transferObj->irp)))
9D00452C  8E42006C   LW V0, 108(S2)
9D004530  8C42000C   LW V0, 12(V0)
9D004534  02A02021   ADDU A0, S5, ZERO
9D004538  0040F809   JALR V0
9D00453C  26C50008   ADDIU A1, S6, 8
9D004540  10400016   BEQ V0, ZERO, 0x9D00459C
9D004544  24030001   ADDIU V1, ZERO, 1
5262:                                    {
5263:                                        /* If the IRP submit was not successful, then return the
5264:                                         * transferObject to the pool and update the result. */
5265:                
5266:                                        result = USB_HOST_RESULT_FAILURE;
9D004554  0B401167   J 0x9D00459C
9D004558  2403FFA8   ADDIU V1, ZERO, -88
5267:                                        *transferHandle = USB_HOST_TRANSFER_HANDLE_INVALID;
9D004548  2402FFFF   ADDIU V0, ZERO, -1
9D00454C  AE020000   SW V0, 0(S0)
5268:                                        transferObj->inUse = false;
9D004550  A2C00000   SB ZERO, 0(S6)
5269:                                    }
5270:                                }
5271:                            }
5272:                            else
5273:                            {
5274:                                /* Could not take the mutual exclusion lock*/
5275:                                result = USB_HOST_RESULT_REQUEST_BUSY;
5276:                            }
5277:                        }
5278:                    }
5279:                
5280:                    return result;
5281:                }
9D00459C  00601021   ADDU V0, V1, ZERO
5282:                
5283:                // *****************************************************************************
5284:                /* Function:
5285:                    USB_HOST_PIPE_HANDLE USB_HOST_DevicePipeOpen 
5286:                    (
5287:                        USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle,
5288:                        USB_ENDPOINT_ADDRESS endpointAddress
5289:                    );
5290:                
5291:                  Summary:
5292:                    Opens a pipe to the specified endpoint.
5293:                
5294:                  Description:
5295:                    This function opens a pipe on the specified endpoint. The pipe parameters
5296:                    will be defined by the endpoint attributes specified in the endpoint
5297:                    descriptor that the attached device reports to the host.
5298:                
5299:                  Remarks:
5300:                    Refer to usb_host_client_driver.h for usage information.
5301:                */
5302:                
5303:                USB_HOST_PIPE_HANDLE USB_HOST_DevicePipeOpen
5304:                (
5305:                    USB_HOST_DEVICE_INTERFACE_HANDLE deviceInterfaceHandle,
5306:                    USB_ENDPOINT_ADDRESS endpointAddress
5307:                )
5308:                {
9D003D5C  27BDFF98   ADDIU SP, SP, -104
9D003D60  AFBF0064   SW RA, 100(SP)
9D003D64  AFB40060   SW S4, 96(SP)
9D003D68  AFB3005C   SW S3, 92(SP)
9D003D6C  AFB20058   SW S2, 88(SP)
9D003D70  AFB10054   SW S1, 84(SP)
9D003D74  AFB00050   SW S0, 80(SP)
9D003D78  00808821   ADDU S1, A0, ZERO
9D003D7C  00A09821   ADDU S3, A1, ZERO
5309:                    uint8_t  interval;
5310:                    uint8_t  pipeNumber;
5311:                    uint32_t deviceIndex;
5312:                    uint8_t  interfaceIndex;
5313:                    uint32_t maxPacketSize;
5314:                
5315:                    USB_HOST_PIPE_HANDLE result;
5316:                    USB_TRANSFER_TYPE transferType;
5317:                    USB_HOST_PIPE_OBJ * pipeObj = NULL;
5318:                    USB_HOST_INTERFACE_DESC_INFO *interfaceInfo;
5319:                    USB_ENDPOINT_DESCRIPTOR * endpointDescriptor;
5320:                    USB_HOST_DEVICE_OBJ  * deviceObj;
5321:                    USB_HOST_ENDPOINT_DESCRIPTOR_QUERY endpointDescQuery;
5322:                    USB_HOST_INTERFACE_DESCRIPTOR_QUERY interfaceQuery;
5323:                    USB_INTERFACE_DESCRIPTOR * interfaceDescriptor;
5324:                
5325:                    /* Get the index of the device from the interface handle. We need this to
5326:                     * get the device object. */
5327:                    deviceIndex =  USB_HOST_DEVICE_INDEX( deviceInterfaceHandle );
9D003D84  308400FF   ANDI A0, A0, 255
5328:                
5329:                    /* Get the index of the interface. We need this to get information about
5330:                     * the endpoint */
5331:                    interfaceIndex =  USB_HOST_INTERFACE_INDEX ( deviceInterfaceHandle );
9D003D80  7C833A00   EXT V1, A0, 8, 8
9D003DB8  A3A3003C   SB V1, 60(SP)
5332:                
5333:                    /* Get the device object because we need the pointer to the HCD pipe open
5334:                     * function. */
5335:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
9D003D88  00042900   SLL A1, A0, 4
9D003D8C  00041180   SLL V0, A0, 6
9D003D90  00451023   SUBU V0, V0, A1
9D003D94  000290C0   SLL S2, V0, 3
9D003D98  00521021   ADDU V0, V0, S2
9D003D9C  3C12A000   LUI S2, -24576
9D003DA0  26526388   ADDIU S2, S2, 25480
9D003DA4  02429021   ADDU S2, S2, V0
5336:                
5337:                    /* Get the interface information object to get the pointer to the interface
5338:                     * descriptor */
5339:                    interfaceInfo = &(deviceObj->configDescriptorInfo.interfaceInfo[interfaceIndex]);
9D003DA8  24620008   ADDIU V0, V1, 8
9D003DAC  00021140   SLL V0, V0, 5
9D003DB0  02421021   ADDU V0, S2, V0
5340:                
5341:                    /* Set default value to return in case of error */
5342:                    result = USB_HOST_PIPE_HANDLE_INVALID;
9D003F2C  0B400FD9   J 0x9D003F64
9D003F30  2410FFFF   ADDIU S0, ZERO, -1
9D003F60  2410FFFF   ADDIU S0, ZERO, -1
5343:                
5344:                    /* We must first find the interface descriptor with the current alternate
5345:                     * setting */
5346:                
5347:                    USB_HOST_DeviceInterfaceQueryContextClear(&interfaceQuery);
5348:                    interfaceQuery.bInterfaceNumber = interfaceIndex;
5349:                    interfaceQuery.bAlternateSetting = interfaceInfo->currentAlternateSetting;
9D003DBC  9043001C   LBU V1, 28(V0)
9D003DC0  A3A3003D   SB V1, 61(SP)
5350:                    interfaceQuery.flags = USB_HOST_INTERFACE_QUERY_BY_NUMBER|USB_HOST_INTERFACE_QUERY_ALT_SETTING;
9D003DC4  24030003   ADDIU V1, ZERO, 3
9D003DC8  AFA30044   SW V1, 68(SP)
5351:                    interfaceDescriptor = USB_HOST_DeviceGeneralInterfaceDescriptorQuery(interfaceInfo->interfaceDescriptor, &interfaceQuery);
9D003DCC  8C440004   LW A0, 4(V0)
9D003DD0  0F4016D5   JAL USB_HOST_DeviceGeneralInterfaceDescriptorQuery
9D003DD4  27A5003C   ADDIU A1, SP, 60
5352:                
5353:                    if(interfaceDescriptor != NULL)
9D003DD8  10400062   BEQ V0, ZERO, 0x9D003F64
9D003DDC  2410FFFF   ADDIU S0, ZERO, -1
5354:                    {
5355:                
5356:                        /* We want to search for the endpoint descriptor so that we can find out the
5357:                         * pipe attributes. Set up the query object to search by endpoint number and
5358:                         * then search for the end point descriptor */
5359:                
5360:                        USB_HOST_DeviceEndpointQueryContextClear(&endpointDescQuery);
5361:                        endpointDescQuery.endpointAddress = endpointAddress;
9D003DE4  A3B30028   SB S3, 40(SP)
5362:                        endpointDescQuery.flags = USB_HOST_ENDPOINT_QUERY_BY_ENDPOINT_ADDRESS;
9D003DE8  24030001   ADDIU V1, ZERO, 1
9D003DEC  AFA30034   SW V1, 52(SP)
5363:                        endpointDescriptor = USB_HOST_DeviceEndpointDescriptorQuery(interfaceDescriptor,&endpointDescQuery);
9D003DF0  00402021   ADDU A0, V0, ZERO
9D003DF4  0F401518   JAL USB_HOST_DeviceEndpointDescriptorQuery
9D003DF8  27A50028   ADDIU A1, SP, 40
5364:                
5365:                        if(deviceObj->inUse) 
9D003DFC  92430000   LBU V1, 0(S2)
9D003E00  50600059   BEQL V1, ZERO, 0x9D003F68
9D003E04  02001021   ADDU V0, S0, ZERO
5366:                        {
5367:                            /* Device object is valid */
5368:                            if((USB_HOST_PNP_IDENTIFIER(deviceInterfaceHandle)) == (USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier)))
9D003E08  00112402   SRL A0, S1, 16
9D003E0C  9643004E   LHU V1, 78(S2)
9D003E10  54830055   BNEL A0, V1, 0x9D003F68
9D003E14  02001021   ADDU V0, S0, ZERO
5369:                            {
5370:                                /* PlugNPlay identifiers are matching */
5371:                
5372:                                if ( endpointDescriptor != NULL )
9D003E18  10400044   BEQ V0, ZERO, 0x9D003F2C
9D003E1C  24030002   ADDIU V1, ZERO, 2
5373:                                {
5374:                                    /* Transfer type */
5375:                                    transferType = endpointDescriptor->transferType;
9D003E20  90460003   LBU A2, 3(V0)
9D003E24  30C60003   ANDI A2, A2, 3
5376:                
5377:                                    /* Interval for periodic transfers */
5378:                                    if ( transferType ==  USB_TRANSFER_TYPE_BULK )
9D003E28  10C30042   BEQ A2, V1, 0x9D003F34
9D003E2C  90430004   LBU V1, 4(V0)
5379:                                    {
5380:                                        /* Bulk endpoints we ignore interval value
5381:                                         * reported by endpoint descriptor */
5382:                                        interval = 0x00;
5383:                                    }
5384:                                    else
5385:                                    {
5386:                                        interval = endpointDescriptor->bInterval;
9D003E30  90480006   LBU T0, 6(V0)
5387:                                    }
5388:                
5389:                                    /* Endpoint maximum packet size */
5390:                                    maxPacketSize = endpointDescriptor->wMaxPacketSize;
9D003E34  90490005   LBU T1, 5(V0)
9D003E38  00094A00   SLL T1, T1, 8
9D003E3C  01234825   OR T1, T1, V1
9D003F34  90420005   LBU V0, 5(V0)
9D003F38  00021200   SLL V0, V0, 8
9D003F3C  00431025   OR V0, V0, V1
9D003F40  2C490041   SLTIU T1, V0, 65
9D003F44  24030040   ADDIU V1, ZERO, 64
9D003F48  0049180B   MOVN V1, V0, T1
9D003F4C  00604821   ADDU T1, V1, ZERO
9D003F50  0B400F90   J USB_HOST_DevicePipeOpen::OSAL_MUTEX_Lock
9D003F54  00004021   ADDU T0, ZERO, ZERO
5391:                                    if( transferType==USB_TRANSFER_TYPE_BULK && maxPacketSize>64 ) maxPacketSize=64;
5392:                
5393:                                    /* The pipe open function should never be called in an event handler or
5394:                                     * in an interrupt context. We don't check for interrupt safety here,
5395:                                     * only thread safety. The safety is needed for protected the pipe pool
5396:                                     * */
5397:                                    if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexPipeObj), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
5398:                                    {
5399:                                        for ( pipeNumber = 0 ; pipeNumber < USB_HOST_PIPES_NUMBER ; pipeNumber++)
9D003E6C  2405000A   ADDIU A1, ZERO, 10
9D003EC0  1445FFEB   BNE V0, A1, 0x9D003E70
9D003EC4  24630010   ADDIU V1, V1, 16
9D003EC8  0B400FD6   J USB_HOST_DevicePipeOpen::OSAL_MUTEX_Unlock
9D003ECC  24030001   ADDIU V1, ZERO, 1
5400:                                        {
5401:                                            if( gUSBHostPipeObj[pipeNumber].inUse == false )
9D003E54  3C02A000   LUI V0, -24576
9D003E58  904262E8   LBU V0, 25320(V0)
9D003E5C  10400009   BEQ V0, ZERO, 0x9D003E84
9D003E60  3C03A000   LUI V1, -24576
9D003E64  246362F8   ADDIU V1, V1, 25336
9D003E68  24020001   ADDIU V0, ZERO, 1
9D003E70  90640000   LBU A0, 0(V1)
9D003E74  14800011   BNE A0, ZERO, 0x9D003EBC
9D003E78  00403821   ADDU A3, V0, ZERO
9D003E84  00003821   ADDU A3, ZERO, ZERO
5402:                                            {
5403:                                                pipeObj= & gUSBHostPipeObj[pipeNumber];
9D003E7C  0B400FA3   J 0x9D003E8C
9D003E80  00073900   SLL A3, A3, 4
9D003E88  00073900   SLL A3, A3, 4
9D003E8C  3C14A000   LUI S4, -24576
9D003E90  269462E8   ADDIU S4, S4, 25320
9D003E94  0287A021   ADDU S4, S4, A3
5404:                                                result = (USB_HOST_PIPE_HANDLE)(pipeObj);
5405:                                                pipeObj->inUse = true;
9D003E98  24020001   ADDIU V0, ZERO, 1
9D003E9C  A2820000   SB V0, 0(S4)
5406:                                                break;
5407:                                            }
5408:                                        }
5409:                
5410:                                        /* Release the mutual exclusion lock */
5411:                                        OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexPipeObj));
5412:                                    }
5413:                                    else
5414:                                    {
5415:                                        /* If the mutual exclusion lock failed for unknown reason, we don't do anything
5416:                                         * here as we will any ways check for a valid handle in result.
5417:                                         * result has an invalid handle at this point */
5418:                                    }
5419:                
5420:                                    if(result != USB_HOST_PIPE_HANDLE_INVALID)
9D003EA8  2402FFFF   ADDIU V0, ZERO, -1
9D003EAC  16820008   BNE S4, V0, 0x9D003ED0
9D003EB0  02808021   ADDU S0, S4, ZERO
9D003EB4  0B400FDA   J 0x9D003F68
9D003EB8  02001021   ADDU V0, S0, ZERO
9D003EBC  24420001   ADDIU V0, V0, 1
5421:                                    {
5422:                                        /* This means the pipeObj is valid. We can try opening the pipe by
5423:                                         * using the HCD pipe open function */
5424:                
5425:                                        pipeObj->pipeHandle = deviceObj->hcdInterface->hostPipeSetup( deviceObj->hcdHandle,
9D003ED0  8E42006C   LW V0, 108(S2)
9D003ED4  8E440064   LW A0, 100(S2)
9D003ED8  92450060   LBU A1, 96(S2)
9D003EDC  92470074   LBU A3, 116(S2)
9D003EE0  92430075   LBU V1, 117(S2)
9D003EE4  AFA30010   SW V1, 16(SP)
9D003EE8  AFA60014   SW A2, 20(SP)
9D003EEC  AFA80018   SW T0, 24(SP)
9D003EF0  AFA9001C   SW T1, 28(SP)
9D003EF4  8E430078   LW V1, 120(S2)
9D003EF8  AFA30020   SW V1, 32(SP)
9D003EFC  8C42001C   LW V0, 28(V0)
9D003F00  0040F809   JALR V0
9D003F04  02603021   ADDU A2, S3, ZERO
5426:                                                deviceObj->deviceAddress,   /* Address of the device */ 
5427:                                                endpointAddress,            /* Endpoint */
5428:                                                deviceObj->hubAddress,       /* Hub address and port */
5429:                                                deviceObj->devicePort,         
5430:                                                transferType,               /* Pipe type */ 
5431:                                                interval,                   /* bInterval */
5432:                                                maxPacketSize,              /* Pipe size */ 
5433:                                                deviceObj->speed            /* Speed of the pipe */
5434:                                                );     
5435:                
5436:                                        if(pipeObj->pipeHandle == DRV_USB_HOST_PIPE_HANDLE_INVALID)
9D003F08  2403FFFF   ADDIU V1, ZERO, -1
9D003F0C  14430004   BNE V0, V1, 0x9D003F20
9D003F10  AE820008   SW V0, 8(S4)
5437:                                        {
5438:                                            /* The HCD pipe open function failed. Release the pipe object
5439:                                             * back and then update result. */
5440:                
5441:                                            pipeObj->inUse = false;
9D003F14  A2800000   SB ZERO, 0(S4)
9D003F18  0B400FD9   J 0x9D003F64
9D003F1C  2410FFFF   ADDIU S0, ZERO, -1
5442:                                            result = USB_HOST_PIPE_HANDLE_INVALID;
5443:                                        }
5444:                                        else
5445:                                        {
5446:                                            /* HCD pipe open function worked. Update the pipe object */
5447:                                            pipeObj->endpointAddress = endpointAddress;
9D003F20  A293000C   SB S3, 12(S4)
5448:                                            pipeObj->interfaceHandle = deviceInterfaceHandle ;
9D003F24  0B400FD9   J 0x9D003F64
9D003F28  AE910004   SW S1, 4(S4)
5449:                
5450:                                        }
5451:                                    }
5452:                                }
5453:                            }
5454:                        }
5455:                    }
5456:                
5457:                    return result;
5458:                }
9D003F64  02001021   ADDU V0, S0, ZERO
5459:                
5460:                // *****************************************************************************
5461:                /* Function:
5462:                    USB_HOST_RESULT USB_HOST_DevicePipeClose 
5463:                    (
5464:                        USB_HOST_PIPE_HANDLE pipeHandle
5465:                    );
5466:                
5467:                  Summary:
5468:                    Closes an existing pipe.
5469:                
5470:                  Description:
5471:                    This function closes an existing pipe. Any transfers that are queued or
5472:                    in-progress on the pipe will be aborted and the transfer complete events
5473:                    will be generated. Once closed, no transfers can be queued on the pipe.
5474:                 
5475:                  Remarks:
5476:                     Refer to usb_host_client_driver.h for usage details.
5477:                */
5478:                
5479:                USB_HOST_RESULT USB_HOST_DevicePipeClose
5480:                (
5481:                    USB_HOST_PIPE_HANDLE pipeHandle
5482:                )
5483:                {
9D008334  27BDFFE8   ADDIU SP, SP, -24
9D008338  AFBF0014   SW RA, 20(SP)
9D00833C  AFB00010   SW S0, 16(SP)
5484:                    USB_HOST_RESULT result;
5485:                    USB_HOST_PIPE_OBJ * pipeObj;
5486:                    USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle;
5487:                    USB_HOST_DEVICE_OBJ * deviceObj;
5488:                    int deviceIndex;
5489:                
5490:                    if((pipeHandle == USB_HOST_PIPE_HANDLE_INVALID) || (pipeHandle == 0))
9D008340  2482FFFF   ADDIU V0, A0, -1
9D008344  2C42FFFE   SLTIU V0, V0, -2
9D008348  10400018   BEQ V0, ZERO, 0x9D0083AC
9D00834C  00808021   ADDU S0, A0, ZERO
5491:                    {
5492:                        result = USB_HOST_RESULT_PIPE_HANDLE_INVALID;
5493:                    }
5494:                    else
5495:                    {
5496:                        /* The pipe handle is a pointer to the pipe object */
5497:                        pipeObj = (USB_HOST_PIPE_OBJ *)(pipeHandle);
5498:                
5499:                        /* Get the handle to the interface to which this pipe belongs */
5500:                        interfaceHandle = pipeObj->interfaceHandle;
9D008350  8C820004   LW V0, 4(A0)
5501:                
5502:                        /* From the interface handle get the device index and hence the device
5503:                         * object */
5504:                        deviceIndex = USB_HOST_DEVICE_INDEX(interfaceHandle);
9D008354  304400FF   ANDI A0, V0, 255
5505:                        deviceObj = &gUSBHostDeviceList[deviceIndex];
9D008358  00042900   SLL A1, A0, 4
9D00835C  00041980   SLL V1, A0, 6
9D008360  00651823   SUBU V1, V1, A1
9D008364  000320C0   SLL A0, V1, 3
9D008368  00641821   ADDU V1, V1, A0
9D00836C  3C04A000   LUI A0, -24576
9D008370  24846388   ADDIU A0, A0, 25480
9D008374  00831821   ADDU V1, A0, V1
5506:                
5507:                        if((USB_HOST_PNP_IDENTIFIER(interfaceHandle)) == (USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier)))
9D008378  00021402   SRL V0, V0, 16
9D00837C  9464004E   LHU A0, 78(V1)
9D008380  5444000B   BNEL V0, A0, 0x9D0083B0
9D008384  2402FFA8   ADDIU V0, ZERO, -88
5508:                        {
5509:                            /* Use the HCD routine to close the pipe and deallocate the pipe
5510:                             * object */
5511:                
5512:                            deviceObj->hcdInterface->hostPipeClose(pipeObj->pipeHandle);
9D008388  8C62006C   LW V0, 108(V1)
9D00838C  8C420020   LW V0, 32(V0)
9D008390  0040F809   JALR V0
9D008394  8E040008   LW A0, 8(S0)
5513:                            pipeObj->inUse = false;
9D008398  A2000000   SB ZERO, 0(S0)
5514:                            pipeObj->pipeHandle = DRV_USB_HOST_PIPE_HANDLE_INVALID;
9D00839C  2402FFFF   ADDIU V0, ZERO, -1
9D0083A0  AE020008   SW V0, 8(S0)
9D0083A4  0B4020EC   J 0x9D0083B0
9D0083A8  24020001   ADDIU V0, ZERO, 1
9D0083AC  2402FFA0   ADDIU V0, ZERO, -96
5515:                            result = USB_HOST_RESULT_SUCCESS;
5516:                        }
5517:                        else
5518:                        {
5519:                            result = USB_HOST_RESULT_FAILURE;
5520:                        }
5521:                    }
5522:                
5523:                    return(result);
5524:                }
9D0083B0  8FBF0014   LW RA, 20(SP)
5525:                
5526:                // *****************************************************************************
5527:                /* Function:
5528:                    USB_HOST_RESULT USB_HOST_DevicePipeHaltClear
5529:                    (
5530:                        USB_HOST_PIPE_HANDLE pipeHandle,
5531:                        USB_HOST_REQUEST_HANDLE * requestHandle,
5532:                        uintptr_t context
5533:                    );
5534:                
5535:                  Summary:
5536:                    Clears the halt condition on a pipe.
5537:                
5538:                  Description:
5539:                    This function clears the halt condition on the specified pipe. This
5540:                    function will cause a CLEAR FEATURE control request to be sent to the
5541:                    device. The completion of the control transfer will be indicated by the
5542:                    USB_HOST_DEVICE_EVENT_DEVICE_HALT_CLEAR_COMPLETE event.
5543:                
5544:                  Remarks:
5545:                    Refer to usb_host_client_driver.h for usage information.
5546:                */
5547:                
5548:                USB_HOST_RESULT USB_HOST_DevicePipeHaltClear
5549:                (
5550:                    USB_HOST_PIPE_HANDLE pipeHandle,
5551:                    USB_HOST_REQUEST_HANDLE * requestHandle,
5552:                    uintptr_t context
5553:                )
5554:                {
5555:                    USB_HOST_RESULT result = USB_HOST_RESULT_FAILURE;
5556:                    USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle;
5557:                    USB_HOST_DEVICE_OBJ * deviceObj;
5558:                    USB_HOST_CONTROL_TRANSFER_OBJ * controlTransferObj; 
5559:                    USB_HOST_PIPE_OBJ * pipeObj;
5560:                    int deviceIndex;
5561:                
5562:                
5563:                    /* Check if we have a valid pipe */
5564:                    if((USB_HOST_PIPE_HANDLE_INVALID == pipeHandle) || (0 == pipeHandle))
5565:                    {
5566:                        result = USB_HOST_RESULT_PIPE_HANDLE_INVALID;
5567:                    }
5568:                    else
5569:                    {
5570:                        /* Request Handle pointer cannot be NULL */
5571:                        if(requestHandle == NULL)
5572:                        {
5573:                            result = USB_HOST_RESULT_PARAMETER_INVALID;
5574:                        }
5575:                        else
5576:                        {
5577:                            /* Get the index of the device to which this pipe belongs. This can
5578:                             * be obtained from the interface handle. The interface handle is
5579:                             * stored in the pipe object */
5580:                
5581:                            pipeObj = (USB_HOST_PIPE_OBJ *)(pipeHandle);
5582:                            interfaceHandle = pipeObj->interfaceHandle;
5583:                            deviceIndex = USB_HOST_DEVICE_INDEX(interfaceHandle);
5584:                            deviceObj = &gUSBHostDeviceList[deviceIndex];
5585:                
5586:                            /* The interface handle  PNP identifier does not match the device PNP
5587:                             * identifier. The device is not the same */
5588:                            if(USB_HOST_PNP_IDENTIFIER(interfaceHandle) != 
5589:                                    USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
5590:                            {
5591:                                result = USB_HOST_RESULT_FAILURE; 
5592:                            }
5593:                            else
5594:                            {
5595:                                /* Set the request handle default to invalid */
5596:                                *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
5597:                
5598:                                /* Get a mutual exclusion lock as the the control transfer object is a global resource */
5599:                                if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexControlTransferObj), OSAL_WAIT_FOREVER) 
5600:                                        == OSAL_RESULT_TRUE)
5601:                                {
5602:                                    if(!deviceObj->controlTransferObj.inUse)
5603:                                    {
5604:                                        /* This means that there no control request in progress. We can assign
5605:                                         * request now. The request handle is updated to point to the device
5606:                                         * control transfer object. */
5607:                
5608:                                        deviceObj->controlTransferObj.inUse = true;
5609:                                        *requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
5610:                                    }
5611:                                    else
5612:                                    {
5613:                                        /* A control transfer is in progress. */
5614:                                        result = USB_HOST_RESULT_REQUEST_BUSY;
5615:                                    }
5616:                
5617:                                    /* Unlock the mutual exclusion lock */
5618:                                    OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexControlTransferObj));
5619:                                }
5620:                                else
5621:                                {
5622:                                    /* The mutual exclusion lock could not be obtained */
5623:                                    result = USB_HOST_RESULT_REQUEST_BUSY;
5624:                                }
5625:                
5626:                                if(*requestHandle != USB_HOST_REQUEST_HANDLE_INVALID)
5627:                                {
5628:                                    /* Set up the control transfer object. The endpoint halt
5629:                                     * clear request does not have a data stage. */
5630:                                    controlTransferObj = &deviceObj->controlTransferObj;
5631:                                    controlTransferObj->requestType = USB_HOST_CONTROL_REQUEST_TYPE_PIPE_HALT_CLEAR;
5632:                
5633:                                    /* Create the setup packet */
5634:                                    _USB_HOST_FillSetupPacket(
5635:                                            &(deviceObj->setupPacket),
5636:                                            ( USB_SETUP_DIRN_HOST_TO_DEVICE |
5637:                                              USB_SETUP_TYPE_STANDARD |
5638:                                              USB_SETUP_RECIPIENT_ENDPOINT ),
5639:                                            USB_REQUEST_CLEAR_FEATURE ,
5640:                                            USB_FEATURE_SELECTOR_ENDPOINT_HALT , pipeObj->endpointAddress  ,0 ) ;
5641:                
5642:                                    controlTransferObj->requestType = USB_HOST_CONTROL_REQUEST_TYPE_PIPE_HALT_CLEAR;
5643:                                    controlTransferObj->controlIRP.data = NULL;
5644:                                    controlTransferObj->controlIRP.setup = &deviceObj->setupPacket;
5645:                                    controlTransferObj->controlIRP.size = deviceObj->setupPacket.wLength;
5646:                                    controlTransferObj->controlIRP.callback = _USB_HOST_DeviceControlTransferCallback;
5647:                                    controlTransferObj->controlIRP.userData = interfaceHandle;
5648:                                    controlTransferObj->context = context;
5649:                                    controlTransferObj->callback = NULL;
5650:                
5651:                                    if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, &(controlTransferObj->controlIRP)))
5652:                                    {
5653:                                        /* There was a problem while submitting the IRP. Update the result and
5654:                                         * the transfer handle. Return the control transfer object back to the
5655:                                         * device object */
5656:                
5657:                                        result = USB_HOST_RESULT_FAILURE;
5658:                                        controlTransferObj->inUse = false;
5659:                                        *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
5660:                                    }
5661:                                    else
5662:                                    {
5663:                                        result = USB_HOST_RESULT_SUCCESS;
5664:                                    }
5665:                                }
5666:                            }
5667:                        }
5668:                    }
5669:                
5670:                    return(result);
5671:                }
5672:                
5673:                // *****************************************************************************
5674:                /* Function:
5675:                    USB_HOST_RESULT USB_HOST_DeviceRelease
5676:                    (
5677:                        USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
5678:                    );
5679:                
5680:                  Summary:
5681:                    Releases an the device ownership.
5682:                
5683:                  Description:
5684:                    This function allows the client driver to release device level ownership.
5685:                
5686:                  Remarks:
5687:                    Refer to usb_host_client_driver.h for usage information.
5688:                 */
5689:                
5690:                USB_HOST_RESULT USB_HOST_DeviceRelease
5691:                (
5692:                    USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle
5693:                )
5694:                {
5695:                    int deviceIndex;
5696:                    unsigned int pnpIdentifier;
5697:                    USB_HOST_RESULT result;
5698:                    USB_HOST_DEVICE_OBJ * deviceObj;
5699:                    
5700:                    deviceIndex = USB_HOST_DEVICE_INDEX(deviceHandle);
9D008B2C  308400FF   ANDI A0, A0, 255
5701:                    pnpIdentifier = USB_HOST_PNP_IDENTIFIER(deviceHandle);
9D008B28  00042C02   SRL A1, A0, 16
5702:                    
5703:                    /* Get the device object */
5704:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
9D008B30  00041900   SLL V1, A0, 4
9D008B34  00041180   SLL V0, A0, 6
9D008B38  00431023   SUBU V0, V0, V1
9D008B3C  000218C0   SLL V1, V0, 3
9D008B40  00431021   ADDU V0, V0, V1
9D008B44  3C03A000   LUI V1, -24576
9D008B48  24636388   ADDIU V1, V1, 25480
9D008B4C  00621021   ADDU V0, V1, V0
5705:                    
5706:                    if(!deviceObj->inUse)
9D008B50  90430000   LBU V1, 0(V0)
9D008B54  1060000A   BEQ V1, ZERO, 0x9D008B80
9D008B58  00000000   NOP
5707:                    {
5708:                        /* This device object is not in use. May have been disconnected */
5709:                        result = USB_HOST_RESULT_DEVICE_UNKNOWN;
9D008B80  03E00008   JR RA
9D008B84  2402FFA7   ADDIU V0, ZERO, -89
5710:                    }
5711:                    else 
5712:                    {
5713:                        if(pnpIdentifier != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
9D008B5C  9443004E   LHU V1, 78(V0)
9D008B60  14650009   BNE V1, A1, 0x9D008B88
9D008B64  00000000   NOP
5714:                        {
5715:                            /* This device is not the same that client driver thinks it is */
5716:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
9D008B88  03E00008   JR RA
9D008B8C  2402FFA7   ADDIU V0, ZERO, -89
5717:                        }
5718:                        else
5719:                        {
5720:                            if(deviceObj->deviceClientDriver == NULL)
9D008B68  8C4300E0   LW V1, 224(V0)
9D008B6C  10600008   BEQ V1, ZERO, 0x9D008B90
9D008B70  00000000   NOP
5721:                            {
5722:                                /* This is should not happen */
5723:                                result = USB_HOST_RESULT_DEVICE_UNKNOWN;
5724:                            }
5725:                            else
5726:                            {
5727:                                /* Release the interface */
5728:                                deviceObj->deviceClientDriver = NULL;
9D008B74  AC4000E0   SW ZERO, 224(V0)
5729:                                result = USB_HOST_RESULT_SUCCESS;
9D008B78  03E00008   JR RA
9D008B7C  24020001   ADDIU V0, ZERO, 1
5730:                            }
5731:                        }
5732:                    }    
5733:                        
5734:                    return(result);
5735:                }
9D008B90  03E00008   JR RA
5736:                
5737:                // *****************************************************************************
5738:                /* Function:
5739:                    USB_INTERFACE_ASSOCIATION_DESCRIPTOR * USB_HOST_DeviceIADQuery
5740:                    (
5741:                        USB_CONFIGURATION_DESCRIPTOR * configuration
5742:                        USB_HOST_IAD_QUERY * query,
5743:                    );
5744:                
5745:                  Summary:
5746:                    Queries the configuration for the specified IAD.
5747:                
5748:                  Description:
5749:                    This function queries the configuration for the specified IAD and returns a
5750:                    pointer to the interface association descriptor if found. The return pointer
5751:                    will point to the standard interface association descriptor.  The search
5752:                    criteria can specified by using the flags. 
5753:                    
5754:                  Remarks:
5755:                    This function is optional and may not be available on all implementations of
5756:                    the USB Host Layer.
5757:                */
5758:                
5759:                USB_INTERFACE_ASSOCIATION_DESCRIPTOR * USB_HOST_DeviceIADQuery
5760:                (
5761:                    USB_CONFIGURATION_DESCRIPTOR * configuration,
5762:                    USB_HOST_IAD_QUERY * query
5763:                )
5764:                {
9D008154  27BDFFE0   ADDIU SP, SP, -32
9D008158  AFBF001C   SW RA, 28(SP)
9D00815C  AFB10018   SW S1, 24(SP)
9D008160  AFB00014   SW S0, 20(SP)
5765:                    USB_INTERFACE_ASSOCIATION_DESCRIPTOR * result = NULL;
9D0081DC  00008021   ADDU S0, ZERO, ZERO
5766:                    USB_DESCRIPTOR_HEADER * descriptorHeader;
5767:                    uint8_t * search;
5768:                    uint8_t * lastLocation;
5769:                
5770:                    if(configuration == NULL)
9D008164  1080001E   BEQ A0, ZERO, 0x9D0081E0
9D008168  00808021   ADDU S0, A0, ZERO
5771:                    {
5772:                        /* Cannot proceed. Note that result is already NULL */
5773:                    }
5774:                    else
5775:                    {
5776:                        /* Keep track of the last location of this descriptor */
5777:                        search = (uint8_t *)(configuration);
5778:                        lastLocation = (uint8_t *)(_USB_HOST_FindEndOfDescriptor(search));
9D00816C  0F4023B6   JAL _USB_HOST_FindEndOfDescriptor
9D008170  00A08821   ADDU S1, A1, ZERO
5779:                
5780:                        if((query->context != 0) && (query->context < (uintptr_t)(lastLocation)))
9D008174  8E230004   LW V1, 4(S1)
9D008178  50600004   BEQL V1, ZERO, 0x9D00818C
9D00817C  0202182B   SLTU V1, S0, V0
9D008180  0062202B   SLTU A0, V1, V0
5781:                        {
5782:                            /* This is a continuing search. We start the search from the last
5783:                             * saved location */
5784:                            search = (uint8_t *)(query->context);
9D008184  0064800B   MOVN S0, V1, A0
5785:                        }
5786:                
5787:                        while(search < lastLocation)
9D008188  0202182B   SLTU V1, S0, V0
9D00818C  10600013   BEQ V1, ZERO, 0x9D0081DC
9D008190  2403000B   ADDIU V1, ZERO, 11
9D0081C8  0202182B   SLTU V1, S0, V0
9D0081CC  5460FFF6   BNEL V1, ZERO, 0x9D0081A8
9D0081D0  92030001   LBU V1, 1(S0)
9D0081D4  0B402078   J 0x9D0081E0
9D0081D8  00008021   ADDU S0, ZERO, ZERO
5788:                        {
5789:                            descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
5790:                            if(descriptorHeader->descType == USB_DESCRIPTOR_INTERFACE_ASSOCIATION)
9D008194  92040001   LBU A0, 1(S0)
9D008198  54830009   BNEL A0, V1, 0x9D0081C0
9D00819C  2404000B   ADDIU A0, ZERO, 11
9D0081A8  54640006   BNEL V1, A0, 0x9D0081C4
9D0081AC  92030000   LBU V1, 0(S0)
5791:                            {
5792:                                /* This means we found an IAD. Update result and stop searching */
5793:                                result = (USB_INTERFACE_ASSOCIATION_DESCRIPTOR *)(search);
5794:                                
5795:                                /* Setup the context to point to the next descriptor else
5796:                                 * we will always loop at this descriptor the next time the 
5797:                                 * search function is called. */
5798:                                query->context = (uintptr_t)(search + descriptorHeader->size);
9D0081A0  0B40206D   J 0x9D0081B4
9D0081A4  92020000   LBU V0, 0(S0)
9D0081B0  92020000   LBU V0, 0(S0)
9D0081B4  02021021   ADDU V0, S0, V0
5799:                                break;
9D0081B8  0B402078   J 0x9D0081E0
9D0081BC  AE220004   SW V0, 4(S1)
5800:                            }
5801:                            else
5802:                            {
5803:                                /* Go to the next descriptor */
5804:                                search += descriptorHeader->size;
9D0081C0  92030000   LBU V1, 0(S0)
9D0081C4  02038021   ADDU S0, S0, V1
5805:                            }
5806:                        }
5807:                    }
5808:                
5809:                    return(result);
5810:                }
9D0081E0  02001021   ADDU V0, S0, ZERO
5811:                
5812:                // *****************************************************************************
5813:                /* Function:
5814:                    void USB_HOST_DeviceIADQueryContextClear
5815:                    (
5816:                        USB_HOST_IAD_QUERY * query
5817:                    );
5818:                
5819:                  Summary:
5820:                    Clear the query object.
5821:                
5822:                  Description:
5823:                    This function clears the query object. Using the query after it has been
5824:                    clear will cause the USB_HOST_DeviceIADQuery() and function to reset the
5825:                    search location to the start of the configuration descriptor.
5826:                
5827:                  Remarks:
5828:                    This function is optional and may not be available on all implementations of
5829:                    the USB Host Layer.
5830:                */
5831:                
5832:                void USB_HOST_DeviceIADQueryContextClear
5833:                (
5834:                    USB_HOST_IAD_QUERY * query
5835:                )
5836:                {
5837:                    if(query != NULL)
5838:                    {
5839:                        query->context = 0;
9D005964  AFA00024   SW ZERO, 36(SP)
5840:                    }
5841:                }
5842:                
5843:                // *****************************************************************************
5844:                /* Function:
5845:                    USB_HOST_RESULT USB_HOST_DeviceConfigurationSet 
5846:                    (
5847:                        USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
5848:                        USB_HOST_REQUEST_HANDLE * requestHandle,
5849:                        uint8_t configurationIndex,
5850:                        uintptr_t context
5851:                    );
5852:                
5853:                  Summary:
5854:                    Sets the active configuration for the device.
5855:                
5856:                  Description:
5857:                    This function sets the configuration that the host layer must set for this
5858:                    device. A handle to the request is returned in requestHandle. The completion
5859:                    of this request is indicated by the USB_HOST_DEVICE_EVENT_CONFIGURATION_SET
5860:                    complete event.
5861:                
5862:                  Remarks:
5863:                    Refer to usb_host_client_driver.h for usage details.
5864:                */
5865:                
5866:                USB_HOST_RESULT USB_HOST_DeviceConfigurationSet 
5867:                (
5868:                    USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
5869:                    USB_HOST_REQUEST_HANDLE * requestHandle,
5870:                    uint8_t configurationIndex,
5871:                    uintptr_t context
5872:                )
5873:                {
5874:                    USB_HOST_RESULT result;
5875:                    USB_HOST_DEVICE_OBJ * deviceObj;
5876:                    unsigned int deviceIndex;
5877:                    unsigned int pnpIdentifier;
5878:                
5879:                    if(deviceHandle == USB_HOST_DEVICE_CLIENT_HANDLE_INVALID)
9D0076E0  2402FFFF   ADDIU V0, ZERO, -1
9D0076E4  10820023   BEQ A0, V0, 0x9D007774
9D0076E8  308300FF   ANDI V1, A0, 255
5880:                    {
5881:                        /* Device client handle is not valid */
5882:                        result = USB_HOST_RESULT_PARAMETER_INVALID;
9D007774  03E00008   JR RA
9D007778  2402FFA3   ADDIU V0, ZERO, -93
5883:                    }
5884:                    else
5885:                    {
5886:                        /* We have a valid client handle. Get the device index from the client
5887:                         * handle */
5888:                
5889:                        deviceIndex = USB_HOST_DEVICE_INDEX(deviceHandle);
5890:                        deviceObj = &gUSBHostDeviceList[deviceIndex];
9D0076EC  00032900   SLL A1, V1, 4
9D0076F0  00031180   SLL V0, V1, 6
9D0076F4  00451023   SUBU V0, V0, A1
9D0076F8  000218C0   SLL V1, V0, 3
9D0076FC  00431021   ADDU V0, V0, V1
9D007700  3C03A000   LUI V1, -24576
9D007704  24636388   ADDIU V1, V1, 25480
9D007708  00621021   ADDU V0, V1, V0
5891:                        pnpIdentifier = USB_HOST_PNP_IDENTIFIER(deviceHandle);
5892:                
5893:                        if((!deviceObj->inUse) || (pnpIdentifier != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier)))
9D00770C  90430000   LBU V1, 0(V0)
9D007710  1060001A   BEQ V1, ZERO, 0x9D00777C
9D007714  00042402   SRL A0, A0, 16
9D007718  9443004E   LHU V1, 78(V0)
9D00771C  14640019   BNE V1, A0, 0x9D007784
9D007720  00000000   NOP
5894:                        {
5895:                            /* This device is not valid */
5896:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
9D00777C  03E00008   JR RA
9D007780  2402FFA7   ADDIU V0, ZERO, -89
9D007784  03E00008   JR RA
9D007788  2402FFA7   ADDIU V0, ZERO, -89
5897:                        }
5898:                        else
5899:                        {
5900:                            /* Check if this is valid configuration. */
5901:                            if(configurationIndex >= deviceObj->nConfiguration)
9D007724  904300D4   LBU V1, 212(V0)
9D007728  00C3182B   SLTU V1, A2, V1
9D00772C  10600017   BEQ V1, ZERO, 0x9D00778C
9D007730  00000000   NOP
5902:                            {
5903:                                /* The device does not support this configuration */
5904:                                result = USB_HOST_RESULT_CONFIGURATION_UNKNOWN;
9D00778C  03E00008   JR RA
9D007790  2402FFA4   ADDIU V0, ZERO, -92
5905:                            }
5906:                            else
5907:                            {
5908:                                if((!deviceObj->controlTransferObj.inUse) &&
9D007734  90430004   LBU V1, 4(V0)
9D007738  14600016   BNE V1, ZERO, 0x9D007794
9D00773C  00000000   NOP
9D007740  8C4301AC   LW V1, 428(V0)
9D007744  14600015   BNE V1, ZERO, 0x9D00779C
9D007748  2403000F   ADDIU V1, ZERO, 15
5909:                                        (deviceObj->configurationState == USB_HOST_DEVICE_CONFIG_STATE_READY_FOR_CONFIG) &&
9D00774C  8C4400F0   LW A0, 240(V0)
9D007750  14830014   BNE A0, V1, 0x9D0077A4
9D007754  24030001   ADDIU V1, ZERO, 1
5910:                                        (deviceObj->deviceState == USB_HOST_DEVICE_STATE_READY))
5911:                                {
5912:                                    /* The configuration can be set */
5913:                                    deviceObj->controlTransferObj.inUse = true;
9D007758  A0430004   SB V1, 4(V0)
5914:                                    deviceObj->controlTransferObj.context = context;
9D00775C  AC470008   SW A3, 8(V0)
5915:                                    deviceObj->requestedConfigurationNumber = configurationIndex;
9D007760  A04600FC   SB A2, 252(V0)
5916:                                    deviceObj->configurationState = USB_HOST_DEVICE_CONFIG_STATE_START;
9D007764  24030001   ADDIU V1, ZERO, 1
9D007768  AC4301AC   SW V1, 428(V0)
5917:                                    result = USB_HOST_RESULT_SUCCESS;
9D00776C  03E00008   JR RA
9D007770  24020001   ADDIU V0, ZERO, 1
5918:                                }
5919:                                else
5920:                                {
5921:                                    /* The device is not ready for any requests at this point */
5922:                                    result = USB_HOST_RESULT_REQUEST_BUSY;
9D007794  03E00008   JR RA
9D007798  2402FF9C   ADDIU V0, ZERO, -100
9D00779C  03E00008   JR RA
9D0077A0  2402FF9C   ADDIU V0, ZERO, -100
5923:                                }
5924:                            }
5925:                        }
5926:                    }
5927:                
5928:                    return(result);
5929:                }
9D0077A4  03E00008   JR RA
5930:                
5931:                // *****************************************************************************
5932:                /* Function:
5933:                    USB_INTERFACE_DESCRIPTOR * USB_HOST_DeviceGeneralInterfaceDescriptorQuery
5934:                    (
5935:                        void * descriptor
5936:                        USB_HOST_INTERFACE_DESCRIPTOR_QUERY * query,
5937:                    );
5938:                
5939:                  Summary:
5940:                    Queries the IAD group for the specified query.
5941:                
5942:                  Description:
5943:                    This function will query will search for an interface starting from the
5944:                    location pointed to by the descriptor parameter. This descriptor parameter
5945:                    could be a pointer to an IAD or a interface descriptor.  The return pointer
5946:                    will point to the standard interface descriptor and class specific interface
5947:                    descriptors for that interface. The search criteria can specified by using
5948:                    the flags. 
5949:                    
5950:                    In a case where the interface has more than one alternate settings, the
5951:                    function can be called repetitively to continue the search till the end of the
5952:                    configuration descriptor is reached or till the search fails. The query flag
5953:                    in such should be set to ignore the alternate setting field.  The query
5954:                    object maintains the last point where the search was successful and
5955:                    continues the search from that point onwards. Resetting the query object
5956:                    (through the USB_HOST_DeviceInterfaceQueryContextClear()) function will
5957:                    reset the search object and cause the search to start from the top.
5958:                
5959:                  Remarks:
5960:                    Refer to usb_host_client_driver.h for usage information.
5961:                */
5962:                
5963:                USB_INTERFACE_DESCRIPTOR * USB_HOST_DeviceGeneralInterfaceDescriptorQuery
5964:                (
5965:                    void * descriptor,
5966:                    USB_HOST_INTERFACE_DESCRIPTOR_QUERY * query
5967:                )
5968:                {
9D005B54  27BDFFE0   ADDIU SP, SP, -32
9D005B58  AFBF001C   SW RA, 28(SP)
9D005B5C  AFB10018   SW S1, 24(SP)
9D005B60  AFB00014   SW S0, 20(SP)
5969:                    USB_INTERFACE_DESCRIPTOR * result = NULL;
5970:                    USB_DESCRIPTOR_HEADER * descriptorHeader;
5971:                    uint8_t * search;
5972:                    uint8_t * lastLocation;
5973:                    USB_HOST_INTERFACE_QUERY_FLAG matchedCriteria = 0;
5974:                    USB_INTERFACE_DESCRIPTOR * interfaceDescriptor;
5975:                
5976:                    if(descriptor != NULL)
9D005B64  10800049   BEQ A0, ZERO, 0x9D005C8C
9D005B68  00808021   ADDU S0, A0, ZERO
5977:                    {
5978:                        /* We have a non null descritpor. Find where this descriptor ends */
5979:                        search = (uint8_t *)(descriptor);
5980:                        lastLocation = (uint8_t *)(_USB_HOST_FindEndOfDescriptor(search));
9D005B6C  0F4023B6   JAL _USB_HOST_FindEndOfDescriptor
9D005B70  00A08821   ADDU S1, A1, ZERO
5981:                
5982:                        if((query->context != 0) && (query->context < (uintptr_t)(lastLocation)))
9D005B74  8E23000C   LW V1, 12(S1)
9D005B78  50600004   BEQL V1, ZERO, 0x9D005B8C
9D005B7C  0202182B   SLTU V1, S0, V0
9D005B80  0062202B   SLTU A0, V1, V0
5983:                        {
5984:                            /* This is a continuing search. We start the search from the last
5985:                             * saved location */
5986:                            search = (uint8_t *)(query->context);
9D005B84  0064800B   MOVN S0, V1, A0
5987:                        }
5988:                
5989:                        while(search < lastLocation)
9D005B88  0202182B   SLTU V1, S0, V0
9D005B8C  1060003E   BEQ V1, ZERO, 0x9D005C88
9D005B90  24050004   ADDIU A1, ZERO, 4
9D005C74  0202182B   SLTU V1, S0, V0
9D005C78  5460FFC7   BNEL V1, ZERO, 0x9D005B98
9D005C7C  92030001   LBU V1, 1(S0)
9D005C80  0B401723   J 0x9D005C8C
9D005C84  00008021   ADDU S0, ZERO, ZERO
9D005C88  00008021   ADDU S0, ZERO, ZERO
5990:                        {
5991:                            /* Reset the matching criteria as this is a new search */
5992:                            matchedCriteria = 0;
5993:                            descriptorHeader = (USB_DESCRIPTOR_HEADER *)(search);
5994:                            
5995:                            if(descriptorHeader->descType == USB_DESCRIPTOR_INTERFACE)
9D005B94  92030001   LBU V1, 1(S0)
9D005B98  54650035   BNEL V1, A1, 0x9D005C70
9D005B9C  92030000   LBU V1, 0(S0)
5996:                            {
5997:                                interfaceDescriptor = (USB_INTERFACE_DESCRIPTOR *)(search);
5998:                
5999:                                /* This means we found a interface descriptor. We need to check
6000:                                 * if it meets the criteria */
6001:                
6002:                                if(query->flags == USB_HOST_INTERFACE_QUERY_ANY)
9D005BA0  8E240008   LW A0, 8(S1)
9D005BA4  14800005   BNE A0, ZERO, 0x9D005BBC
9D005BA8  30860001   ANDI A2, A0, 1
6003:                                {
6004:                                    /* This means any interface descriptor is fine. We should
6005:                                     * stop searching. Save the query location in the context */
6006:                
6007:                                    query->context = (uintptr_t)(search + descriptorHeader->size);
9D005BAC  92020000   LBU V0, 0(S0)
9D005BB0  02021021   ADDU V0, S0, V0
6008:                                    result = (USB_INTERFACE_DESCRIPTOR *)(search);
6009:                                    break;
9D005BB4  0B401723   J 0x9D005C8C
9D005BB8  AE22000C   SW V0, 12(S1)
6010:                                }
6011:                                else
6012:                                {
6013:                                    /* Need to apply the specified criteria */
6014:                
6015:                                    if(query->flags & USB_HOST_INTERFACE_QUERY_BY_NUMBER)
9D005BBC  10C00005   BEQ A2, ZERO, 0x9D005BD4
9D005BC0  00001821   ADDU V1, ZERO, ZERO
6016:                                    {
6017:                                        if(interfaceDescriptor->bInterfaceNumber == query->bInterfaceNumber)
9D005BC4  92060002   LBU A2, 2(S0)
9D005BC8  92230000   LBU V1, 0(S1)
9D005BCC  00C31826   XOR V1, A2, V1
9D005BD0  2C630001   SLTIU V1, V1, 1
6018:                                        {
6019:                                            /* Matches by number */
6020:                                            matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_NUMBER;
6021:                                        }
6022:                                    }
6023:                
6024:                                    if(query->flags & USB_HOST_INTERFACE_QUERY_ALT_SETTING)
9D005BD4  30860002   ANDI A2, A0, 2
9D005BD8  10C00007   BEQ A2, ZERO, 0x9D005BF8
9D005BDC  30860004   ANDI A2, A0, 4
6025:                                    {
6026:                                        if(interfaceDescriptor->bAlternateSetting == query->bAlternateSetting)
9D005BE0  92080003   LBU T0, 3(S0)
9D005BE4  92270001   LBU A3, 1(S1)
6027:                                        {
6028:                                            /* Matches by alternate setting */
6029:                                            matchedCriteria |= USB_HOST_INTERFACE_QUERY_ALT_SETTING;
9D005BE8  34660002   ORI A2, V1, 2
9D005BEC  01073826   XOR A3, T0, A3
9D005BF0  00C7180A   MOVZ V1, A2, A3
6030:                                        }
6031:                                    }
6032:                
6033:                                    if(query->flags & USB_HOST_INTERFACE_QUERY_BY_CLASS)
9D005BF4  30860004   ANDI A2, A0, 4
9D005BF8  10C00007   BEQ A2, ZERO, 0x9D005C18
9D005BFC  30860008   ANDI A2, A0, 8
6034:                                    {
6035:                                        if(interfaceDescriptor->bInterfaceClass == query->bInterfaceClass)
9D005C00  92080005   LBU T0, 5(S0)
9D005C04  92270002   LBU A3, 2(S1)
6036:                                        {
6037:                                            /* Matches by interface class */
6038:                                            matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_CLASS;
9D005C08  34660004   ORI A2, V1, 4
9D005C0C  01073826   XOR A3, T0, A3
9D005C10  00C7180A   MOVZ V1, A2, A3
6039:                                        }
6040:                                    }
6041:                
6042:                                    if(query->flags & USB_HOST_INTERFACE_QUERY_BY_SUBCLASS)
9D005C14  30860008   ANDI A2, A0, 8
9D005C18  10C00007   BEQ A2, ZERO, 0x9D005C38
9D005C1C  30860010   ANDI A2, A0, 16
6043:                                    {
6044:                                        if(interfaceDescriptor->bInterfaceSubClass == query->bInterfaceSubClass)
9D005C20  92080006   LBU T0, 6(S0)
9D005C24  92270003   LBU A3, 3(S1)
6045:                                        {
6046:                                            /* Matches by interface subclass */
6047:                                            matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_SUBCLASS;
9D005C28  34660008   ORI A2, V1, 8
9D005C2C  01073826   XOR A3, T0, A3
9D005C30  00C7180A   MOVZ V1, A2, A3
6048:                                        }
6049:                                    }
6050:                
6051:                                    if(query->flags & USB_HOST_INTERFACE_QUERY_BY_PROTOCOL)
9D005C34  30860010   ANDI A2, A0, 16
9D005C38  10C00005   BEQ A2, ZERO, 0x9D005C50
9D005C3C  34660010   ORI A2, V1, 16
6052:                                    {
6053:                                        if(interfaceDescriptor->bInterfaceProtocol == query->bInterfaceProtocol)
9D005C40  92080007   LBU T0, 7(S0)
9D005C44  92270004   LBU A3, 4(S1)
6054:                                        {
6055:                                            /* Matches by interface protocol */
6056:                                            matchedCriteria |= USB_HOST_INTERFACE_QUERY_BY_PROTOCOL;
9D005C48  01073826   XOR A3, T0, A3
9D005C4C  00C7180A   MOVZ V1, A2, A3
6057:                                        }
6058:                                    }
6059:                
6060:                                    /* Now check if we have met all the criteria */
6061:                
6062:                                    if(matchedCriteria == query->flags)
9D005C50  54640005   BNEL V1, A0, 0x9D005C68
9D005C54  92030000   LBU V1, 0(S0)
6063:                                    {
6064:                                        /* Yes we have. Save the search location and exit */
6065:                                        query->context = (uintptr_t)(search + descriptorHeader->size);
9D005C58  92020000   LBU V0, 0(S0)
9D005C5C  02021021   ADDU V0, S0, V0
6066:                                        result = (USB_INTERFACE_DESCRIPTOR *)(search);
6067:                                        break;
9D005C60  0B401723   J 0x9D005C8C
9D005C64  AE22000C   SW V0, 12(S1)
9D005C68  0B40171D   J 0x9D005C74
9D005C6C  02038021   ADDU S0, S0, V1
6068:                                    }
6069:                                    else
6070:                                    {
6071:                                        /* We did not match the criteria */
6072:                                        search += descriptorHeader->size;
6073:                                    }
6074:                                }
6075:                            }
6076:                            else
6077:                            {
6078:                                /* Go to the next descriptor */
6079:                                search += descriptorHeader->size;
9D005C70  02038021   ADDU S0, S0, V1
6080:                            }
6081:                        }
6082:                    }
6083:                
6084:                    return(result);
6085:                }
9D005C8C  02001021   ADDU V0, S0, ZERO
6086:                
6087:                // *****************************************************************************
6088:                /* Function:
6089:                    USB_HOST_RESULT USB_HOST_DeviceInterfaceSet
6090:                    (
6091:                        USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle,
6092:                        USB_HOST_REQUEST_HANDLE * requestHandle,
6093:                        uint8_t alternateSetting,
6094:                        uintptr_t context
6095:                    );
6096:                
6097:                  Summary:
6098:                    Activates an alternate setting for the specified interface.
6099:                
6100:                  Description:
6101:                    This function activates an alternate setting for the specified interface.
6102:                    This will cause the host layer to send a SET INTERFACE request to the
6103:                    device.  The specified interface should have been claimed. The completion of
6104:                    the SET INTERFACE function will be indicated by the
6105:                    USB_HOST_DEVICE_EVENT_SET_INTERFACE_COMPLETE event.
6106:                
6107:                  Remarks:
6108:                    Refer to usb_host_client_driver.h for usage information.
6109:                */
6110:                
6111:                USB_HOST_RESULT USB_HOST_DeviceInterfaceSet
6112:                (
6113:                    USB_HOST_DEVICE_INTERFACE_HANDLE interfaceHandle,
6114:                    USB_HOST_REQUEST_HANDLE * requestHandle,
6115:                    uint8_t alternateSetting,
6116:                    uintptr_t context
6117:                )
6118:                {
6119:                    USB_HOST_RESULT result = USB_HOST_RESULT_FAILURE;
6120:                    USB_HOST_DEVICE_OBJ * deviceObj;
6121:                    USB_HOST_CONTROL_TRANSFER_OBJ * controlTransferObj; 
6122:                    int deviceIndex, interfaceIndex, pnpIdentifier;
6123:                    USB_HOST_INTERFACE_DESC_INFO * interfaceDescInfo;
6124:                    USB_HOST_INTERFACE_DESCRIPTOR_QUERY interfaceQueryObject;
6125:                
6126:                    /* Get the device index and then the pointer to the device object */
6127:                
6128:                    deviceIndex = USB_HOST_DEVICE_INDEX(interfaceHandle);
6129:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
6130:                
6131:                    if(!deviceObj->inUse)
6132:                    {
6133:                        /* Device object is not valid anymore */
6134:                        result = USB_HOST_RESULT_DEVICE_UNKNOWN;
6135:                    }
6136:                    else
6137:                    {
6138:                        /* Check the Plug N Play identifier */
6139:                        pnpIdentifier = USB_HOST_PNP_IDENTIFIER(interfaceHandle);
6140:                        if(pnpIdentifier != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
6141:                        {
6142:                            /* This is not the same device the client driver thinks it is */
6143:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
6144:                
6145:                        }
6146:                        else
6147:                        {
6148:                            interfaceIndex = USB_HOST_INTERFACE_INDEX(interfaceHandle);
6149:                            interfaceDescInfo = &deviceObj->configDescriptorInfo.interfaceInfo[interfaceIndex];
6150:                            if(interfaceDescInfo->interfaceDescriptor == NULL)
6151:                            {
6152:                                /* This means this interface is not valid */
6153:                                result = USB_HOST_RESULT_INTERFACE_UNKNOWN;
6154:                            }
6155:                            else
6156:                            {
6157:                                /* We must search for this interface */
6158:                                USB_HOST_DeviceInterfaceQueryContextClear(&interfaceQueryObject);
6159:                                interfaceQueryObject.bInterfaceNumber = interfaceIndex;
6160:                                interfaceQueryObject.bAlternateSetting = alternateSetting;
6161:                                interfaceQueryObject.flags = USB_HOST_INTERFACE_QUERY_ALT_SETTING|USB_HOST_INTERFACE_QUERY_BY_NUMBER;
6162:                                if(USB_HOST_DeviceGeneralInterfaceDescriptorQuery(interfaceDescInfo->interfaceDescriptor,
6163:                                            &interfaceQueryObject) == NULL)
6164:                                {
6165:                                    /* This alternate setting does not exist */
6166:                                    result = USB_HOST_RESULT_INTERFACE_UNKNOWN;
6167:                                }
6168:                                else
6169:                                {
6170:                                    /* Set the request handle default to invalid */
6171:                                    *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
6172:                
6173:                                    /* Get a mutual exclusion lock as the the control transfer object is a global resource */
6174:                                    if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexControlTransferObj), OSAL_WAIT_FOREVER) 
6175:                                            == OSAL_RESULT_TRUE)
6176:                                    {
6177:                                        if(!deviceObj->controlTransferObj.inUse)
6178:                                        {
6179:                                            /* This means that there no control request in progress. We can assign
6180:                                             * request now. The request handle is updated to point to the device
6181:                                             * control transfer object. */
6182:                
6183:                                            deviceObj->controlTransferObj.inUse = true;
6184:                                            *requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
6185:                                        }
6186:                                        else
6187:                                        {
6188:                                            /* A control transfer is in progress. */
6189:                                            result = USB_HOST_RESULT_REQUEST_BUSY;
6190:                                        }
6191:                
6192:                                        /* Unlock the mutual exclusion lock */
6193:                                        OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexControlTransferObj));
6194:                                    }
6195:                                    else
6196:                                    {
6197:                                        /* The mutual exclusion lock could not be obtained */
6198:                                        result = USB_HOST_RESULT_REQUEST_BUSY;
6199:                                    }
6200:                
6201:                                    if(*requestHandle != USB_HOST_REQUEST_HANDLE_INVALID)
6202:                                    {
6203:                                        /* Set up the control transfer object. The endpoint halt
6204:                                         * clear request does not have a data stage. */
6205:                                        controlTransferObj = &deviceObj->controlTransferObj;
6206:                                        controlTransferObj->requestType = USB_HOST_CONTROL_REQUEST_TYPE_INTERFACE_SET;
6207:                                        
6208:                                        /* Remember which alternate setting was requested. This
6209:                                         * will be needed after we get the event */
6210:                                        deviceObj->requestedAlternateSetting = alternateSetting;
6211:                
6212:                                        _USB_HOST_FillSetupPacket(
6213:                                                &(deviceObj->setupPacket),
6214:                                                ( USB_SETUP_DIRN_HOST_TO_DEVICE |
6215:                                                  USB_SETUP_TYPE_STANDARD |
6216:                                                  USB_SETUP_RECIPIENT_INTERFACE ),
6217:                                                USB_REQUEST_SET_INTERFACE,
6218:                                                alternateSetting , interfaceIndex  ,0 ) ;
6219:                
6220:                                        controlTransferObj->controlIRP.data = NULL;
6221:                                        controlTransferObj->controlIRP.setup = &deviceObj->setupPacket;
6222:                                        controlTransferObj->controlIRP.size = deviceObj->setupPacket.wLength;
6223:                                        controlTransferObj->controlIRP.callback = _USB_HOST_DeviceControlTransferCallback;
6224:                                        controlTransferObj->controlIRP.userData = interfaceHandle;
6225:                                        controlTransferObj->context = context;
6226:                                        controlTransferObj->callback = NULL;
6227:                
6228:                                        if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, &(controlTransferObj->controlIRP)))
6229:                                        {
6230:                                            /* There was a problem while submitting the IRP. Update the result and
6231:                                             * the transfer handle. Return the control transfer object back to the
6232:                                             * device object */
6233:                
6234:                                            result = USB_HOST_RESULT_FAILURE;
6235:                                            controlTransferObj->inUse = false;
6236:                                            *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
6237:                                        }
6238:                                        else
6239:                                        {
6240:                                            result = USB_HOST_RESULT_SUCCESS;
6241:                                        }
6242:                                    }
6243:                                }
6244:                            }
6245:                        }
6246:                    }
6247:                
6248:                    return(result);
6249:                }
6250:                
6251:                // *****************************************************************************
6252:                /* Function:
6253:                    USB_HOST_RESULT USB_HOST_DeviceStringDescriptorGet
6254:                    (
6255:                        USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle,
6256:                        USB_HOST_DEVICE_STRING stringType,
6257:                        uint16_t languageID,
6258:                        void * stringDescriptor,
6259:                        size_t length,
6260:                        USB_HOST_REQUEST_HANDLE * requestHandle,
6261:                        USB_HOST_STRING_REQUEST_COMPLETE_CALLBACK callback,
6262:                        uintptr_t context
6263:                    );
6264:                
6265:                  Summary:
6266:                    Retrieves specified string descriptor from the device
6267:                
6268:                  Description:
6269:                    This function retrieves the specified string descriptor from the device.
6270:                    This function will cause the host layer to issue a control transfer to the
6271:                    device. When the string descriptor is available, the host layer will call
6272:                    the callback function to let the application know that the request has
6273:                    completed. 
6274:                    
6275:                    The function will return a valid request handle in requestHandle, if the
6276:                    request was successful. This request handle will be returned in the callback
6277:                    function. The size of the stringDescriptor buffer is specified by the length
6278:                    parameter.  Only length number of bytes will be retrieved. The type of
6279:                    device string descriptor to be retrieved is specified by the stringType
6280:                    parameter. The supported language IDs, manufacturer, product and serial
6281:                    number strings can be obtained. While obtaining the supported language IDs,
6282:                    the languageID parameter will be ignored.
6283:                
6284:                  Remarks:
6285:                    None.
6286:                */
6287:                
6288:                USB_HOST_RESULT USB_HOST_DeviceStringDescriptorGet
6289:                (
6290:                    USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle,
6291:                    USB_HOST_DEVICE_STRING stringType,
6292:                    uint16_t languageID,
6293:                    void * stringDescriptor,
6294:                    size_t length,
6295:                    USB_HOST_REQUEST_HANDLE * requestHandle,
6296:                    USB_HOST_STRING_REQUEST_COMPLETE_CALLBACK callback,
6297:                    uintptr_t context
6298:                )
6299:                {
6300:                    int deviceIndex, pnpIdentifier;
6301:                    USB_HOST_DEVICE_OBJ * deviceObj;
6302:                    USB_HOST_RESULT result = USB_HOST_RESULT_FAILURE;
6303:                    USB_HOST_CONTROL_TRANSFER_OBJ * controlTransferObj;
6304:                    uint8_t stringIndex;
6305:                
6306:                    /* Get the device index and then the pointer to the device object */
6307:                
6308:                    deviceIndex = USB_HOST_DEVICE_INDEX(deviceObjHandle);
6309:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
6310:                
6311:                    if(!deviceObj->inUse)
6312:                    {
6313:                        /* Device object is not valid anymore */
6314:                        result = USB_HOST_RESULT_DEVICE_UNKNOWN;
6315:                    }
6316:                    else
6317:                    {
6318:                        /* Check the Plug N Play identifier */
6319:                        pnpIdentifier = USB_HOST_PNP_IDENTIFIER(deviceObjHandle);
6320:                        if(pnpIdentifier != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
6321:                        {
6322:                            /* This is not the same device as the application thinks it is */
6323:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
6324:                        }
6325:                        else
6326:                        {
6327:                            if((stringDescriptor == NULL) || (length == 0) || (requestHandle == NULL) || (callback == NULL))
6328:                            {
6329:                                /* One of the required parameter is not valid */
6330:                                result = USB_HOST_RESULT_PARAMETER_INVALID;
6331:                            }
6332:                            else
6333:                            {
6334:                                /* Need to check if the device is in a failure state */
6335:                                if(deviceObj->deviceState == USB_HOST_DEVICE_STATE_ERROR)
6336:                                {
6337:                                    result = USB_HOST_RESULT_FAILURE;
6338:                                }
6339:                                else
6340:                                {
6341:                                    if(deviceObj->deviceState != USB_HOST_DEVICE_STATE_READY)
6342:                                    {
6343:                                        /* The device must be in a ready state */
6344:                                        result = USB_HOST_RESULT_REQUEST_BUSY;
6345:                                    }
6346:                                    else
6347:                                    {
6348:                                        /* Map the string type to string index. Set the default
6349:                                         * string index to 0. */
6350:                                        
6351:                                        stringIndex = 0;
6352:                                        switch(stringType)
6353:                                        {
6354:                                            case USB_HOST_DEVICE_STRING_LANG_ID:
6355:                
6356:                                                /* Setting string index to zero will get the
6357:                                                 * the language ID */
6358:                                                stringIndex = 0;
6359:                                                break;
6360:                
6361:                                            case USB_HOST_DEVICE_STRING_MANUFACTURER:
6362:                
6363:                                                /* Set the string index to the manufacture string
6364:                                                   index */
6365:                                                stringIndex = deviceObj->deviceDescriptor.iManufacturer;
6366:                                                break;
6367:                
6368:                                            case USB_HOST_DEVICE_STRING_PRODUCT:
6369:                
6370:                                                /* Set the string index to the manufacture string
6371:                                                   index */
6372:                                                stringIndex = deviceObj->deviceDescriptor.iProduct;
6373:                                                break;
6374:                
6375:                                            case USB_HOST_DEVICE_STRING_SERIAL_NUMBER:
6376:                
6377:                                                /* Set the string index to the manufacture string
6378:                                                   index */
6379:                                                stringIndex = deviceObj->deviceDescriptor.iSerialNumber;
6380:                                                break;
6381:                
6382:                                            default:
6383:                                                break;
6384:                                        }
6385:                
6386:                                        if((stringIndex == 0) && (stringType != USB_HOST_DEVICE_STRING_LANG_ID))
6387:                                        {
6388:                                            /* This means that the device does not support the
6389:                                             * requested string. */
6390:                
6391:                                            result = USB_HOST_RESULT_STRING_DESCRIPTOR_UNSUPPORTED;
6392:                                        }
6393:                                        else
6394:                                        {
6395:                                            /* Set the request handle default to invalid */
6396:                                            *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
6397:                
6398:                                            /* Get a mutual exclusion lock as the control transfer object is a global
6399:                                             * resource */
6400:                
6401:                                            if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexControlTransferObj), OSAL_WAIT_FOREVER) 
6402:                                                    == OSAL_RESULT_TRUE)
6403:                                            {
6404:                                                if(!deviceObj->controlTransferObj.inUse)
6405:                                                {
6406:                                                    /* This means that there no control request in progress. We can assign
6407:                                                     * request now. The request handle is updated to point to the device
6408:                                                     * control transfer object. */
6409:                
6410:                                                    deviceObj->controlTransferObj.inUse = true;
6411:                                                    *requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
6412:                                                }
6413:                                                else
6414:                                                {
6415:                                                    /* A control transfer is in progress. */
6416:                                                    result = USB_HOST_RESULT_REQUEST_BUSY;
6417:                                                }
6418:                
6419:                                                /* Unlock the mutual exclusion lock */
6420:                                                OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexControlTransferObj));
6421:                                            }
6422:                                            else
6423:                                            {
6424:                                                /* The mutual exclusion lock could not be obtained */
6425:                                                result = USB_HOST_RESULT_REQUEST_BUSY;
6426:                                            }
6427:                
6428:                                            if(*requestHandle != USB_HOST_REQUEST_HANDLE_INVALID)
6429:                                            {
6430:                                                /* Set up the control transfer object. The request type
6431:                                                 * allows the one control transfer handler to identify the
6432:                                                 * type of the request. In this case this is a string
6433:                                                 * descriptor request.  */
6434:                                                controlTransferObj = &deviceObj->controlTransferObj;
6435:                                                controlTransferObj->requestType = USB_HOST_CONTROL_REQUEST_TYPE_STRING_DESCRIPTOR;
6436:                
6437:                                                _USB_HOST_FillSetupPacket(
6438:                                                        &(deviceObj->setupPacket),
6439:                                                        ( USB_SETUP_DIRN_DEVICE_TO_HOST |
6440:                                                          USB_SETUP_TYPE_STANDARD |
6441:                                                          USB_SETUP_RECIPIENT_DEVICE ),
6442:                                                        USB_REQUEST_GET_DESCRIPTOR,
6443:                                                        ((USB_DESCRIPTOR_STRING << 8)|stringIndex), languageID, length ) ;
6444:                
6445:                                                /* The userData filed in the IRP is set to the device object
6446:                                                 * handle. This will allow the control transfer callback to
6447:                                                 * identify the device which submitted the control
6448:                                                 * transfer. */
6449:                
6450:                                                controlTransferObj->controlIRP.data = stringDescriptor;
6451:                                                controlTransferObj->controlIRP.setup = &deviceObj->setupPacket;
6452:                                                controlTransferObj->controlIRP.size = deviceObj->setupPacket.wLength;
6453:                                                controlTransferObj->controlIRP.callback = _USB_HOST_DeviceControlTransferCallback;
6454:                                                controlTransferObj->controlIRP.userData = deviceObjHandle ;
6455:                                                controlTransferObj->context = context;
6456:                                                controlTransferObj->callback = callback;
6457:                
6458:                                                if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, &(controlTransferObj->controlIRP)))
6459:                                                {
6460:                                                    /* There was a problem while submitting the IRP. Update the result and
6461:                                                     * the transfer handle. Return the control transfer object back to the
6462:                                                     * device object */
6463:                
6464:                                                    result = USB_HOST_RESULT_FAILURE;
6465:                                                    controlTransferObj->inUse = false;
6466:                                                    *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
6467:                                                }
6468:                                                else
6469:                                                {
6470:                                                    result = USB_HOST_RESULT_SUCCESS;
6471:                                                }
6472:                                            }
6473:                                        }
6474:                                    }
6475:                                }
6476:                            }
6477:                        }
6478:                    }
6479:                    
6480:                    return(result);
6481:                }
6482:                
6483:                // *****************************************************************************
6484:                /* Function:
6485:                    void USB_HOST_OverCurrentDetected
6486:                    (
6487:                        USB_HOST_DEVICE_OBJ_HANDLE parentDeviceObjHandle,
6488:                        uint8_t port,
6489:                        USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle
6490:                    );
6491:                
6492:                  Summary:
6493:                    This function provides indication to the host layer that an over-current
6494:                    event has occurred.
6495:                    
6496:                  Description:
6497:                    This function provides indication to the host layer that an over-current
6498:                    event has occurred. The host layer will in turn forward the event to the
6499:                    application. This function is called exclusively by the root hub or the
6500:                    external hub driver. The root hub or the external driver will de-enumerate
6501:                    this device after the function returns.
6502:                
6503:                  Remarks:
6504:                    This function is optional and may not be available on all implementations of
6505:                    the USB Host Layer. 
6506:                */
6507:                
6508:                void USB_HOST_OverCurrentDetected
6509:                (
6510:                    USB_HOST_DEVICE_OBJ_HANDLE parentDeviceObjHandle,
6511:                    uint8_t port,
6512:                    USB_HOST_DEVICE_OBJ_HANDLE deviceObjHandle
6513:                )
6514:                {
6515:                    /* This function is called when an overcurrent condition has occurred. The
6516:                     * root hub or the external hub driver would de-enumerate the device after
6517:                     * this function exits. So the only thing we should do is to call the
6518:                     * application event handler and let the application know that the over
6519:                     * current event has occurred. */
6520:                
6521:                    if(gUSBHostObj.hostEventHandler != NULL)
6522:                    {
6523:                        /* In this version of the host layer, we do not send any event data with
6524:                         * this event */
6525:                
6526:                        gUSBHostObj.hostEventHandler(USB_HOST_EVENT_PORT_OVERCURRENT_DETECTED, NULL, gUSBHostObj.context);
6527:                    }
6528:                }
6529:                
6530:                // *****************************************************************************
6531:                /* Function:
6532:                    USB_HOST_RESULT USB_HOST_ConfigurationDescriptorGet
6533:                    (
6534:                        USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
6535:                        USB_HOST_REQUEST_HANDLE * requestHandle
6536:                        uint8_t configurationIndex,
6537:                        void * buffer,
6538:                        size_t size,
6539:                        uintptr_t context
6540:                    );
6541:                
6542:                  Summary:
6543:                    Requests for a configuration descriptor.
6544:                
6545:                  Description:
6546:                    This function places a USB Host request to obtain a device configuration
6547:                    descriptor. The function is non blocking. A pointer to the configuration
6548:                    descriptor data will be available in event data when the
6549:                    USB_HOST_DEVICE_EVENT_CONFIGURATION_DESCRIPTOR_GET_COMPLETE event occurs.
6550:                    The size of the configuration descriptor will be available in the event
6551:                    data.
6552:                
6553:                  Remarks:
6554:                    None.
6555:                */
6556:                
6557:                USB_HOST_RESULT USB_HOST_DeviceConfigurationDescriptorGet
6558:                (
6559:                    USB_HOST_DEVICE_CLIENT_HANDLE deviceHandle,
6560:                    USB_HOST_REQUEST_HANDLE * requestHandle,
6561:                    uint8_t configurationValue,
6562:                    void * buffer,
6563:                    size_t size,
6564:                    uintptr_t context
6565:                )
6566:                {
6567:                    int deviceIndex, pnpIdentifier;
6568:                    USB_HOST_DEVICE_OBJ * deviceObj;
6569:                    USB_HOST_RESULT result = USB_HOST_RESULT_FAILURE;
6570:                    USB_HOST_CONTROL_TRANSFER_OBJ * controlTransferObj;
6571:                
6572:                    /* Get the device index and then the pointer to the device object */
6573:                
6574:                    deviceIndex = USB_HOST_DEVICE_INDEX(deviceHandle);
6575:                    deviceObj = &gUSBHostDeviceList[deviceIndex];
6576:                
6577:                    if(!deviceObj->inUse)
6578:                    {
6579:                        /* Device object is not valid anymore */
6580:                        result = USB_HOST_RESULT_DEVICE_UNKNOWN;
6581:                    }
6582:                    else
6583:                    {
6584:                        /* Check the Plug N Play identifier */
6585:                        pnpIdentifier = USB_HOST_PNP_IDENTIFIER(deviceHandle);
6586:                        if(pnpIdentifier != USB_HOST_PNP_IDENTIFIER(deviceObj->deviceIdentifier))
6587:                        {
6588:                            /* This is not the same device as the application thinks it is */
6589:                            result = USB_HOST_RESULT_DEVICE_UNKNOWN;
6590:                        }
6591:                        else
6592:                        {
6593:                            if((size == 0) || (requestHandle == NULL) || (buffer == NULL))
6594:                            {
6595:                                /* One of the required parameter is not valid */
6596:                                result = USB_HOST_RESULT_PARAMETER_INVALID;
6597:                            }
6598:                            else
6599:                            {
6600:                                /* Need to check if the device is in a failure state */
6601:                                if(deviceObj->deviceState == USB_HOST_DEVICE_STATE_ERROR)
6602:                                {
6603:                                    result = USB_HOST_RESULT_FAILURE;
6604:                                }
6605:                                else
6606:                                {
6607:                                    if(deviceObj->deviceState != USB_HOST_DEVICE_STATE_READY)
6608:                                    {
6609:                                        /* The device must be in a ready state */
6610:                                        result = USB_HOST_RESULT_REQUEST_BUSY;
6611:                                    }
6612:                                    else
6613:                                    {     
6614:                                        /* Set the request handle default to invalid */
6615:                                        *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
6616:                
6617:                                        /* Get a mutual exclusion lock as the control transfer object is a global
6618:                                         * resource */
6619:                
6620:                                        if(OSAL_MUTEX_Lock(&(gUSBHostObj.mutexControlTransferObj), OSAL_WAIT_FOREVER) 
6621:                                                == OSAL_RESULT_TRUE)
6622:                                        {
6623:                                            if(!deviceObj->controlTransferObj.inUse)
6624:                                            {
6625:                                                /* This means that there no control request in progress. We can assign
6626:                                                 * request now. The request handle is updated to point to the device
6627:                                                 * control transfer object. */
6628:                
6629:                                                deviceObj->controlTransferObj.inUse = true;
6630:                                                *requestHandle = (USB_HOST_REQUEST_HANDLE)(&deviceObj->controlTransferObj);
6631:                                            }
6632:                                            else
6633:                                            {
6634:                                                /* A control transfer is in progress. */
6635:                                                result = USB_HOST_RESULT_REQUEST_BUSY;
6636:                                            }
6637:                
6638:                                            /* Unlock the mutual exclusion lock */
6639:                                            OSAL_MUTEX_Unlock(&(gUSBHostObj.mutexControlTransferObj));
6640:                                        }
6641:                                        else
6642:                                        {
6643:                                            /* The mutual exclusion lock could not be obtained */
6644:                                            result = USB_HOST_RESULT_REQUEST_BUSY;
6645:                                        }
6646:                
6647:                                        if(*requestHandle != USB_HOST_REQUEST_HANDLE_INVALID)
6648:                                        {
6649:                
6650:                                            /* Create the Setup packet */
6651:                                            _USB_HOST_FillSetupPacket(
6652:                                                    &(deviceObj->setupPacket),
6653:                                                    ( USB_SETUP_DIRN_DEVICE_TO_HOST |
6654:                                                      USB_SETUP_TYPE_STANDARD |
6655:                                                      USB_SETUP_RECIPIENT_DEVICE ),
6656:                                                    USB_REQUEST_GET_DESCRIPTOR,
6657:                                                    ( USB_DESCRIPTOR_CONFIGURATION << 8 ) + configurationValue , 0 , size ) ;
6658:                
6659:                                            /* Set up the control transfer object. The endpoint halt
6660:                                             * clear request does not have a data stage. */
6661:                                            controlTransferObj = &deviceObj->controlTransferObj;
6662:                                            controlTransferObj->requestType = USB_HOST_CONTROL_REQUEST_TYPE_CONFIGURATION_DESCRIPTOR_GET;
6663:                
6664:                                            controlTransferObj->controlIRP.data = buffer;
6665:                                            controlTransferObj->controlIRP.setup = &deviceObj->setupPacket;
6666:                                            controlTransferObj->controlIRP.size = deviceObj->setupPacket.wLength;
6667:                                            controlTransferObj->controlIRP.callback = _USB_HOST_DeviceControlTransferCallback;
6668:                                            controlTransferObj->controlIRP.userData = deviceHandle;
6669:                                            controlTransferObj->context = context;
6670:                                            controlTransferObj->callback = NULL;
6671:                
6672:                                            if(USB_ERROR_NONE != deviceObj->hcdInterface->hostIRPSubmit( deviceObj->controlPipeHandle, &(controlTransferObj->controlIRP)))
6673:                                            {
6674:                                                /* There was a problem while submitting the IRP. Update the result and
6675:                                                 * the transfer handle. Return the control transfer object back to the
6676:                                                 * device object */
6677:                
6678:                                                result = USB_HOST_RESULT_FAILURE;
6679:                                                controlTransferObj->inUse = false;
6680:                                                *requestHandle = USB_HOST_REQUEST_HANDLE_INVALID;
6681:                                            }
6682:                                            else
6683:                                            {
6684:                                                result = USB_HOST_RESULT_SUCCESS;
6685:                                            }
6686:                
6687:                                        }
6688:                
6689:                                    }
6690:                                }
6691:                            }
6692:                        }
6693:                    }
6694:                    return result;
6695:                }
6696:                
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/system/tmr/src/sys_tmr.c
1:                   /*******************************************************************************
2:                     Timer System Service Definition
3:                   
4:                   Company:
5:                   Microchip Technology Inc.
6:                   
7:                   File Name:
8:                   sys_tmr.c
9:                   
10:                  Summary:
11:                  Timer System Service implementation.
12:                  
13:                  Description:
14:                  The Timer System Service provides a simple interface to manage the Timer modules
15:                  on Microchip micro controllers.  This file implements the core interface routines
16:                  for the System Timer Service.
17:                  While building the SYS TMR from source, ALWAYS use this file in the build.
18:                   *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                    Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                    Microchip licenses to you the right to use, modify, copy and distribute
25:                    Software only when embedded on a Microchip microcontroller or digital signal
26:                    controller that is integrated into your product or third party product
27:                    (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                    You should refer to the license agreement accompanying this Software for
30:                    additional information regarding your rights and obligations.
31:                  
32:                    SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                    EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                    MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                    IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                    CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                    OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                    INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                    CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                    SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                    (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                   *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: Included Files
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  /*  This section lists the other files that are included in this file.
51:                   */
52:                  
53:                  #include "system/tmr/src/sys_tmr_local.h"
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Section: Variable Definitions
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  
61:                  
62:                  
63:                  /* System timer instance */
64:                  static SYS_TMR_OBJECT sSysTmrObject = {0};
65:                  
66:                  /* Client object array */
67:                  static SYS_TMR_CLIENT_OBJECT sClientObjects [ SYS_TMR_MAX_CLIENT_OBJECTS ];
68:                  
69:                  
70:                  // *****************************************************************************
71:                  
72:                  /* OSAL user protection 
73:                  
74:                  Summary:
75:                      Enforces the user threads protection
76:                  
77:                  Description:
78:                      Protects against multiple users using concurrently the TMR service.
79:                      For efficiency reasons, there is NO PROTECTION for each API call except
80:                      when creating and deleting new timer clients!
81:                      What it means is that:
82:                      - A client timer cannot be used concurrently from multiple threads!
83:                      It's ok to pass a handle from one thread to another as long as
84:                      there's is no access from more than one thread at a time
85:                  
86:                  Remarks:
87:                  
88:                  None.
89:                   */
90:                  
91:                  static __inline__ bool __attribute__((always_inline)) _UserGblLockCreate(void) {
92:                      // create the shared Data Lock
93:                      return OSAL_SEM_Create(&sSysTmrObject.userSem, OSAL_SEM_TYPE_BINARY, 1, 1) == OSAL_RESULT_TRUE;
94:                  }
95:                  
96:                  static __inline__ void __attribute__((always_inline)) _UserGblLockDelete(void) {
97:                      OSAL_SEM_Delete(&sSysTmrObject.userSem);
98:                  }
99:                  
100:                 // locks access to shared resources
101:                 
102:                 static __inline__ void __attribute__((always_inline)) _UserGblLock(void) {
103:                     // Shared Data Lock
104:                     OSAL_SEM_Pend(&sSysTmrObject.userSem, OSAL_WAIT_FOREVER);
105:                 }
106:                 
107:                 // unlocks access to shared resources
108:                 
109:                 static __inline__ void __attribute__((always_inline)) _UserGblUnlock(void) {
110:                     // Shared Data unlock
111:                     OSAL_SEM_Post(&sSysTmrObject.userSem);
112:                 }
113:                 
114:                 // ISR protection
115:                 // when the timer driver delivers the notification in interrupts
116:                 #if (SYS_TMR_INTERRUPT_NOTIFICATION)
117:                 // do not re-schedule while locked the timer ISR
118:                 // this needs to be real quick
119:                 
120:                 static __inline__ bool __attribute__((always_inline)) _IsrTmrLock(OSAL_CRITSECT_DATA_TYPE* pCritStat) {
121:                     *pCritStat = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_LOW);
122:                     return DRV_TMR_AlarmDisable(sSysTmrObject.driverHandle);
123:                 }
124:                 
125:                 static __inline__ void __attribute__((always_inline)) _IsrTmrUnlock(bool lock, OSAL_CRITSECT_DATA_TYPE critStat) {
126:                     DRV_TMR_AlarmEnable(sSysTmrObject.driverHandle, lock);
127:                     OSAL_CRIT_Leave(OSAL_CRIT_TYPE_LOW, critStat);
128:                 }
129:                 
130:                 #else   // !(SYS_TMR_INTERRUPT_NOTIFICATION)
131:                 
132:                 static __inline__ bool __attribute__((always_inline)) _IsrTmrLock(OSAL_CRITSECT_DATA_TYPE* pCritStat) {
133:                     return false;
134:                 }
135:                 
136:                 static __inline__ void __attribute__((always_inline)) _IsrTmrUnlock(bool lock, OSAL_CRITSECT_DATA_TYPE critStat) {
137:                 }
138:                 
139:                 #endif  // (SYS_TMR_INTERRUPT_NOTIFICATION)
140:                 
141:                 static __inline__ void __attribute__((always_inline)) _SYS_TMR_ClientSrvUnlock(void) {
142:                     _UserGblUnlock();
143:                 }
144:                 
145:                 
146:                 // access to the object is protected from threads and ISR
147:                 // make it quick
148:                 
149:                 static __inline__ void __attribute__((always_inline)) _SYS_TMR_ClientDelete(SYS_TMR_CLIENT_OBJECT* pClient) {
150:                     pClient->isrEnable = 0;
9D002984  A2000001   SB ZERO, 1(S0)
151:                     pClient->isrState = SYS_TMR_CLIENT_ISR_IDLE;
9D002988  A2000002   SB ZERO, 2(S0)
152:                     pClient->currState = SYS_TMR_CLIENT_FREE;
9D00298C  0B400A67   J 0x9D00299C
9D002990  A2000000   SB ZERO, 0(S0)
153:                     // do other clean up here
154:                 }
155:                 
156:                 static __inline__ bool __attribute__((always_inline)) _SYS_TMR_ObjectCheck(SYS_MODULE_OBJ object) {
157:                     // basic sanity check we're the right object
158:                     return (SYS_TMR_OBJECT*) object == &sSysTmrObject;
159:                 }
160:                 
161:                 static __inline__ bool __attribute__((always_inline)) _SYS_TMR_ReadyCheck(void) {
162:                     // basic sanity check the SYS_TMR is in the up and running state
163:                     return sSysTmrObject.status == SYS_STATUS_READY;
9D004CD4  3C02A000   LUI V0, -24576
164:                 }
165:                 
166:                 // check the validity of a client handle and locks the user threads
167:                 // returns a valid pointer if success and _SYS_TMR_ClientSrvUnlock() needs to be called
168:                 // returns 0 if invalid, do NOT call _SYS_TMR_ClientSrvUnlock !
169:                 //
170:                 
171:                 static SYS_TMR_CLIENT_OBJECT* _SYS_TMR_ClientCheckSrvLock(SYS_TMR_HANDLE handle) {
172:                     if (!_SYS_TMR_ReadyCheck()) {
173:                         return 0;
174:                     }
175:                 
176:                     // lock client access
177:                     _UserGblLock();
178:                     if (handle != 0 && handle != SYS_TMR_HANDLE_INVALID) { // extra sanity check could be added here
179:                         if (((SYS_TMR_CLIENT_OBJECT*) handle)->currState > 0) {
180:                             return (SYS_TMR_CLIENT_OBJECT*) handle;
181:                         }
182:                     }
183:                 
184:                     // not a valid client
185:                     _UserGblUnlock();
186:                     return 0;
187:                 }
188:                 
189:                 // *****************************************************************************
190:                 // *****************************************************************************
191:                 // Section: SYS TMR Interface Function Definitions
192:                 // *****************************************************************************
193:                 // *****************************************************************************
194:                 
195:                 // *****************************************************************************
196:                 
197:                 /* Function:
198:                    SYS_MODULE_OBJ SYS_TMR_Initialize ( const SYS_MODULE_INDEX index,
199:                    const SYS_MODULE_INIT * const init )
200:                 
201:                 Summary:
202:                 Initializes hardware and data for the instance of the Timer module and opens
203:                 the specific module instance.
204:                 
205:                 Description:
206:                 This function initializes hardware for the instance of the Timer module,
207:                 using the specified hardware initialization data. It also initializes any
208:                 internal data structures.
209:                 
210:                 Parameters:
211:                 index           - Index for the instance to be initialized
212:                 
213:                 init            - Pointer to a data structure containing any data necessary
214:                 to initialize the driver. This pointer may be null if no
215:                 data is required because static overrides have been
216:                 provided.
217:                 
218:                 Returns:
219:                 None
220:                  */
221:                 
222:                 SYS_MODULE_OBJ SYS_TMR_Initialize(const SYS_MODULE_INDEX index,
223:                         const SYS_MODULE_INIT * const init) {
9D007D18  27BDFFE8   ADDIU SP, SP, -24
9D007D1C  AFBF0014   SW RA, 20(SP)
9D007D20  AFB00010   SW S0, 16(SP)
9D007D24  00A08021   ADDU S0, A1, ZERO
224:                 
225:                     while (true) {
226:                         memset(&sSysTmrObject, 0, sizeof (sSysTmrObject));
9D007D28  3C02A000   LUI V0, -24576
9D007D2C  AC40010C   SW ZERO, 268(V0)
9D007D30  2442010C   ADDIU V0, V0, 268
9D007D34  AC400004   SW ZERO, 4(V0)
9D007D38  AC400008   SW ZERO, 8(V0)
9D007D3C  AC40000C   SW ZERO, 12(V0)
9D007D40  AC400010   SW ZERO, 16(V0)
9D007D44  AC400014   SW ZERO, 20(V0)
9D007D48  AC400018   SW ZERO, 24(V0)
9D007D4C  AC40001C   SW ZERO, 28(V0)
9D007D50  AC400020   SW ZERO, 32(V0)
9D007D54  AC400024   SW ZERO, 36(V0)
227:                 
228:                         if (init == 0 || index != SYS_TMR_INDEX_0) {
9D007D58  10A00017   BEQ A1, ZERO, 0x9D007DB8
9D007D5C  AC400028   SW ZERO, 40(V0)
9D007D60  14800016   BNE A0, ZERO, 0x9D007DBC
9D007D64  2403FFFF   ADDIU V1, ZERO, -1
229:                             break;
230:                         }
231:                 
232:                         const SYS_TMR_INIT * sysTmrInit;
233:                         sysTmrInit = (const SYS_TMR_INIT *) init;
234:                         // clear the client structures
235:                         memset(sClientObjects, 0, sizeof (sClientObjects));
9D007D68  3C04A000   LUI A0, -24576
9D007D6C  248400A8   ADDIU A0, A0, 168
9D007D70  00002821   ADDU A1, ZERO, ZERO
9D007D74  0F40202B   JAL memset
9D007D78  24060064   ADDIU A2, ZERO, 100
236:                 
237:                         /* Set the status for the state machine to advance */
238:                         sSysTmrObject.drvIndex = sysTmrInit->drvIndex;
9D007D7C  3C02A000   LUI V0, -24576
9D007D80  96030002   LHU V1, 2(S0)
9D007D84  A443010C   SH V1, 268(V0)
239:                         sSysTmrObject.sysTickFreq = sysTmrInit->tmrFreq;
9D007D88  8E030004   LW V1, 4(S0)
9D007D8C  2450010C   ADDIU S0, V0, 268
240:                 
241:                         if (!_UserGblLockCreate()) { // failed to create OSAL protection
242:                             break;
243:                         }
244:                 
245:                         // success; proceed with the initialization
246:                         sSysTmrObject.status = SYS_STATUS_BUSY;
9D007DA8  24020001   ADDIU V0, ZERO, 1
9D007DAC  AE020008   SW V0, 8(S0)
247:                         /* Return timer object */
248:                         return (SYS_MODULE_OBJ)&sSysTmrObject;
9D007DB0  0B401F72   J 0x9D007DC8
9D007DB4  02001021   ADDU V0, S0, ZERO
249:                     }
250:                 
251:                     // initialization failed
252:                     sSysTmrObject.status = SYS_STATUS_ERROR;
9D007DB8  2403FFFF   ADDIU V1, ZERO, -1
9D007DBC  3C02A000   LUI V0, -24576
9D007DC0  AC430114   SW V1, 276(V0)
253:                     return SYS_MODULE_OBJ_INVALID;
9D007DC4  2402FFFF   ADDIU V0, ZERO, -1
254:                 }
9D007DC8  8FBF0014   LW RA, 20(SP)
255:                 
256:                 
257:                 // *****************************************************************************
258:                 
259:                 /* Function:
260:                    void SYS_TMR_Deinitialize ( SYS_MODULE_OBJ object )
261:                 
262:                 Summary:
263:                 De-initializes the specific module instance of the Timer module.
264:                 
265:                 Description:
266:                 De-initializes the specific module instance disabling its operation (and
267:                 any hardware for driver modules). Resets all the internal data
268:                 structures and fields for the specified instance to the default
269:                 settings.
270:                 
271:                 PreCondition:
272:                 The SYS_TMR_Initialize function should have been called before calling
273:                 this function.
274:                 
275:                 Parameters:
276:                 object          - SYS TMR object handle, returned from SYS_TMR_Initialize
277:                 
278:                 Returns:
279:                 None.
280:                  */
281:                 
282:                 void SYS_TMR_Deinitialize(SYS_MODULE_OBJ object) {
283:                     int ix;
284:                 
285:                     if (!_SYS_TMR_ObjectCheck(object)) {
286:                         return;
287:                     }
288:                 
289:                     // we're up and running
290:                     // make sure no new clients are accepted
291:                     _UserGblLock();
292:                 
293:                     // now kill all clients
294:                     if (sSysTmrObject.driverHandle != 0 && sSysTmrObject.driverHandle != DRV_HANDLE_INVALID) {
295:                         DRV_TMR_Close(sSysTmrObject.driverHandle);
296:                         sSysTmrObject.driverHandle = 0;
297:                     }
298:                 
299:                     // release all clients
300:                     SYS_TMR_CLIENT_OBJECT* pClient = sClientObjects + 0;
301:                     for (ix = 0; ix < sizeof (sClientObjects) / sizeof (*sClientObjects); ix++, pClient++) {
302:                         pClient->isrEnable = 0;
303:                         if (pClient->currState != SYS_TMR_CLIENT_FREE) {
304:                             _SYS_TMR_ClientDelete(pClient);
305:                         }
306:                     }
307:                 
308:                     _UserGblLockDelete();
309:                 
310:                     sSysTmrObject.status = SYS_STATUS_UNINITIALIZED;
311:                 
312:                 }
313:                 
314:                 
315:                 // *****************************************************************************
316:                 
317:                 /* Function:
318:                    SYS_STATUS SYS_TMR_Status ( SYS_MODULE_OBJ object )
319:                 
320:                 Summary:
321:                 Returns status of the specific module instance of the Timer module.
322:                 
323:                 Description:
324:                 This function returns the status of the specific module instance disabling its
325:                 operation (and any hardware for driver modules).
326:                 
327:                 PreCondition:
328:                 The SYS_TMR_Initialize function should have been called before calling
329:                 this function.
330:                 
331:                 Parameters:
332:                 object          - SYS TMR object handle, returned from SYS_TMR_Initialize
333:                 
334:                 Returns:
335:                 SYS_STATUS_READY    Indicates that any previous module operation for the
336:                 specified module has completed
337:                 
338:                 SYS_STATUS_BUSY     Indicates that a previous module operation for the
339:                 specified module has not yet completed
340:                 
341:                 SYS_STATUS_ERROR    Indicates that the specified module is in an error state
342:                  */
343:                 
344:                 SYS_STATUS SYS_TMR_Status(SYS_MODULE_OBJ object) {
345:                     if (!_SYS_TMR_ObjectCheck(object)) {
346:                         return SYS_STATUS_UNINITIALIZED;
347:                     }
348:                 
349:                     return ( sSysTmrObject.status);
350:                 }
351:                 
352:                 SYS_STATUS SYS_TMR_ModuleStatusGet(const SYS_MODULE_INDEX index) {
353:                     return (index == SYS_TMR_INDEX_0) ? sSysTmrObject.status : SYS_STATUS_UNINITIALIZED;
354:                 }
355:                 
356:                 
357:                 
358:                 // *****************************************************************************
359:                 
360:                 /* Function:
361:                    void SYS_TMR_Tasks ( SYS_MODULE_OBJ object )
362:                 
363:                 Summary:
364:                 Maintains the system Timer's state machine and implements its ISR.
365:                 
366:                 Description:
367:                 This routine is used to maintain the system Timer's internal state machine and
368:                 implement its ISR for interrupt-driven implementations.
369:                 
370:                 Precondition:
371:                 The SYS_TMR_Initialize function must have been called for the specified Timer
372:                 driver instance.
373:                 
374:                 Parameters:
375:                 object          - SYS TMR object handle, returned from SYS_TMR_Initialize
376:                 
377:                 Returns:
378:                 None.
379:                  */
380:                 
381:                 void SYS_TMR_Tasks(SYS_MODULE_OBJ object) {
9D002758  27BDFFC8   ADDIU SP, SP, -56
9D00275C  AFBF0034   SW RA, 52(SP)
9D002760  AFB60030   SW S6, 48(SP)
9D002764  AFB5002C   SW S5, 44(SP)
9D002768  AFB40028   SW S4, 40(SP)
9D00276C  AFB30024   SW S3, 36(SP)
9D002770  AFB20020   SW S2, 32(SP)
9D002774  AFB1001C   SW S1, 28(SP)
382:                     if (!_SYS_TMR_ObjectCheck(object)) {
9D002778  3C02A000   LUI V0, -24576
9D00277C  2442010C   ADDIU V0, V0, 268
9D002780  144400AD   BNE V0, A0, 0x9D002A38
9D002784  AFB00018   SW S0, 24(SP)
383:                         return;
384:                     }
385:                 
386:                     switch (sSysTmrObject.status) {
9D002788  3C02A000   LUI V0, -24576
9D00278C  8C420114   LW V0, 276(V0)
9D002790  24030001   ADDIU V1, ZERO, 1
9D002794  10430005   BEQ V0, V1, 0x9D0027AC
9D002798  24030002   ADDIU V1, ZERO, 2
9D00279C  1043004B   BEQ V0, V1, 0x9D0028CC
9D0027A0  3C02A000   LUI V0, -24576
387:                         case SYS_STATUS_BUSY:
388:                             // Performing the initialization
389:                             // Try to open a TMR driver
390:                             sSysTmrObject.driverHandle = DRV_TMR_Open(sSysTmrObject.drvIndex, DRV_IO_INTENT_EXCLUSIVE);
9D0027AC  3C10A000   LUI S0, -24576
9D0027B0  9604010C   LHU A0, 268(S0)
9D0027B4  0F402414   JAL DRV_TMR_Open
9D0027B8  24050008   ADDIU A1, ZERO, 8
9D0027BC  2610010C   ADDIU S0, S0, 268
391:                 
392:                             if (sSysTmrObject.driverHandle == DRV_HANDLE_INVALID) { // spin here until the driver is opened
9D0027C0  2403FFFF   ADDIU V1, ZERO, -1
9D0027C4  1043009C   BEQ V0, V1, 0x9D002A38
9D0027C8  AE020004   SW V0, 4(S0)
393:                                 break;
394:                             }
395:                 
396:                             // try to set up the service parameters
397:                             if (!_SYS_TMR_Setup(&sSysTmrObject)) { // some parameter error occurred
398:                                 DRV_TMR_Close(sSysTmrObject.driverHandle);
9D0029D4  3C10A000   LUI S0, -24576
9D0029D8  2610010C   ADDIU S0, S0, 268
9D0029DC  0F4024E4   JAL DRV_TMR_Close
9D0029E0  8E040004   LW A0, 4(S0)
399:                                 sSysTmrObject.driverHandle = 0;
9D0029E4  AE000004   SW ZERO, 4(S0)
400:                                 sSysTmrObject.status = SYS_STATUS_ERROR;
9D0029E8  2402FFFF   ADDIU V0, ZERO, -1
401:                                 break;
9D0029EC  0B400A8E   J 0x9D002A38
9D0029F0  AE020008   SW V0, 8(S0)
402:                             }
403:                 
404:                             // success
405:                             /* Set the alarm */
406:                             DRV_TMR_AlarmRegister(sSysTmrObject.driverHandle, sSysTmrObject.driverPeriod, true,
9D002890  8E040004   LW A0, 4(S0)
9D002894  3C029D01   LUI V0, -25343
9D002898  2442988C   ADDIU V0, V0, -26484
9D00289C  AFA20010   SW V0, 16(SP)
9D0028A0  24060001   ADDIU A2, ZERO, 1
9D0028A4  0F4018B2   JAL DRV_TMR_AlarmRegister
9D0028A8  02003821   ADDU A3, S0, ZERO
407:                                     (uintptr_t) & sSysTmrObject, _SYS_TMR_AlarmCallback);
408:                             /*Enable the alarm*/
409:                             DRV_TMR_AlarmEnable(sSysTmrObject.driverHandle, true);
9D0028AC  8E040004   LW A0, 4(S0)
9D0028B0  0F4023E6   JAL DRV_TMR_AlarmEnable
9D0028B4  24050001   ADDIU A1, ZERO, 1
410:                             /* Start the timer */
411:                             DRV_TMR_Start(sSysTmrObject.driverHandle);
9D0028B8  0F40236C   JAL DRV_TMR_Start
9D0028BC  8E040004   LW A0, 4(S0)
412:                 
413:                             /* Status of the state machine is changed to indicate initialization complete */
414:                             sSysTmrObject.status = SYS_STATUS_READY;
9D0028C0  24020002   ADDIU V0, ZERO, 2
415:                             break;
9D0028C4  0B400A8E   J 0x9D002A38
9D0028C8  AE020008   SW V0, 8(S0)
416:                 
417:                         case SYS_STATUS_READY:
418:                 
419:                             /* If there is no activity we need not run the loop */
420:                 #if (SYS_TMR_INTERRUPT_NOTIFICATION)
421:                             // block user access; we may delete clients
422:                             _UserGblLock();
423:                             _SYS_TMR_ProcessIsrClients();
424:                             _UserGblUnlock();
425:                 #else
426:                             if (sSysTmrObject.alarmReceived == true) {
9D0028CC  90420134   LBU V0, 308(V0)
9D0028D0  1040005A   BEQ V0, ZERO, 0x9D002A3C
9D0028D4  8FBF0034   LW RA, 52(SP)
427:                                 sSysTmrObject.alarmReceived = false;
9D0028D8  3C10A000   LUI S0, -24576
9D0028DC  2610010C   ADDIU S0, S0, 268
428:                                 // block user access; we may delete clients
429:                                 _UserGblLock();
430:                                 _SYS_TMR_ProcessTmrAlarm();
431:                                 _UserGblUnlock();
432:                             }
433:                 #endif  // (SYS_TMR_INTERRUPT_NOTIFICATION)
434:                             break;
435:                 
436:                         default: // SYS_STATUS_ERROR, SYS_STATUS_UNINITIALIZED, etc.
437:                             // do nothing
438:                             break;
439:                     }
440:                 
441:                 }
9D0027A4  0B400A8F   J 0x9D002A3C
9D0027A8  8FBF0034   LW RA, 52(SP)
9D0029CC  0B400A8F   J 0x9D002A3C
9D0029D0  8FBF0034   LW RA, 52(SP)
9D002A38  8FBF0034   LW RA, 52(SP)
442:                 
443:                 static bool _SYS_TMR_Setup(SYS_TMR_OBJECT* tmrObject) {
444:                     uint32_t drvFreq, drvPeriod, errorFreq;
445:                     uint32_t tickFreq, tickUnitCount;
446:                 
447:                     // sanity check, protect against user error
448:                     if (sSysTmrObject.sysTickFreq == 0 || SYS_TMR_UNIT_RESOLUTION < 1000 || SYS_TMR_UNIT_RESOLUTION / sSysTmrObject.sysTickFreq < 1) {
9D0027CC  3C03A000   LUI V1, -24576
449:                         return false;
450:                     }
451:                 
452:                     drvFreq = DRV_TMR_CounterFrequencyGet(tmrObject->driverHandle);
9D0027F0  0F401CE6   JAL DRV_TMR_CounterFrequencyGet
453:                     // sanity check that we can obtain the requested frequency
454:                     // with the underlying 16 bit timer (period = [2, 0xffff]);
455:                     drvPeriod = drvFreq / tmrObject->sysTickFreq;
9D0027F8  3C03A000   LUI V1, -24576
456:                 
457:                     if (drvPeriod < 2 || drvPeriod > 0xffff) { // required freq not within obtainable range
9D00280C  24A7FFFE   ADDIU A3, A1, -2
458:                         return false;
459:                     }
460:                     // calculate the actual tick frequency
461:                     tickFreq = drvFreq / drvPeriod;
9D002820  0045001B   DIVU V0, A1
462:                     // check we're within requested limits
463:                     if (tickFreq >= tmrObject->sysTickFreq) {
9D00282C  0083482B   SLTU T1, A0, V1
464:                         errorFreq = tickFreq - tmrObject->sysTickFreq;
9D002830  00833023   SUBU A2, A0, V1
465:                     } else {
466:                         errorFreq = tmrObject->sysTickFreq - tickFreq;
467:                     }
468:                 
469:                     if ((errorFreq * 100) / tmrObject->sysTickFreq > SYS_TMR_FREQUENCY_TOLERANCE) { // too great an error
9D00283C  00073080   SLL A2, A3, 2
470:                         return false;
471:                     }
472:                 
473:                     // calculate the timer units
474:                     tickUnitCount = SYS_TMR_UNIT_RESOLUTION / tickFreq;
9D002868  0064001B   DIVU V1, A0
475:                     if (tickUnitCount < 1) { // not enough resolution
9D002874  10600057   BEQ V1, ZERO, 0x9D0029D4
476:                         return false;
477:                     }
478:                 
479:                     // success
480:                     tmrObject->sysTickFreq = tickFreq;
9D00287C  2610010C   ADDIU S0, S0, 268
481:                     tmrObject->sysTickUnitCount = tickUnitCount;
9D002884  AE030010   SW V1, 16(S0)
482:                     tmrObject->driverFreq = drvFreq;
9D002888  AE020020   SW V0, 32(S0)
483:                     tmrObject->driverPeriod = drvPeriod;
9D00288C  AE050024   SW A1, 36(S0)
484:                 
485:                 
486:                     return true;
487:                 }
488:                 
489:                 
490:                 // *****************************************************************************
491:                 
492:                 /* Function:
493:                    SYS_TMR_HANDLE _SYS_TMR_ClientCreate ( unsigned int periodMs,  
494:                    uintptr_t context, SYS_TMR_CALLBACK callback, SYS_TMR_FLAGS flags )
495:                 
496:                 Summary:
497:                     Creates a new timer client, if possible.
498:                 
499:                 Description:
500:                     It tries to add a new timer client using the requested period in milliseconds.
501:                 
502:                 Parameters:
503:                     periodMs    - alarm time
504:                     context     - client supplied parameter to be passed in the callback
505:                                   not used by the TMR service itself
506:                     callback    - client function to be called when the alarm expired                
507:                     flags       - SYS_TMR_FLAGS object flags 
508:                 
509:                 Returns:
510:                     A valid SYS_TMR_HANDLE if success
511:                     SYS_TMR_HANDLE_INVALID if failed
512:                  */
513:                 
514:                 static SYS_TMR_HANDLE _SYS_TMR_ClientCreate(uint32_t periodMs, uintptr_t context, SYS_TMR_CALLBACK callback, SYS_TMR_FLAGS flags) {
9D004CE8  27BDFFD8   ADDIU SP, SP, -40
9D004CEC  AFBF0024   SW RA, 36(SP)
9D004CF0  AFB40020   SW S4, 32(SP)
9D004CF4  AFB3001C   SW S3, 28(SP)
9D004CF8  AFB20018   SW S2, 24(SP)
9D004CFC  AFB10014   SW S1, 20(SP)
9D004D00  AFB00010   SW S0, 16(SP)
9D004D04  00808821   ADDU S1, A0, ZERO
9D004D08  00A09021   ADDU S2, A1, ZERO
9D004D0C  00C09821   ADDU S3, A2, ZERO
515:                     SYS_TMR_CLIENT_OBJECT *timerObj;
516:                     SYS_TMR_CLIENT_OBJECT *newObj;
517:                     int index;
518:                 
519:                     if (!_SYS_TMR_ReadyCheck()) {
9D004CD8  8C480114   LW T0, 276(V0)
9D004CDC  24030002   ADDIU V1, ZERO, 2
9D004CE0  1503005D   BNE T0, V1, 0x9D004E58
9D004CE4  2402FFFF   ADDIU V0, ZERO, -1
520:                         return SYS_TMR_HANDLE_INVALID;
521:                     }
522:                 
523:                     // lock user access
524:                     _UserGblLock();
525:                 
526:                     newObj = (SYS_TMR_CLIENT_OBJECT*) SYS_TMR_HANDLE_INVALID;
527:                     timerObj = sClientObjects + 0;
9D004D64  3C10A000   LUI S0, -24576
9D004D68  261000A8   ADDIU S0, S0, 168
528:                     for (index = 0; index < sizeof (sClientObjects) / sizeof (*sClientObjects); index++, timerObj++) {
9D004DE8  5603FFDA   BNEL S0, V1, 0x9D004D54
9D004DEC  82020000   LB V0, 0(S0)
9D004DF0  2410FFFF   ADDIU S0, ZERO, -1
9D004E2C  261000BC   ADDIU S0, S0, 188
9D004E30  3C03A000   LUI V1, -24576
9D004E34  0B401354   J 0x9D004D50
9D004E38  2463010C   ADDIU V1, V1, 268
529:                         if (timerObj->currState == SYS_TMR_CLIENT_FREE) { // found free object			
9D004D38  0B401388   J 0x9D004E20
9D004D3C  3C02A000   LUI V0, -24576
9D004D48  0B401388   J 0x9D004E20
9D004D4C  3C02A000   LUI V0, -24576
9D004D50  82020000   LB V0, 0(S0)
9D004D54  54400024   BNEL V0, ZERO, 0x9D004DE8
9D004D58  26100014   ADDIU S0, S0, 20
9D004E20  804200A8   LB V0, 168(V0)
9D004E24  1040FFCF   BEQ V0, ZERO, 0x9D004D64
9D004E28  3C10A000   LUI S0, -24576
530:                             memset(timerObj, 0x0, sizeof (*timerObj));
9D004D5C  0B40135C   J 0x9D004D70
9D004D60  AE000000   SW ZERO, 0(S0)
9D004D6C  AE000000   SW ZERO, 0(S0)
9D004D70  AE000004   SW ZERO, 4(S0)
9D004D74  AE000008   SW ZERO, 8(S0)
9D004D78  AE00000C   SW ZERO, 12(S0)
9D004D7C  AE000010   SW ZERO, 16(S0)
531:                             if (_SYS_TMR_ClientParamSet(timerObj, periodMs, context, callback)) {
9D004D80  02002021   ADDU A0, S0, ZERO
9D004D84  02202821   ADDU A1, S1, ZERO
9D004D88  02403021   ADDU A2, S2, ZERO
9D004D8C  0F401B59   JAL _SYS_TMR_ClientParamSet
9D004D90  02603821   ADDU A3, S3, ZERO
9D004D94  50400017   BEQL V0, ZERO, _SYS_TMR_ClientCreate::_UserGblUnlock
9D004D98  2410FFFF   ADDIU S0, ZERO, -1
532:                                 if ((flags & SYS_TMR_FLAG_PERIODIC) != 0) {
9D004D9C  32820001   ANDI V0, S4, 1
9D004DA0  10400006   BEQ V0, ZERO, 0x9D004DBC
9D004DA4  32941000   ANDI S4, S4, 4096
533:                                     timerObj->flags.periodic = true;
9D004DA8  92020003   LBU V0, 3(S0)
9D004DAC  24030001   ADDIU V1, ZERO, 1
9D004DB0  7C620004   INS V0, V1, 0, 1
9D004DB4  0B401375   J 0x9D004DD4
9D004DB8  A2020003   SB V0, 3(S0)
534:                                 } else if ((flags & SYS_TMR_FLAG_AUTO_DELETE) != 0) {
9D004DBC  52800006   BEQL S4, ZERO, 0x9D004DD8
9D004DC0  24020001   ADDIU V0, ZERO, 1
535:                                     timerObj->flags.auto_del = true;
9D004DC4  92020003   LBU V0, 3(S0)
9D004DC8  24030001   ADDIU V1, ZERO, 1
9D004DCC  7C620844   INS V0, V1, 1, 1
9D004DD0  A2020003   SB V0, 3(S0)
536:                                 }
537:                 
538:                                 // enable the object, seen by the ISR thread
539:                                 timerObj->currState = SYS_TMR_CLIENT_ACTIVE;
9D004DD4  24020001   ADDIU V0, ZERO, 1
9D004DD8  A2020000   SB V0, 0(S0)
540:                                 timerObj->isrState = SYS_TMR_CLIENT_ISR_ACTIVE;
9D004DDC  A2020002   SB V0, 2(S0)
541:                                 timerObj->isrEnable = 1;
9D004DE0  0B40137D   J _SYS_TMR_ClientCreate::_UserGblUnlock
9D004DE4  A2020001   SB V0, 1(S0)
542:                                 newObj = timerObj;
543:                             }
544:                             // else wrong parameters
545:                             break;
546:                         }
547:                     }
548:                 
549:                     _UserGblUnlock();
550:                 
551:                     return (SYS_TMR_HANDLE) newObj;
9D004E18  0B40138F   J 0x9D004E3C
9D004E1C  02001021   ADDU V0, S0, ZERO
552:                 
553:                 }
9D004E3C  8FBF0024   LW RA, 36(SP)
554:                 
555:                 // Assigns the timing parameters
556:                 
557:                 static bool _SYS_TMR_ClientParamSet(SYS_TMR_CLIENT_OBJECT *timerObj, uint32_t periodMs, uintptr_t context, SYS_TMR_CALLBACK callback) {
558:                     uint32_t upError, lowError, error;
559:                     uint32_t unitCount, upUnits, lowUnits;
560:                 
561:                     // sanity check
562:                     if (periodMs == 0 || periodMs >= (0xffffffff / SYS_TMR_UNIT_RESOLUTION)) {
9D006D64  24A2FFFF   ADDIU V0, A1, -1
9D006D68  3C030006   LUI V1, 6
9D006D6C  34638DB7   ORI V1, V1, -29257
9D006D70  0043182B   SLTU V1, V0, V1
9D006D74  10600033   BEQ V1, ZERO, 0x9D006E44
9D006D78  00001021   ADDU V0, ZERO, ZERO
563:                         return false;
564:                     }
565:                 
566:                     unitCount = (periodMs * (sSysTmrObject.sysTickFreq * sSysTmrObject.sysTickUnitCount)) / 1000;
9D006D7C  3C03A000   LUI V1, -24576
9D006D80  2463010C   ADDIU V1, V1, 268
9D006D84  8C620010   LW V0, 16(V1)
9D006D88  8C63000C   LW V1, 12(V1)
9D006D8C  70431802   MUL V1, V0, V1
9D006D90  70651802   MUL V1, V1, A1
9D006D94  3C081062   LUI T0, 4194
9D006D98  25084DD3   ADDIU T0, T0, 19923
9D006D9C  00680019   MULTU 0, V1, T0
9D006DA0  00001810   MFHI V1
9D006DA4  00031982   SRL V1, V1, 6
9D006DA8  0062282B   SLTU A1, V1, V0
9D006DAC  0045180B   MOVN V1, V0, A1
567:                     if (unitCount < sSysTmrObject.sysTickUnitCount) { // cannot go lower than that
568:                         unitCount = sSysTmrObject.sysTickUnitCount;
569:                     }
570:                 
571:                     // calculate errors: truncation and round up
572:                     lowUnits = (unitCount / sSysTmrObject.sysTickUnitCount) * sSysTmrObject.sysTickUnitCount;
9D006DB0  0062001B   DIVU V1, V0
9D006DB4  004001F4   TEQ V0, ZERO
9D006DB8  00002812   MFLO A1
9D006DBC  70A22802   MUL A1, A1, V0
573:                     lowError = (unitCount >= lowUnits) ? unitCount - lowUnits : lowUnits - unitCount;
9D006DC0  0065402B   SLTU T0, V1, A1
9D006DC4  00654823   SUBU T1, V1, A1
9D006DC8  00A32823   SUBU A1, A1, V1
9D006DCC  00A8480B   MOVN T1, A1, T0
9D006DD0  01204021   ADDU T0, T1, ZERO
574:                 
575:                     upUnits = ((unitCount + sSysTmrObject.sysTickUnitCount - 1) / sSysTmrObject.sysTickUnitCount) * sSysTmrObject.sysTickUnitCount;
9D006DD4  2445FFFF   ADDIU A1, V0, -1
9D006DD8  00A32821   ADDU A1, A1, V1
9D006DDC  00A2001B   DIVU A1, V0
9D006DE0  004001F4   TEQ V0, ZERO
9D006DE4  00002812   MFLO A1
9D006DE8  70A21002   MUL V0, A1, V0
576:                     upError = (unitCount >= upUnits) ? unitCount - upUnits : upUnits - unitCount;
9D006DEC  0062282B   SLTU A1, V1, V0
9D006DF0  00624823   SUBU T1, V1, V0
9D006DF4  00431023   SUBU V0, V0, V1
9D006DF8  0125100A   MOVZ V0, T1, A1
577:                 
578:                     error = (upError > lowError) ? lowError : upError;
9D006DFC  0102282B   SLTU A1, T0, V0
9D006E00  0045400A   MOVZ T0, V0, A1
579:                 
580:                     if ((error * 100 / unitCount) > SYS_TMR_CLIENT_TOLERANCE) { // too great an error
9D006E04  00081080   SLL V0, T0, 2
9D006E08  00082900   SLL A1, T0, 4
9D006E0C  00451021   ADDU V0, V0, A1
9D006E10  00022880   SLL A1, V0, 2
9D006E14  00451021   ADDU V0, V0, A1
9D006E18  0043001B   DIVU V0, V1
9D006E1C  006001F4   TEQ V1, ZERO
9D006E20  00002812   MFLO A1
9D006E24  2CA5000B   SLTIU A1, A1, 11
9D006E28  10A00006   BEQ A1, ZERO, 0x9D006E44
9D006E2C  00001021   ADDU V0, ZERO, ZERO
581:                         return false;
582:                     }
583:                 
584:                     timerObj->tuRate = timerObj->tuCount = unitCount;
9D006E30  AC830004   SW V1, 4(A0)
9D006E34  AC830008   SW V1, 8(A0)
585:                     timerObj->context = context;
9D006E38  AC86000C   SW A2, 12(A0)
586:                     timerObj->callback = callback;
9D006E3C  AC870010   SW A3, 16(A0)
587:                 
588:                     return true;
9D006E40  24020001   ADDIU V0, ZERO, 1
589:                 }
9D006E44  03E00008   JR RA
590:                 
591:                 
592:                 
593:                 
594:                 // delete clients that are marked for delition
595:                 #if (SYS_TMR_INTERRUPT_NOTIFICATION)
596:                 
597:                 // process timer alarm, ISR context
598:                 
599:                 static void _SYS_TMR_ProcessIsrAlarm(void) {
600:                     int ix;
601:                     SYS_TMR_CLIENT_OBJECT* pClient;
602:                 
603:                     // get number of elapsed counts
604:                     uint32_t nTicks = sSysTmrObject.sysTickCount - sSysTmrObject.sysTickPrevCount;
605:                     sSysTmrObject.sysTickPrevCount = sSysTmrObject.sysTickCount;
606:                     uint32_t nUnitsElapsed = (nTicks * sSysTmrObject.sysTickUnitCount);
607:                 
608:                 
609:                     pClient = sClientObjects + 0;
610:                     for (ix = 0; ix < sizeof (sClientObjects) / sizeof (*sClientObjects); ix++, pClient++) {
611:                         if (pClient->isrEnable && pClient->isrState == SYS_TMR_CLIENT_ISR_ACTIVE) {
612:                             if ((pClient->tuCount -= nUnitsElapsed) <= 0) { // timeout
613:                                 /* invoke callback routine */
614:                                 if (pClient->callback != 0) {
615:                                     pClient->callback(pClient->context, sSysTmrObject.sysTickCount);
616:                                 }
617:                                 if (pClient->flags.periodic == true) { // reload
618:                                     pClient->tuCount += pClient->tuRate;
619:                                 } else if (pClient->callback != 0 && pClient->flags.auto_del == true) { // client notified; delete this object
620:                                     // mark it to be deleted later on
621:                                     pClient->isrState = SYS_TMR_CLIENT_ISR_MARK_DEL;
622:                                 } else { // non delete non periodic object; store the timeout condition
623:                                     pClient->isrState = SYS_TMR_CLIENT_ISR_MARK_INACTIVE;
624:                                     pClient->tuCount = 0;
625:                                 }
626:                             }
627:                         }
628:                     }
629:                 
630:                 }
631:                 
632:                 static void _SYS_TMR_ProcessIsrClients(void) {
633:                     int ix;
634:                     SYS_TMR_CLIENT_OBJECT* pClient;
635:                 
636:                 
637:                     bool isrLock;
638:                     OSAL_CRITSECT_DATA_TYPE critSect;
639:                 
640:                     isrLock = _IsrTmrLock(&critSect);
641:                 
642:                     pClient = sClientObjects + 0;
643:                     for (ix = 0; ix < sizeof (sClientObjects) / sizeof (*sClientObjects); ix++, pClient++) {
644:                         if (pClient->isrState == SYS_TMR_CLIENT_ISR_MARK_DEL) {
645:                             _SYS_TMR_ClientDelete(pClient);
646:                         } else if (pClient->isrState == SYS_TMR_CLIENT_ISR_MARK_INACTIVE) {
647:                             pClient->isrEnable = 0;
648:                             pClient->currState = SYS_TMR_CLIENT_INACTIVE;
649:                         }
650:                     }
651:                 
652:                     _IsrTmrUnlock(isrLock, critSect);
653:                 }
654:                 
655:                 #else // !(SYS_TMR_INTERRUPT_NOTIFICATION)
656:                 
657:                 // process timer alarm
658:                 // occurs within TMR thread
659:                 
660:                 static void _SYS_TMR_ProcessTmrAlarm(void) {
661:                     int ix;
662:                     SYS_TMR_CLIENT_OBJECT* pClient;
663:                 
664:                     // get number of elapsed counts
665:                     uint32_t nTicks = sSysTmrObject.sysTickCount - sSysTmrObject.sysTickPrevCount;
9D002904  0B400A7D   J SYS_TMR_Tasks::_SYS_TMR_ProcessTmrAlarm
9D002908  3C02A000   LUI V0, -24576
9D002914  0B400A7D   J SYS_TMR_Tasks::_SYS_TMR_ProcessTmrAlarm
9D002918  3C02A000   LUI V0, -24576
9D0029F4  2442010C   ADDIU V0, V0, 268
9D0029F8  8C530014   LW S3, 20(V0)
9D0029FC  8C430018   LW V1, 24(V0)
9D002A08  02639823   SUBU S3, S3, V1
666:                     sSysTmrObject.sysTickPrevCount = sSysTmrObject.sysTickCount;
9D002A00  8C440014   LW A0, 20(V0)
9D002A04  AC440018   SW A0, 24(V0)
667:                     uint32_t nUnitsElapsed = (nTicks * sSysTmrObject.sysTickUnitCount);
9D002A0C  8C420010   LW V0, 16(V0)
9D002A10  72629802   MUL S3, S3, V0
668:                 
669:                 
670:                     pClient = sClientObjects + 0;
9D002A14  3C10A000   LUI S0, -24576
9D002A18  261000A8   ADDIU S0, S0, 168
671:                     for (ix = 0; ix < sizeof (sClientObjects) / sizeof (*sClientObjects); ix++, pClient++) {
9D00299C  26100014   ADDIU S0, S0, 20
9D0029A0  5611FFDF   BNEL S0, S1, 0x9D002920
9D0029A4  82020000   LB V0, 0(S0)
9D002A2C  3C11A000   LUI S1, -24576
9D002A30  0B400A47   J SYS_TMR_Tasks::_SYS_TMR_ProcessTmrAlarm
9D002A34  2631010C   ADDIU S1, S1, 268
672:                         if (pClient->currState == SYS_TMR_CLIENT_ACTIVE) {
9D00291C  82020000   LB V0, 0(S0)
9D002920  5452001F   BNEL V0, S2, 0x9D0029A0
9D002924  26100014   ADDIU S0, S0, 20
9D002A1C  24120001   ADDIU S2, ZERO, 1
673:                             if ((pClient->tuCount -= nUnitsElapsed) <= 0) { // timeout
9D002928  8E020004   LW V0, 4(S0)
9D00292C  00531023   SUBU V0, V0, S3
9D002930  1C40001A   BGTZ V0, 0x9D00299C
9D002934  AE020004   SW V0, 4(S0)
674:                                 /* invoke callback routine */
675:                                 if (pClient->callback != 0) {
9D002938  8E020010   LW V0, 16(S0)
9D00293C  10400004   BEQ V0, ZERO, 0x9D002950
9D002940  26A3010C   ADDIU V1, S5, 268
676:                                     pClient->callback(pClient->context, sSysTmrObject.sysTickCount);
9D002944  8C650014   LW A1, 20(V1)
9D002948  0040F809   JALR V0
9D00294C  8E04000C   LW A0, 12(S0)
9D002A28  3C15A000   LUI S5, -24576
677:                                 }
678:                                 if (pClient->flags.periodic == true) { // reload
9D002950  8E020000   LW V0, 0(S0)
9D002954  00541824   AND V1, V0, S4
9D002958  50600006   BEQL V1, ZERO, SYS_TMR_Tasks::_SYS_TMR_ProcessTmrAlarm
9D00295C  8E030010   LW V1, 16(S0)
9D002A20  3C140100   LUI S4, 256
679:                                     pClient->tuCount += pClient->tuRate;
9D002960  8E030004   LW V1, 4(S0)
9D002964  8E020008   LW V0, 8(S0)
9D002968  00621021   ADDU V0, V1, V0
9D00296C  0B400A67   J 0x9D00299C
9D002970  AE020004   SW V0, 4(S0)
680:                                 } else if (pClient->callback != 0 && pClient->flags.auto_del == true) { // client notified; delete this object
9D002974  10600007   BEQ V1, ZERO, SYS_TMR_Tasks::_SYS_TMR_ProcessTmrAlarm
9D002978  7C420640   EXT V0, V0, 25, 1
9D00297C  50400006   BEQL V0, ZERO, 0x9D002998
9D002980  A2160000   SB S6, 0(S0)
681:                                     _SYS_TMR_ClientDelete(pClient);
682:                                 } else { // non delete non periodic object; store the timeout condition
683:                                     pClient->currState = SYS_TMR_CLIENT_INACTIVE;
9D002994  A2160000   SB S6, 0(S0)
9D002A24  24160002   ADDIU S6, ZERO, 2
684:                                     pClient->tuCount = 0;
9D002998  AE000004   SW ZERO, 4(S0)
685:                                 }
686:                             }
687:                         }
688:                     }
689:                 
690:                 }
691:                 
692:                 #endif  // (SYS_TMR_INTERRUPT_NOTIFICATION)
693:                 
694:                 // *****************************************************************************
695:                 // *****************************************************************************
696:                 // Section: SYS TMR Client Setup Routines
697:                 // *****************************************************************************
698:                 // *****************************************************************************
699:                 
700:                 SYS_TMR_HANDLE SYS_TMR_ObjectCreate(uint32_t periodMs, uintptr_t context, SYS_TMR_CALLBACK callback, SYS_TMR_FLAGS flags) {
701:                     return _SYS_TMR_ClientCreate(periodMs, context, callback, flags);
702:                 }
703:                 
704:                 void SYS_TMR_ObjectDelete(SYS_TMR_HANDLE handle) {
705:                 
706:                     SYS_TMR_CLIENT_OBJECT * timerObj = _SYS_TMR_ClientCheckSrvLock(handle);
707:                 
708:                     if (timerObj) { // valid client; lock other users access   
709:                         _SYS_TMR_ClientDelete(timerObj);
710:                         _SYS_TMR_ClientSrvUnlock();
711:                     }
712:                 
713:                 }
714:                 
715:                 void SYS_TMR_CallbackStop(SYS_TMR_HANDLE handle) {
716:                     SYS_TMR_ObjectDelete(handle);
717:                 }
718:                 
719:                 bool SYS_TMR_ObjectReload(SYS_TMR_HANDLE handle, uint32_t periodMs, uintptr_t context, SYS_TMR_CALLBACK callback) {
720:                     SYS_TMR_CLIENT_OBJECT * timerObj = _SYS_TMR_ClientCheckSrvLock(handle);
721:                 
722:                     if (timerObj) {
723:                         timerObj->isrEnable = 0;
724:                         bool res = _SYS_TMR_ClientParamSet(timerObj, periodMs, context, callback);
725:                 
726:                         if (timerObj->isrState == SYS_TMR_CLIENT_ISR_MARK_DEL) { // client is too late
727:                             _SYS_TMR_ClientDelete(timerObj);
728:                             res = false;
729:                         }
730:                 
731:                         timerObj->isrState = SYS_TMR_CLIENT_ISR_ACTIVE;
732:                         timerObj->isrEnable = 1;
733:                         _SYS_TMR_ClientSrvUnlock();
734:                         return res;
735:                     }
736:                 
737:                     return false;
738:                 }
739:                 
740:                 uint32_t SYS_TMR_ObjectCountGet(SYS_TMR_HANDLE handle, uint32_t* pRateMs) {
741:                     uint32_t obCount;
742:                 
743:                 
744:                     SYS_TMR_CLIENT_OBJECT * timerObj = _SYS_TMR_ClientCheckSrvLock(handle);
745:                 
746:                     if (timerObj) {
747:                         if (pRateMs) { // transform to ms
748:                             *pRateMs = (timerObj->tuRate * 1000) / SYS_TMR_UNIT_RESOLUTION;
749:                         }
750:                 
751:                         obCount = timerObj->tuCount;
752:                         if (obCount == 0 && timerObj->flags.auto_del != 0) { // timed out, delete it
753:                             _SYS_TMR_ClientDelete(timerObj);
754:                         }
755:                         _SYS_TMR_ClientSrvUnlock();
756:                         // round up so that don't return 0 if there are still counts
757:                         return (obCount * 1000 + SYS_TMR_UNIT_RESOLUTION - 1) / SYS_TMR_UNIT_RESOLUTION;
758:                     }
759:                 
760:                     return -1;
761:                 
762:                 }
763:                 
764:                 SYS_TMR_HANDLE SYS_TMR_CallbackPeriodic(uint32_t periodMs, uintptr_t context, SYS_TMR_CALLBACK callback) {
765:                     return _SYS_TMR_ClientCreate(periodMs, context, callback, SYS_TMR_FLAG_PERIODIC);
766:                 }
767:                 
768:                 SYS_TMR_HANDLE SYS_TMR_CallbackSingle(uint32_t periodMs, uintptr_t context, SYS_TMR_CALLBACK callback) {
9D009A64  27BDFFE8   ADDIU SP, SP, -24
9D009A68  AFBF0014   SW RA, 20(SP)
769:                     return _SYS_TMR_ClientCreate(periodMs, context, callback, SYS_TMR_FLAG_SINGLE | SYS_TMR_FLAG_AUTO_DELETE);
9D009A6C  0F401335   JAL _SYS_TMR_ClientCreate
9D009A70  24071000   ADDIU A3, ZERO, 4096
770:                 }
9D009A74  8FBF0014   LW RA, 20(SP)
771:                 
772:                 SYS_TMR_HANDLE SYS_TMR_DelayMS(uint32_t delayMs) {
773:                     return _SYS_TMR_ClientCreate(delayMs, 0, 0, SYS_TMR_FLAG_SINGLE | SYS_TMR_FLAG_AUTO_DELETE);
774:                 }
775:                 
776:                 bool SYS_TMR_DelayStatusGet(SYS_TMR_HANDLE handle) {
777:                     return SYS_TMR_ObjectCountGet(handle, 0) == 0;
778:                 }
779:                 
780:                 
781:                 
782:                 
783:                 // *****************************************************************************
784:                 
785:                 /* Function:
786:                    static void _SYS_TMR_AlarmCallback ( uintptr_t context, uint32_t alarmCount )
787:                 
788:                 Summary:
789:                     System timer alarm call back function.
790:                 
791:                 Description:
792:                     This function is called by the underlying timer driver
793:                     when the registered alarm time has elapsed
794:                     (i.e. another system tick has occurred).
795:                 
796:                 Precondition:
797:                     None
798:                 
799:                 Parameters:
800:                     context    - callback parameter
801:                     alarmCount - current alarm count
802:                 Returns:
803:                     None.
804:                 
805:                  */
806:                 
807:                 static void _SYS_TMR_AlarmCallback(uintptr_t context, uint32_t alarmCount) {
808:                 
809:                     SYS_TMR_OBJECT* pTmrObj = (SYS_TMR_OBJECT*) context;
810:                 
811:                     if (alarmCount < pTmrObj->sysTickCount) { // overflow
9D00988C  8C820014   LW V0, 20(A0)
9D009890  00A2102B   SLTU V0, A1, V0
9D009894  10400004   BEQ V0, ZERO, 0x9D0098A8
9D009898  00000000   NOP
812:                         pTmrObj->sysTickCountHigh++;
9D00989C  8C82001C   LW V0, 28(A0)
9D0098A0  24420001   ADDIU V0, V0, 1
9D0098A4  AC82001C   SW V0, 28(A0)
813:                     }
814:                     // set new count
815:                     pTmrObj->sysTickCount = alarmCount;
9D0098A8  AC850014   SW A1, 20(A0)
816:                 
817:                 #if (SYS_TMR_INTERRUPT_NOTIFICATION)
818:                     _SYS_TMR_ProcessIsrAlarm();
819:                 #else
820:                     pTmrObj->alarmReceived = true;
9D0098AC  24020001   ADDIU V0, ZERO, 1
821:                 #endif
822:                 
823:                 }
824:                 
825:                 
826:                 // for the following functions no lock is performed
827:                 // because they need to be really fast and
828:                 // they are info only anyway
829:                 
830:                 uint32_t SYS_TMR_TickCountGet(void) {
831:                     return _SYS_TMR_ReadyCheck() ? sSysTmrObject.sysTickCount : 0;
832:                 }
833:                 
834:                 uint64_t SYS_TMR_TickCountGetLong(void) {
835:                     if (!_SYS_TMR_ReadyCheck()) {
836:                         return 0;
837:                     }
838:                 
839:                     uint64_t tick1, tick2;
840:                 
841:                     do {
842:                         tick1 = (uint64_t) sSysTmrObject.sysTickCountHigh << 32 | sSysTmrObject.sysTickCount;
843:                         tick2 = (uint64_t) sSysTmrObject.sysTickCountHigh << 32 | sSysTmrObject.sysTickCount;
844:                     }    while (tick1 != tick2);
845:                 
846:                     return tick2;
847:                 }
848:                 
849:                 uint32_t SYS_TMR_TickCounterFrequencyGet(void) {
850:                     return _SYS_TMR_ReadyCheck() ? sSysTmrObject.sysTickFreq : 0;
851:                 }
852:                 
853:                 uint32_t SYS_TMR_SystemCountFrequencyGet(void) {
854:                     return _SYS_TMR_ReadyCheck() ? sSysTmrObject.driverFreq : 0;
855:                 }
856:                 
857:                 
858:                 // for this one we need to access the driver
859:                 // we need to make sure the object is valid
860:                 // use a 64 bit values to avoid overflow
861:                 
862:                 uint64_t SYS_TMR_SystemCountGet(void) {
863:                 
864:                     if (!_SYS_TMR_ReadyCheck()) {
865:                         return 0;
866:                     }
867:                 
868:                     uint16_t drvCount1, drvCount2;
869:                 
870:                     union {
871:                         uint64_t ull;
872:                 
873:                         struct {
874:                             uint32_t low;
875:                             uint32_t high;
876:                         };
877:                     } sll1, sll2;
878:                 
879:                     do {
880:                         drvCount1 = DRV_TMR_CounterValueGet(sSysTmrObject.driverHandle);
881:                         sll1.low = sSysTmrObject.sysTickCount;
882:                         sll1.high = sSysTmrObject.sysTickCountHigh;
883:                         drvCount2 = DRV_TMR_CounterValueGet(sSysTmrObject.driverHandle);
884:                         sll2.low = sSysTmrObject.sysTickCount;
885:                         sll2.high = sSysTmrObject.sysTickCountHigh;
886:                     } while (drvCount2 < drvCount1 || sll1.ull != sll2.ull);
887:                 
888:                 
889:                     return (sll1.ull * sSysTmrObject.driverFreq) / sSysTmrObject.sysTickFreq + drvCount2;
890:                 }
891:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/system/int/src/sys_int_pic32.c
1:                   /*******************************************************************************
2:                     Interrupt System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_int_pic32.c
9:                   
10:                    Summary:
11:                      Interrupt System Service APIs.
12:                  
13:                    Description:
14:                      This file contains functions related to the Interrupt System Service for PIC32
15:                      devices.
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include "system/int/sys_int.h"
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: Function Definitions
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  
52:                  /******************************************************************************
53:                  
54:                    Function:
55:                      void SYS_INT_Initialize ( void )
56:                  
57:                    Summary:
58:                      Configures and initializes the interrupt sub-system.
59:                  
60:                    Description:
61:                      This function appropriately configures and initializes the interrupt sub-system
62:                      for the current system design.
63:                  
64:                    Precondition:
65:                      None.
66:                  
67:                    Parameters:
68:                      None.
69:                  
70:                    Returns:
71:                      None.
72:                  
73:                    Example:
74:                    <code>
75:                    SYS_INT_Initialize();
76:                    </code>
77:                  
78:                    Remarks:
79:                      This function is not implemented in the System Interrupt library.  It is
80:                      implemented by the board support package (using the processor-specific
81:                      interrupt peripheral library) because it requires knowledge of the specific
82:                      interrupt requirements for each system.
83:                  */
84:                  
85:                  void SYS_INT_Initialize ( void )
86:                  
87:                  {
88:                      /* enable the multi vector */
89:                      PLIB_INT_MultiVectorSelect( INT_ID_0 );
90:                  }
91:                  
92:                  //*******************************************************************************
93:                  /*  Function:
94:                       SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
95:                  
96:                    Summary:
97:                      Disables interrupts to the processor and return the previois status.
98:                      
99:                    Description:
100:                     This function disables interrupts to the processor at the top level. This
101:                     function can be called to prevent any source from being able to generate an
102:                     interrupt. It returns the processor status (which includes global interrupt
103:                     status and Interrupt Priority status) before disabling the interrupts.
104:                 
105:                   Remarks:
106:                     See sys_int.h file for more details.
107:                 */
108:                 
109:                 SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
110:                 {
9D009A2C  27BDFFF8   ADDIU SP, SP, -8
9D009A30  AFBF0004   SW RA, 4(SP)
111:                     SYS_INT_PROCESSOR_STATUS processorStatus;
112:                 
113:                     /* Save the processor status and then Disable the global interrupt */
114:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
9D009A34  41626000   DI V0
9D009A38  000000C0   EHB
115:                 
116:                     /* return the processor status */
117:                     return processorStatus;
118:                 }
9D009A3C  8FBF0004   LW RA, 4(SP)
119:                 
120:                 //*******************************************************************************
121:                 /* Function:
122:                     void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
123:                 
124:                   Summary:
125:                     Restores the processor status.
126:                 
127:                   Description:
128:                     This function sets the processor status based on the 32 bit value passed as 
129:                     a parameter. 0th bit of the status is for Master Interrupt status.
130:                 
131:                   Remarks:
132:                     See sys_int.h file for more details.
133:                 */
134:                 
135:                 void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
136:                 {
9D009A48  27BDFFF8   ADDIU SP, SP, -8
9D009A4C  AFBF0004   SW RA, 4(SP)
137:                     __builtin_mtc0(12, 0, processorStatus);
9D009A50  40846000   MTC0 A0, Status
9D009A54  000000C0   EHB
138:                 }
9D009A58  8FBF0004   LW RA, 4(SP)
139:                 
140:                 // *****************************************************************************
141:                 /*  Disable the generation of interrupts to the CPU
142:                 
143:                   Summary:
144:                      Disables all interrupts
145:                 
146:                   Description:
147:                      This function disables all interrupts.
148:                 
149:                   Remarks:
150:                     This API will be depricated soon. Use "SYS_INT_StatusGetAndDisable" instead.
151:                  */
152:                 
153:                 bool SYS_INT_Disable( void )
154:                 {
9D009974  27BDFFF8   ADDIU SP, SP, -8
9D009978  AFBF0004   SW RA, 4(SP)
155:                     SYS_INT_PROCESSOR_STATUS processorStatus;
156:                 
157:                     /* Save the processor status and then Disable the global interrupt */
158:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
9D00997C  41626000   DI V0
9D009980  000000C0   EHB
159:                 
160:                     /* return the interrupt status */
161:                     return (bool)(processorStatus & 0x01);
162:                 }
9D009984  30420001   ANDI V0, V0, 1
163:                 
164:                 // *****************************************************************************
165:                 /* Function:
166:                     bool SYS_INT_SourceDisable ( INT_SOURCE source )
167:                 
168:                   Summary:
169:                     Disables the interrupt source.
170:                 
171:                   Description:
172:                     This routine disables the given source from generating interrupts the 
173:                     processor when events occur.It returns the interrupt source enable/disable 
174:                 	status before disabling the interrupt source.
175:                 
176:                   Remarks:
177:                     See sys_int.h file for more details.
178:                  */
179:                 
180:                 
181:                 bool SYS_INT_SourceDisable ( INT_SOURCE source )
182:                 {
9D009204  27BDFFF8   ADDIU SP, SP, -8
9D009208  AFBF0004   SW RA, 4(SP)
183:                     bool intSrcStatus;
184:                     SYS_INT_PROCESSOR_STATUS processorStatus;
185:                 
186:                     /* Save the processor status and then Disable the global interrupt */
187:                     processorStatus = ( SYS_INT_PROCESSOR_STATUS )__builtin_disable_interrupts();
9D00920C  41656000   DI A1
9D009210  000000C0   EHB
188:                     
189:                     /* get the interrupt status of this source before disable is called */
190:                     intSrcStatus = PLIB_INT_SourceIsEnabled (INT_ID_0 , source);
191:                 
192:                     /* disable the interrupts */
193:                     PLIB_INT_SourceDisable (INT_ID_0 , source);
194:                 
195:                     /* restore the state of CP0 Status register before the disable occurred*/
196:                     __builtin_mtc0(12, 0, processorStatus);
9D00923C  40856000   MTC0 A1, Status
9D009240  000000C0   EHB
197:                 
198:                     /* return the source status */
199:                     return intSrcStatus;
200:                 }
9D009248  30420001   ANDI V0, V0, 1
201:                 
202:                 
203:                 // *****************************************************************************
204:                 /* Sets the external interrupt trigger type.
205:                 
206:                   Summary:
207:                     Sets the external interrupt trigger type.
208:                 
209:                   Description:
210:                     This function sets the External interrupt trigger type.
211:                 
212:                   Remarks:
213:                     Refer the datasheet to know the external interrupt sources supported.
214:                  */
215:                 
216:                 void SYS_INT_ExternalInterruptTriggerSet ( 	INT_EXTERNAL_SOURCES source,
217:                 										INT_EXTERNAL_EDGE_TRIGGER edgeTrigger )
218:                 {
219:                 	if ( edgeTrigger == INT_EDGE_TRIGGER_RISING )
220:                 	{
221:                 		PLIB_INT_ExternalRisingEdgeSelect ( INT_ID_0, source );
222:                 	}
223:                 	else
224:                 	{
225:                 		PLIB_INT_ExternalFallingEdgeSelect ( INT_ID_0, source );
226:                 	}
227:                 }
228:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/system/devcon/src/sys_devcon_pic32mx.c
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the Device Control system service. While building 
17:                      the system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "sys_devcon_local.h"
53:                  #include "peripheral/int/plib_int.h"
54:                  #include "peripheral/osc/plib_osc.h"
55:                  #include "peripheral/pcache/plib_pcache.h"
56:                  #include "peripheral/bmx/plib_bmx.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  //
70:                  #ifndef PLIB_PCACHE_PREFETCH_ENABLE_ALL
71:                  #define PLIB_PCACHE_PREFETCH_ENABLE_ALL 3
72:                  #endif
73:                  
74:                  // *****************************************************************************
75:                  /* Function:
76:                      void SYS_DEVCON_PerformanceConfig( void )
77:                  
78:                    Summary:
79:                      Configures the PFM wait states and prefetch (cache) module for maximum 
80:                      performance.
81:                  
82:                    Description:
83:                      This function configures the PFM wait states and prefetch (cache) module 
84:                      for maximum performance.
85:                  
86:                    Remarks:
87:                      None.
88:                  */
89:                  
90:                  void __attribute__((nomips16)) SYS_DEVCON_PerformanceConfig( unsigned int sysclk )
91:                  {
9D009100  27BDFFF8   ADDIU SP, SP, -8
9D009104  AFBF0004   SW RA, 4(SP)
92:                      bool int_flag = false;
93:                      register unsigned long tmp = 0;
94:                  
95:                      /* Set kseg0 coherency algorithm to "cacheable, non-coherent, write-back, 
96:                       * write-allocate. This is needed for the prefetch buffer */
97:                      asm("mfc0 %0,$16,0" :  "=r"(tmp));
9D009108  40028000   MFC0 V0, Config
98:                      tmp = (tmp & ~7) | 3;
9D00910C  7C021004   INS V0, ZERO, 0, 3
9D009110  34420003   ORI V0, V0, 3
99:                      asm("mtc0 %0,$16,0" :: "r" (tmp));
9D009114  40828000   MTC0 V0, Config
100:                 
101:                     /* Set the PFM wait states based on the system clock */
102:                     #if defined(PLIB_PCACHE_ExistsWaitState)
103:                     if (PLIB_PCACHE_ExistsWaitState(PCACHE_ID_0))
104:                     {
105:                         int ws; /* number of wait states */
106:                         if (sysclk <= 30000000)
107:                             ws = 0;
108:                         else if (sysclk <= 60000000)
109:                             ws = 1;
110:                         else if (sysclk <= 80000000)
111:                             ws = 2;
112:                         else
113:                             ws = 3;
114:                         /* Interrupts must be disabled when changing wait states */
115:                         int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
116:                 
117:                         PLIB_PCACHE_WaitStateSet(PCACHE_ID_0, ws);
118:                 
119:                         if (int_flag)
120:                         {
121:                             PLIB_INT_Enable(INT_ID_0);
122:                             int_flag = false;
123:                         }
124:                     }
125:                     #endif // defined(PLIB_PCACHE_ExistsWaitState)
126:                 
127:                     /* Interrupts must be disabled when enabling the Prefetch Cache Module */
128:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D009130  30820001   ANDI V0, A0, 1
129:                 
130:                     /* Enable Prefetch Cache Module */
131:                     #if defined(PLIB_PCACHE_ExistsPrefetchEnable)
132:                     if (PLIB_PCACHE_ExistsPrefetchEnable(PCACHE_ID_0))
133:                     {
134:                         PLIB_PCACHE_PrefetchEnableSet(PCACHE_ID_0, PLIB_PCACHE_PREFETCH_ENABLE_ALL);
135:                     }
136:                     #endif
137:                 
138:                     /* Set the SRAM wait states to zero */
139:                     #if defined (PLIB_BMX_ExistsDataRamWaitState)
140:                     if (PLIB_BMX_ExistsDataRamWaitState(BMX_ID_0))
141:                     {
142:                         PLIB_BMX_DataRamWaitStateSet(BMX_ID_0, PLIB_BMX_DATA_RAM_WAIT_ZERO);
143:                     }            
144:                     #endif
145:                     if (int_flag)
9D009134  10400006   BEQ V0, ZERO, 0x9D009150
9D009138  8FBF0004   LW RA, 4(SP)
146:                     {
147:                         PLIB_INT_Enable(INT_ID_0);
148:                     }
149:                 }
9D00914C  8FBF0004   LW RA, 4(SP)
150:                 
151:                 /*******************************************************************************
152:                  End of File
153:                 */
154:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/system/devcon/src/sys_devcon.c
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on PIC32M Microchip microcontrollers. This file Implements 
16:                      the core interface routines for the Device Control system service.  While 
17:                      building the system service from source, ALWAYS include this file in the 
18:                      build for PIC32M devices.
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  //DOM-IGNORE-END
45:                  
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: Included Files
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  #include "system/devcon/src/sys_devcon_local.h"
54:                  #include "peripheral/int/plib_int.h"
55:                  #include "peripheral/devcon/plib_devcon.h"
56:                  #include "peripheral/osc/plib_osc.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  /* System Device Control Instance */
71:                  SYS_DEVCON_OBJECT sysDevconObj;
72:                  
73:                  
74:                  // *****************************************************************************
75:                  // *****************************************************************************
76:                  // Section: SYS DEVCON Module Initialization Routines
77:                  // *****************************************************************************
78:                  // *****************************************************************************
79:                  
80:                  // *****************************************************************************
81:                  /* Function:
82:                      SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX           index,
83:                                                         const SYS_MODULE_INIT * const    init )
84:                  
85:                    Summary:
86:                      Initializes data for the instance of the Device Control module and opens
87:                      the specific module instance.
88:                  
89:                    Description:
90:                      This function initializes the instance of the Device Control module,
91:                      using the specified initialization data. It also initializes any
92:                      internal data structures.
93:                  
94:                    Remarks:
95:                      This routine should only be called once during system initialization
96:                      unless SYS_DEVCON_Deinitialize is first called to deinitialize the device
97:                      instance before reinitializing it. If the system was already initialized
98:                      it safely returns without causing any disturbance.
99:                  */
100:                 
101:                 SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX index,
102:                                                    const SYS_MODULE_INIT * const init )
103:                 {
104:                     sysDevconObj.status = SYS_STATUS_READY;
9D009A98  24020002   ADDIU V0, ZERO, 2
9D009A9C  AF8280B4   SW V0, -32588(GP)
105:                 
106:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
9D009AA0  AF8080B0   SW ZERO, -32592(GP)
107:                 
108:                     return (SYS_MODULE_OBJ)SYS_DEVCON_INDEX_0;
109:                 }
9D009AA4  03E00008   JR RA
110:                 
111:                 
112:                 // *****************************************************************************
113:                 /* Function:
114:                     void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ                  object,
115:                                                const SYS_MODULE_INIT * const   init )
116:                 
117:                    Summary:
118:                     Reinitializes and refreshes the hardware for the instance of the Device 
119:                     Control module.
120:                 
121:                    Description:
122:                     This function reinitializes the instance of the Device Control module using 
123:                     the supplied data. It modifies the internal data structure.
124:                 
125:                    Remarks:
126:                     This operation uses the same initialization data structure as the
127:                     SYS_DEVCON_Initialize operation. This operation can be used to change the
128:                     power state of a DEVCON module. This function can be called multiple times
129:                     to reinitialize the module. This operation uses the same initialization
130:                     data structure as the Initialize operation. This operation can also be
131:                     used to refresh the hardware registers as defined by the initialization
132:                     data.
133:                 */
134:                 
135:                 void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ object,
136:                                            const SYS_MODULE_INIT * const init )
137:                 {
138:                     sysDevconObj.status = SYS_STATUS_READY;
139:                 
140:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
141:                 }
142:                 
143:                 
144:                 // *****************************************************************************
145:                 /* Function:
146:                     void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
147:                 
148:                   Summary:
149:                     Deinitializes the specific module instance of the DEVCON module
150:                 
151:                   Description:
152:                     This function deinitializes the specific module instance disabling its operation 
153:                     (and any hardware for driver modules). Resets all of the internal data
154:                     structures and fields for the specified instance to the default settings.
155:                 
156:                   Remarks:
157:                     Once the Initialize operation has been called, the Deinitialize
158:                     operation must be called before the Initialize operation can be called
159:                     again.
160:                 */
161:                 
162:                 void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
163:                 {
164:                     sysDevconObj.status = SYS_STATUS_UNINITIALIZED;
165:                 }
166:                 
167:                 
168:                 // *****************************************************************************
169:                 /* Function:
170:                     SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
171:                 
172:                   Summary:
173:                     Returns status of the specific instance of the Device Control module.
174:                 
175:                   Description:
176:                     This function returns the status of the specific module instance.
177:                 
178:                   Remarks:
179:                     None.
180:                 */
181:                 
182:                 SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
183:                 {
184:                     return sysDevconObj.status; 
185:                 }
186:                 
187:                 
188:                 // *****************************************************************************
189:                 /* Function:
190:                     void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
191:                 
192:                   Summary:
193:                     Maintains the system Device Control state machine.
194:                 
195:                   Description:
196:                     This function is used to maintain the system Device Control internal state machine.
197:                 
198:                   Remarks:
199:                     This function is normally not called directly by an application.  It is
200:                     called by the system's Tasks routine (SYS_Tasks) or by the appropriate raw
201:                     ISR.
202:                 */
203:                 
204:                 void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
205:                 {
206:                     switch (sysDevconObj.state)
207:                     {
208:                         case SYS_DEVCON_STATE_INIT:
209:                         case SYS_DEVCON_STATE_BUSY:
210:                         case SYS_DEVCON_STATE_READY:
211:                         default:
212:                             break;
213:                     }
214:                 }
215:                 
216:                     
217:                 // *****************************************************************************
218:                 // *****************************************************************************
219:                 // Section: SYS DEVCON Client Setup Routines
220:                 // *****************************************************************************
221:                 // *****************************************************************************
222:                 
223:                 // *****************************************************************************
224:                 /* Function:
225:                     void SYS_DEVCON_SystemUnlock( void )
226:                 
227:                   Summary:
228:                     Performs a system unlock sequence by writing to the SYSKEY register.
229:                 
230:                   Description:
231:                     Performs a system unlock sequence by writing to the SYSKEY register. A 
232:                     system unlock sequence is required before performing certain actions such
233:                     as changing a clock frequency or IO unlocking.
234:                 
235:                   Remarks:
236:                     None.
237:                 */
238:                 
239:                 void SYS_DEVCON_SystemUnlock( void )
240:                 {
9D0090A8  27BDFFF8   ADDIU SP, SP, -8
9D0090AC  AFBF0004   SW RA, 4(SP)
241:                     bool int_flag = false;
242:                 
243:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D0090D8  30620001   ANDI V0, V1, 1
244:                 
245:                     PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
246:                 
247:                     if (int_flag)
9D0090DC  10400006   BEQ V0, ZERO, 0x9D0090F8
9D0090E0  8FBF0004   LW RA, 4(SP)
248:                     {
249:                         PLIB_INT_Enable(INT_ID_0);
250:                     }
251:                 }
9D0090F4  8FBF0004   LW RA, 4(SP)
252:                 
253:                 
254:                 // *****************************************************************************
255:                 /* Function:
256:                     void SYS_DEVCON_SystemLock( void )
257:                 
258:                   Summary:
259:                     Performs a system lock sequence by writing to the SYSKEY register.
260:                 
261:                   Description:
262:                     Performs a system lock sequence by writing to the SYSKEY register. A 
263:                     system lock sequence is required after performing the action that required
264:                     a system lock sequence.
265:                 
266:                   Remarks:
267:                     None.
268:                 */
269:                 
270:                 void SYS_DEVCON_SystemLock( void )
271:                 {
9D009420  27BDFFF8   ADDIU SP, SP, -8
9D009424  AFBF0004   SW RA, 4(SP)
272:                     bool int_flag = false;
273:                    
274:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D009440  30420001   ANDI V0, V0, 1
275:                 
276:                     PLIB_DEVCON_SystemLock(DEVCON_ID_0);
277:                 
278:                     if (int_flag)
9D009444  10400006   BEQ V0, ZERO, 0x9D009460
9D009448  8FBF0004   LW RA, 4(SP)
279:                     {
280:                         PLIB_INT_Enable(INT_ID_0);
281:                     }
282:                 }
9D00945C  8FBF0004   LW RA, 4(SP)
283:                 
284:                 
285:                 // *****************************************************************************
286:                 /* Function:
287:                     void SYS_DEVCON_JTAGEnable( void )
288:                 
289:                   Summary:
290:                     Enables the JTAG port on the device.
291:                 
292:                   Description:
293:                     Enables the JTAG port on the device.
294:                 
295:                   Remarks:
296:                     None.
297:                 */
298:                 
299:                 void SYS_DEVCON_JTAGEnable( void )
300:                 {
301:                     PLIB_DEVCON_JTAGPortEnable(DEVCON_ID_0);
302:                 }
303:                 
304:                 
305:                 // *****************************************************************************
306:                 /* Function:
307:                     void SYS_DEVCON_JTAGDisable( void )
308:                 
309:                   Summary:
310:                     Disables the JTAG port on the device.
311:                 
312:                   Description:
313:                     Disables the JTAG port on the device.
314:                 
315:                   Remarks:
316:                     None.
317:                 */
318:                 
319:                 void SYS_DEVCON_JTAGDisable( void )
320:                 {
321:                     PLIB_DEVCON_JTAGPortDisable(DEVCON_ID_0);
322:                 }
323:                 
324:                 
325:                 // *****************************************************************************
326:                 /* Function:
327:                     void SYS_DEVCON_TraceEnable( void )
328:                 
329:                   Summary:
330:                     Enables the Trace output port on the device.
331:                 
332:                   Description:
333:                     Enables the Trace output port on the device.
334:                 
335:                   Remarks:
336:                     None.
337:                 */
338:                 
339:                 void SYS_DEVCON_TraceEnable( void )
340:                 {
341:                     #if defined PLIB_DEVCON_ExistsTraceOutput
342:                         if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
343:                         {
344:                             PLIB_DEVCON_TraceOutputEnable(DEVCON_ID_0);
345:                         }
346:                     #endif
347:                 }
348:                 
349:                 
350:                 // *****************************************************************************
351:                 /* Function:
352:                     void SYS_DEVCON_TraceDisable( void )
353:                 
354:                   Summary:
355:                     Disables the Trace output port on the device.
356:                 
357:                   Description:
358:                     Disables the Trace output port on the device.
359:                 
360:                   Remarks:
361:                     None.
362:                 */
363:                 
364:                 void SYS_DEVCON_TraceDisable( void )
365:                 {
366:                     #if defined PLIB_DEVCON_ExistsTraceOutput
367:                     if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
368:                     {
369:                         PLIB_DEVCON_TraceOutputDisable(DEVCON_ID_0);
370:                     }
371:                     #endif
372:                 }
373:                 
374:                 
375:                 // *****************************************************************************
376:                 /* Function:
377:                     void SYS_DEVCON_PowerModeEnter(SYS_POWER_MODE pwrMode)
378:                 
379:                   Summary:
380:                     Puts the device in a low-power state.
381:                 
382:                   Description:
383:                     This function puts the device in a low-power state.
384:                 
385:                   Remarks:
386:                     None.
387:                 */
388:                 
389:                 void __attribute__((nomips16)) SYS_DEVCON_PowerModeEnter( SYS_POWER_MODE pwrMode )
390:                 {
391:                     OSC_OPERATION_ON_WAIT op = SYS_POWER_MODE_IDLE;
392:                 
393:                     switch (pwrMode)
394:                     {
395:                         case SYS_POWER_MODE_IDLE:
396:                             op = OSC_ON_WAIT_IDLE;
397:                             break;
398:                         case SYS_POWER_MODE_SLEEP:
399:                             op = OSC_ON_WAIT_SLEEP;
400:                             break;
401:                         default:
402:                             break;
403:                     }
404:                 
405:                     
406:                     #if defined PLIB_OSC_ExistsOnWaitAction
407:                     if(PLIB_OSC_ExistsOnWaitAction(OSC_ID_0))
408:                     {
409:                         SYS_DEVCON_SystemUnlock();
410:                         PLIB_OSC_OnWaitActionSet (OSC_ID_0, op);
411:                         SYS_DEVCON_SystemLock();
412:                     }
413:                     #endif
414:                     asm volatile ( "wait" );
415:                 }
416:                 
417:                 
418:                 /*******************************************************************************
419:                  End of File
420:                 */
421:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/system/clk/src/sys_clk_pic32mx.c
1:                   /*******************************************************************************
2:                     SYS CLK Static Functions for Clock System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_clk_static.c
9:                   
10:                    Summary:
11:                      SYS CLK static function implementations for the Clock System Service.
12:                  
13:                    Description:
14:                      The Clock System Service provides a simple interface to manage the oscillators
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Clock System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system clock configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                      
24:                      Static single-open interfaces also eliminate the need for the open handle.
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  //DOM-IGNORE-END
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Include Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include "system_config.h"
59:                  #include "system_definitions.h"
60:                  #include "peripheral/osc/plib_osc.h"
61:                  #include "system/devcon/sys_devcon.h"
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: File Scope Functions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  // *****************************************************************************
70:                  /* Function:
71:                      void SYS_CLK_Static_Initialize ( const SYS_CLK_INIT const * clkInit )
72:                  
73:                    Summary:
74:                      Initializes hardware and internal data structure of the System Clock.
75:                  
76:                    Description:
77:                      This function initializes the hardware and internal data structure of System
78:                      Clock Service.
79:                  
80:                    Remarks:
81:                      This is configuration values for the static version of the Clock System Service 
82:                      module is determined by the user via the Microchip Harmony Configurator GUI.
83:                      This template will build a sys_clk_static.h and sys_clk_static.c file with 
84:                      the configuration per the user's choice.
85:                  
86:                      The objective is to eliminate the user's need to be knowledgeable in the function of
87:                      the 'configuration bits' to configure the system oscillators. 
88:                  */
89:                  
90:                  void SYS_CLK_Initialize( const SYS_CLK_INIT const * clkInit )
91:                  {
9D008D48  27BDFFE8   ADDIU SP, SP, -24
9D008D4C  AFBF0014   SW RA, 20(SP)
92:                      SYS_DEVCON_SystemUnlock ( );
9D008D50  0F40242A   JAL SYS_DEVCON_SystemUnlock
9D008D54  00000000   NOP
93:                      
94:                      PLIB_OSC_FRCDivisorSelect( OSC_ID_0, OSC_FRC_DIV_2);
95:                  
96:                  
97:                  
98:                  
99:                      /* Enable Peripheral Bus 1 */
100:                     PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 0, 2 );
101:                 
102:                  
103:                     /* Disable REFCLKO1*/
104:                     PLIB_OSC_ReferenceOscDisable ( OSC_ID_0, OSC_REFERENCE_1 );
105:                     /* Disable REFCLK1_OE*/
106:                     PLIB_OSC_ReferenceOutputDisable ( OSC_ID_0, OSC_REFERENCE_1 );
107:                 
108:                     SYS_DEVCON_SystemLock ( );
9D008D9C  0F402508   JAL SYS_DEVCON_SystemLock
9D008DA0  00000000   NOP
109:                 }
9D008DA4  8FBF0014   LW RA, 20(SP)
110:                 
111:                 //******************************************************************************
112:                 /* Function:
113:                     inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
114:                 
115:                   Summary:
116:                     Gets the system clock frequency in Hertz.
117:                 
118:                   Description:
119:                     This function gets the System clock frequency in Hertz.
120:                 
121:                   Precondition:
122:                     None.
123:                 
124:                   Parameters:
125:                     None.
126:                 
127:                   Returns:
128:                     System clock frequency in Hertz.
129:                 
130:                   Example:
131:                     <code>
132:                     uint32_t sysClockHz;
133:                 
134:                     sysClockHz = SYS_CLK_SystemFrequencyGet ( );
135:                     </code>
136:                 
137:                   Remarks:
138:                  */
139:                 
140:                 inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
141:                 {
142:                     return SYS_CLK_FREQ;
143:                 }
9D009AE0  3C0202DC   LUI V0, 732
144:                 
145:                 //******************************************************************************
146:                 /* Function:
147:                     inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
148:                 
149:                   Summary:
150:                     Gets the selected clock peripheral bus frequency in Hertz.
151:                 
152:                   Description:
153:                     This function gets the selected peripheral bus clock frequency in Hertz.
154:                 
155:                   Precondition:
156:                     None.
157:                 
158:                   Parameters:
159:                 	peripheralBus - Reference clock bus selection. One of the possible value from
160:                 				CLK_BUSES_PERIPHERAL enum. For devices that do not have multiple
161:                 				clock channels for Reference clock, CLK_BUS_PERIPHERAL_1 should be
162:                 				the selection.
163:                 
164:                   Returns:
165:                     Clock frequency in Hertz.
166:                 
167:                   Example:
168:                     <code>
169:                     unsigned long peripheralClockHz;
170:                 
171:                     peripheralClockHz = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_PERIPHERAL_5 );
172:                     </code>
173:                 
174:                   Remarks:
175:                 	Most of the devices doesn't have multiple Peripheral clock buses. In that case, 
176:                 	pass CLK_USB_PERIPHERAL_1 as the bus number.
177:                  */
178:                 
179:                 inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
180:                 {
181:                     return SYS_CLK_BUS_PERIPHERAL_1;
182:                 }
9D009AEC  3C02016E   LUI V0, 366
183:                 
184:                 
185:                 //******************************************************************************
186:                 /* Function:
187:                     inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
188:                 
189:                   Summary:
190:                     Gets the selected Reference clock bus frequency in Hertz.
191:                 
192:                   Description:
193:                     This function gets frequency of the selected Reference clock bus in Hertz.
194:                 
195:                   Precondition:
196:                     None.
197:                 
198:                   Parameters:
199:                 	peripheralBus - Reference clock bus selection. One of the possible value from
200:                 				CLK_BUSES_REFERENCE enum. For devices that do not have multiple
201:                 				clock channels for Reference clock, CLK_BUS_REFERENCE_1 should be
202:                 				the selection.
203:                 
204:                   Returns:
205:                     Clock frequency in Hz.
206:                 
207:                   Example:
208:                     <code>
209:                     unsigned long sysClockOutputHz;
210:                 
211:                     sysClockOutputHz = SYS_CLK_ReferenceFrequencyGet ( CLK_BUS_REFERENCE_3 );
212:                     </code>
213:                 
214:                   Remarks:
215:                     None.
216:                  */
217:                 
218:                 inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
219:                 {
220:                 	return 0;
221:                 
222:                 }
223:                 
224:                 /******************************************************************************
225:                   Function:
226:                     void SYS_CLK_SecondaryOscillatorEnable ( void )
227:                 
228:                   Summary:
229:                     Enables the secondary oscillator.
230:                 
231:                   Description:
232:                     This function enables the secondary oscillator.
233:                 
234:                   Remarks:
235:                     For more details refer sys_clk.h.
236:                 */
237:                 
238:                 void SYS_CLK_SecondaryOscillatorEnable ( void )
239:                 {
9D0093EC  27BDFFE8   ADDIU SP, SP, -24
9D0093F0  AFBF0014   SW RA, 20(SP)
240:                     /* Check for secondary oscillator status */
241:                     if (!PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
9D0093E4  1440000C   BNE V0, ZERO, 0x9D009418
9D0093E8  00000000   NOP
242:                     {    
243:                         /* Unlock and enable secondary oscillator */
244:                         SYS_DEVCON_SystemUnlock();
9D0093F4  0F40242A   JAL SYS_DEVCON_SystemUnlock
9D0093F8  00000000   NOP
245:                         
246:                         PLIB_OSC_SecondaryEnable(OSC_ID_0);
247:                         
248:                         SYS_DEVCON_SystemLock();
9D009408  0F402508   JAL SYS_DEVCON_SystemLock
9D00940C  00000000   NOP
249:                     }
250:                 }
9D009410  8FBF0014   LW RA, 20(SP)
251:                 
252:                 /******************************************************************************
253:                   Function:
254:                     void SYS_CLK_SecondaryOscillatorDisable ( void )
255:                 
256:                   Summary:
257:                     Disables the secondary oscillator.
258:                 
259:                   Description:
260:                     This function disables the secondary oscillator.
261:                 
262:                   Remarks:
263:                     For more details refer sys_clk.h.
264:                 */
265:                 
266:                 void SYS_CLK_SecondaryOscillatorDisable ( void )
267:                 {
268:                     /* Check for secondary oscillator status */
269:                     if (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
270:                     {    
271:                         /* Unlock and disable secondary oscillator*/
272:                         SYS_DEVCON_SystemUnlock();
273:                         
274:                         PLIB_OSC_SecondaryDisable(OSC_ID_0);
275:                         
276:                         SYS_DEVCON_SystemLock();
277:                     }
278:                 }
279:                 
280:                 /******************************************************************************
281:                   Function:
282:                     bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
283:                 
284:                   Summary:
285:                     Identifies whether secondary oscillator is enabled or disabled.
286:                 
287:                   Description:
288:                     This function identifies whether the secondary oscillator is enabled or 
289:                     disabled.
290:                     
291:                   Remarks:
292:                     For more details refer sys_clk.h.
293:                 */
294:                 
295:                 bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
296:                 {
297:                     return (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0));
298:                 }
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_tokenpid_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_TokenPID_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TokenPID
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_TokenPIDGet
16:                          PLIB_USB_TokenPIDSet
17:                          PLIB_USB_ExistsTokenPID
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_TOKENPID_DEFAULT_H
48:                  #define _USB_TOKENPID_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_TokenPIDGet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_TokenPIDGet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_TokenPIDGet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE USB_PID USB_TokenPIDGet_Default( USB_MODULE_ID index )
64:                  {
65:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                      return (USB_PID)usb->UxTOK.UxTOKbits.PID ; 
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_TokenPIDSet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_TokenPIDSet 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_TokenPIDSet function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_TokenPIDSet_Default( USB_MODULE_ID index , USB_PID pidValue )
80:                  {
81:                       volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                  	 usb->UxTOK.UxTOKbits.PID =  pidValue ;
83:                  }
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USB_ExistsTokenPID_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USB_ExistsTokenPID
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USB_ExistsTokenPID function.
93:                  */
94:                  
95:                  #define PLIB_USB_ExistsTokenPID PLIB_USB_ExistsTokenPID
96:                  PLIB_TEMPLATE bool USB_ExistsTokenPID_Default( USB_MODULE_ID index )
97:                  {
98:                      return true;
99:                  }
100:                 
101:                 PLIB_TEMPLATE void USB_TokenSend_Default(USB_MODULE_ID index, USB_PID pidValue, uint8_t endpoint, uint8_t deviceAddress, bool isLowSpeed)
102:                 {
103:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
104:                 	usb->UxADDR.DEVADDR = deviceAddress & 0x7F ;
9D000C14  91020220   LBU V0, 544(T0)
9D000F40  91020220   LBU V0, 544(T0)
9D006C44  90430220   LBU V1, 544(V0)
9D0076AC  90430220   LBU V1, 544(V0)
105:                 	usb->UxADDR.LSPDEN = isLowSpeed ;
9D000C20  91020220   LBU V0, 544(T0)
9D000F4C  91020220   LBU V0, 544(T0)
9D006C50  90430220   LBU V1, 544(V0)
9D0076BC  90430220   LBU V1, 544(V0)
106:                     /* Write to the token register */
107:                     usb->UxTOK.w = (pidValue << UxTOK_PID_POSITION )|endpoint;
9D000C2C  356B00D0   ORI T3, T3, 208
9D000F58  00031100   SLL V0, V1, 4
9D006C5C  000B1900   SLL V1, T3, 4
9D0076CC  000A1900   SLL V1, T2, 4
108:                 }
109:                 
110:                 #endif /*_USB_TOKENPID_DEFAULT_H*/
111:                 
112:                 /******************************************************************************
113:                  End of File
114:                 */
115:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_stopinidle_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_StopInIdle_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StopInIdle
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_StopInIdleEnable
16:                          PLIB_USB_StopInIdleDisable
17:                          PLIB_USB_ExistsStopInIdle
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_STOPINIDLE_DEFAULT_H
48:                  #define _USB_STOPINIDLE_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_StopInIdleEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_StopInIdleEnable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USB_StopInIdleEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_StopInIdleEnable_Default( USB_MODULE_ID index )
63:                  {
64:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
65:                      usb->UxCNFG1.USBSIDL = 1;
9D005E78  920202A0   LBU V0, 672(S0)
9D005E7C  7C622104   INS V0, V1, 4, 1
9D005E80  A20202A0   SB V0, 672(S0)
66:                     
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_StopInIdleDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_StopInIdleDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_StopInIdleDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_StopInIdleDisable_Default( USB_MODULE_ID index )
80:                  {
81:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                      usb->UxCNFG1.USBSIDL = 1;
9D003218  3C02BF88   LUI V0, -16504
9D00321C  904352E0   LBU V1, 21216(V0)
9D003220  7E232104   INS V1, S1, 4, 1
9D003224  A04352E0   SB V1, 21216(V0)
9D005E8C  920202A0   LBU V0, 672(S0)
9D005E90  24030001   ADDIU V1, ZERO, 1
9D005E94  7C622104   INS V0, V1, 4, 1
9D005E98  A20202A0   SB V0, 672(S0)
83:                  }
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USB_ExistsStopInIdle_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USB_ExistsStopInIdle
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USB_ExistsStopInIdle function.
93:                  */
94:                  
95:                  #define PLIB_USB_ExistsStopInIdle PLIB_USB_ExistsStopInIdle
96:                  PLIB_TEMPLATE bool USB_ExistsStopInIdle_Default( USB_MODULE_ID index )
97:                  {
98:                      return true;
99:                  }
100:                 
101:                 
102:                 #endif /*_USB_STOPINIDLE_DEFAULT_H*/
103:                 
104:                 /******************************************************************************
105:                  End of File
106:                 */
107:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_startofframes_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_StartOfFrames_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StartOfFrames
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_SOFEnable
16:                          PLIB_USB_SOFDisable
17:                          PLIB_USB_ExistsStartOfFrames
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_STARTOFFRAMES_DEFAULT_H
48:                  #define _USB_STARTOFFRAMES_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_SOFEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_SOFEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_SOFEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_SOFEnable_Default( USB_MODULE_ID index )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                  	usb->UxCON.w |=  UxCON_USBEN_SOFEN_MASK ;
9D001C6C  8E020210   LW V0, 528(S0)
9D001C70  34420001   ORI V0, V0, 1
9D001C74  AE020210   SW V0, 528(S0)
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_SOFDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_SOFDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_SOFDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_SOFDisable_Default( USB_MODULE_ID index )
80:                  {
81:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                  	usb->UxCON.w &= ( ~ UxCON_USBEN_SOFEN_MASK);
9D001E08  8E020210   LW V0, 528(S0)
9D001E0C  7C020004   INS V0, ZERO, 0, 1
9D001E10  AE020210   SW V0, 528(S0)
83:                   
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  USB_ExistsStartOfFrames_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_USB_ExistsStartOfFrames
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_USB_ExistsStartOfFrames function.
95:                  */
96:                  
97:                  #define PLIB_USB_ExistsStartOfFrames PLIB_USB_ExistsStartOfFrames
98:                  PLIB_TEMPLATE bool USB_ExistsStartOfFrames_Default( USB_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 #endif /*_USB_STARTOFFRAMES_DEFAULT_H*/
104:                 
105:                 /******************************************************************************
106:                  End of File
107:                 */
108:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_softhreshold_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_SOFThreshold_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SOFThreshold
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_SOFThresholdGet
16:                          PLIB_USB_SOFThresholdSet
17:                          PLIB_USB_ExistsSOFThreshold
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_SOFTHRESHOLD_DEFAULT_H
48:                  #define _USB_SOFTHRESHOLD_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_SOFThresholdGet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_SOFThresholdGet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_SOFThresholdGet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE uint8_t USB_SOFThresholdGet_Default( USB_MODULE_ID index )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                  	return ( usb->UxSOF.CNT );
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_SOFThresholdSet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_SOFThresholdSet 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_SOFThresholdSet function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_SOFThresholdSet_Default( USB_MODULE_ID index , uint8_t threshold )
80:                  {
81:                  	 volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D005F28  8C820020   LW V0, 32(A0)
82:                       usb->UxSOF.CNT  =   ( 0xFF & threshold ) ;
9D005F2C  2403004A   ADDIU V1, ZERO, 74
9D005F30  A0430270   SB V1, 624(V0)
83:                    
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_ExistsSOFThreshold_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_ExistsSOFThreshold
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USB_ExistsSOFThreshold function.
94:                  */
95:                  
96:                  #define PLIB_USB_ExistsSOFThreshold PLIB_USB_ExistsSOFThreshold
97:                  PLIB_TEMPLATE bool USB_ExistsSOFThreshold_Default( USB_MODULE_ID index )
98:                  {
99:                      return true;
100:                 }
101:                 
102:                 
103:                 #endif /*_USB_SOFTHRESHOLD_DEFAULT_H*/
104:                 
105:                 /******************************************************************************
106:                  End of File
107:                 */
108:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_otg_vbuspoweronoff_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OTG_VbusPowerOnOff_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OTG_VbusPowerOnOff
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OTG_VBusPowerOff
16:                          PLIB_USB_OTG_VBusPowerOn
17:                          PLIB_USB_ExistsOTG_VbusPowerOnOff
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_OTG_VBUSPOWERONOFF_DEFAULT_H
48:                  #define _USB_OTG_VBUSPOWERONOFF_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_OTG_VBusPowerOff_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_OTG_VBusPowerOff 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_OTG_VBusPowerOff function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_OTG_VBusPowerOff_Default( USB_MODULE_ID index )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                      usb->UxOTGCON.VBUSON = 0;
67:                  
68:                  }
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USB_OTG_VBusPowerOn_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USB_OTG_VBusPowerOn 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USB_OTG_VBusPowerOn function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USB_OTG_VBusPowerOn_Default( USB_MODULE_ID index )
81:                  {
82:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D005F34  8C820020   LW V0, 32(A0)
83:                      usb->UxOTGCON.VBUSON = 1;
9D005F38  90430030   LBU V1, 48(V0)
9D005F3C  24050001   ADDIU A1, ZERO, 1
9D005F40  7CA318C4   INS V1, A1, 3, 1
9D005F44  A0430030   SB V1, 48(V0)
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_ExistsOTG_VbusPowerOnOff_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_ExistsOTG_VbusPowerOnOff
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USB_ExistsOTG_VbusPowerOnOff function.
94:                  */
95:                  
96:                  #define PLIB_USB_ExistsOTG_VbusPowerOnOff PLIB_USB_ExistsOTG_VbusPowerOnOff
97:                  PLIB_TEMPLATE bool USB_ExistsOTG_VbusPowerOnOff_Default( USB_MODULE_ID index )
98:                  {
99:                      return true;
100:                 }
101:                 
102:                 
103:                 #endif /*_USB_OTG_VBUSPOWERONOFF_DEFAULT_H*/
104:                 
105:                 /******************************************************************************
106:                  End of File
107:                 */
108:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_otg_interruptstatus_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OTG_InterruptStatus_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OTG_InterruptStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OTG_InterruptFlagSet
16:                          PLIB_USB_OTG_InterruptFlagClear
17:                          PLIB_USB_OTG_InterruptFlagGet
18:                          PLIB_USB_ExistsOTG_InterruptStatus
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_OTG_INTERRUPTSTATUS_DEFAULT_H
49:                  #define _USB_OTG_INTERRUPTSTATUS_DEFAULT_H
50:                  
51:                  #include "../templates/usb_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_OTG_InterruptFlagSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_OTG_InterruptFlagSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptFlagSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_OTG_InterruptFlagSet_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                  	usb->UxOTGIR.w  |= interruptFlag ;
67:                      
68:                  }
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USB_OTG_InterruptFlagClear_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USB_OTG_InterruptFlagClear 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptFlagClear function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USB_OTG_InterruptFlagClear_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
81:                  {
82:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
83:                  	usb->UxOTGIR.w = interruptFlag ;
9D001B34  24020040   ADDIU V0, ZERO, 64
9D001B38  AE020000   SW V0, 0(S0)
84:                  
85:                  }
86:                  
87:                  //******************************************************************************
88:                  /* Function :  USB_OTG_InterruptFlagGet_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_USB_OTG_InterruptFlagGet 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptFlagGet function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE bool USB_OTG_InterruptFlagGet_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
98:                  {
99:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
100:                     return (  ( ( ( usb->UxOTGIR.w  ) & ( interruptFlag) )) ? 1 : 0 );
9D001B24  8E020000   LW V0, 0(S0)
9D001B28  30420040   ANDI V0, V0, 64
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  USB_ExistsOTG_InterruptStatus_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_USB_ExistsOTG_InterruptStatus
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_USB_ExistsOTG_InterruptStatus function.
112:                 */
113:                 
114:                 #define PLIB_USB_ExistsOTG_InterruptStatus PLIB_USB_ExistsOTG_InterruptStatus
115:                 PLIB_TEMPLATE bool USB_ExistsOTG_InterruptStatus_Default( USB_MODULE_ID index )
116:                 {
117:                     return true;
118:                 }
119:                 
120:                 
121:                 #endif /*_USB_OTG_INTERRUPTSTATUS_DEFAULT_H*/
122:                 
123:                 /******************************************************************************
124:                  End of File
125:                 */
126:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_otg_interrupt_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OTG_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OTG_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OTG_InterruptEnable
16:                          PLIB_USB_OTG_InterruptDisable
17:                          PLIB_USB_OTG_InterruptIsEnabled
18:                          PLIB_USB_ExistsOTG_Interrupt
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_OTG_INTERRUPT_DEFAULT_H
49:                  #define _USB_OTG_INTERRUPT_DEFAULT_H
50:                  
51:                  #include "../templates/usb_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_OTG_InterruptEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_OTG_InterruptEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_OTG_InterruptEnable_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
64:                  {
65:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D008C38  8C820020   LW V0, 32(A0)
9D008CB8  8C820020   LW V0, 32(A0)
66:                  	usb->UxOTGIE.w   |= interruptFlag;
9D001DB8  8E020010   LW V0, 16(S0)
9D001DBC  34420040   ORI V0, V0, 64
9D001DC0  AE020010   SW V0, 16(S0)
9D001EC0  8E020010   LW V0, 16(S0)
9D001EC4  34420040   ORI V0, V0, 64
9D001EC8  AE020010   SW V0, 16(S0)
9D008C3C  8C430010   LW V1, 16(V0)
9D008C40  34630008   ORI V1, V1, 8
9D008C44  AC430010   SW V1, 16(V0)
9D008CBC  8C430010   LW V1, 16(V0)
9D008CC0  34630040   ORI V1, V1, 64
9D008CC4  AC430010   SW V1, 16(V0)
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_OTG_InterruptDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_OTG_InterruptDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_OTG_InterruptDisable_Default( USB_MODULE_ID index , USB_OTG_INTERRUPTS     interruptFlag )
80:                  {
81:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                      usb->UxOTGIE.w   &= (~interruptFlag);
9D001B60  8E020010   LW V0, 16(S0)
9D001B64  7C023184   INS V0, ZERO, 6, 1
9D001B68  AE020010   SW V0, 16(S0)
9D001C04  8E020010   LW V0, 16(S0)
9D001C08  7C023184   INS V0, ZERO, 6, 1
9D001C0C  AE020010   SW V0, 16(S0)
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_OTG_InterruptIsEnabled_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_OTG_InterruptIsEnabled 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USB_OTG_InterruptIsEnabled function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE bool USB_OTG_InterruptIsEnabled_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
97:                  {   
98:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
99:                      return ( ( usb->UxOTGIE.w ) & interruptFlag ? 1 : 0 );
9D001B14  8E020010   LW V0, 16(S0)
9D001B18  30420040   ANDI V0, V0, 64
100:                 }
101:                 
102:                 
103:                 //******************************************************************************
104:                 /* Function :  USB_ExistsOTG_Interrupt_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_USB_ExistsOTG_Interrupt
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_USB_ExistsOTG_Interrupt function.
111:                 */
112:                 
113:                 #define PLIB_USB_ExistsOTG_Interrupt PLIB_USB_ExistsOTG_Interrupt
114:                 PLIB_TEMPLATE bool USB_ExistsOTG_Interrupt_Default( USB_MODULE_ID index )
115:                 {
116:                     return true;
117:                 }
118:                 
119:                 
120:                 #endif /*_USB_OTG_INTERRUPT_DEFAULT_H*/
121:                 
122:                 /******************************************************************************
123:                  End of File
124:                 */
125:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_opmodeselect_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_OpModeSelect_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OpModeSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_OperatingModeSelect
16:                          PLIB_USB_ExistsOpModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_OPMODESELECT_DEFAULT_H
47:                  #define _USB_OPMODESELECT_DEFAULT_H
48:                  
49:                  #include "../templates/usb_registers.h"
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_OperatingModeSelect_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_OperatingModeSelect
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USB_OperatingModeSelect function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_OperatingModeSelect_Default( USB_MODULE_ID index , USB_OPMODES opMode )
63:                  {
64:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D005F48  8C820020   LW V0, 32(A0)
65:                      usb->UxCON.UxCONbits.USBEN_SOFEN = 0;
9D005F4C  90430210   LBU V1, 528(V0)
9D005F50  7C030004   INS V1, ZERO, 0, 1
9D005F54  A0430210   SB V1, 528(V0)
66:                      usb->UxCON.UxCONbits.HOSTEN = 0 ;
9D005F58  90430210   LBU V1, 528(V0)
9D005F5C  7C0318C4   INS V1, ZERO, 3, 1
9D005F60  A0430210   SB V1, 528(V0)
67:                  	usb->UxOTGCON.OTGEN = 0;
9D005F64  90430030   LBU V1, 48(V0)
9D005F68  7C031084   INS V1, ZERO, 2, 1
9D005F6C  A0430030   SB V1, 48(V0)
68:                      switch ( opMode )
69:                      {
70:                          case USB_OPMODE_NONE:
71:                               break;
72:                  			
73:                          case USB_OPMODE_DEVICE:
74:                               usb->UxCON.UxCONbits.USBEN_SOFEN = 1; 
75:                              break;
76:                  
77:                          case USB_OPMODE_HOST:
78:                              usb->UxCON.UxCONbits.HOSTEN = 1 ;
9D005F70  90430210   LBU V1, 528(V0)
9D005F74  7CA318C4   INS V1, A1, 3, 1
9D005F78  A0430210   SB V1, 528(V0)
9D005F7C  00001021   ADDU V0, ZERO, ZERO
79:                              break;
80:                  
81:                          case USB_OPMODE_OTG:
82:                              usb->UxOTGCON.OTGEN = 1;
83:                              break;
84:                  
85:                          default:
86:                              PLIB_ASSERT( 0, "In USB_OperatingModeSelect, unknown operating mode!" );
87:                              break;
88:                      }
89:                  }
90:                  
91:                  //******************************************************************************
92:                  /* Function :  USB_ExistsOpModeSelect_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_USB_ExistsOpModeSelect
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_USB_ExistsOpModeSelect function.
99:                  */
100:                 
101:                 #define PLIB_USB_ExistsOpModeSelect PLIB_USB_ExistsOpModeSelect
102:                 PLIB_TEMPLATE bool USB_ExistsOpModeSelect_Default( USB_MODULE_ID index )
103:                 {
104:                     return true;
105:                 }
106:                 
107:                 
108:                 #endif /*_USB_OPMODESELECT_DEFAULT_H*/
109:                 
110:                 /******************************************************************************
111:                  End of File
112:                 */
113:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_nexttokenspeed_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_NextTokenSpeed_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : NextTokenSpeed
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_TokenSpeedSelect
16:                          PLIB_USB_ExistsNextTokenSpeed
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_NEXTTOKENSPEED_DEFAULT_H
47:                  #define _USB_NEXTTOKENSPEED_DEFAULT_H
48:                  
49:                  #include "../templates/usb_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_TokenSpeedSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USB_TokenSpeedSelect
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USB_TokenSpeedSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void USB_TokenSpeedSelect_Default( USB_MODULE_ID index , USB_TOKEN_SPEED tokenSpeed )
62:                  {
63:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
64:                      usb->UxADDR.LSPDEN =   ( tokenSpeed & 0x01 )^ 0x01 ;
9D001C2C  90430220   LBU V1, 544(V0)
9D001C30  24040001   ADDIU A0, ZERO, 1
9D001C34  7C8339C4   INS V1, A0, 7, 1
9D001C38  A0430220   SB V1, 544(V0)
9D001C54  90430220   LBU V1, 544(V0)
9D001C58  7C0339C4   INS V1, ZERO, 7, 1
9D001C5C  A0430220   SB V1, 544(V0)
65:                  
66:                  }
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USB_ExistsNextTokenSpeed_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USB_ExistsNextTokenSpeed
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USB_ExistsNextTokenSpeed function.
76:                  */
77:                  
78:                  #define PLIB_USB_ExistsNextTokenSpeed PLIB_USB_ExistsNextTokenSpeed
79:                  PLIB_TEMPLATE bool USB_ExistsNextTokenSpeed_Default( USB_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_USB_NEXTTOKENSPEED_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_modulepower_32bit16bit.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ModulePower_32Bit16Bit.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ModulePower
13:                      and its Variant : 32Bit16Bit
14:                      For following APIs :
15:                          PLIB_USB_Enable
16:                          PLIB_USB_Disable
17:                          PLIB_USB_ExistsModulePower
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_MODULEPOWER_32BIT16BIT_H
48:                  #define _USB_MODULEPOWER_32BIT16BIT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_Enable_32Bit16Bit
55:                  
56:                    Summary:
57:                      Implements 32Bit16Bit variant of PLIB_USB_Enable 
58:                  
59:                    Description:
60:                      This template implements the 32Bit16Bit variant of the PLIB_USB_Enable function.
61:                  */
62:                  
63:                      
64:                  PLIB_TEMPLATE void USB_Enable_32Bit16Bit( USB_MODULE_ID index )
65:                  {
66:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
67:                  	usb->UxPWRC.USBPWR = 1;
9D005E60  92020040   LBU V0, 64(S0)
9D005E64  7C620004   INS V0, V1, 0, 1
9D005E68  A2020040   SB V0, 64(S0)
68:                      
69:                  }
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USB_Disable_32Bit16Bit
73:                  
74:                    Summary:
75:                      Implements 32Bit16Bit variant of PLIB_USB_Disable 
76:                  
77:                    Description:
78:                      This template implements the 32Bit16Bit variant of the PLIB_USB_Disable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void USB_Disable_32Bit16Bit( USB_MODULE_ID index )
82:                  {
83:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
84:                  	usb->UxPWRC.USBPWR = 0 ;
85:                   
86:                  }
87:                  
88:                  //******************************************************************************
89:                  /* Function :  USB_ExistsModulePower_32Bit16Bit
90:                  
91:                    Summary:
92:                      Implements 32Bit16Bit variant of PLIB_USB_ExistsModulePower
93:                  
94:                    Description:
95:                      This template implements the 32Bit16Bit variant of the PLIB_USB_ExistsModulePower function.
96:                  */
97:                  
98:                  #define PLIB_USB_ExistsModulePower PLIB_USB_ExistsModulePower
99:                  PLIB_TEMPLATE bool USB_ExistsModulePower_32Bit16Bit( USB_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_USB_MODULEPOWER_32BIT16BIT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_livejstate_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_LiveJState_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : LiveJState
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_JStateIsActive
16:                          PLIB_USB_ExistsLiveJState
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_LIVEJSTATE_DEFAULT_H
47:                  #define _USB_LIVEJSTATE_DEFAULT_H
48:                  
49:                  #include "../templates/usb_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_JStateIsActive_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USB_JStateIsActive 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USB_JStateIsActive function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE bool USB_JStateIsActive_Default( USB_MODULE_ID index )
62:                  {
63:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D001C10  8E220020   LW V0, 32(S1)
64:                      return (  usb->UxCON.UxCONbits.JSTATE );
9D001C14  8C430210   LW V1, 528(V0)
9D001C18  7C6301C0   EXT V1, V1, 7, 1
65:                  }
66:                  
67:                  //******************************************************************************
68:                  /* Function :  USB_ExistsLiveJState_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_USB_ExistsLiveJState
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_USB_ExistsLiveJState function.
75:                  */
76:                  
77:                  #define PLIB_USB_ExistsLiveJState PLIB_USB_ExistsLiveJState
78:                  PLIB_TEMPLATE bool USB_ExistsLiveJState_Default( USB_MODULE_ID index )
79:                  {
80:                      return true;
81:                  }
82:                  
83:                  
84:                  #endif /*_USB_LIVEJSTATE_DEFAULT_H*/
85:                  
86:                  /******************************************************************************
87:                   End of File
88:                  */
89:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_lasttransactiondetails_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_LastTransactionDetails_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : LastTransactionDetails
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_LastTransactionDetailsGet
16:                          PLIB_USB_ExistsLastTransactionDetails
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_LASTTRANSACTIONDETAILS_DEFAULT_H
47:                  #define _USB_LASTTRANSACTIONDETAILS_DEFAULT_H
48:                  
49:                  #include "../templates/usb_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_LastTransactionDetailsGet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USB_LastTransactionDetailsGet 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USB_LastTransactionDetailsGet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void USB_LastTransactionDetailsGet_Default( USB_MODULE_ID index , USB_BUFFER_DIRECTION * direction , USB_PING_PONG_STATE * pingpong , uint8_t * endpoint )
62:                  {
63:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
64:                      *direction = usb->UxSTAT.DIR;
9D001DF4  8E020200   LW V0, 512(S0)
9D001EE4  8E020200   LW V0, 512(S0)
9D001EE8  7C4200C0   EXT V0, V0, 3, 1
65:                      *pingpong = usb->UxSTAT.PPBI;
9D001DF8  8E020200   LW V0, 512(S0)
9D001EEC  8E030200   LW V1, 512(S0)
9D001EF0  7C630080   EXT V1, V1, 2, 1
66:                      *endpoint = usb->UxSTAT.ENDPT;
9D001DFC  8E020200   LW V0, 512(S0)
9D001EF4  8E040200   LW A0, 512(S0)
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_ExistsLastTransactionDetails_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_ExistsLastTransactionDetails
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_ExistsLastTransactionDetails function.
77:                  */
78:                  
79:                  #define PLIB_USB_ExistsLastTransactionDetails PLIB_USB_ExistsLastTransactionDetails
80:                  PLIB_TEMPLATE bool USB_ExistsLastTransactionDetails_Default( USB_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_USB_LASTTRANSACTIONDETAILS_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_hostgeneratesreset_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_HostGeneratesReset_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : HostGeneratesReset
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_ResetSignalEnable
16:                          PLIB_USB_ResetSignalDisable
17:                          PLIB_USB_ExistsHostGeneratesReset
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_HOSTGENERATESRESET_DEFAULT_H
48:                  #define _USB_HOSTGENERATESRESET_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_ResetSignalEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_ResetSignalEnable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USB_ResetSignalEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_ResetSignalEnable_Default( USB_MODULE_ID index )
63:                  {
64:                   	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D008CA8  8C820020   LW V0, 32(A0)
65:                  	usb->UxCON.w |=  UxCON_USBRST_MASK ;
9D008CAC  8C430210   LW V1, 528(V0)
9D008CB0  34630010   ORI V1, V1, 16
9D008CB4  AC430210   SW V1, 528(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_ResetSignalDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_ResetSignalDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_ResetSignalDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_ResetSignalDisable_Default( USB_MODULE_ID index )
80:                  {
81:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                  	usb->UxCON.w &= ( ~ UxCON_USBRST_MASK);
9D001BE4  8E020210   LW V0, 528(S0)
9D001BE8  7C022104   INS V0, ZERO, 4, 1
9D001BEC  AE020210   SW V0, 528(S0)
83:                  }
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USB_ExistsHostGeneratesReset_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USB_ExistsHostGeneratesReset
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USB_ExistsHostGeneratesReset function.
93:                  */
94:                  
95:                  #define PLIB_USB_ExistsHostGeneratesReset PLIB_USB_ExistsHostGeneratesReset
96:                  PLIB_TEMPLATE bool USB_ExistsHostGeneratesReset_Default( USB_MODULE_ID index )
97:                  {
98:                      return true;
99:                  }
100:                 
101:                 
102:                 #endif /*_USB_HOSTGENERATESRESET_DEFAULT_H*/
103:                 
104:                 /******************************************************************************
105:                  End of File
106:                 */
107:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_gen_interruptstatus_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_GEN_InterruptStatus_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : GEN_InterruptStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_InterruptFlagSet
16:                          PLIB_USB_InterruptFlagClear
17:                          PLIB_USB_InterruptFlagGet
18:                          PLIB_USB_ExistsGEN_InterruptStatus
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_GEN_INTERRUPTSTATUS_DEFAULT_H
49:                  #define _USB_GEN_INTERRUPTSTATUS_DEFAULT_H
50:                  
51:                  #include "../templates/usb_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_InterruptFlagSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_InterruptFlagSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_InterruptFlagSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_InterruptFlagSet_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
64:                  {
65:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
66:                      usb->UxIR.w  |= interruptFlag;
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_InterruptFlagClear_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_InterruptFlagClear 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USB_InterruptFlagClear function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USB_InterruptFlagClear_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
80:                  {
81:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
82:                  	usb->UxIR.w  = interruptFlag;
9D001B80  24020001   ADDIU V0, ZERO, 1
9D001B84  AE0201C0   SW V0, 448(S0)
9D001CB0  24020040   ADDIU V0, ZERO, 64
9D001CB4  AE0201C0   SW V0, 448(S0)
9D001CE4  24020002   ADDIU V0, ZERO, 2
9D001CE8  AE0201C0   SW V0, 448(S0)
9D001D04  24020004   ADDIU V0, ZERO, 4
9D001D08  AE0201C0   SW V0, 448(S0)
9D001D38  24020080   ADDIU V0, ZERO, 128
9D001D3C  AE0201C0   SW V0, 448(S0)
9D001D58  24020020   ADDIU V0, ZERO, 32
9D001D5C  AE0201C0   SW V0, 448(S0)
9D001D78  24020010   ADDIU V0, ZERO, 16
9D001D7C  AE0201C0   SW V0, 448(S0)
9D001D98  24020040   ADDIU V0, ZERO, 64
9D001D9C  AE0201C0   SW V0, 448(S0)
9D001DD8  AE0301C0   SW V1, 448(S0)
9D001E00  24020008   ADDIU V0, ZERO, 8
9D001E04  AE0201C0   SW V0, 448(S0)
9D001EF8  24040008   ADDIU A0, ZERO, 8
9D001EFC  AE0401C0   SW A0, 448(S0)
83:                  }
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USB_InterruptFlagGet_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USB_InterruptFlagGet 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USB_InterruptFlagGet function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE bool USB_InterruptFlagGet_Default( USB_MODULE_ID index , USB_INTERRUPTS interruptFlag )
96:                  {
97:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
98:                      return ( (( usb->UxIR.w ) & interruptFlag) ? 1 : 0 );
9D001B70  8E0201C0   LW V0, 448(S0)
9D001B74  30420040   ANDI V0, V0, 64
9D001ECC  8E0201C0   LW V0, 448(S0)
9D001ED0  30420008   ANDI V0, V0, 8
99:                  }
100:                 
101:                 //******************************************************************************
102:                 /* Function :  USB_InterruptFlagGet_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_USB_InterruptFlagAllGet 
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_USB_InterruptFlagAllGet function.
109:                 */
110:                 
111:                 PLIB_TEMPLATE USB_INTERRUPTS USB_InterruptFlagAllGet_Default( USB_MODULE_ID index )
112:                 {
113:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D001B08  8C900020   LW S0, 32(A0)
114:                 	return (USB_INTERRUPTS) (  usb->UxIR.w ) ;
9D001B0C  8E1201C0   LW S2, 448(S0)
115:                 }
116:                 
117:                 //******************************************************************************
118:                 /* Function :  USB_ExistsGEN_InterruptStatus_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_USB_ExistsGEN_InterruptStatus
122:                 
123:                   Description:
124:                     This template implements the Default variant of the PLIB_USB_ExistsGEN_InterruptStatus function.
125:                 */
126:                 
127:                 #define PLIB_USB_ExistsGEN_InterruptStatus PLIB_USB_ExistsGEN_InterruptStatus
128:                 PLIB_TEMPLATE bool USB_ExistsGEN_InterruptStatus_Default( USB_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 
134:                 #endif /*_USB_GEN_INTERRUPTSTATUS_DEFAULT_H*/
135:                 
136:                 /******************************************************************************
137:                  End of File
138:                 */
139:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_gen_interrupt_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_GEN_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : GEN_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_InterruptEnable
16:                          PLIB_USB_InterruptDisable
17:                          PLIB_USB_InterruptIsEnabled
18:                          PLIB_USB_ExistsGEN_Interrupt
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_GEN_INTERRUPT_DEFAULT_H
49:                  #define _USB_GEN_INTERRUPT_DEFAULT_H
50:                  
51:                  #include "../templates/usb_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_InterruptEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_InterruptEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_InterruptEnable
61:                      function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_InterruptEnable_Default
65:                  ( 
66:                      USB_MODULE_ID index , 
67:                      USB_INTERRUPTS interruptFlag 
68:                  )
69:                  {
70:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D007B10  8E020020   LW V0, 32(S0)
71:                  	usb->UxIE.w  |= interruptFlag ;
9D001B88  8E0201D0   LW V0, 464(S0)
9D001B8C  34420001   ORI V0, V0, 1
9D001B90  AE0201D0   SW V0, 464(S0)
9D001B94  8E0201D0   LW V0, 464(S0)
9D001B98  34420008   ORI V0, V0, 8
9D001B9C  AE0201D0   SW V0, 464(S0)
9D001BB4  8E0201D0   LW V0, 464(S0)
9D001BB8  34420040   ORI V0, V0, 64
9D001BBC  AE0201D0   SW V0, 464(S0)
9D001C78  8E0201D0   LW V0, 464(S0)
9D001C7C  34420004   ORI V0, V0, 4
9D001C80  AE0201D0   SW V0, 464(S0)
9D001CB8  8E0201D0   LW V0, 464(S0)
9D001CBC  34420040   ORI V0, V0, 64
9D001CC0  AE0201D0   SW V0, 464(S0)
9D007B14  8C4301D0   LW V1, 464(V0)
9D007B18  34630040   ORI V1, V1, 64
9D007B1C  AC4301D0   SW V1, 464(V0)
72:                  }
73:                  
74:                  //******************************************************************************
75:                  /* Function :  USB_InterruptDisable_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_USB_InterruptDisable 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the
82:                      PLIB_USB_InterruptDisable function.
83:                  */
84:                  
85:                  PLIB_TEMPLATE void USB_InterruptDisable_Default
86:                  ( 
87:                      USB_MODULE_ID index , 
88:                      USB_INTERRUPTS interruptFlag 
89:                  )
90:                  {
91:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D007B50  8E020020   LW V0, 32(S0)
92:                  	usb->UxIE.w &= (~interruptFlag);
9D001DA0  8E0201D0   LW V0, 464(S0)
9D001DA4  7C023184   INS V0, ZERO, 6, 1
9D001DA8  AE0201D0   SW V0, 464(S0)
9D001DDC  8E0201D0   LW V0, 464(S0)
9D001DE0  7C020004   INS V0, ZERO, 0, 1
9D001DE4  AE0201D0   SW V0, 464(S0)
9D001DE8  8E0201D0   LW V0, 464(S0)
9D001DEC  7C0218C4   INS V0, ZERO, 3, 1
9D001DF0  AE0201D0   SW V0, 464(S0)
9D001E14  8E0201D0   LW V0, 464(S0)
9D001E18  7C021084   INS V0, ZERO, 2, 1
9D001E1C  AE0201D0   SW V0, 464(S0)
9D007B54  8C4301D0   LW V1, 464(V0)
9D007B58  7C033184   INS V1, ZERO, 6, 1
9D007B5C  AC4301D0   SW V1, 464(V0)
93:                  }
94:                  
95:                  //******************************************************************************
96:                  /* Function :  USB_InterruptIsEnabled_Default
97:                  
98:                    Summary:
99:                      Implements Default variant of PLIB_USB_InterruptIsEnabled 
100:                 
101:                   Description:
102:                     This template implements the Default variant of the
103:                     PLIB_USB_InterruptIsEnabled function.
104:                 */
105:                 
106:                 PLIB_TEMPLATE bool USB_InterruptIsEnabled_Default
107:                 ( 
108:                     USB_MODULE_ID index , 
109:                     USB_INTERRUPTS interruptFlag 
110:                 )
111:                 {
112:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
113:                     return ( (usb->UxIE.w )  & interruptFlag ? 1 : 0 );
114:                 }
115:                 
116:                 //******************************************************************************
117:                 /* Function :  USB_ExistsGEN_Interrupt_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_USB_ExistsGEN_Interrupt
121:                 
122:                   Description:
123:                     This template implements the Default variant of the
124:                     PLIB_USB_ExistsGEN_Interrupt function.
125:                 */
126:                 
127:                 #define PLIB_USB_ExistsGEN_Interrupt PLIB_USB_ExistsGEN_Interrupt
128:                 PLIB_TEMPLATE bool USB_ExistsGEN_Interrupt_Default( USB_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 #endif /*_USB_GEN_INTERRUPT_DEFAULT_H*/
134:                 
135:                 /******************************************************************************
136:                  End of File
137:                 */
138:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_err_interruptstatus_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ERR_InterruptStatus_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ERR_InterruptStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_ErrorInterruptFlagSet
16:                          PLIB_USB_ErrorInterruptFlagClear
17:                          PLIB_USB_ErrorInterruptFlagGet
18:                          PLIB_USB_ExistsERR_InterruptStatus
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USB_ERR_INTERRUPTSTATUS_DEFAULT_H
49:                  #define _USB_ERR_INTERRUPTSTATUS_DEFAULT_H
50:                  
51:                  #include "../templates/usb_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_ErrorInterruptFlagSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_ErrorInterruptFlagSet 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the
61:                      PLIB_USB_ErrorInterruptFlagSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_ErrorInterruptFlagSet_Default
65:                  ( 
66:                      USB_MODULE_ID index , 
67:                      USB_ERROR_INTERRUPTS   interruptFlag 
68:                  )
69:                  {
70:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
71:                  	usb->UxEIR.w |=  interruptFlag ;
72:                     
73:                  }
74:                  
75:                  //******************************************************************************
76:                  /* Function :  USB_ErrorInterruptFlagClear_Default
77:                  
78:                    Summary:
79:                      Implements Default variant of PLIB_USB_ErrorInterruptFlagClear 
80:                  
81:                    Description:
82:                      This template implements the Default variant of the
83:                      PLIB_USB_ErrorInterruptFlagClear function.
84:                  */
85:                  
86:                  PLIB_TEMPLATE void USB_ErrorInterruptFlagClear_Default
87:                  ( 
88:                      USB_MODULE_ID index , 
89:                      USB_ERROR_INTERRUPTS interruptFlag 
90:                  )
91:                  {
92:                   	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
93:                  	usb->UxEIR.w = interruptFlag ;
9D001CE0  AE0201E0   SW V0, 480(S0)
94:                  }
95:                  
96:                  //******************************************************************************
97:                  /* Function :  USB_ErrorInterruptFlagGet_Default
98:                  
99:                    Summary:
100:                     Implements Default variant of PLIB_USB_ErrorInterruptFlagGet 
101:                 
102:                   Description:
103:                     This template implements the Default variant of the
104:                     PLIB_USB_ErrorInterruptFlagGet function.
105:                 */
106:                 
107:                 PLIB_TEMPLATE bool USB_ErrorInterruptFlagGet_Default
108:                 ( 
109:                     USB_MODULE_ID index , 
110:                     USB_ERROR_INTERRUPTS interruptFlag 
111:                 )
112:                 {
113:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
114:                     return ( ( usb->UxEIR.w) & interruptFlag ? 1 : 0 );
115:                 }
116:                 
117:                 //******************************************************************************
118:                 /* Function :  USB_ErrorInterruptFlagAllGet_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_USB_ErrorInterruptFlagAllGet 
122:                 
123:                   Description:
124:                     This template implements the Default variant of the
125:                     PLIB_USB_ErrorInterruptFlagAllGet function.
126:                 */
127:                 
128:                 PLIB_TEMPLATE USB_ERROR_INTERRUPTS USB_ErrorInterruptFlagAllGet_Default( USB_MODULE_ID index )
129:                 {
130:                 	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
131:                     return (USB_ERROR_INTERRUPTS)( usb->UxEIR.w);
9D001CDC  8E0201E0   LW V0, 480(S0)
132:                 
133:                 }
134:                 
135:                 //******************************************************************************
136:                 /* Function :  USB_ExistsERR_InterruptStatus_Default
137:                 
138:                   Summary:
139:                     Implements Default variant of PLIB_USB_ExistsERR_InterruptStatus
140:                 
141:                   Description:
142:                     This template implements the Default variant of the
143:                     PLIB_USB_ExistsERR_InterruptStatus function.
144:                 */
145:                 
146:                 #define PLIB_USB_ExistsERR_InterruptStatus PLIB_USB_ExistsERR_InterruptStatus
147:                 PLIB_TEMPLATE bool USB_ExistsERR_InterruptStatus_Default( USB_MODULE_ID index )
148:                 {
149:                     return true;
150:                 }
151:                 
152:                 
153:                 #endif /*_USB_ERR_INTERRUPTSTATUS_DEFAULT_H*/
154:                 
155:                 /******************************************************************************
156:                  End of File
157:                 */
158:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_epnrxenableenhanced_pic32.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_EPnRxEnableEnhanced_PIC32.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EPnRxEnableEnhanced
13:                      and its Variant : PIC32
14:                      For following APIs :
15:                          PLIB_USB_EPnRxEnable
16:                          PLIB_USB_ExistsEPnRxEnable
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_EPNRXENABLEENHANCED_PIC32_H
47:                  #define _USB_EPNRXENABLEENHANCED_PIC32_H
48:                  
49:                  #include "../templates/usb_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_EPnRxEnable_PIC32
53:                  
54:                    Summary:
55:                      Implements PIC32 variant of PLIB_USB_EPnRxEnable 
56:                  
57:                    Description:
58:                      This template implements the PIC32 variant of the PLIB_USB_EPnRxEnable
59:                      function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_EPnRxEnable_PIC32
63:                  ( 
64:                      USB_MODULE_ID index , 
65:                      uint8_t endpoint 
66:                  )
67:                  {
68:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
69:                      usb->UxEP[endpoint].UxEPbits.EPRXEN = 1;
70:                  }
71:                  
72:                  //******************************************************************************
73:                  /* Function :  USB_EPnRxDisable_PIC32
74:                  
75:                    Summary:
76:                      Implements PIC32 variant of PLIB_USB_EPnRxDisable 
77:                  
78:                    Description:
79:                      This template implements the PIC32 variant of the PLIB_USB_EPnRxDisable
80:                      function.
81:                  */
82:                  
83:                  PLIB_TEMPLATE void USB_EPnRxDisable_PIC32
84:                  ( 
85:                      USB_MODULE_ID index , 
86:                      uint8_t endpoint 
87:                  )
88:                  {
89:                      volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
90:                      usb->UxEP[endpoint].UxEPbits.EPRXEN = 0;
91:                  }
92:                  
93:                  //******************************************************************************
94:                  /* Function :  USB_EPnTxEnable_PIC32
95:                  
96:                    Summary:
97:                      Implements PIC32 variant of PLIB_USB_EPnTxEnable 
98:                  
99:                    Description:
100:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxEnable
101:                     function.
102:                 */
103:                 
104:                 PLIB_TEMPLATE void USB_EPnTxEnable_PIC32
105:                 ( 
106:                     USB_MODULE_ID index , 
107:                     uint8_t endpoint 
108:                 )
109:                 {
110:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
111:                     usb->UxEP[endpoint].UxEPbits.EPTXEN = 1;
112:                 }
113:                 
114:                 //******************************************************************************
115:                 /* Function :  USB_EPnTxDisable_PIC32
116:                 
117:                   Summary:
118:                     Implements PIC32 variant of PLIB_USB_EPnTxDisable 
119:                 
120:                   Description:
121:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxDisable
122:                     function.
123:                 */
124:                 
125:                 PLIB_TEMPLATE void USB_EPnTxDisable_PIC32
126:                 ( 
127:                     USB_MODULE_ID index , 
128:                     uint8_t endpoint 
129:                 )
130:                 {
131:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
132:                     usb->UxEP[endpoint].UxEPbits.EPTXEN = 0;
133:                 }
134:                 
135:                 //******************************************************************************
136:                 /* Function :  USB_EPnHandshakeEnable_PIC32
137:                 
138:                   Summary:
139:                     Implements PIC32 variant of PLIB_USB_EPnTxEnable 
140:                 
141:                   Description:
142:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxEnable
143:                     function.
144:                 */
145:                 
146:                 PLIB_TEMPLATE void USB_EPnHandshakeEnable_PIC32
147:                 ( 
148:                     USB_MODULE_ID index , 
149:                     uint8_t endpoint 
150:                 )
151:                 {
152:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
153:                     usb->UxEP[endpoint].UxEPbits.EPHSHK = 1;
9D000C08  910202C0   LBU V0, 704(T0)
9D000C0C  7C620004   INS V0, V1, 0, 1
9D000C10  A10202C0   SB V0, 704(T0)
9D000F30  910202C0   LBU V0, 704(T0)
9D000F34  24040001   ADDIU A0, ZERO, 1
9D000F38  7C820004   INS V0, A0, 0, 1
9D000F3C  A10202C0   SB V0, 704(T0)
9D006C34  904302C0   LBU V1, 704(V0)
9D006C38  24040001   ADDIU A0, ZERO, 1
9D006C3C  7C830004   INS V1, A0, 0, 1
9D006C40  A04302C0   SB V1, 704(V0)
9D00769C  904302C0   LBU V1, 704(V0)
9D0076A0  24040001   ADDIU A0, ZERO, 1
9D0076A4  7C830004   INS V1, A0, 0, 1
9D0076A8  A04302C0   SB V1, 704(V0)
154:                    
155:                 }
156:                 
157:                 //******************************************************************************
158:                 /* Function :  USB_EPnTxDisable_PIC32
159:                 
160:                   Summary:
161:                     Implements PIC32 variant of PLIB_USB_EPnTxDisable 
162:                 
163:                   Description:
164:                     This template implements the PIC32 variant of the PLIB_USB_EPnTxDisable
165:                     function.
166:                 */
167:                 
168:                 PLIB_TEMPLATE void USB_EPnHandshakeDisable_PIC32
169:                 ( 
170:                     USB_MODULE_ID index , 
171:                     uint8_t endpoint 
172:                 )
173:                 {
174:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
175:                     usb->UxEP[endpoint].UxEPbits.EPHSHK = 0;
9D006C20  904302C0   LBU V1, 704(V0)
9D006C24  7C030004   INS V1, ZERO, 0, 1
9D006C28  A04302C0   SB V1, 704(V0)
9D006C2C  0B401B11   J _DRV_USBFS_HOST_NonControlSendToken::_DRV_USBFS_SendTokenToAddress
9D006C30  00000000   NOP
176:                 }
177:                 
178:                 //******************************************************************************
179:                 /* Function :  USB_EPnControlTransferEnable_PIC32
180:                 
181:                   Summary:
182:                     Implements PIC32 variant of PLIB_USB_EPnControlTransferEnable 
183:                 
184:                   Description:
185:                     This template implements the PIC32 variant of the
186:                     PLIB_USB_EPnControlTransferEnable function.
187:                 */
188:                 
189:                 PLIB_TEMPLATE void USB_EPnControlTransferEnable_PIC32
190:                 ( 
191:                     USB_MODULE_ID index , 
192:                     uint8_t endpoint 
193:                 )
194:                 {
195:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
196:                     usb->UxEP[endpoint].w &= (~UxEP_EPCONDIS_MASK);
197:                     usb->UxEP[endpoint].w |= (UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK);
198:                 }
199:                 
200:                 PLIB_TEMPLATE void USB_EPnAttributesSet_PIC32
201:                 (
202:                     USB_MODULE_ID index, 
203:                     uint8_t endpoint, 
204:                     int direction, 
205:                     bool isControl, 
206:                     bool handshake
207:                 )
208:                 {
209:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
210:                 
211:                     if(isControl)
212:                     {
213:                         usb->UxEP[endpoint].w &= (~UxEP_EPCONDIS_MASK);
214:                         usb->UxEP[endpoint].w |= (UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK|UxEP_EPHSHK_MASK);
215:                     }
216:                     else 
217:                 	{  
218:                 		/* Set the direction and handshake */
219:                         usb->UxEP[endpoint].w |= ((UxEP_EPRXEN_MASK >> direction)|handshake);
220:                 	}
221:                 }
222:                 
223:                 PLIB_TEMPLATE void USB_EPnAttributesClear_PIC32
224:                 (
225:                     USB_MODULE_ID index, 
226:                     uint8_t endpoint
227:                 )
228:                 {
229:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
230:                     
231:                     usb->UxEP[endpoint].w |= UxEP_EPCONDIS_MASK;
232:                     usb->UxEP[endpoint].w &= (~(UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK|UxEP_EPHSHK_MASK));
233:                 }
234:                 
235:                 PLIB_TEMPLATE void USB_EPnDirectionDisable_PIC32
236:                 (
237:                     USB_MODULE_ID index, 
238:                     uint8_t endpoint, 
239:                     int direction
240:                 )
241:                 {
242:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
243:                     usb->UxEP[endpoint].w &= (~(UxEP_EPRXEN_MASK >> direction));
244:                 }
245:                 
246:                 //******************************************************************************
247:                 /* Function :  USB_EPnControlTransferDisable_PIC32
248:                 
249:                   Summary:
250:                     Implements PIC32 variant of PLIB_USB_EPnControlTransferDisable 
251:                 
252:                   Description:
253:                     This template implements the PIC32 variant of the
254:                     PLIB_USB_EPnControlTransferDisable function.
255:                 */
256:                 
257:                 PLIB_TEMPLATE void USB_EPnControlTransferDisable_PIC32
258:                 ( 
259:                     USB_MODULE_ID index , 
260:                     uint8_t endpoint 
261:                 )
262:                 {
263:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
264:                     usb->UxEP[endpoint].UxEPbits.EPCONDIS = 1;
265:                 }
266:                 
267:                 //******************************************************************************
268:                 /* Function :  USB_EPnIsStalled_PIC32
269:                 
270:                   Summary:
271:                     Implements PIC32 variant of PLIB_USB_EPnIsStalled 
272:                 
273:                   Description:
274:                     This template implements the PIC32 variant of the PLIB_USB_EPnIsStalled 
275:                     function.
276:                 */
277:                 
278:                 PLIB_TEMPLATE bool USB_EPnIsStalled_PIC32
279:                 ( 
280:                     USB_MODULE_ID index , 
281:                     uint8_t endpoint 
282:                 )
283:                 {
284:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
285:                 	return ( usb->UxEP[endpoint].UxEPbits.EPSTALL );
286:                 }
287:                 
288:                 //******************************************************************************
289:                 /* Function :  USB_EPnStallClear_PIC32
290:                 
291:                   Summary:
292:                     Implements PIC32 variant of PLIB_USB_EPnStallClear 
293:                 
294:                   Description:
295:                     This template implements the PIC32 variant of the PLIB_USB_EPnStallClear 
296:                     function.
297:                 */
298:                 
299:                 PLIB_TEMPLATE void USB_EPnStallClear_PIC32
300:                 (
301:                     USB_MODULE_ID index , 
302:                     uint8_t endpoint 
303:                 )
304:                 {
305:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
306:                     usb->UxEP[endpoint].UxEPbits.EPSTALL = 0;
307:                 }
308:                 
309:                 
310:                 PLIB_TEMPLATE void USB_EP0HostSetup_PIC32(USB_MODULE_ID index)
311:                 {
312:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D005FC8  8C820020   LW V0, 32(A0)
313:                 	
314:                 	usb->UxEP[0].w = 0x00 ;
9D005FCC  AC4002C0   SW ZERO, 704(V0)
315:                 	
316:                     /* Set up endpoint 0 for typical host operation.
317:                      * Enable Transmit, Receive, Control Transfers, Handshake
318:                      * Disable NAK Retry and Low speed connect */
319:                     
320:                     usb->UxEP[0].w |= (UxEP0_RETRYDIS_MASK|UxEP_EPHSHK_MASK|UxEP_EPTXEN_MASK|UxEP_EPRXEN_MASK);
9D005FD0  8C4302C0   LW V1, 704(V0)
9D005FD4  3463004D   ORI V1, V1, 77
9D005FD8  AC4302C0   SW V1, 704(V0)
321:                 }
322:                 
323:                 //******************************************************************************
324:                 /* Function :  USB_ExistsEPnRxEnable_PIC32
325:                 
326:                   Summary:
327:                     Implements PIC32 variant of PLIB_USB_ExistsEPnRxEnable
328:                 
329:                   Description:
330:                     This template implements the PIC32 variant of the PLIB_USB_ExistsEPnRxEnable
331:                     function.
332:                 */
333:                 
334:                 #define PLIB_USB_ExistsEPnRxEnable PLIB_USB_ExistsEPnRxEnable
335:                 PLIB_TEMPLATE bool USB_ExistsEPnRxEnable_PIC32( USB_MODULE_ID index )
336:                 {
337:                     return true;
338:                 }
339:                 
340:                 
341:                 #endif /*_USB_EPNRXENABLEENHANCED_PIC32_H*/
342:                 
343:                 /******************************************************************************
344:                  End of File
345:                 */
346:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_ep0lowspeedconnect_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_EP0LowSpeedConnect_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EP0LowSpeedConnect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_EP0LSDirectConnectEnable
16:                          PLIB_USB_EP0LSDirectConnectDisable
17:                          PLIB_USB_ExistsEP0LowSpeedConnect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_EP0LOWSPEEDCONNECT_DEFAULT_H
48:                  #define _USB_EP0LOWSPEEDCONNECT_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_EP0LSDirectConnectEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_EP0LSDirectConnectEnable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the
60:                      PLIB_USB_EP0LSDirectConnectEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_EP0LSDirectConnectEnable_Default( USB_MODULE_ID index )
64:                  {
65:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D001C3C  8E220020   LW V0, 32(S1)
66:                     usb->UxEP[0].UxEPSET = UxEP0_LSPD_MASK;
9D001C40  24030080   ADDIU V1, ZERO, 128
9D001C44  AC4302C8   SW V1, 712(V0)
9D001C48  0B40071B   J _DRV_USBFS_HOST_Tasks_ISR::PLIB_USB_SOFEnable
9D001C4C  00000000   NOP
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_EP0LSDirectConnectDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_EP0LSDirectConnectDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the
77:                      PLIB_USB_EP0LSDirectConnectDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USB_EP0LSDirectConnectDisable_Default( USB_MODULE_ID index )
81:                  {
82:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D001C60  8E220020   LW V0, 32(S1)
9D001EA8  8E220020   LW V0, 32(S1)
83:                     usb->UxEP[0].UxEPCLR = UxEP0_LSPD_MASK;
9D001C64  24030080   ADDIU V1, ZERO, 128
9D001C68  AC4302C4   SW V1, 708(V0)
9D001EAC  24030080   ADDIU V1, ZERO, 128
9D001EB0  AC4302C4   SW V1, 708(V0)
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_ExistsEP0LowSpeedConnect_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_ExistsEP0LowSpeedConnect
91:                  
92:                    Description:
93:                      This template implements the Default variant of the
94:                      PLIB_USB_ExistsEP0LowSpeedConnect function.
95:                  */
96:                  
97:                  #define PLIB_USB_ExistsEP0LowSpeedConnect PLIB_USB_ExistsEP0LowSpeedConnect
98:                  PLIB_TEMPLATE bool USB_ExistsEP0LowSpeedConnect_Default( USB_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 
104:                 #endif /*_USB_EP0LOWSPEEDCONNECT_DEFAULT_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_bufferfreeze_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_BufferFreeze_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BufferFreeze
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_PingPongFreeze
16:                          PLIB_USB_PingPongUnfreeze
17:                          PLIB_USB_ExistsBufferFreeze
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_BUFFERFREEZE_DEFAULT_H
48:                  #define _USB_BUFFERFREEZE_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USB_PingPongFreeze_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USB_PingPongFreeze 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USB_PingPongFreeze
61:                      function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void USB_PingPongFreeze_Default( USB_MODULE_ID index )
65:                  {
66:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
67:                  	usb->UxCON.w |=  UxCON_PPBRST_MASK ;
68:                    
69:                  }
70:                  
71:                  //******************************************************************************
72:                  /* Function :  USB_PingPongUnfreeze_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_USB_PingPongUnfreeze 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the
79:                      PLIB_USB_PingPongUnfreeze function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void USB_PingPongUnfreeze_Default( USB_MODULE_ID index )
83:                  {
84:                  
85:                  	volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
86:                  	usb->UxCON.w &= ( ~ UxCON_PPBRST_MASK);
87:                      
88:                  }
89:                  
90:                  //******************************************************************************
91:                  /* Function :  USB_PingPongReset_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_USB_PingPongReset 
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_USB_PingPongReset
98:                      function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE void USB_PingPongReset_Default( USB_MODULE_ID index )
102:                 {
103:                 
104:                     volatile usb_registers_t   * usb = ((usb_registers_t *)(index));
9D001E20  8E220020   LW V0, 32(S1)
9D005FA4  8C820020   LW V0, 32(A0)
105:                     usb->UxCON.w |= UxCON_PPBRST_MASK;
9D001E24  8C440210   LW A0, 528(V0)
9D001E28  34840002   ORI A0, A0, 2
9D001E2C  AC440210   SW A0, 528(V0)
9D005FA8  8C430210   LW V1, 528(V0)
9D005FAC  34630002   ORI V1, V1, 2
9D005FB0  AC430210   SW V1, 528(V0)
106:                 	usb->UxCON.w &= ( ~ UxCON_PPBRST_MASK);
9D001E30  8C440210   LW A0, 528(V0)
9D001E34  7C040844   INS A0, ZERO, 1, 1
9D001E38  AC440210   SW A0, 528(V0)
9D005FB4  8C430210   LW V1, 528(V0)
9D005FB8  7C030844   INS V1, ZERO, 1, 1
9D005FBC  AC430210   SW V1, 528(V0)
107:                 }
108:                 
109:                 
110:                 //******************************************************************************
111:                 /* Function :  USB_ExistsBufferFreeze_Default
112:                 
113:                   Summary:
114:                     Implements Default variant of PLIB_USB_ExistsBufferFreeze
115:                 
116:                   Description:
117:                     This template implements the Default variant of the
118:                     PLIB_USB_ExistsBufferFreeze function.
119:                 */
120:                 
121:                 #define PLIB_USB_ExistsBufferFreeze PLIB_USB_ExistsBufferFreeze
122:                 PLIB_TEMPLATE bool USB_ExistsBufferFreeze_Default( USB_MODULE_ID index )
123:                 {
124:                     return true;
125:                 }
126:                 
127:                 
128:                 #endif /*_USB_BUFFERFREEZE_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_bdtbaseaddress_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_BDTBaseAddress_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BDTBaseAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_BDTBaseAddressGet
16:                          PLIB_USB_BDTBaseAddressSet
17:                          PLIB_USB_ExistsBDTBaseAddress
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_BDTBASEADDRESS_DEFAULT_H
48:                  #define _USB_BDTBASEADDRESS_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_BDTBaseAddressGet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_BDTBaseAddressGet 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the
60:                      PLIB_USB_BDTBaseAddressGet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void* USB_BDTBaseAddressGet_Default( USB_MODULE_ID index )
64:                  {
65:                      uint32_t retval;
66:                  	volatile usb_registers_t * usb = ((usb_registers_t *)(index));
67:                  	
68:                      retval = ( ( usb->UxBDTP3.BDTPTRU << 24 ) | ( usb->UxBDTP2.BDTPTRH << 16 ) | ( usb->UxBDTP1.BDTPTRL << 9 ) );
69:                  	
70:                  	return ( void * )retval;
71:                  }
72:                  
73:                  //******************************************************************************
74:                  /* Function :  USB_BDTBaseAddressSet_Default
75:                  
76:                    Summary:
77:                      Implements Default variant of PLIB_USB_BDTBaseAddressSet 
78:                  
79:                    Description:
80:                      This template implements the Default variant of the
81:                      PLIB_USB_BDTBaseAddressSet function.
82:                  */
83:                  
84:                  PLIB_TEMPLATE void USB_BDTBaseAddressSet_Default( USB_MODULE_ID index , void* address )
85:                  {
86:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
87:                  	uint32_t value = (uint32_t) address;
88:                  	usb->UxBDTP3.BDTPTRU = ( value >> 24 ) & 0xFF ;
9D005EE8  00022602   SRL A0, V0, 24
9D005EEC  A2040290   SB A0, 656(S0)
89:                  	usb->UxBDTP2.BDTPTRH = ( value >> 16 ) & 0xFF ;
9D005EF0  7C443C00   EXT A0, V0, 16, 8
9D005EF4  A2040280   SB A0, 640(S0)
90:                  	usb->UxBDTP1.BDTPTRL = ( value >> 9 ) & 0x7F;
9D005EF8  7C423240   EXT V0, V0, 9, 7
9D005EFC  92040230   LBU A0, 560(S0)
9D005F00  7C443844   INS A0, V0, 1, 7
9D005F04  A2040230   SB A0, 560(S0)
91:                  }
92:                  
93:                  //******************************************************************************
94:                  /* Function :  USB_ExistsBDTBaseAddress_Default
95:                  
96:                    Summary:
97:                      Implements Default variant of PLIB_USB_ExistsBDTBaseAddress
98:                  
99:                    Description:
100:                     This template implements the Default variant of the
101:                     PLIB_USB_ExistsBDTBaseAddress function.
102:                 */
103:                 
104:                 #define PLIB_USB_ExistsBDTBaseAddress PLIB_USB_ExistsBDTBaseAddress
105:                 PLIB_TEMPLATE bool USB_ExistsBDTBaseAddress_Default( USB_MODULE_ID index )
106:                 {
107:                     return true;
108:                 }
109:                 
110:                 
111:                 #endif /*_USB_BDTBASEADDRESS_DEFAULT_H*/
112:                 
113:                 /******************************************************************************
114:                  End of File
115:                 */
116:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_automaticsuspend_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_AutomaticSuspend_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AutomaticSuspend
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_AutoSuspendDisable
16:                          PLIB_USB_AutoSuspendEnable
17:                          PLIB_USB_ExistsAutomaticSuspend
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USB_AUTOMATICSUSPEND_DEFAULT_H
48:                  #define _USB_AUTOMATICSUSPEND_DEFAULT_H
49:                  
50:                  #include "../templates/usb_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USB_AutoSuspendDisable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USB_AutoSuspendDisable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the
60:                      PLIB_USB_AutoSuspendDisable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void USB_AutoSuspendDisable_Default( USB_MODULE_ID index )
64:                  {
65:                  	volatile usb_registers_t * usb = ((usb_registers_t *)(index));
66:                  	usb->UxCNFG1CLR =  UxCNFG1_UASUSPND_MASK ;
9D005EB4  AE0202A4   SW V0, 676(S0)
67:                  }
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USB_AutoSuspendEnable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USB_AutoSuspendEnable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the
77:                      PLIB_USB_AutoSuspendEnable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USB_AutoSuspendEnable_Default( USB_MODULE_ID index )
81:                  {
82:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
83:                  	usb->UxCNFG1SET =  UxCNFG1_UASUSPND_MASK ;
9D005EA8  AE0202A8   SW V0, 680(S0)
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USB_ExistsAutomaticSuspend_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USB_ExistsAutomaticSuspend
91:                  
92:                    Description:
93:                      This template implements the Default variant of the
94:                      PLIB_USB_ExistsAutomaticSuspend function.
95:                  */
96:                  
97:                  #define PLIB_USB_ExistsAutomaticSuspend PLIB_USB_ExistsAutomaticSuspend
98:                  PLIB_TEMPLATE bool USB_ExistsAutomaticSuspend_Default( USB_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 
104:                 #endif /*_USB_AUTOMATICSUSPEND_DEFAULT_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/usb/templates/usb_all_interrupt_default.h
1:                   /*******************************************************************************
2:                     USB Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usb_ALL_Interrupt_Default.h
6:                   
7:                     Summary:
8:                       USB PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ALL_Interrupt
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USB_AllInterruptEnable
16:                          PLIB_USB_ExistsALL_Interrupt
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USB_ALL_INTERRUPT_DEFAULT_H
47:                  #define _USB_ALL_INTERRUPT_DEFAULT_H
48:                  
49:                  #include "../templates/usb_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USB_AllInterruptEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USB_AllInterruptEnable 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the
59:                      PLIB_USB_AllInterruptEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void USB_AllInterruptEnable_Default
63:                  ( 
64:                      USB_MODULE_ID index , 
65:                      USB_INTERRUPTS usbInterruptsFlag , 
66:                      USB_ERROR_INTERRUPTS usbErrorInterruptsFlag , 
67:                      USB_OTG_INTERRUPTS otgInterruptFlag 
68:                  )
69:                  {
70:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
71:                  	usb->UxIE.w = usbInterruptsFlag;
72:                      usb->UxEIE.w = usbErrorInterruptsFlag;
73:                  	usb->UxOTGIE.w = otgInterruptFlag;
74:                  }
75:                  
76:                  //******************************************************************************
77:                  /* Function :  USB_InterruptEnableGet_Default
78:                  
79:                    Summary:
80:                      Implements Default variant of PLIB_USB_InterruptEnableGet 
81:                  
82:                    Description:
83:                      This template implements the Default variant of the
84:                      PLIB_USB_InterruptEnableGet function.
85:                  */
86:                  
87:                  PLIB_TEMPLATE USB_INTERRUPTS USB_InterruptEnableGet_Default 
88:                  (
89:                      USB_MODULE_ID index
90:                  )
91:                  {
92:                      volatile usb_registers_t * usb = ((usb_registers_t *)(index));
93:                      return (USB_INTERRUPTS)( usb->UxIE.w );
9D001B10  8E1301D0   LW S3, 464(S0)
94:                  }
95:                  
96:                  //******************************************************************************
97:                  /* Function :  USB_ExistsALL_Interrupt_Default
98:                  
99:                    Summary:
100:                     Implements Default variant of PLIB_USB_ExistsALL_Interrupt
101:                 
102:                   Description:
103:                     This template implements the Default variant of the
104:                     PLIB_USB_ExistsALL_Interrupt function.
105:                 */
106:                 
107:                 #define PLIB_USB_ExistsALL_Interrupt PLIB_USB_ExistsALL_Interrupt
108:                 PLIB_TEMPLATE bool USB_ExistsALL_Interrupt_Default( USB_MODULE_ID index )
109:                 {
110:                     return true;
111:                 }
112:                 
113:                 
114:                 #endif /*_USB_ALL_INTERRUPT_DEFAULT_H*/
115:                 
116:                 /******************************************************************************
117:                  End of File
118:                 */
119:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/tmr/templates/tmr_prescale_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Prescale_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Prescale
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_PrescaleSelect
16:                          PLIB_TMR_PrescaleGet
17:                          PLIB_TMR_ExistsPrescale
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_PRESCALE_DEFAULT_H
48:                  #define _TMR_PRESCALE_DEFAULT_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  TMR_PrescaleSelect_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_TMR_PrescaleSelect
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_TMR_PrescaleSelect function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void TMR_PrescaleSelect_Default( TMR_MODULE_ID index , TMR_PRESCALE prescale )
63:                  {
64:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
65:                      
66:                      if(TMR_ID_1 == index)
9D0077AC  3C02BF80   LUI V0, -16512
9D0077B0  24420600   ADDIU V0, V0, 1536
9D0077B4  14820029   BNE A0, V0, _DRV_TMR_ClockPrescaleSet::PLIB_TMR_PrescaleSelect
9D0077B8  00000000   NOP
67:                      {
68:                          switch(prescale)
9D0077BC  24020003   ADDIU V0, ZERO, 3
9D0077C0  10A20014   BEQ A1, V0, _DRV_TMR_ClockPrescaleSet::PLIB_TMR_PrescaleSelect
9D0077C4  00000000   NOP
9D0077C8  2CA20004   SLTIU V0, A1, 4
9D0077CC  10400005   BEQ V0, ZERO, _DRV_TMR_ClockPrescaleSet::PLIB_TMR_PrescaleSelect
9D0077D0  24020006   ADDIU V0, ZERO, 6
9D0077D4  10A0000A   BEQ A1, ZERO, _DRV_TMR_ClockPrescaleSet::PLIB_TMR_PrescaleSelect
9D0077D8  00000000   NOP
9D0077E4  10A20011   BEQ A1, V0, _DRV_TMR_ClockPrescaleSet::PLIB_TMR_PrescaleSelect
9D0077E8  00000000   NOP
9D0077EC  24020007   ADDIU V0, ZERO, 7
9D0077F0  10A20014   BEQ A1, V0, _DRV_TMR_ClockPrescaleSet::PLIB_TMR_PrescaleSelect
9D0077F4  00000000   NOP
69:                          {
70:                              case TMR_PRESCALE_VALUE_1:  tmr->TxCON.TCKPS = 0;
9D007800  94820000   LHU V0, 0(A0)
9D007804  7C023104   INS V0, ZERO, 4, 3
9D007808  A4820000   SH V0, 0(A0)
71:                                                          break;
72:                              case TMR_PRESCALE_VALUE_8:  tmr->TxCON.TCKPS = 1;
9D007814  94820000   LHU V0, 0(A0)
9D007818  24030001   ADDIU V1, ZERO, 1
9D00781C  7C623104   INS V0, V1, 4, 3
9D007820  A4820000   SH V0, 0(A0)
73:                                                          break;
74:                              case TMR_PRESCALE_VALUE_64: tmr->TxCON.TCKPS = 2;
9D00782C  94820000   LHU V0, 0(A0)
9D007830  24030002   ADDIU V1, ZERO, 2
9D007834  7C623104   INS V0, V1, 4, 3
9D007838  A4820000   SH V0, 0(A0)
75:                                                          break;
76:                              case TMR_PRESCALE_VALUE_256: tmr->TxCON.TCKPS = 3;
9D007844  94820000   LHU V0, 0(A0)
9D007848  24030003   ADDIU V1, ZERO, 3
9D00784C  7C623104   INS V0, V1, 4, 3
9D007850  A4820000   SH V0, 0(A0)
77:                                                          break;
78:                              default: PLIB_ASSERT(false, " Given Prescale value is not supported for Timer1");
79:                          }
80:                      }
81:                      else
82:                      {
83:                          tmr->TxCON.TCKPS = prescale;
9D00307C  94440800   LHU A0, 2048(V0)
9D003080  7C043104   INS A0, ZERO, 4, 3
9D003084  A4440800   SH A0, 2048(V0)
9D00785C  94820000   LHU V0, 0(A0)
9D007860  7CA23104   INS V0, A1, 4, 3
9D007864  A4820000   SH V0, 0(A0)
84:                      }
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  TMR_PrescaleGet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_TMR_PrescaleGet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_TMR_PrescaleGet function.
96:                  */
97:                  
98:                  PLIB_TEMPLATE uint16_t TMR_PrescaleGet_Default( TMR_MODULE_ID index )
99:                  {
100:                     tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
101:                     uint8_t temp_prescaler;
102:                     uint16_t preScaler;
103:                 
104:                     temp_prescaler = tmr->TxCON.TCKPS;
9D0073E4  8C830000   LW V1, 0(A0)
105:                                           
106:                     if(TMR_ID_1 == index)
9D0073E8  3C05BF80   LUI A1, -16512
9D0073EC  24A50600   ADDIU A1, A1, 1536
9D0073F0  14850010   BNE A0, A1, DRV_TMR_CounterFrequencyGet::PLIB_TMR_PrescaleGet
9D0073F4  7C631100   EXT V1, V1, 4, 3
107:                     {
108:                         /* 1, 8, 64, 256 */
109:                         switch(temp_prescaler)
9D0073F8  24040001   ADDIU A0, ZERO, 1
9D0073FC  50640013   BEQL V1, A0, 0x9D00744C
9D007400  24030008   ADDIU V1, ZERO, 8
9D007404  10600007   BEQ V1, ZERO, 0x9D007424
9D007408  24040002   ADDIU A0, ZERO, 2
9D00740C  10640007   BEQ V1, A0, 0x9D00742C
9D007410  24040100   ADDIU A0, ZERO, 256
110:                         {
111:                             case 0x00u: preScaler = 1u;
9D007424  0B401D13   J 0x9D00744C
9D007428  24030001   ADDIU V1, ZERO, 1
112:                                         break;
113:                             case 0x01u: preScaler = 8u;
114:                                         break;
115:                             case 0x02u: preScaler = 64u;
9D00742C  0B401D13   J 0x9D00744C
9D007430  24030040   ADDIU V1, ZERO, 64
116:                                         break;
117:                             case 0x03u: preScaler = 256u;
118:                                         break;
119:                             default:    preScaler = 0u;
9D007414  38630003   XORI V1, V1, 3
9D007418  0003200B   MOVN A0, ZERO, V1
9D00741C  0B401D13   J 0x9D00744C
9D007420  00801821   ADDU V1, A0, ZERO
120:                         }
121:                     }
122:                     else
123:                     {
124:                         /* 1, 2, 4, 8, 16, 32, 64, 256 */
125:                         if ( temp_prescaler == 7u )
126:                         {
127:                             temp_prescaler++;
9D007434  38650007   XORI A1, V1, 7
9D007438  24040008   ADDIU A0, ZERO, 8
9D00743C  0085180A   MOVZ V1, A0, A1
128:                         }
129:                         preScaler = (uint16_t)(0x01u << temp_prescaler);
9D007440  24040001   ADDIU A0, ZERO, 1
9D007444  00641804   SLLV V1, A0, V1
9D007448  3063FFFF   ANDI V1, V1, -1
130:                     }
131:                     return preScaler;
132:                 
133:                 }
134:                 
135:                 
136:                 //******************************************************************************
137:                 /* Function :  TMR_ExistsPrescale_Default
138:                 
139:                   Summary:
140:                     Implements Default variant of PLIB_TMR_ExistsPrescale
141:                 
142:                   Description:
143:                     This template implements the Default variant of the PLIB_TMR_ExistsPrescale function.
144:                 */
145:                 
146:                 #define PLIB_TMR_ExistsPrescale PLIB_TMR_ExistsPrescale
147:                 PLIB_TEMPLATE bool TMR_ExistsPrescale_Default( TMR_MODULE_ID index )
148:                 {
149:                     return true;
150:                 }
151:                 
152:                 
153:                 #endif /*_TMR_PRESCALE_DEFAULT_H*/
154:                 
155:                 /******************************************************************************
156:                  End of File
157:                 */
158:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/tmr/templates/tmr_period32bit_in16bitregister_pic32.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Period32Bit_In16BitRegister_pic32.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Period32Bit
13:                      and its Variant : In16BitRegister_pic32
14:                      For following APIs :
15:                          PLIB_TMR_Period32BitSet
16:                          PLIB_TMR_Period32BitGet
17:                          PLIB_TMR_ExistsPeriod32Bit
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_PERIOD32BIT_IN16BITREGISTER_PIC32_H
48:                  #define _TMR_PERIOD32BIT_IN16BITREGISTER_PIC32_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  TMR_Period32BitSet_In16BitRegister_pic32
54:                  
55:                    Summary:
56:                      Implements In16BitRegister_pic32 variant of PLIB_TMR_Period32BitSet 
57:                  
58:                    Description:
59:                      This template implements the In16BitRegister_pic32 variant of the PLIB_TMR_Period32BitSet function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void TMR_Period32BitSet_In16BitRegister_pic32( TMR_MODULE_ID index , uint32_t period )
63:                  {
64:                      tmr_registers_t volatile * tmrX = ((tmr_registers_t *)(index));
65:                      tmr_registers_t volatile * tmrY = ((tmr_registers_t *)(index + 0x0200u));
66:                  
67:                  	if( _TMR_MODULE_ID_IS_EVEN(index) )
9D006374  7C850240   EXT A1, A0, 9, 1
9D006378  14A0000B   BNE A1, ZERO, 0x9D0063A8
9D00637C  3065FFFF   ANDI A1, V1, -1
68:                  	{
69:                          /* Lower 16 bits to Even Timer and higher 16 bits to Odd Timer */
70:                          tmrX->PRx = ( period & 0xFFFFu );
9D006380  AC850020   SW A1, 32(A0)
71:                          tmrY->PRx = ( (period >> 16u) & 0xFFFFu );
9D006384  00031C02   SRL V1, V1, 16
9D006388  AC830220   SW V1, 544(A0)
9D00638C  0B4018EA   J 0x9D0063A8
9D006390  00000000   NOP
72:                  	}
73:                  	else
74:                  	{
75:                  		PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_Period32BitSet");
76:                  	}
77:                  }
78:                  
79:                  
80:                  //******************************************************************************
81:                  /* Function :  TMR_Period32BitGet_In16BitRegister_pic32
82:                  
83:                    Summary:
84:                      Implements In16BitRegister_pic32 variant of PLIB_TMR_Period32BitGet 
85:                  
86:                    Description:
87:                      This template implements the In16BitRegister_pic32 variant of the PLIB_TMR_Period32BitGet function.
88:                  */
89:                  
90:                  PLIB_TEMPLATE uint32_t TMR_Period32BitGet_In16BitRegister_pic32( TMR_MODULE_ID index )
91:                  {
92:                      tmr_registers_t volatile * tmrX = ((tmr_registers_t *)(index));
93:                      tmr_registers_t volatile * tmrY = ((tmr_registers_t *)(index + 0x0200u));
94:                      uint32_t val1 = 0u, val2 = 0u;
95:                  
96:                  	if( _TMR_MODULE_ID_IS_EVEN(index) )
97:                  	{
98:                          val1 = (uint32_t)(tmrX->PRx);
99:                          val2 = (uint32_t)(tmrY->PRx << 16u);
100:                 	}
101:                 	else
102:                 	{
103:                 		PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_Period32BitGet");
104:                 	}	
105:                 
106:                     return ( val1 | val2 );
107:                 }
108:                 
109:                 
110:                 //******************************************************************************
111:                 /* Function :  TMR_ExistsPeriod32Bit_In16BitRegister_pic32
112:                 
113:                   Summary:
114:                     Implements In16BitRegister_pic32 variant of PLIB_TMR_ExistsPeriod32Bit
115:                 
116:                   Description:
117:                     This template implements the In16BitRegister_pic32 variant of the PLIB_TMR_ExistsPeriod32Bit function.
118:                 */
119:                 
120:                 #define PLIB_TMR_ExistsPeriod32Bit PLIB_TMR_ExistsPeriod32Bit
121:                 PLIB_TEMPLATE bool TMR_ExistsPeriod32Bit_In16BitRegister_pic32( TMR_MODULE_ID index )
122:                 {
123:                     if (TMR_ID_1 == index)
124:                     {
125:                         return false;
126:                     }
127:                     else
128:                     {
129:                         return true;
130:                     }
131:                 }
132:                 
133:                 
134:                 #endif /*_TMR_PERIOD32BIT_IN16BITREGISTER_PIC32_H*/
135:                 
136:                 /******************************************************************************
137:                  End of File
138:                 */
139:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/tmr/templates/tmr_period16bit_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Period16Bit_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Period16Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Period16BitSet
16:                          PLIB_TMR_Period16BitGet
17:                          PLIB_TMR_ExistsPeriod16Bit
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_PERIOD16BIT_Default_H
48:                  #define _TMR_PERIOD16BIT_Default_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_Period16BitSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_TMR_Period16BitSet
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_TMR_Period16BitSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_Period16BitSet_Default( TMR_MODULE_ID index , uint16_t period )
64:                  {
65:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
9D006398  8C63000C   LW V1, 12(V1)
66:                      tmr->PRx = period;
9D003094  2404027A   ADDIU A0, ZERO, 634
9D003098  AC440820   SW A0, 2080(V0)
9D0063A0  3231FFFF   ANDI S1, S1, -1
9D0063A4  AC710020   SW S1, 32(V1)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  TMR_Period16BitGet_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_TMR_Period16BitGet
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_TMR_Period16BitGet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint16_t TMR_Period16BitGet_Default( TMR_MODULE_ID index )
81:                  {
82:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
83:                      return (uint16_t)tmr->PRx;
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  TMR_ExistsPeriod16Bit_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_TMR_ExistsPeriod16Bit
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_TMR_ExistsPeriod16Bit function.
95:                  */
96:                  
97:                  #define PLIB_TMR_ExistsPeriod16Bit PLIB_TMR_ExistsPeriod16Bit
98:                  PLIB_TEMPLATE bool TMR_ExistsPeriod16Bit_Default( TMR_MODULE_ID index )
99:                  {
100:                     return true;
101:                 }
102:                 
103:                 
104:                 #endif /*_TMR_PERIOD16BIT_Default_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/tmr/templates/tmr_mode32bit_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Mode32Bit_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Mode32Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Mode32BitEnable
16:                          PLIB_TMR_ExistsMode32Bit
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _TMR_MODE32BIT_DEFAULT_H
47:                  #define _TMR_MODE32BIT_DEFAULT_H
48:                  
49:                  #include "tmr_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  TMR_Mode32BitEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_TMR_Mode32BitEnable 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_TMR_Mode32BitEnable function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void TMR_Mode32BitEnable_Default( TMR_MODULE_ID index )
62:                  {
63:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
64:                      
65:                      if ( _TMR_MODULE_ID_IS_EVEN(index) )
66:                      {
67:                          tmr->TxCONSET = TxCON_T32_MASK;
9D004AAC  24020008   ADDIU V0, ZERO, 8
9D004AB0  AE020008   SW V0, 8(S0)
68:                      }
69:                      else
70:                      {
71:                          PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_Mode32BitEnable");
72:                      }
73:                  }
74:                  
75:                  
76:                  //******************************************************************************
77:                  /* Function :  TMR_ExistsMode32Bit_Default
78:                  
79:                    Summary:
80:                      Implements Default variant of PLIB_TMR_ExistsMode32Bit
81:                  
82:                    Description:
83:                      This template implements the Default variant of the PLIB_TMR_ExistsMode32Bit function.
84:                  */
85:                  
86:                  #define PLIB_TMR_ExistsMode32Bit PLIB_TMR_ExistsMode32Bit
87:                  PLIB_TEMPLATE bool TMR_ExistsMode32Bit_Default( TMR_MODULE_ID index )
88:                  {
89:                      if ( _TMR_MODULE_ID_IS_EVEN(index) )
9D004AA0  7E020240   EXT V0, S0, 9, 1
90:                      {
91:                          return true;
92:                      }
93:                      else
94:                      {
95:                          PLIB_ASSERT(false, "This Timer instance does not support Mode32BitControl feature");
96:                          return false;
97:                      }
98:                  }
99:                  
100:                 
101:                 #endif /*_TMR_MODE32BIT_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/tmr/templates/tmr_mode16bit_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Mode16Bit_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Mode16Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Mode16BitEnable
16:                          PLIB_TMR_ExistsMode16Bit
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _TMR_MODE16BIT_DEFAULT_H
47:                  #define _TMR_MODE16BIT_DEFAULT_H
48:                  
49:                  #include "tmr_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  TMR_Mode16BitEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_TMR_Mode16BitEnable 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_TMR_Mode16BitEnable function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void TMR_Mode16BitEnable_Default( TMR_MODULE_ID index )
62:                  {
63:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
64:                      
65:                      if (_TMR_MODULE_ID_IS_EVEN(index))
9D004A7C  7E020240   EXT V0, S0, 9, 1
9D004A80  54400019   BNEL V0, ZERO, DRV_TMR_Initialize::_DRV_TMR_InstanceSetup
9D004A84  3C02BF80   LUI V0, -16512
66:                      {
67:                          tmr->TxCONCLR = TxCON_T32_MASK;
9D003088  24040008   ADDIU A0, ZERO, 8
9D00308C  AC440804   SW A0, 2052(V0)
9D004A88  24020008   ADDIU V0, ZERO, 8
9D004A8C  AE020004   SW V0, 4(S0)
68:                      }
69:                      else
70:                      {
71:                          PLIB_ASSERT(false, "Other timers are by default in 16 bit mode");
72:                      }
73:                  }
74:                  
75:                  
76:                  
77:                  //******************************************************************************
78:                  /* Function :  TMR_ExistsMode16Bit_Default
79:                  
80:                    Summary:
81:                      Implements Default variant of PLIB_TMR_ExistsMode16Bit
82:                  
83:                    Description:
84:                      This template implements the Default variant of the PLIB_TMR_ExistsMode16Bit function.
85:                  */
86:                  
87:                  #define PLIB_TMR_ExistsMode16Bit PLIB_TMR_ExistsMode16Bit
88:                  PLIB_TEMPLATE bool TMR_ExistsMode16Bit_Default( TMR_MODULE_ID index )
89:                  {
90:                      /* 16 bit mode always exists */
91:                      return true;
92:                  }
93:                  
94:                  
95:                  #endif /*_TMR_MODE16BIT_DEFAULT_H*/
96:                  
97:                  /******************************************************************************
98:                   End of File
99:                  */
100:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/tmr/templates/tmr_enablecontrol_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_Start
16:                          PLIB_TMR_Stop
17:                          PLIB_TMR_ExistsEnableControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_ENABLECONTROL_DEFAULT_H
48:                  #define _TMR_ENABLECONTROL_DEFAULT_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_Start_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_TMR_Start 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_TMR_Start function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_Start_Default( TMR_MODULE_ID index )
64:                  {
65:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
9D008D34  8C42000C   LW V0, 12(V0)
66:                  
67:                      tmr->TxCONSET = TxCON_ON_MASK;
9D0032D4  34038000   ORI V1, ZERO, -32768
9D0032D8  3C02BF80   LUI V0, -16512
9D0032DC  AC430808   SW V1, 2056(V0)
9D0032F4  0B400CB6   J 0x9D0032D8
9D0032F8  34038000   ORI V1, ZERO, -32768
9D008D38  34038000   ORI V1, ZERO, -32768
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  TMR_Stop_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_TMR_Stop 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the PLIB_TMR_Stop function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void TMR_Stop_Default( TMR_MODULE_ID index )
82:                  {
83:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
9D009288  8C42000C   LW V0, 12(V0)
84:                  
85:                      tmr->TxCONCLR = TxCON_ON_MASK;
9D00928C  34038000   ORI V1, ZERO, -32768
9D009290  AC430004   SW V1, 4(V0)
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  TMR_ExistsEnableControl_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_TMR_ExistsEnableControl
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_TMR_ExistsEnableControl function.
97:                  */
98:                  
99:                  #define PLIB_TMR_ExistsEnableControl PLIB_TMR_ExistsEnableControl
100:                 PLIB_TEMPLATE bool TMR_ExistsEnableControl_Default( TMR_MODULE_ID index )
101:                 {
102:                     return true;
103:                 }
104:                 
105:                 
106:                 #endif /*_TMR_ENABLECONTROL_DEFAULT_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/tmr/templates/tmr_counterasyncwritecontrol_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_CounterAsyncWriteControl_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CounterAsyncWriteControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_CounterAsyncWriteEnable
16:                          PLIB_TMR_CounterAsyncWriteDisable
17:                          PLIB_TMR_ExistsCounterAsyncWriteControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_COUNTERASYNCWRITECONTROL_DEFAULT_H
48:                  #define _TMR_COUNTERASYNCWRITECONTROL_DEFAULT_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  TMR_CounterAsyncWriteEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_TMR_CounterAsyncWriteEnable
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_TMR_CounterAsyncWriteEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void TMR_CounterAsyncWriteEnable_Default( TMR_MODULE_ID index )
63:                  {
64:                      tmr1_registers_t volatile * tmr = ((tmr1_registers_t *)(index));
65:                      
66:                      if(TMR_ID_1 == index)
67:                      {
68:                          tmr->TxCONCLR = TxCON_TWDIS_MASK; 
9D004AC8  3C02BF80   LUI V0, -16512
9D004ACC  AC430604   SW V1, 1540(V0)
69:                      }
70:                      else
71:                      {
72:                          PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_CounterAsyncWriteEnable");
73:                      }
74:                  }
75:                  
76:                  
77:                  //******************************************************************************
78:                  /* Function :  TMR_CounterAsyncWriteDisable_Default
79:                  
80:                    Summary:
81:                      Implements Default variant of PLIB_TMR_CounterAsyncWriteDisable
82:                  
83:                    Description:
84:                      This template implements the Default variant of the PLIB_TMR_CounterAsyncWriteDisable function.
85:                  */
86:                  
87:                  PLIB_TEMPLATE void TMR_CounterAsyncWriteDisable_Default( TMR_MODULE_ID index )
88:                  {
89:                      tmr1_registers_t volatile * tmr = ((tmr1_registers_t *)(index));
90:                      
91:                      if(TMR_ID_1 == index)
92:                      {
93:                          tmr->TxCONSET = TxCON_TWDIS_MASK;
9D004AD8  3C02BF80   LUI V0, -16512
9D004ADC  AC430608   SW V1, 1544(V0)
94:                      }
95:                      else
96:                      {
97:                          PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_CounterAsyncWriteDisable");
98:                      }
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  TMR_ExistsCounterAsyncWriteControl_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_TMR_ExistsCounterAsyncWriteControl
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_TMR_ExistsCounterAsyncWriteControl function.
110:                 */
111:                 
112:                 #define PLIB_TMR_ExistsCounterAsyncWriteControl PLIB_TMR_ExistsCounterAsyncWriteControl
113:                 PLIB_TEMPLATE bool TMR_ExistsCounterAsyncWriteControl_Default( TMR_MODULE_ID index )
114:                 {
115:                     if(TMR_ID_1 == index)
116:                     {
117:                         return true;
118:                     }
119:                     else
120:                     {
121:                         PLIB_ASSERT(false, "This Timer instance does not support CounterAsyncWrite feature");
122:                         return false;
123:                     }
124:                 }
125:                 
126:                 
127:                 #endif /*_TMR_COUNTERASYNCWRITECONTROL_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/tmr/templates/tmr_counter16bit_in16bitregister.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_Counter16Bit_In16BitRegister.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Counter16Bit
13:                      and its Variant : In16BitRegister
14:                      For following APIs :
15:                          PLIB_TMR_Counter16BitSet
16:                          PLIB_TMR_Counter16BitGet
17:                          PLIB_TMR_Counter16BitClear
18:                          PLIB_TMR_ExistsCounter16Bit
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _TMR_COUNTER16BIT_IN16BITREGISTER_H
49:                  #define _TMR_COUNTER16BIT_IN16BITREGISTER_H
50:                  
51:                  #include "tmr_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  TMR_Counter16BitSet_In16BitRegister
55:                  
56:                    Summary:
57:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitSet
58:                  
59:                    Description:
60:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void TMR_Counter16BitSet_In16BitRegister( TMR_MODULE_ID index , uint16_t value )
64:                  {
65:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
66:                      
67:                      tmr->TMRx = value;
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  TMR_Counter16BitGet_In16BitRegister
73:                  
74:                    Summary:
75:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitGet
76:                  
77:                    Description:
78:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitGet function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE uint16_t TMR_Counter16BitGet_In16BitRegister( TMR_MODULE_ID index )
82:                  {
83:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
84:                  
85:                      return (uint16_t)tmr->TMRx;
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  TMR_Counter16BitClear_In16BitRegister
91:                  
92:                    Summary:
93:                      Implements In16BitRegister variant of PLIB_TMR_Counter16BitClear
94:                  
95:                    Description:
96:                      This template implements the In16BitRegister variant of the PLIB_TMR_Counter16BitClear function.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void TMR_Counter16BitClear_In16BitRegister( TMR_MODULE_ID index )
100:                 {
101:                     tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
102:                     
103:                     tmr->TMRx = 0u;
9D003090  AC400810   SW ZERO, 2064(V0)
104:                 }
105:                 
106:                 
107:                 //******************************************************************************
108:                 /* Function :  TMR_ExistsCounter16Bit_In16BitRegister
109:                 
110:                   Summary:
111:                     Implements In16BitRegister variant of PLIB_TMR_ExistsCounter16Bit
112:                 
113:                   Description:
114:                     This template implements the In16BitRegister variant of the PLIB_TMR_ExistsCounter16Bit function.
115:                 */
116:                 
117:                 #define PLIB_TMR_ExistsCounter16Bit PLIB_TMR_ExistsCounter16Bit
118:                 PLIB_TEMPLATE bool TMR_ExistsCounter16Bit_In16BitRegister( TMR_MODULE_ID index )
119:                 {
120:                     return true;
121:                 }
122:                 
123:                 
124:                 #endif /*_TMR_COUNTER16BIT_IN16BITREGISTER_H*/
125:                 
126:                 /******************************************************************************
127:                  End of File
128:                 */
129:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/tmr/templates/tmr_clocksourcesync_inverted.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_ClockSourceSync_Inverted.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ClockSourceSync
13:                      and its Variant : Inverted
14:                      For following APIs :
15:                          PLIB_TMR_ClockSourceExternalSyncEnable
16:                          PLIB_TMR_ClockSourceExternalSyncDisable
17:                          PLIB_TMR_ExistsClockSourceSync
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _TMR_CLOCKSOURCESYNC_INVERTED_H
48:                  #define _TMR_CLOCKSOURCESYNC_INVERTED_H
49:                  
50:                  #include "tmr_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  TMR_ClockSourceExternalSyncEnable_Inverted
54:                  
55:                    Summary:
56:                      Implements Inverted variant of PLIB_TMR_ClockSourceExternalSyncEnable 
57:                  
58:                    Description:
59:                      This template implements the Inverted variant of the PLIB_TMR_ClockSourceExternalSyncEnable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void TMR_ClockSourceExternalSyncEnable_Inverted( TMR_MODULE_ID index )
63:                  {
64:                      tmr1_registers_t volatile * tmr = ((tmr1_registers_t *)(index));
65:                  
66:                      /* This feature is present in Timer 1 only */
67:                      if(TMR_ID_1 == index)
68:                      {
69:                          tmr->TxCONSET = TxCON_TSYNC_MASK; 
9D006AF0  0B401AD5   J _DRV_TMR_ClockSourceSet::PLIB_TMR_ClockSourceExternalSyncEnable
9D006AF4  24030004   ADDIU V1, ZERO, 4
9D006B54  3C02BF80   LUI V0, -16512
9D006B58  AC430608   SW V1, 1544(V0)
70:                      }
71:                      else
72:                      {
73:                          PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_ClockSourceExternalSyncEnable");
74:                      }
75:                  }
76:                  
77:                  
78:                  //******************************************************************************
79:                  /* Function :  TMR_ClockSourceExternalSyncDisable_Inverted
80:                  
81:                    Summary:
82:                      Implements Inverted variant of PLIB_TMR_ClockSourceExternalSyncDisable 
83:                  
84:                    Description:
85:                      This template implements the Inverted variant of the PLIB_TMR_ClockSourceExternalSyncDisable function.
86:                  */
87:                  
88:                  PLIB_TEMPLATE void TMR_ClockSourceExternalSyncDisable_Inverted( TMR_MODULE_ID index )
89:                  {
90:                      tmr1_registers_t volatile * tmr = ((tmr1_registers_t *)(index));
91:                  
92:                      /* This feature is present in Timer 1 only */
93:                      if(TMR_ID_1 == index)
94:                      {
95:                          tmr->TxCONCLR = TxCON_TSYNC_MASK; 
9D006B4C  0B401AD9   J _DRV_TMR_ClockSourceSet::PLIB_TMR_ClockSourceExternalSyncDisable
9D006B50  24030004   ADDIU V1, ZERO, 4
9D006B64  3C02BF80   LUI V0, -16512
9D006B68  AC430604   SW V1, 1540(V0)
96:                      }
97:                      else
98:                      {
99:                          PLIB_ASSERT(false, "This Timer instance does not support PLIB_TMR_ClockSourceExternalSyncEnable");
100:                     }
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  TMR_ExistsClockSourceSync_Inverted
106:                 
107:                   Summary:
108:                     Implements Inverted variant of PLIB_TMR_ExistsClockSourceSync
109:                 
110:                   Description:
111:                     This template implements the Inverted variant of the PLIB_TMR_ExistsClockSourceSync function.
112:                 */
113:                 
114:                 #define PLIB_TMR_ExistsClockSourceSync PLIB_TMR_ExistsClockSourceSync
115:                 PLIB_TEMPLATE bool TMR_ExistsClockSourceSync_Inverted( TMR_MODULE_ID index )
116:                 {
117:                     if(TMR_ID_1 == index)
118:                     {
119:                         return true; 
120:                     }
121:                     else
122:                     {
123:                         return false;
124:                     } 
125:                 }
126:                 
127:                 
128:                 #endif /*_TMR_CLOCKSOURCESYNC_INVERTED_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/tmr/templates/tmr_clocksource_default.h
1:                   /*******************************************************************************
2:                     TMR Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       tmr_ClockSource_Default.h
6:                   
7:                     Summary:
8:                       TMR PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ClockSource
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_TMR_ClockSourceSelect
16:                          PLIB_TMR_ExistsClockSource
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _TMR_CLOCKSOURCE_DEFAULT_H
47:                  #define _TMR_CLOCKSOURCE_DEFAULT_H
48:                  
49:                  #include "tmr_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  TMR_ClockSourceSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_TMR_ClockSourceSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_TMR_ClockSourceSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void TMR_ClockSourceSelect_Default( TMR_MODULE_ID index , TMR_CLOCK_SOURCE source )
62:                  {
63:                      tmr_registers_t volatile * tmr = ((tmr_registers_t *)(index));
64:                  
65:                      tmr->TxCON.TCS = source;
9D00306C  3C02BF80   LUI V0, -16512
9D003070  94440800   LHU A0, 2048(V0)
9D003074  7C040844   INS A0, ZERO, 1, 1
9D003078  A4440800   SH A0, 2048(V0)
9D006A94  94820000   LHU V0, 0(A0)
9D006A98  7C020844   INS V0, ZERO, 1, 1
9D006A9C  A4820000   SH V0, 0(A0)
9D006AC4  3C02BF80   LUI V0, -16512
9D006AC8  94430600   LHU V1, 1536(V0)
9D006ACC  24040001   ADDIU A0, ZERO, 1
9D006AD0  7C830844   INS V1, A0, 1, 1
9D006AD4  A4430600   SH V1, 1536(V0)
9D006B00  94820000   LHU V0, 0(A0)
9D006B04  7C620844   INS V0, V1, 1, 1
9D006B08  A4820000   SH V0, 0(A0)
9D006B20  3C02BF80   LUI V0, -16512
9D006B24  94430600   LHU V1, 1536(V0)
9D006B28  24040001   ADDIU A0, ZERO, 1
9D006B2C  7C830844   INS V1, A0, 1, 1
9D006B30  A4430600   SH V1, 1536(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  TMR_ExistsClockSource_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_TMR_ExistsClockSource
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_TMR_ExistsClockSource function.
77:                  */
78:                  
79:                  #define PLIB_TMR_ExistsClockSource PLIB_TMR_ExistsClockSource
80:                  PLIB_TEMPLATE bool TMR_ExistsClockSource_Default( TMR_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_TMR_CLOCKSOURCE_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/ports/templates/ports_remapoutput_pic32_2.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_RemapOutput_PIC32_2.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : RemapOutput
13:                      and its Variant : PIC32_2
14:                      For following APIs :
15:                          PLIB_PORTS_RemapOutput
16:                          PLIB_PORTS_ExistsRemapOutput
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_REMAPOUTPUT_PIC32_2_H
47:                  #define _PORTS_REMAPOUTPUT_PIC32_2_H
48:                  
49:                  
50:                  //******************************************************************************
51:                  /* Function :  PORTS_RemapOutput_PIC32_2
52:                  
53:                    Summary:
54:                      Implements PIC32_2 variant of PLIB_PORTS_RemapOutput 
55:                  
56:                    Description:
57:                      This template implements the PIC32_2 variant of the PLIB_PORTS_RemapOutput function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void PORTS_RemapOutput_PIC32_2( PORTS_MODULE_ID      index , PORTS_REMAP_OUTPUT_FUNCTION outputFunction , PORTS_REMAP_OUTPUT_PIN      remapOutputPin )
61:                  {
62:                      *(&RPA0R + remapOutputPin) = ( ( *((SFR_TYPE *)(&RPA0R  + remapOutputPin)) ) & ~(_RPA0R_RPA0R_MASK) ) | ( (_RPA0R_RPA0R_MASK) & ((outputFunction)<<(_RPA0R_RPA0R_POSITION)) );
9D007C24  3C02BF81   LUI V0, -16511
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  PORTS_ExistsRemapOutput_PIC32_2
68:                  
69:                    Summary:
70:                      Implements PIC32_2 variant of PLIB_PORTS_ExistsRemapOutput
71:                  
72:                    Description:
73:                      This template implements the PIC32_2 variant of the PLIB_PORTS_ExistsRemapOutput function.
74:                  */
75:                  
76:                  #define PLIB_PORTS_ExistsRemapOutput PLIB_PORTS_ExistsRemapOutput
77:                  PLIB_TEMPLATE bool PORTS_ExistsRemapOutput_PIC32_2( PORTS_MODULE_ID index )
78:                  {
79:                      return true;
80:                  }
81:                  
82:                  
83:                  #endif /*_PORTS_REMAPOUTPUT_PIC32_2_H*/
84:                  
85:                  /******************************************************************************
86:                   End of File
87:                  */
88:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/ports/templates/ports_portswrite_mcu32_pps.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsWrite_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsWrite
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinWrite
16:                          PLIB_PORTS_PinSet
17:                          PLIB_PORTS_PinClear
18:                          PLIB_PORTS_PinToggle
19:                          PLIB_PORTS_Write
20:                          PLIB_PORTS_Set
21:                          PLIB_PORTS_Toggle
22:                          PLIB_PORTS_Clear
23:                          PLIB_PORTS_ExistsPortsWrite
24:                  
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _PORTS_PORTSWRITE_MCU32_PPS_H
54:                  #define _PORTS_PORTSWRITE_MCU32_PPS_H
55:                  
56:                  
57:                  //******************************************************************************
58:                  /* Function :  PORTS_PinWrite_MCU32_PPS
59:                  
60:                    Summary:
61:                      Implements MCU32_PPS variant of PLIB_PORTS_PinWrite 
62:                  
63:                    Description:
64:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinWrite function.
65:                  */
66:                  
67:                  PLIB_TEMPLATE void PORTS_PinWrite_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos , bool            value )
68:                  {
69:                      /* Atomic Implementation */
70:                      if(value == true)
9D003238  304200FF   ANDI V0, V0, 255
9D00323C  10400006   BEQ V0, ZERO, APP_Initialize::PLIB_PORTS_PinWrite
9D003240  24030010   ADDIU V1, ZERO, 16
9D004314  304200FF   ANDI V0, V0, 255
9D004318  10400006   BEQ V0, ZERO, PLIB_PORTS_PinWrite
9D00431C  24030010   ADDIU V1, ZERO, 16
71:                      {
72:                          *(&LATBSET + (channel - 1) * 0x40) = 1<<bitPos;
9D003244  3C02BF88   LUI V0, -16504
9D003248  24426138   ADDIU V0, V0, 24888
9D00324C  AC43FF00   SW V1, -256(V0)
9D004320  3C02BF88   LUI V0, -16504
9D004324  24426138   ADDIU V0, V0, 24888
9D004328  AC43FF00   SW V1, -256(V0)
73:                      }
74:                      else
75:                      {
76:                          *(&LATBCLR + (channel - 1) * 0x40) = 1<<bitPos;
9D003258  3C02BF88   LUI V0, -16504
9D00325C  24426134   ADDIU V0, V0, 24884
9D003260  AC43FF00   SW V1, -256(V0)
9D004334  3C02BF88   LUI V0, -16504
9D004338  24426134   ADDIU V0, V0, 24884
9D00433C  AC43FF00   SW V1, -256(V0)
77:                      }
78:                  }
79:                  
80:                  
81:                  //******************************************************************************
82:                  /* Function :  PORTS_PinSet_MCU32_PPS
83:                  
84:                    Summary:
85:                      Implements MCU32_PPS variant of PLIB_PORTS_PinSet 
86:                  
87:                    Description:
88:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinSet function.
89:                  */
90:                  
91:                  PLIB_TEMPLATE void PORTS_PinSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
92:                  {
93:                  
94:                      *(&LATBSET + (channel - 1) * 0x40) = 1<<bitPos;
9D00340C  24030010   ADDIU V1, ZERO, 16
9D003410  3C02BF88   LUI V0, -16504
9D003414  24426138   ADDIU V0, V0, 24888
9D003418  AC43FF00   SW V1, -256(V0)
9D00341C  0000A821   ADDU S5, ZERO, ZERO
9D0034F8  0B400D2B   J 0x9D0034AC
9D0034FC  02808821   ADDU S1, S4, ZERO
9D003500  26D60080   ADDIU S6, S6, 128
9D00350C  02C0A021   ADDU S4, S6, ZERO
9D003510  0B400D3B   J 0x9D0034EC
9D003514  00009821   ADDU S3, ZERO, ZERO
9D008220  3C02BF88   LUI V0, -16504
9D008224  AC436138   SW V1, 24888(V0)
9D008228  24030008   ADDIU V1, ZERO, 8
9D008234  3C08BF88   LUI T0, -16504
9D008238  24042000   ADDIU A0, ZERO, 8192
9D008258  AD046138   SW A0, 24888(T0)
95:                      
96:                  }
97:                  
98:                  
99:                  //******************************************************************************
100:                 /* Function :  PORTS_PinClear_MCU32_PPS
101:                 
102:                   Summary:
103:                     Implements MCU32_PPS variant of PLIB_PORTS_PinClear 
104:                 
105:                   Description:
106:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_PinClear function.
107:                 */
108:                 
109:                 PLIB_TEMPLATE void PORTS_PinClear_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
110:                 {
111:                 	
112:                     *(&LATBCLR + (channel - 1) * 0x40) = 1<<bitPos;	
9D00348C  24030010   ADDIU V1, ZERO, 16
9D003490  3C02BF88   LUI V0, -16504
9D003494  24426134   ADDIU V0, V0, 24884
9D003498  AC43FF00   SW V1, -256(V0)
9D00349C  0000B021   ADDU S6, ZERO, ZERO
9D003518  24030010   ADDIU V1, ZERO, 16
9D00351C  3C02BF88   LUI V0, -16504
9D003520  24426134   ADDIU V0, V0, 24884
9D003524  AC43FF00   SW V1, -256(V0)
9D003528  3C05A000   LUI A1, -24576
9D00352C  24A50640   ADDIU A1, A1, 1600
9D003570  00001021   ADDU V0, ZERO, ZERO
9D0081F8  3C02BF88   LUI V0, -16504
9D0081FC  24032000   ADDIU V1, ZERO, 8192
9D008200  AC436134   SW V1, 24884(V0)
9D008204  24030010   ADDIU V1, ZERO, 16
9D008208  AC436134   SW V1, 24884(V0)
9D00823C  3C07BF88   LUI A3, -16504
9D008270  ACE46134   SW A0, 24884(A3)
9D008274  2463FFFF   ADDIU V1, V1, -1
9D008278  306300FF   ANDI V1, V1, 255
9D008284  24040010   ADDIU A0, ZERO, 16
9D008288  3C03BF88   LUI V1, -16504
9D00828C  AC646134   SW A0, 24884(V1)
113:                 						   
114:                 }
115:                 
116:                 
117:                 //******************************************************************************
118:                 /* Function :  PORTS_PinToggle_MCU32_PPS
119:                 
120:                   Summary:
121:                     Implements MCU32_PPS variant of PLIB_PORTS_PinToggle 
122:                 
123:                   Description:
124:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_PinToggle function.
125:                 */
126:                 
127:                 PLIB_TEMPLATE void PORTS_PinToggle_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
128:                 {
129:                 
130:                     *(&LATBINV + (channel - 1) * 0x40) = 1<<bitPos;
131:                 						   
132:                 }
133:                 
134:                 
135:                 //******************************************************************************
136:                 /* Function :  PORTS_Write_MCU32_PPS
137:                 
138:                   Summary:
139:                     Implements MCU32_PPS variant of PLIB_PORTS_Write 
140:                 
141:                   Description:
142:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Write function.
143:                 */
144:                 
145:                 PLIB_TEMPLATE void PORTS_Write_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_TYPE value )
146:                 {
147:                     *(&LATB + (channel - 1) * 0x40) = value;
9D007B9C  3C09BF88   LUI T1, -16504
9D007BA0  25226130   ADDIU V0, T1, 24880
9D007BA4  AC40FF00   SW ZERO, -256(V0)
9D007BFC  AD206130   SW ZERO, 24880(T1)
148:                 }
149:                 
150:                 
151:                 //******************************************************************************
152:                 /* Function :  PORTS_Set_MCU32_PPS
153:                 
154:                   Summary:
155:                     Implements MCU32_PPS variant of PLIB_PORTS_Set 
156:                 
157:                   Description:
158:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Set function.
159:                 */
160:                 
161:                 PLIB_TEMPLATE void PORTS_Set_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_TYPE value , PORTS_DATA_MASK mask )
162:                 {
163:                     
164:                     *(&LATBSET + (channel - 1) * 0x40) = (value & mask);
165:                 	
166:                 }
167:                 
168:                 
169:                 //******************************************************************************
170:                 /* Function :  PORTS_Toggle_MCU32_PPS
171:                 
172:                   Summary:
173:                     Implements MCU32_PPS variant of PLIB_PORTS_Toggle 
174:                 
175:                   Description:
176:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Toggle function.
177:                 */
178:                 
179:                 PLIB_TEMPLATE void PORTS_Toggle_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK toggleMask )
180:                 {
181:                     *(&LATBINV + (channel - 1) * 0x40) = toggleMask;
182:                 }
183:                 
184:                 
185:                 //******************************************************************************
186:                 /* Function :  PORTS_Clear_MCU32_PPS
187:                 
188:                   Summary:
189:                     Implements MCU32_PPS variant of PLIB_PORTS_Clear 
190:                 
191:                   Description:
192:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Clear function.
193:                 */
194:                 
195:                 PLIB_TEMPLATE void PORTS_Clear_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK clearMask )
196:                 {
197:                     
198:                     *(&LATBCLR + (channel - 1) * 0x40) = clearMask;	
199:                 						 
200:                 }
201:                 
202:                 
203:                 //******************************************************************************
204:                 /* Function :  PORTS_ExistsPortsWrite_MCU32_PPS
205:                 
206:                   Summary:
207:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsWrite
208:                 
209:                   Description:
210:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsWrite function.
211:                 */
212:                 
213:                 #define PLIB_PORTS_ExistsPortsWrite PLIB_PORTS_ExistsPortsWrite
214:                 PLIB_TEMPLATE bool PORTS_ExistsPortsWrite_MCU32_PPS( PORTS_MODULE_ID index )
215:                 {
216:                     return true;
217:                 }
218:                 
219:                 
220:                 #endif /*_PORTS_PORTSWRITE_MCU32_PPS_H*/
221:                 
222:                 /******************************************************************************
223:                  End of File
224:                 */
225:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/ports/templates/ports_portsread_mcu32_pps.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsRead_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsRead
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinGet
16:                          PLIB_PORTS_Read
17:                          PLIB_PORTS_ExistsPortsRead
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_PORTSREAD_MCU32_PPS_H
48:                  #define _PORTS_PORTSREAD_MCU32_PPS_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinGet_MCU32_PPS
53:                  
54:                    Summary:
55:                      Implements MCU32_PPS variant of PLIB_PORTS_PinGet 
56:                  
57:                    Description:
58:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinGet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE bool PORTS_PinGet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
62:                  {
63:                      return (bool)((*(&PORTB + ((channel - 1) * 0x40)) >> bitPos) & 1);
9D0032B4  3C02BF88   LUI V0, -16504
9D0032B8  8C426120   LW V0, 24864(V0)
9D0032BC  7C420200   EXT V0, V0, 8, 1
9D007F68  8C426120   LW V0, 24864(V0)
9D007F6C  7C420200   EXT V0, V0, 8, 1
9D007F9C  8C426120   LW V0, 24864(V0)
9D007FA0  7C420200   EXT V0, V0, 8, 1
9D007FE0  8C426120   LW V0, 24864(V0)
9D007FE4  7C420200   EXT V0, V0, 8, 1
9D008230  3C09BF88   LUI T1, -16504
9D008248  8D266120   LW A2, 24864(T1)
9D00824C  30C60020   ANDI A2, A2, 32
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  PORTS_Read_MCU32_PPS
69:                  
70:                    Summary:
71:                      Implements MCU32_PPS variant of PLIB_PORTS_Read 
72:                  
73:                    Description:
74:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_Read function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE PORTS_DATA_TYPE PORTS_Read_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel )
78:                  {
79:                      return (*(&PORTB + ((channel - 1) * 0x40)));
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  PORTS_ExistsPortsRead_MCU32_PPS
85:                  
86:                    Summary:
87:                      Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsRead
88:                  
89:                    Description:
90:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsRead function.
91:                  */
92:                  
93:                  #define PLIB_PORTS_ExistsPortsRead PLIB_PORTS_ExistsPortsRead
94:                  PLIB_TEMPLATE bool PORTS_ExistsPortsRead_MCU32_PPS( PORTS_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_PORTS_PORTSREAD_MCU32_PPS_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/ports/templates/ports_portsopendrain_mcu32_pps.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsOpenDrain_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsOpenDrain
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinOpenDrainEnable
16:                          PLIB_PORTS_PinOpenDrainDisable
17:                          PLIB_PORTS_OpenDrainEnable
18:                          PLIB_PORTS_OpenDrainDisable
19:                          PLIB_PORTS_ExistsPortsOpenDrain
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_PORTSOPENDRAIN_MCU32_PPS_H
50:                  #define _PORTS_PORTSOPENDRAIN_MCU32_PPS_H
51:                  
52:                  
53:                  
54:                  
55:                  //******************************************************************************
56:                  /* Function :  PORTS_PinOpenDrainEnable_MCU32_PPS
57:                  
58:                    Summary:
59:                      Implements MCU32_PPS variant of PLIB_PORTS_PinOpenDrainEnable 
60:                  
61:                    Description:
62:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinOpenDrainEnable function.
63:                  */
64:                  
65:                  PLIB_TEMPLATE void PORTS_PinOpenDrainEnable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
66:                  {
67:                      *(&ODCBSET + (channel - 1) * 0x40) = 1<<bitPos;
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  PORTS_PinOpenDrainDisable_MCU32_PPS
73:                  
74:                    Summary:
75:                      Implements MCU32_PPS variant of PLIB_PORTS_PinOpenDrainDisable 
76:                  
77:                    Description:
78:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinOpenDrainDisable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void PORTS_PinOpenDrainDisable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
82:                  {
83:                      *(&ODCBCLR + (channel - 1) * 0x40) = 1<<bitPos;
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  PORTS_OpenDrainEnable_MCU32_PPS
89:                  
90:                    Summary:
91:                      Implements MCU32_PPS variant of PLIB_PORTS_OpenDrainEnable 
92:                  
93:                    Description:
94:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_OpenDrainEnable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void PORTS_OpenDrainEnable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
98:                  {
99:                      *(&ODCBSET + (channel - 1) * 0x40) = mask;
9D007B90  3C0ABF88   LUI T2, -16504
9D007B94  25426148   ADDIU V0, T2, 24904
9D007B98  AC40FF00   SW ZERO, -256(V0)
9D007BF8  AD406148   SW ZERO, 24904(T2)
100:                 }
101:                 
102:                 
103:                 //******************************************************************************
104:                 /* Function :  PORTS_OpenDrainDisable_MCU32_PPS
105:                 
106:                   Summary:
107:                     Implements MCU32_PPS variant of PLIB_PORTS_OpenDrainDisable 
108:                 
109:                   Description:
110:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_OpenDrainDisable function.
111:                 */
112:                 
113:                 PLIB_TEMPLATE void PORTS_OpenDrainDisable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
114:                 {
115:                     *(&ODCBCLR + (channel - 1) * 0x40) = mask;
116:                 }
117:                 
118:                 
119:                 //******************************************************************************
120:                 /* Function :  PORTS_ExistsPortsOpenDrain_MCU32_PPS
121:                 
122:                   Summary:
123:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsOpenDrain
124:                 
125:                   Description:
126:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsOpenDrain function.
127:                 */
128:                 
129:                 #define PLIB_PORTS_ExistsPortsOpenDrain PLIB_PORTS_ExistsPortsOpenDrain
130:                 PLIB_TEMPLATE bool PORTS_ExistsPortsOpenDrain_MCU32_PPS( PORTS_MODULE_ID index )
131:                 {
132:                     return true;
133:                 }
134:                 
135:                 
136:                 #endif /*_PORTS_PORTSOPENDRAIN_MCU32_PPS_H*/
137:                 
138:                 /******************************************************************************
139:                  End of File
140:                 */
141:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/ports/templates/ports_portsdirection_mcu32_pps.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsDirection_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsDirection
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinDirectionInputSet
16:                          PLIB_PORTS_PinDirectionOutputSet
17:                          PLIB_PORTS_DirectionInputSet
18:                          PLIB_PORTS_DirectionOutputSet
19:                          PLIB_PORTS_DirectionGet
20:                          PLIB_PORTS_ExistsPortsDirection
21:                  
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _PORTS_PORTSDIRECTION_MCU32_PPS_H
51:                  #define _PORTS_PORTSDIRECTION_MCU32_PPS_H
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  PORTS_PinDirectionInputSet_MCU32_PPS
56:                  
57:                    Summary:
58:                      Implements MCU32_PPS variant of PLIB_PORTS_PinDirectionInputSet 
59:                  
60:                    Description:
61:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinDirectionInputSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void PORTS_PinDirectionInputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
65:                  {
66:                      *(&TRISBSET + (channel - 1) * 0x40) = 1<<bitPos;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PORTS_PinDirectionOutputSet_MCU32_PPS
72:                  
73:                    Summary:
74:                      Implements MCU32_PPS variant of PLIB_PORTS_PinDirectionOutputSet 
75:                  
76:                    Description:
77:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinDirectionOutputSet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void PORTS_PinDirectionOutputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
81:                  {
82:                      *(&TRISBCLR + (channel - 1) * 0x40) = 1<<bitPos;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  PORTS_DirectionInputSet_MCU32_PPS
88:                  
89:                    Summary:
90:                      Implements MCU32_PPS variant of PLIB_PORTS_DirectionInputSet 
91:                  
92:                    Description:
93:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionInputSet function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void PORTS_DirectionInputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
97:                  {
98:                      *(&TRISBSET + (channel - 1) * 0x40) = mask;
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  PORTS_DirectionOutputSet_MCU32_PPS
104:                 
105:                   Summary:
106:                     Implements MCU32_PPS variant of PLIB_PORTS_DirectionOutputSet 
107:                 
108:                   Description:
109:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionOutputSet function.
110:                 */
111:                 
112:                 PLIB_TEMPLATE void PORTS_DirectionOutputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
113:                 {
114:                     *(&TRISBCLR + (channel - 1) * 0x40) = mask;
9D007BA8  3C08BF88   LUI T0, -16504
9D007BAC  25036114   ADDIU V1, T0, 24852
9D007BB0  24020010   ADDIU V0, ZERO, 16
9D007BB4  AC62FF00   SW V0, -256(V1)
9D007C00  2409201F   ADDIU T1, ZERO, 8223
9D007C04  AD096114   SW T1, 24852(T0)
115:                 }
116:                 
117:                 
118:                 //******************************************************************************
119:                 /* Function :  PORTS_DirectionGet_MCU32_PPS
120:                 
121:                   Summary:
122:                     Implements MCU32_PPS variant of PLIB_PORTS_DirectionGet 
123:                 
124:                   Description:
125:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionGet function.
126:                 */
127:                 
128:                 PLIB_TEMPLATE PORTS_DATA_MASK PORTS_DirectionGet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel )
129:                 {
130:                     return ( *(&TRISB + (channel - 1) * 0x40) );
131:                 }
132:                 
133:                 
134:                 //******************************************************************************
135:                 /* Function :  PORTS_ExistsPortsDirection_MCU32_PPS
136:                 
137:                   Summary:
138:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsDirection
139:                 
140:                   Description:
141:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsDirection function.
142:                 */
143:                 
144:                 #define PLIB_PORTS_ExistsPortsDirection PLIB_PORTS_ExistsPortsDirection
145:                 PLIB_TEMPLATE bool PORTS_ExistsPortsDirection_MCU32_PPS( PORTS_MODULE_ID index )
146:                 {
147:                     return true;
148:                 }
149:                 
150:                 
151:                 #endif /*_PORTS_PORTSDIRECTION_MCU32_PPS_H*/
152:                 
153:                 /******************************************************************************
154:                  End of File
155:                 */
156:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/ports/templates/ports_pinmodeperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinModePerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinModePerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_PinModePerPortSelect
16:                          PLIB_PORTS_ChannelModeSelect
17:                          PLIB_PORTS_ExistsPinModePerPort
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_PINMODEPERPORT_DEFAULT_H
48:                  #define _PORTS_PINMODEPERPORT_DEFAULT_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinModePerPortSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_PORTS_PinModePerPortSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_PORTS_PinModePerPortSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_PinModePerPortSelect_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos , PORTS_PIN_MODE   mode )
62:                  {
63:                      if ( mode == PORTS_PIN_MODE_ANALOG )
64:                  	{
65:                          *(&ANSELBSET + (channel - 1) * 0x40) = 1<<bitPos;	
66:                  	}
67:                  	else
68:                  	{
69:                          *(&ANSELBCLR + (channel - 1) * 0x40) = 1<<bitPos;
70:                  	}
71:                  }
72:                  
73:                  
74:                  //******************************************************************************
75:                  /* Function :  PORTS_ChannelModeSelect_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_PORTS_ChannelModeSelect 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the PLIB_PORTS_ChannelModeSelect function.
82:                  */
83:                  
84:                  PLIB_TEMPLATE void PORTS_ChannelModeSelect_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK   modeMask , PORTS_PIN_MODE mode )
85:                  {
86:                      if ( mode == PORTS_PIN_MODE_ANALOG )
87:                  	{
88:                          *(&ANSELBSET + (channel - 1) * 0x40) = modeMask;	
89:                  	}
90:                  	else
91:                  	{
92:                          *(&ANSELBCLR + (channel - 1) * 0x40) = modeMask;
9D007BC8  3C05BF88   LUI A1, -16504
9D007BCC  24A36104   ADDIU V1, A1, 24836
9D007BD0  AC62FF00   SW V0, -256(V1)
9D007C0C  240623BF   ADDIU A2, ZERO, 9151
9D007C10  ACA66104   SW A2, 24836(A1)
93:                  	}
94:                  }
95:                  
96:                  
97:                  //******************************************************************************
98:                  /* Function :  PORTS_ExistsPinModePerPort_Default
99:                  
100:                   Summary:
101:                     Implements Default variant of PLIB_PORTS_ExistsPinModePerPort
102:                 
103:                   Description:
104:                     This template implements the Default variant of the PLIB_PORTS_ExistsPinModePerPort function.
105:                 */
106:                 
107:                 #define PLIB_PORTS_ExistsPinModePerPort PLIB_PORTS_ExistsPinModePerPort
108:                 PLIB_TEMPLATE bool PORTS_ExistsPinModePerPort_Default( PORTS_MODULE_ID index )
109:                 {
110:                     return true;
111:                 }
112:                 
113:                 
114:                 #endif /*_PORTS_PINMODEPERPORT_DEFAULT_H*/
115:                 
116:                 /******************************************************************************
117:                  End of File
118:                 */
119:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/ports/templates/ports_pinchangenoticeperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinChangeNoticePerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinChangeNoticePerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_PinChangeNoticePerPortEnable
16:                          PLIB_PORTS_PinChangeNoticePerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticeEnable
18:                          PLIB_PORTS_ChannelChangeNoticeDisable
19:                          PLIB_PORTS_ExistsPinChangeNoticePerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H
50:                  #define _PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H
51:                  
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  PORTS_PinChangeNoticePerPortEnable_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_PORTS_PinChangeNoticePerPortEnable 
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_PORTS_PinChangeNoticePerPortEnable function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void PORTS_PinChangeNoticePerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
65:                  {
66:                      *(&CNENBSET + (channel - 1) * 0x40) = 1<<bitPos;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PORTS_PinChangeNoticePerPortDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_PORTS_PinChangeNoticePerPortDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_PORTS_PinChangeNoticePerPortDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void PORTS_PinChangeNoticePerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
81:                  {
82:                      *(&CNENBCLR + (channel - 1) * 0x40) = 1<<bitPos;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  PORTS_ChannelChangeNoticeEnable_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticeEnable 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticeEnable function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticeEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
97:                  {
98:                      *(&CNENBSET + (channel - 1) * 0x40) = mask;
9D007BD4  3C04BF88   LUI A0, -16504
9D007BD8  24826188   ADDIU V0, A0, 24968
9D007BDC  AC40FF00   SW ZERO, -256(V0)
9D007C14  AC806188   SW ZERO, 24968(A0)
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  PORTS_ChannelChangeNoticeDisable_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticeDisable 
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticeDisable function.
110:                 */
111:                 
112:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticeDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
113:                 {
114:                     *(&CNENBCLR + (channel - 1) * 0x40) = mask;
115:                 }
116:                 
117:                 
118:                 //******************************************************************************
119:                 /* Function :  PORTS_ExistsPinChangeNoticePerPort_Default
120:                 
121:                   Summary:
122:                     Implements Default variant of PLIB_PORTS_ExistsPinChangeNoticePerPort
123:                 
124:                   Description:
125:                     This template implements the Default variant of the PLIB_PORTS_ExistsPinChangeNoticePerPort function.
126:                 */
127:                 
128:                 #define PLIB_PORTS_ExistsPinChangeNoticePerPort PLIB_PORTS_ExistsPinChangeNoticePerPort
129:                 PLIB_TEMPLATE bool PORTS_ExistsPinChangeNoticePerPort_Default( PORTS_MODULE_ID index )
130:                 {
131:                     return true;
132:                 }
133:                 
134:                 
135:                 #endif /*_PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H*/
136:                 
137:                 /******************************************************************************
138:                  End of File
139:                 */
140:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/ports/templates/ports_changenoticepullupperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePullUpPerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePullUpPerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePullUpPerPortEnable
16:                          PLIB_PORTS_ChangeNoticePullUpPerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticePullUpEnable
18:                          PLIB_PORTS_ChannelChangeNoticePullUpDisable
19:                          PLIB_PORTS_ExistsChangeNoticePullUpPerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H
50:                  #define _PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  PORTS_ChangeNoticePullUpPerPortEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullUpPerPortEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullUpPerPortEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullUpPerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
64:                  {
65:                      *(&CNPUBSET + (channel - 1) * 0x40) = 1<<bitPos;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  PORTS_ChangeNoticePullUpPerPortDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullUpPerPortDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullUpPerPortDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullUpPerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
80:                  {
81:                      *(&CNPUBCLR + (channel - 1) * 0x40) = 1<<bitPos;
82:                  }
83:                  
84:                  //******************************************************************************
85:                  /* Function :  PORTS_ChannelChangeNoticePullUpEnable_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullUpEnable 
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullUpEnable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullUpEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
95:                  {
96:                      *(&CNPUBSET + (channel - 1) * 0x40) = mask;
9D007BE0  3C03BF88   LUI V1, -16504
9D007BE4  24626158   ADDIU V0, V1, 24920
9D007BE8  AC40FF00   SW ZERO, -256(V0)
9D007C18  24040120   ADDIU A0, ZERO, 288
9D007C1C  AC646158   SW A0, 24920(V1)
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  PORTS_ChannelChangeNoticePullUpDisable_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullUpDisable 
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullUpDisable function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullUpDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
111:                 {
112:                     *(&CNPUBCLR + (channel - 1) * 0x40) = mask;
113:                 }
114:                 
115:                 
116:                 //******************************************************************************
117:                 /* Function :  PORTS_ExistsChangeNoticePullUpPerPort_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_PORTS_ExistsChangeNoticePullUpPerPort
121:                 
122:                   Description:
123:                     This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePullUpPerPort function.
124:                 */
125:                 
126:                 #define PLIB_PORTS_ExistsChangeNoticePullUpPerPort PLIB_PORTS_ExistsChangeNoticePullUpPerPort
127:                 PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePullUpPerPort_Default( PORTS_MODULE_ID index )
128:                 {
129:                     return true;
130:                 }
131:                 
132:                 
133:                 #endif /*_PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H*/
134:                 
135:                 /******************************************************************************
136:                  End of File
137:                 */
138:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/ports/templates/ports_changenoticepulldownperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePullDownPerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePullDownPerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePullDownPerPortEnable
16:                          PLIB_PORTS_ChangeNoticePullDownPerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticePullDownEnable
18:                          PLIB_PORTS_ChannelChangeNoticePullDownDisable
19:                          PLIB_PORTS_ExistsChangeNoticePullDownPerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H
50:                  #define _PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  PORTS_ChangeNoticePullDownPerPortEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullDownPerPortEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullDownPerPortEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullDownPerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
64:                  {
65:                      *(&CNPDBSET + (channel - 1) * 0x40) = 1<<bitPos;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  PORTS_ChangeNoticePullDownPerPortDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullDownPerPortDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullDownPerPortDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullDownPerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
80:                  {
81:                      *(&CNPDBCLR + (channel - 1) * 0x40) = 1<<bitPos;
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  PORTS_ChannelChangeNoticePullDownEnable_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullDownEnable 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullDownEnable function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullDownEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
96:                  {
97:                      *(&CNPDBSET + (channel - 1) * 0x40) = mask;
9D007BEC  3C02BF88   LUI V0, -16504
9D007BF0  244B6168   ADDIU T3, V0, 24936
9D007BF4  AD60FF00   SW ZERO, -256(T3)
9D007C20  AC406168   SW ZERO, 24936(V0)
98:                  }
99:                  
100:                 
101:                 //******************************************************************************
102:                 /* Function :  PORTS_ChannelChangeNoticePullDownDisable_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullDownDisable 
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullDownDisable function.
109:                 */
110:                 
111:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullDownDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
112:                 {
113:                     *(&CNPDBCLR + (channel - 1) * 0x40) = mask;
114:                 }
115:                 
116:                 
117:                 //******************************************************************************
118:                 /* Function :  PORTS_ExistsChangeNoticePullDownPerPort_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_PORTS_ExistsChangeNoticePullDownPerPort
122:                 
123:                   Description:
124:                     This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePullDownPerPort function.
125:                 */
126:                 
127:                 #define PLIB_PORTS_ExistsChangeNoticePullDownPerPort PLIB_PORTS_ExistsChangeNoticePullDownPerPort
128:                 PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePullDownPerPort_Default( PORTS_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 
134:                 #endif /*_PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H*/
135:                 
136:                 /******************************************************************************
137:                  End of File
138:                 */
139:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/ports/templates/ports_changenoticeperportturnon_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePerPortTurnOn_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePerPortTurnOn
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePerPortTurnOn
16:                          PLIB_PORTS_ChangeNoticePerPortTurnOff
17:                          PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H
48:                  #define _PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_ChangeNoticePerPortTurnOn_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_PORTS_ChangeNoticePerPortTurnOn 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePerPortTurnOn function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_ChangeNoticePerPortTurnOn_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel )
62:                  {
63:                      *(&CNCONBSET + (channel - 1) * 0x40) = _CNCONB_ON_MASK;
9D007BB8  3C06BF88   LUI A2, -16504
9D007BBC  24C36178   ADDIU V1, A2, 24952
9D007BC0  34078000   ORI A3, ZERO, -32768
9D007BC4  AC67FF00   SW A3, -256(V1)
9D007C08  ACC76178   SW A3, 24952(A2)
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  PORTS_ChangeNoticePerPortTurnOff_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_PORTS_ChangeNoticePerPortTurnOff 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePerPortTurnOff function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void PORTS_ChangeNoticePerPortTurnOff_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel )
78:                  {
79:                      *(&CNCONBCLR + (channel - 1) * 0x40) = _CNCONB_ON_MASK;
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  PORTS_ExistsChangeNoticePerPortTurnOn_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePerPortTurnOn function.
91:                  */
92:                  
93:                  #define PLIB_PORTS_ExistsChangeNoticePerPortTurnOn PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
94:                  PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePerPortTurnOn_Default( PORTS_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/osc/templates/osc_secondaryenable_default.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_SecondaryEnable_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SecondaryEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsSecondaryEnable
16:                          PLIB_OSC_SecondaryEnable
17:                          PLIB_OSC_SecondaryDisable
18:                          PLIB_OSC_SecondaryIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_SECONDARYENABLE_DEFAULT_H
49:                  #define _OSC_SECONDARYENABLE_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OSC_ExistsSecondaryEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_OSC_ExistsSecondaryEnable
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_OSC_ExistsSecondaryEnable function.
59:                  */
60:                  
61:                  #define PLIB_OSC_ExistsSecondaryEnable PLIB_OSC_ExistsSecondaryEnable
62:                  PLIB_TEMPLATE bool OSC_ExistsSecondaryEnable_Default( OSC_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OSC_SecondaryEnable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_OSC_SecondaryEnable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_OSC_SecondaryEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OSC_SecondaryEnable_Default( OSC_MODULE_ID index )
79:                  {
80:                      OSCCONSET = _OSCCON_SOSCEN_MASK;
9D0093FC  24030002   ADDIU V1, ZERO, 2
9D009400  3C02BF81   LUI V0, -16511
9D009404  AC43F008   SW V1, -4088(V0)
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  OSC_SecondaryDisable_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_OSC_SecondaryDisable 
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_OSC_SecondaryDisable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void OSC_SecondaryDisable_Default( OSC_MODULE_ID index )
95:                  {
96:                      OSCCONCLR = _OSCCON_SOSCEN_MASK;
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OSC_SecondaryIsEnabled_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_OSC_SecondaryIsEnabled 
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_OSC_SecondaryIsEnabled function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE bool OSC_SecondaryIsEnabled_Default( OSC_MODULE_ID index )
111:                 {
112:                    return (bool)OSCCONbits.SOSCEN;
9D0093D8  3C02BF81   LUI V0, -16511
9D0093DC  8C42F000   LW V0, -4096(V0)
9D0093E0  30420002   ANDI V0, V0, 2
113:                 }
114:                 
115:                 
116:                 #endif /*_OSC_SECONDARYENABLE_DEFAULT_H*/
117:                 
118:                 /******************************************************************************
119:                  End of File
120:                 */
121:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/osc/templates/osc_referenceoutputenable_pic32_1.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOutputEnable_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOutputEnable
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOutputEnable
16:                          PLIB_OSC_ReferenceOutputEnable
17:                          PLIB_OSC_ReferenceOutputDisable
18:                          PLIB_OSC_ReferenceOutputIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_REFERENCEOUTPUTENABLE_PIC32_1_H
49:                  #define _OSC_REFERENCEOUTPUTENABLE_PIC32_1_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OSC_ExistsReferenceOutputEnable_PIC32_1
53:                  
54:                    Summary:
55:                      Implements PIC32_1 variant of PLIB_OSC_ExistsReferenceOutputEnable
56:                  
57:                    Description:
58:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsReferenceOutputEnable function.
59:                  */
60:                  
61:                  #define PLIB_OSC_ExistsReferenceOutputEnable PLIB_OSC_ExistsReferenceOutputEnable
62:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOutputEnable_PIC32_1( OSC_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OSC_ReferenceOutputEnable_PIC32_1
70:                  
71:                    Summary:
72:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOutputEnable 
73:                  
74:                    Description:
75:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOutputEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OSC_ReferenceOutputEnable_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
79:                  {
80:                      REFOCONSET = _REFOCON_OE_MASK;
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  OSC_ReferenceOutputDisable_PIC32_1
86:                  
87:                    Summary:
88:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOutputDisable 
89:                  
90:                    Description:
91:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOutputDisable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void OSC_ReferenceOutputDisable_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
95:                  {
96:                      REFOCONCLR = _REFOCON_OE_MASK;
9D008D94  24031000   ADDIU V1, ZERO, 4096
9D008D98  AC43F024   SW V1, -4060(V0)
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OSC_ReferenceOutputIsEnabled_PIC32_1
102:                 
103:                   Summary:
104:                     Implements PIC32_1 variant of PLIB_OSC_ReferenceOutputIsEnabled 
105:                 
106:                   Description:
107:                     This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOutputIsEnabled function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE bool OSC_ReferenceOutputIsEnabled_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
111:                 {
112:                     return (bool)REFOCONbits.OE;
113:                 }
114:                 
115:                 
116:                 #endif /*_OSC_REFERENCEOUTPUTENABLE_PIC32_1_H*/
117:                 
118:                 /******************************************************************************
119:                  End of File
120:                 */
121:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/osc/templates/osc_referenceoscenable_pic32_1.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOscEnable_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOscEnable
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOscEnable
16:                          PLIB_OSC_ReferenceOscEnable
17:                          PLIB_OSC_ReferenceOscDisable
18:                          PLIB_OSC_ReferenceOscIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_REFERENCEOSCENABLE_PIC32_1_H
49:                  #define _OSC_REFERENCEOSCENABLE_PIC32_1_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OSC_ExistsReferenceOscEnable_PIC32_1
53:                  
54:                    Summary:
55:                      Implements PIC32_1 variant of PLIB_OSC_ExistsReferenceOscEnable
56:                  
57:                    Description:
58:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsReferenceOscEnable function.
59:                  */
60:                  
61:                  #define PLIB_OSC_ExistsReferenceOscEnable PLIB_OSC_ExistsReferenceOscEnable
62:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOscEnable_PIC32_1( OSC_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OSC_ReferenceOscEnable_PIC32_1
70:                  
71:                    Summary:
72:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOscEnable 
73:                  
74:                    Description:
75:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OSC_ReferenceOscEnable_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
79:                  {
80:                      REFOCONSET = _REFOCON_ON_MASK;
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  OSC_ReferenceOscDisable_PIC32_1
86:                  
87:                    Summary:
88:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOscDisable 
89:                  
90:                    Description:
91:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscDisable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void OSC_ReferenceOscDisable_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
95:                  {
96:                      REFOCONCLR = _REFOCON_ON_MASK;
9D008D88  3C02BF81   LUI V0, -16511
9D008D8C  34038000   ORI V1, ZERO, -32768
9D008D90  AC43F024   SW V1, -4060(V0)
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OSC_ReferenceOscIsEnabled_PIC32_1
102:                 
103:                   Summary:
104:                     Implements PIC32_1 variant of PLIB_OSC_ReferenceOscIsEnabled 
105:                 
106:                   Description:
107:                     This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscIsEnabled function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE bool OSC_ReferenceOscIsEnabled_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
111:                 {
112:                     return (bool)REFOCONbits.ON;
113:                 }
114:                 
115:                 
116:                 #endif /*_OSC_REFERENCEOSCENABLE_PIC32_1_H*/
117:                 
118:                 /******************************************************************************
119:                  End of File
120:                 */
121:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/osc/templates/osc_pbclockdivisor_pic32_1.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_PBClockDivisor_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PBClockDivisor
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsPBClockDivisor
16:                          PLIB_OSC_PBClockDivisorGet
17:                          PLIB_OSC_PBClockDivisorSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_PBCLOCKDIVISOR_PIC32_1_H
48:                  #define _OSC_PBCLOCKDIVISOR_PIC32_1_H
49:                  
50:                  
51:                  // *****************************************************************************
52:                  /* Oscillator Peripheral Bus Clock Divisor Value Type
53:                  
54:                    Summary:
55:                      Type of the oscillator PB Clock divisor value.
56:                  
57:                    Description:
58:                      This macro defines the type of the oscillator PB Clock divisor value.
59:                  
60:                    Remarks:
61:                      None
62:                  */
63:                  
64:                  #define OSC_PB_CLOCK_DIV_TYPE						SFR_TYPE
65:                  
66:                  
67:                  // *****************************************************************************
68:                  /* Oscillator Peripheral Bus count
69:                  
70:                    Summary:
71:                      The number of Peripheral buses in available in the device.
72:                  
73:                    Description:
74:                      This macro gives the number of Peripheral buses in available in the device.
75:                  
76:                    Remarks:
77:                      None
78:                  */
79:                  
80:                  #define PERIPHERAL_BUSES_MAX						1
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OSC_ExistsPBClockDivisor_PIC32_1
85:                  
86:                    Summary:
87:                      Implements PIC32_1 variant of PLIB_OSC_ExistsPBClockDivisor
88:                  
89:                    Description:
90:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsPBClockDivisor function.
91:                  */
92:                  
93:                  #define PLIB_OSC_ExistsPBClockDivisor PLIB_OSC_ExistsPBClockDivisor
94:                  PLIB_TEMPLATE bool OSC_ExistsPBClockDivisor_PIC32_1( OSC_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OSC_PBClockDivisorGet_PIC32_1
102:                 
103:                   Summary:
104:                     Implements PIC32_1 variant of PLIB_OSC_PBClockDivisorGet
105:                 
106:                   Description:
107:                     This template implements the PIC32_1 variant of the PLIB_OSC_PBClockDivisorGet function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE OSC_PB_CLOCK_DIV_TYPE OSC_PBClockDivisorGet_PIC32_1( OSC_MODULE_ID index , OSC_PERIPHERAL_BUS peripheralBusNumber )
111:                 {
112:                     return (OSC_PB_CLOCK_DIV_TYPE)(0x01u << OSCCONbits.PBDIV);
113:                 }
114:                 
115:                 
116:                 //******************************************************************************
117:                 /* Function :  OSC_PBClockDivisorSet_PIC32_1
118:                 
119:                   Summary:
120:                     Implements PIC32_1 variant of PLIB_OSC_PBClockDivisorSet
121:                 
122:                   Description:
123:                     This template implements the PIC32_1 variant of the PLIB_OSC_PBClockDivisorSet function.
124:                 */
125:                 
126:                 PLIB_TEMPLATE void OSC_PBClockDivisorSet_PIC32_1( OSC_MODULE_ID index , OSC_PERIPHERAL_BUS peripheralBusNumber , OSC_PB_CLOCK_DIV_TYPE peripheralBusClkDiv )
127:                 {
128:                     uint8_t regValue;
129:                 
130:                     for (regValue = 0u; regValue < 4u; regValue++)
131:                     {
132:                         if ( peripheralBusClkDiv == ( 0x01u << regValue ) )
9D008D6C  24020002   ADDIU V0, ZERO, 2
9D008D70  10400006   BEQ V0, ZERO, 0x9D008D8C
9D008D74  3C02BF81   LUI V0, -16511
133:                         {
134:                             OSCCONbits.PBDIV = regValue;
9D008D78  3C02BF81   LUI V0, -16511
9D008D7C  8C43F000   LW V1, -4096(V0)
9D008D80  7C83A4C4   INS V1, A0, 19, 2
9D008D84  AC43F000   SW V1, -4096(V0)
135:                             return;
136:                         }
137:                     }
138:                     PLIB_ASSERT(false, "Given PB Divisor value is not supported for the selected device");
139:                 }
140:                 
141:                 
142:                 #endif /*_OSC_PBCLOCKDIVISOR_PIC32_1_H*/
143:                 
144:                 /******************************************************************************
145:                  End of File
146:                 */
147:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/osc/templates/osc_onwaitaction_default.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_OnWaitAction_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OnWaitAction
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsOnWaitAction
16:                          PLIB_OSC_OnWaitActionSet
17:                          PLIB_OSC_OnWaitActionGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_ONWAITACTION_DEFAULT_H
48:                  #define _OSC_ONWAITACTION_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  OSC_ExistsOnWaitAction_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_OSC_ExistsOnWaitAction
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_OSC_ExistsOnWaitAction function.
58:                  */
59:                  
60:                  #define PLIB_OSC_ExistsOnWaitAction PLIB_OSC_ExistsOnWaitAction
61:                  PLIB_TEMPLATE bool OSC_ExistsOnWaitAction_Default( OSC_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  OSC_OnWaitActionSet_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_OSC_OnWaitActionSet 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_OSC_OnWaitActionSet function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void OSC_OnWaitActionSet_Default( OSC_MODULE_ID index , OSC_OPERATION_ON_WAIT onWait )
78:                  {
79:                      OSCCONbits.SLPEN = onWait;
9D003054  3C02BF81   LUI V0, -16511
9D003058  8C43F000   LW V1, -4096(V0)
9D00305C  7C032104   INS V1, ZERO, 4, 1
9D003060  AC43F000   SW V1, -4096(V0)
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OSC_OnWaitActionGet_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_OSC_OnWaitActionGet 
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_OSC_OnWaitActionGet function.
91:                  */
92:                  
93:                  PLIB_TEMPLATE OSC_OPERATION_ON_WAIT OSC_OnWaitActionGet_Default( OSC_MODULE_ID index )
94:                  {
95:                      return (OSC_OPERATION_ON_WAIT)OSCCONbits.SLPEN;
96:                  }
97:                  
98:                  
99:                  #endif /*_OSC_ONWAITACTION_DEFAULT_H*/
100:                 
101:                 /******************************************************************************
102:                  End of File
103:                 */
104:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/osc/templates/osc_frcdivisor_default.h
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_FRCDivisor_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : FRCDivisor
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsFRCDivisor
16:                          PLIB_OSC_FRCDivisorSelect
17:                          PLIB_OSC_FRCDivisorGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_FRCDIVISOR_DEFAULT_H
48:                  #define _OSC_FRCDIVISOR_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  OSC_ExistsFRCDivisor_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_OSC_ExistsFRCDivisor
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_OSC_ExistsFRCDivisor function.
58:                  */
59:                  
60:                  #define PLIB_OSC_ExistsFRCDivisor PLIB_OSC_ExistsFRCDivisor
61:                  PLIB_TEMPLATE bool OSC_ExistsFRCDivisor_Default( OSC_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  OSC_FRCDivisorSelect_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_OSC_FRCDivisorSelect 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_OSC_FRCDivisorSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void OSC_FRCDivisorSelect_Default( OSC_MODULE_ID index , OSC_FRC_DIV divisorFRC )
78:                  {
79:                      OSCCONbits.FRCDIV = divisorFRC;
9D008D58  3C02BF81   LUI V0, -16511
9D008D5C  8C43F000   LW V1, -4096(V0)
9D008D60  24040001   ADDIU A0, ZERO, 1
9D008D64  7C83D604   INS V1, A0, 24, 3
9D008D68  AC43F000   SW V1, -4096(V0)
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OSC_FRCDivisorGet_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_OSC_FRCDivisorGet
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_OSC_FRCDivisorGet function.
91:                  */
92:                  
93:                  PLIB_TEMPLATE uint16_t OSC_FRCDivisorGet_Default( OSC_MODULE_ID index )
94:                  {
95:                      uint16_t returnValue  = 0u;
96:                  
97:                      if ( OSCCONbits.FRCDIV != 7u )
98:                      {
99:                          returnValue = ( 1u << OSCCONbits.FRCDIV );
100:                     }
101:                     else
102:                     {
103:                         returnValue = 256u;
104:                     }
105:                 
106:                     return returnValue;
107:                 }
108:                 
109:                 
110:                 #endif /*_OSC_FRCDIVISOR_DEFAULT_H*/
111:                 
112:                 /******************************************************************************
113:                  End of File
114:                 */
115:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/oc/templates/oc_timerselect_default.h
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_TimerSelect_Default.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TimerSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                  	PLIB_OC_TimerSelect
16:                  	PLIB_OC_ExistsTimerSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OC_TIMERSELECT_DEFAULT_H
47:                  #define _OC_TIMERSELECT_DEFAULT_H
48:                  
49:                  #include "oc_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OC_TimerSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_OC_TimerSelect
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_OC_TimerSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void OC_TimerSelect_Default( OC_MODULE_ID index , OC_16BIT_TIMERS tmr )
62:                  {
63:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
64:                  
65:                      regs->OCxCON.OCTSEL = tmr;
9D003118  94453000   LHU A1, 12288(V0)
9D00311C  7C0518C4   INS A1, ZERO, 3, 1
9D003120  A4453000   SH A1, 12288(V0)
9D003190  94443200   LHU A0, 12800(V0)
9D003194  7C0418C4   INS A0, ZERO, 3, 1
9D003198  A4443200   SH A0, 12800(V0)
9D0031B4  94433400   LHU V1, 13312(V0)
9D0031B8  7C0318C4   INS V1, ZERO, 3, 1
9D0031BC  A4433400   SH V1, 13312(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  OC_ExistsTimerSelect_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_OC_ExistsTimerSelect
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_OC_ExistsTimerSelect function.
77:                  */
78:                  
79:                  #define PLIB_OC_ExistsTimerSelect PLIB_OC_ExistsTimerSelect
80:                  PLIB_TEMPLATE bool OC_ExistsTimerSelect_Default( OC_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_OC_TIMERSELECT_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/oc/templates/oc_pulsewidth_32bit_variant.h
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_PulseWidth_32Bit_Variant.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PulseWidth
13:                      and its Variant : 32Bit_Variant
14:                      For following APIs :
15:                          PLIB_OC_PulseWidth32BitSet
16:                          PLIB_OC_PulseWidth16BitSet
17:                          PLIB_OC_ExistsPulseWidth
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OC_PULSEWIDTH_32BIT_VARIANT_H
48:                  #define _OC_PULSEWIDTH_32BIT_VARIANT_H
49:                  
50:                  #include "oc_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  OC_PulseWidth32BitSet_32Bit_Variant
54:                  
55:                    Summary:
56:                      Implements 32Bit_Variant variant of PLIB_OC_PulseWidth32BitSet 
57:                  
58:                    Description:
59:                      This template implements the 32Bit_Variant variant of the PLIB_OC_PulseWidth32BitSet function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void OC_PulseWidth32BitSet_32Bit_Variant( OC_MODULE_ID index , uint32_t pulseWidth )
63:                  {
64:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
65:                  
66:                      regs->OCxRS = pulseWidth;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  OC_PulseWidth16BitSet_32Bit_Variant
72:                  
73:                    Summary:
74:                      Implements 32Bit_Variant variant of PLIB_OC_PulseWidth16BitSet 
75:                  
76:                    Description:
77:                      This template implements the 32Bit_Variant variant of the PLIB_OC_PulseWidth16BitSet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void OC_PulseWidth16BitSet_32Bit_Variant( OC_MODULE_ID index , uint16_t pulseWidth )
81:                  {
82:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
83:                  
84:                      regs->OCxRS = pulseWidth;
9D00312C  24050213   ADDIU A1, ZERO, 531
9D003130  AC453020   SW A1, 12320(V0)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  OC_ExistsPulseWidth_32Bit_Variant
90:                  
91:                    Summary:
92:                      Implements 32Bit_Variant variant of PLIB_OC_ExistsPulseWidth
93:                  
94:                    Description:
95:                      This template implements the 32Bit_Variant variant of the PLIB_OC_ExistsPulseWidth function.
96:                  */
97:                  
98:                  #define PLIB_OC_ExistsPulseWidth PLIB_OC_ExistsPulseWidth
99:                  PLIB_TEMPLATE bool OC_ExistsPulseWidth_32Bit_Variant( OC_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_OC_PULSEWIDTH_32BIT_VARIANT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/oc/templates/oc_enablecontrol_default.h
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OC_Enable
16:                          PLIB_OC_Disable
17:                          PLIB_OC_IsEnabled
18:                          PLIB_OC_ExistsEnableControl
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OC_ENABLECONTROL_DEFAULT_H
49:                  #define _OC_ENABLECONTROL_DEFAULT_H
50:                  
51:                  #include "oc_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  OC_Enable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_OC_Enable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_OC_Enable function.
61:                      Operation is atomic.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void OC_Enable_Default( OC_MODULE_ID index )
65:                  {
66:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
67:                  
68:                      regs->OCxCONSET = OCxCON_ON_MASK;
9D003134  34058000   ORI A1, ZERO, -32768
9D003138  AC453008   SW A1, 12296(V0)
9D0031A4  AC453208   SW A1, 12808(V0)
9D0050D0  34028000   ORI V0, ZERO, -32768
9D0050D4  0B401442   J 0x9D005108
9D0050D8  AC820008   SW V0, 8(A0)
9D005100  34028000   ORI V0, ZERO, -32768
9D005104  AC820008   SW V0, 8(A0)
69:                  }
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  OC_Disable_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_OC_Disable 
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_OC_Disable function.
80:                      Operation is atomic.
81:                  */
82:                  
83:                  PLIB_TEMPLATE void OC_Disable_Default( OC_MODULE_ID index )
84:                  {
85:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
86:                  
87:                      regs->OCxCONCLR = OCxCON_ON_MASK;
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  OC_IsEnabled_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_OC_IsEnabled 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_OC_IsEnabled function.
99:                      Operation is atomic.
100:                 */
101:                 
102:                 PLIB_TEMPLATE bool OC_IsEnabled_Default( OC_MODULE_ID index )
103:                 {
104:                     volatile oc_register_t *regs = (volatile oc_register_t *)index;
105:                 
106:                     return regs->OCxCON.ON;
107:                 }
108:                 
109:                 
110:                 //******************************************************************************
111:                 /* Function :  OC_ExistsEnableControl_Default
112:                 
113:                   Summary:
114:                     Implements Default variant of PLIB_OC_ExistsEnableControl
115:                 
116:                   Description:
117:                     This template implements the Default variant of the PLIB_OC_ExistsEnableControl function.
118:                 */
119:                 
120:                 #define PLIB_OC_ExistsEnableControl PLIB_OC_ExistsEnableControl
121:                 PLIB_TEMPLATE bool OC_ExistsEnableControl_Default( OC_MODULE_ID index )
122:                 {
123:                     return true;
124:                 }
125:                 
126:                 
127:                 #endif /*_OC_ENABLECONTROL_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/oc/templates/oc_comparemodeselect_default.h
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_CompareModeSelect_Default.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CompareModeSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OC_ModeSelect
16:                          PLIB_OC_ExistsCompareModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OC_COMPAREMODESELECT_DEFAULT_H
47:                  #define _OC_COMPAREMODESELECT_DEFAULT_H
48:                  
49:                  #include "oc_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OC_ModeSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_OC_ModeSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_OC_ModeSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void OC_ModeSelect_Default( OC_MODULE_ID index , OC_COMPARE_MODES cmpMode )
62:                  {
63:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
64:                  
65:                      regs->OCxCON.OCM = cmpMode;
9D0030F8  24503000   ADDIU S0, V0, 12288
9D0030FC  94453000   LHU A1, 12288(V0)
9D003100  24080005   ADDIU T0, ZERO, 5
9D003104  7D051004   INS A1, T0, 0, 3
9D003108  A4453000   SH A1, 12288(V0)
9D003174  94443200   LHU A0, 12800(V0)
9D003178  24060003   ADDIU A2, ZERO, 3
9D00317C  7CC41004   INS A0, A2, 0, 3
9D003180  A4443200   SH A0, 12800(V0)
9D0050BC  24443400   ADDIU A0, V0, 13312
9D0050C0  94433400   LHU V1, 13312(V0)
9D0050C4  24050001   ADDIU A1, ZERO, 1
9D0050C8  7CA31004   INS V1, A1, 0, 3
9D0050CC  A4433400   SH V1, 13312(V0)
9D0050EC  24443400   ADDIU A0, V0, 13312
9D0050F0  94433400   LHU V1, 13312(V0)
9D0050F4  24050002   ADDIU A1, ZERO, 2
9D0050F8  7CA31004   INS V1, A1, 0, 3
9D0050FC  A4433400   SH V1, 13312(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  OC_ExistsCompareModeSelect_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_OC_ExistsCompareModeSelect
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_OC_ExistsCompareModeSelect function.
77:                  */
78:                  
79:                  #define PLIB_OC_ExistsCompareModeSelect PLIB_OC_ExistsCompareModeSelect
80:                  PLIB_TEMPLATE bool OC_ExistsCompareModeSelect_Default( OC_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_OC_COMPAREMODESELECT_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/oc/templates/oc_buffervalue_32bit_variant.h
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_BufferValue_32Bit_Variant.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BufferValue
13:                      and its Variant : 32Bit_Variant
14:                      For following APIs :
15:                          PLIB_OC_Buffer32BitSet
16:                          PLIB_OC_Buffer16BitSet
17:                          PLIB_OC_ExistsBufferValue
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OC_BUFFERVALUE_32BIT_VARIANT_H
48:                  #define _OC_BUFFERVALUE_32BIT_VARIANT_H
49:                  
50:                  #include "oc_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  OC_Buffer32BitSet_32Bit_Variant
54:                  
55:                    Summary:
56:                      Implements 32Bit_Variant variant of PLIB_OC_Buffer32BitSet 
57:                  
58:                    Description:
59:                      This template implements the 32Bit_Variant variant of the PLIB_OC_Buffer32BitSet function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void OC_Buffer32BitSet_32Bit_Variant( OC_MODULE_ID index , uint32_t val32Bit )
63:                  {
64:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
65:                  
66:                      regs->OCxR = val32Bit;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  OC_Buffer16BitSet_32Bit_Variant
72:                  
73:                    Summary:
74:                      Implements 32Bit_Variant variant of PLIB_OC_Buffer16BitSet 
75:                  
76:                    Description:
77:                      This template implements the 32Bit_Variant variant of the PLIB_OC_Buffer16BitSet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void OC_Buffer16BitSet_32Bit_Variant( OC_MODULE_ID index , uint16_t val16Bit )
81:                  {
82:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
83:                  
84:                      regs->OCxR = val16Bit;
9D003124  240501C6   ADDIU A1, ZERO, 454
9D003128  AC453010   SW A1, 12304(V0)
9D00319C  24040266   ADDIU A0, ZERO, 614
9D0031A0  AC443210   SW A0, 12816(V0)
9D0031C0  AC403410   SW ZERO, 13328(V0)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  OC_ExistsBufferValue_32Bit_Variant
90:                  
91:                    Summary:
92:                      Implements 32Bit_Variant variant of PLIB_OC_ExistsBufferValue
93:                  
94:                    Description:
95:                      This template implements the 32Bit_Variant variant of the PLIB_OC_ExistsBufferValue function.
96:                  */
97:                  
98:                  #define PLIB_OC_ExistsBufferValue PLIB_OC_ExistsBufferValue
99:                  PLIB_TEMPLATE bool OC_ExistsBufferValue_32Bit_Variant( OC_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 #endif /*_OC_BUFFERVALUE_32BIT_VARIANT_H*/
105:                 
106:                 /******************************************************************************
107:                  End of File
108:                 */
109:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/oc/templates/oc_buffersize_default.h
1:                   /*******************************************************************************
2:                     OC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       oc_BufferSize_Default.h
6:                   
7:                     Summary:
8:                       OC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BufferSize
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OC_BufferSizeSelect
16:                          PLIB_OC_ExistsBufferSize
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OC_BUFFERSIZE_DEFAULT_H
47:                  #define _OC_BUFFERSIZE_DEFAULT_H
48:                  
49:                  #include "oc_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OC_BufferSizeSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_OC_BufferSizeSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_OC_BufferSizeSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void OC_BufferSizeSelect_Default( OC_MODULE_ID index , OC_BUFFER_SIZE size )
62:                  {
63:                      volatile oc_register_t *regs = (volatile oc_register_t *)index;
64:                  
65:                      regs->OCxCON.OC32 = size;
9D00310C  94453000   LHU A1, 12288(V0)
9D003110  7C052944   INS A1, ZERO, 5, 1
9D003114  A4453000   SH A1, 12288(V0)
9D003184  94443200   LHU A0, 12800(V0)
9D003188  7C042944   INS A0, ZERO, 5, 1
9D00318C  A4443200   SH A0, 12800(V0)
9D0031A8  94433400   LHU V1, 13312(V0)
9D0031AC  7C032944   INS V1, ZERO, 5, 1
9D0031B0  A4433400   SH V1, 13312(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  OC_ExistsBufferSize_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_OC_ExistsBufferSize
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_OC_ExistsBufferSize function.
77:                  */
78:                  
79:                  #define PLIB_OC_ExistsBufferSize PLIB_OC_ExistsBufferSize
80:                  PLIB_TEMPLATE bool OC_ExistsBufferSize_Default( OC_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_OC_BUFFERSIZE_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/int/templates/int_vectorselect_default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_VectorSelect_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : VectorSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsVectorSelect
16:                          PLIB_INT_MultiVectorSelect
17:                          PLIB_INT_SingleVectorSelect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _INT_VECTORSELECT_DEFAULT_H
48:                  #define _INT_VECTORSELECT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  INT_ExistsVectorSelect_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_INT_ExistsVectorSelect
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_INT_ExistsVectorSelect function.
58:                  */
59:                  #define PLIB_INT_ExistsVectorSelect PLIB_INT_ExistsVectorSelect
60:                  PLIB_TEMPLATE bool INT_ExistsVectorSelect_Default( INT_MODULE_ID index )
61:                  {
62:                      return true;
63:                  }
64:                  
65:                  //******************************************************************************
66:                  /* Function :  INT_MultiVectorSelect_Default
67:                  
68:                    Summary:
69:                      Implements Default variant of PLIB_INT_MultiVectorSelect 
70:                  
71:                    Description:
72:                      This template implements the Default variant of the PLIB_INT_MultiVectorSelect function.
73:                  */
74:                  PLIB_TEMPLATE void INT_MultiVectorSelect_Default( INT_MODULE_ID index )
75:                  {
76:                      INTCONSET = _INTCON_MVEC_MASK;
9D00309C  24041000   ADDIU A0, ZERO, 4096
9D0030A0  3C03BF88   LUI V1, -16504
9D0030A4  AC641008   SW A0, 4104(V1)
9D009AAC  24031000   ADDIU V1, ZERO, 4096
77:                  }
78:                  
79:                  //******************************************************************************
80:                  /* Function :  INT_SingleVectorSelect_Default
81:                  
82:                    Summary:
83:                      Implements Default variant of PLIB_INT_SingleVectorSelect 
84:                  
85:                    Description:
86:                      This template implements the Default variant of the PLIB_INT_SingleVectorSelect function.
87:                  */
88:                  PLIB_TEMPLATE void INT_SingleVectorSelect_Default( INT_MODULE_ID index )
89:                  {
90:                      INTCONCLR = _INTCON_MVEC_MASK;
91:                  }
92:                  
93:                  #endif /*_INT_VECTORSELECT_DEFAULT_H*/
94:                  
95:                  /******************************************************************************
96:                   End of File
97:                  */
98:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/int/templates/int_vectorpriority_default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_VectorPriority_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : VectorPriority
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsVectorPriority
16:                          PLIB_INT_VectorPrioritySet
17:                          PLIB_INT_VectorPriorityGet
18:                          PLIB_INT_VectorSubPrioritySet
19:                          PLIB_INT_VectorSubPriorityGet
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _INT_VECTORPRIORITY_DEFAULT_H
50:                  #define _INT_VECTORPRIORITY_DEFAULT_H
51:                  
52:                  //******************************************************************************
53:                  /* Function :  INT_ExistsVectorPriority_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_INT_ExistsVectorPriority
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_INT_ExistsVectorPriority function.
60:                  */
61:                  #define PLIB_INT_ExistsVectorPriority PLIB_INT_ExistsVectorPriority
62:                  PLIB_TEMPLATE bool INT_ExistsVectorPriority_Default( INT_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  //******************************************************************************
68:                  /* Function :  INT_VectorPrioritySet_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_INT_VectorPrioritySet 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_INT_VectorPrioritySet function.
75:                  
76:                    Note:
77:                      The algorithm to calculate and write the field location has changed to use
78:                      actual vector numbers. The enumeration for INT_VECTOR should now match the
79:                      names to the actual vector numbers.
80:                  */
81:                  PLIB_TEMPLATE void INT_VectorPrioritySet_Default( INT_MODULE_ID index , INT_VECTOR vector , INT_PRIORITY_LEVEL priority )
82:                  {
83:                      volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
84:                      uint32_t mask = 0x07 << ((vector & 0x03) * 8 + 2);
85:                      uint32_t position = (vector & 0x03) * 8 + 2;
86:                  
87:                      /* read-modify-write */
88:                      *IPCx &= ~mask;
9D0030A8  3C03BF88   LUI V1, -16504
9D0030AC  24631090   ADDIU V1, V1, 4240
9D0030B0  8C650020   LW A1, 32(V1)
9D0030B4  7C052084   INS A1, ZERO, 2, 3
9D0030B8  AC650020   SW A1, 32(V1)
9D00313C  8C680020   LW T0, 32(V1)
9D003140  7C08A484   INS T0, ZERO, 18, 3
9D003144  AC680020   SW T0, 32(V1)
9D006448  3C10BF88   LUI S0, -16504
9D00644C  26101090   ADDIU S0, S0, 4240
9D006450  8E020010   LW V0, 16(S0)
9D006454  7C022084   INS V0, ZERO, 2, 3
9D006458  AE020010   SW V0, 16(S0)
9D006490  8E020070   LW V0, 112(S0)
9D006494  7C02A484   INS V0, ZERO, 18, 3
9D006498  AE020070   SW V0, 112(S0)
89:                      *IPCx |= (priority << position) & mask;
9D0030BC  8C650020   LW A1, 32(V1)
9D0030C0  34A5001C   ORI A1, A1, 28
9D0030C4  AC650020   SW A1, 32(V1)
9D003148  8C690020   LW T1, 32(V1)
9D00314C  3C080018   LUI T0, 24
9D003150  01284025   OR T0, T1, T0
9D003154  AC680020   SW T0, 32(V1)
9D00645C  8E020010   LW V0, 16(S0)
9D006460  34420004   ORI V0, V0, 4
9D006464  AE020010   SW V0, 16(S0)
9D00649C  8E030070   LW V1, 112(S0)
9D0064A0  3C020010   LUI V0, 16
9D0064A4  00621025   OR V0, V1, V0
9D0064A8  AE020070   SW V0, 112(S0)
90:                  }
91:                  
92:                  //******************************************************************************
93:                  /* Function :  INT_VectorPriorityGet_Default
94:                  
95:                    Summary:
96:                      Implements Default variant of PLIB_INT_VectorPriorityGet 
97:                  
98:                    Description:
99:                      This template implements the Default variant of the PLIB_INT_VectorPriorityGet function.
100:                 
101:                   Note:
102:                     The algorithm to calculate and write the field location has changed to use
103:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
104:                     names to the actual vector numbers.
105:                 */
106:                 PLIB_TEMPLATE INT_PRIORITY_LEVEL INT_VectorPriorityGet_Default( INT_MODULE_ID index , INT_VECTOR vector )
107:                 {
108:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
109:                     uint32_t mask = 0x07 << (((vector & 0x03) * 8) + 2);
110:                     uint32_t position = (((vector & 0x03) * 8) + 2);
111:                 
112:                     return (INT_PRIORITY_LEVEL) ((*IPCx & mask) >> position);
113:                 }
114:                 
115:                 //******************************************************************************
116:                 /* Function :  INT_VectorSubPrioritySet_Default
117:                 
118:                   Summary:
119:                     Implements Default variant of PLIB_INT_VectorSubPrioritySet 
120:                 
121:                   Description:
122:                     This template implements the Default variant of the PLIB_INT_VectorSubPrioritySet function.
123:                 
124:                   Note:
125:                     The algorithm to calculate and write the field location has changed to use
126:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
127:                     names to the actual vector numbers.
128:                 */
129:                 PLIB_TEMPLATE void INT_VectorSubPrioritySet_Default( INT_MODULE_ID index , INT_VECTOR vector , INT_SUBPRIORITY_LEVEL subPriority )
130:                 {
131:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
132:                     uint32_t mask = 0x03 << ((vector & 0x03) * 8);
133:                     uint32_t position = (vector & 0x03) * 8;
134:                 
135:                     /* read-modify-write */
136:                     *IPCx &= ~mask; /* zeroed mask */
9D0030C8  8C650020   LW A1, 32(V1)
9D0030CC  7C050804   INS A1, ZERO, 0, 2
9D0030D0  AC650020   SW A1, 32(V1)
9D003158  8C680020   LW T0, 32(V1)
9D00315C  7C088C04   INS T0, ZERO, 16, 2
9D003160  AC680020   SW T0, 32(V1)
9D006468  8E020010   LW V0, 16(S0)
9D00646C  7C020804   INS V0, ZERO, 0, 2
9D006470  AE020010   SW V0, 16(S0)
9D0064AC  8E020070   LW V0, 112(S0)
9D0064B0  7C028C04   INS V0, ZERO, 16, 2
9D0064B4  AE020070   SW V0, 112(S0)
137:                     *IPCx |= (subPriority << position) & mask; /* set value */
9D0030D4  8C650020   LW A1, 32(V1)
9D0030D8  AC650020   SW A1, 32(V1)
9D003164  8C680020   LW T0, 32(V1)
9D003168  AC680020   SW T0, 32(V1)
9D006474  8E020010   LW V0, 16(S0)
9D006478  AE020010   SW V0, 16(S0)
9D0064B8  8E020070   LW V0, 112(S0)
9D0064BC  AE020070   SW V0, 112(S0)
138:                 }
139:                 
140:                 //******************************************************************************
141:                 /* Function :  INT_VectorSubPriorityGet_Default
142:                 
143:                   Summary:
144:                     Implements Default variant of PLIB_INT_VectorSubPriorityGet 
145:                 
146:                   Description:
147:                     This template implements the Default variant of the PLIB_INT_VectorSubPriorityGet function.
148:                 
149:                   Note:
150:                     The algorithm to calculate and write the field location has changed to use
151:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
152:                     names to the actual vector numbers.
153:                 */
154:                 PLIB_TEMPLATE INT_SUBPRIORITY_LEVEL INT_VectorSubPriorityGet_Default( INT_MODULE_ID index , INT_VECTOR vector )
155:                 {
156:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
157:                     uint32_t mask = 0x03 << ((vector & 0x03) * 8);
158:                     uint32_t position = (vector & 0x03) * 8;
159:                 
160:                     return (INT_SUBPRIORITY_LEVEL) ((*IPCx & mask) >> position);
161:                 }
162:                 
163:                 #endif /*_INT_VECTORPRIORITY_DEFAULT_H*/
164:                 
165:                 /******************************************************************************
166:                  End of File
167:                 */
168:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/int/templates/int_sourceflag_default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_SourceFlag_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SourceFlag
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsSourceFlag
16:                          PLIB_INT_SourceFlagGet
17:                          PLIB_INT_SourceFlagSet
18:                          PLIB_INT_SourceFlagClear
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_SOURCEFLAG_DEFAULT_H
49:                  #define _INT_SOURCEFLAG_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  INT_ExistsSourceFlag_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_INT_ExistsSourceFlag
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_INT_ExistsSourceFlag function.
59:                  */
60:                  #define PLIB_INT_ExistsSourceFlag PLIB_INT_ExistsSourceFlag
61:                  PLIB_TEMPLATE bool INT_ExistsSourceFlag_Default( INT_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  //******************************************************************************
67:                  /* Function :  INT_SourceFlagGet_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_INT_SourceFlagGet 
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_INT_SourceFlagGet function.
74:                  
75:                    Note:
76:                      The source enum encoding is (x * 32) + y, where x is the register number 
77:                      (IFSx) and y is the bit position. 0b0xxy_yyyy
78:                  */
79:                  PLIB_TEMPLATE bool INT_SourceFlagGet_Default( INT_MODULE_ID index , INT_SOURCE source )
80:                  {
81:                      volatile uint32_t *IFSx = (volatile uint32_t *)(&IFS0 + ((0x10 * (source / 32)) / 4));
9D007894  00022142   SRL A0, V0, 5
82:                  
83:                      return (bool)((*IFSx >> (source & 0x1f)) & 0x1);
9D0078A8  8C640000   LW A0, 0(V1)
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  INT_SourceFlagSet_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_INT_SourceFlagSet 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_INT_SourceFlagSet function.
94:                  
95:                    Note:
96:                      The source enum encoding is (x * 32) + y, where x is the register number 
97:                      (IFSx) and y is the bit position. 0b0xxy_yyyy
98:                  */
99:                  PLIB_TEMPLATE void INT_SourceFlagSet_Default( INT_MODULE_ID index , INT_SOURCE source )
100:                 {
101:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
102:                     volatile uint32_t *IFSxSET = (volatile uint32_t *)(IFSx + 2);
103:                 
104:                     *IFSxSET = 1 << (source & 0x1f);
105:                 }
106:                 
107:                 //******************************************************************************
108:                 /* Function :  INT_SourceFlagClear_Default
109:                 
110:                   Summary:
111:                     Implements Default variant of PLIB_INT_SourceFlagClear 
112:                 
113:                   Description:
114:                     This template implements the Default variant of the PLIB_INT_SourceFlagClear function.
115:                 
116:                   Note:
117:                     The source enum encoding is (x * 32) + y, where x is the register number 
118:                     (IFSx) and y is the bit position. 0b0xxy_yyyy
119:                 */
120:                 PLIB_TEMPLATE void INT_SourceFlagClear_Default( INT_MODULE_ID index , INT_SOURCE source )
121:                 {
122:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
9D006018  00021942   SRL V1, V0, 5
9D00601C  00031900   SLL V1, V1, 4
9D006020  3C05BF88   LUI A1, -16504
9D006024  24A51030   ADDIU A1, A1, 4144
9D006028  00A32821   ADDU A1, A1, V1
9D007B30  00022142   SRL A0, V0, 5
9D007B34  00042100   SLL A0, A0, 4
9D007B38  3C03BF88   LUI V1, -16504
9D007B3C  24631030   ADDIU V1, V1, 4144
9D007B40  00641821   ADDU V1, V1, A0
9D008618  00022142   SRL A0, V0, 5
9D00861C  00042100   SLL A0, A0, 4
9D008620  3C03BF88   LUI V1, -16504
9D008624  24631030   ADDIU V1, V1, 4144
9D008628  00641821   ADDU V1, V1, A0
9D008CF0  00021942   SRL V1, V0, 5
9D008CF4  00031900   SLL V1, V1, 4
9D008CF8  24A51030   ADDIU A1, A1, 4144
9D008CFC  00A32821   ADDU A1, A1, V1
123:                     volatile uint32_t *IFSxCLR = (volatile uint32_t *)(IFSx + 1);
124:                 
125:                     *IFSxCLR = 1 << (source & 0x1f);
9D0030DC  3C07BF88   LUI A3, -16504
9D0030E0  24E71030   ADDIU A3, A3, 4144
9D0030E4  24050200   ADDIU A1, ZERO, 512
9D0030E8  ACE50004   SW A1, 4(A3)
9D00316C  ACE40004   SW A0, 4(A3)
9D005120  24030200   ADDIU V1, ZERO, 512
9D005124  3C02BF88   LUI V0, -16504
9D005128  24421030   ADDIU V0, V0, 4144
9D00512C  AC430004   SW V1, 4(V0)
9D00602C  24030001   ADDIU V1, ZERO, 1
9D006030  00431004   SLLV V0, V1, V0
9D006034  ACA20004   SW V0, 4(A1)
9D006A34  24031000   ADDIU V1, ZERO, 4096
9D006A38  3C02BF88   LUI V0, -16504
9D006A3C  24421030   ADDIU V0, V0, 4144
9D006A40  AC430004   SW V1, 4(V0)
9D0078C0  24040001   ADDIU A0, ZERO, 1
9D007B44  24040001   ADDIU A0, ZERO, 1
9D007B48  00441004   SLLV V0, A0, V0
9D007B4C  AC620004   SW V0, 4(V1)
9D00862C  24040001   ADDIU A0, ZERO, 1
9D008630  00441004   SLLV V0, A0, V0
9D008634  AC620004   SW V0, 4(V1)
9D008D00  24030001   ADDIU V1, ZERO, 1
9D008D04  00431004   SLLV V0, V1, V0
9D008D08  ACA20004   SW V0, 4(A1)
126:                 }
127:                 
128:                 #endif /*_INT_SOURCEFLAG_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/int/templates/int_sourcecontrol_default.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_SourceControl_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SourceControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsSourceControl
16:                          PLIB_INT_SourceEnable
17:                          PLIB_INT_SourceDisable
18:                          PLIB_INT_SourceIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_SOURCECONTROL_DEFAULT_H
49:                  #define _INT_SOURCECONTROL_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  INT_ExistsSourceControl_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_INT_ExistsSourceControl
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_INT_ExistsSourceControl function.
59:                  */
60:                  #define PLIB_INT_ExistsSourceControl PLIB_INT_ExistsSourceControl
61:                  PLIB_TEMPLATE bool INT_ExistsSourceControl_Default( INT_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  //******************************************************************************
67:                  /* Function :  INT_SourceEnable_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_INT_SourceEnable 
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_INT_SourceEnable function.
74:                  
75:                    Note:
76:                      The source enum encoding is (x * 32) + y, where x is the register number 
77:                      (IECx) and y is the bit position. 0b0xxy_yyyy
78:                  */
79:                  PLIB_TEMPLATE void INT_SourceEnable_Default( INT_MODULE_ID index , INT_SOURCE source )
80:                  {
81:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
9D0048FC  00022142   SRL A0, V0, 5
9D004900  00042100   SLL A0, A0, 4
9D004904  3C03BF88   LUI V1, -16504
9D004908  24631060   ADDIU V1, V1, 4192
9D00490C  00641821   ADDU V1, V1, A0
9D0056C8  00022142   SRL A0, V0, 5
9D0056CC  00042100   SLL A0, A0, 4
9D0056D0  3C03BF88   LUI V1, -16504
9D0056D4  24631060   ADDIU V1, V1, 4192
9D0056D8  00641821   ADDU V1, V1, A0
9D00603C  00022942   SRL A1, V0, 5
9D006040  00052900   SLL A1, A1, 4
9D006044  3C04BF88   LUI A0, -16504
9D006048  24841060   ADDIU A0, A0, 4192
9D00604C  00852021   ADDU A0, A0, A1
9D006924  00022142   SRL A0, V0, 5
9D006928  00042100   SLL A0, A0, 4
9D00692C  3C03BF88   LUI V1, -16504
9D006930  24631060   ADDIU V1, V1, 4192
9D006934  00641821   ADDU V1, V1, A0
9D008C4C  00022142   SRL A0, V0, 5
9D008C50  00042100   SLL A0, A0, 4
9D008C54  3C03BF88   LUI V1, -16504
9D008C58  24631060   ADDIU V1, V1, 4192
9D008C5C  00641821   ADDU V1, V1, A0
9D008D14  00023142   SRL A2, V0, 5
9D008D18  00063100   SLL A2, A2, 4
9D008D1C  3C05BF88   LUI A1, -16504
9D008D20  24A51060   ADDIU A1, A1, 4192
9D008D24  00A62821   ADDU A1, A1, A2
9D008E94  00022142   SRL A0, V0, 5
9D008E98  00042100   SLL A0, A0, 4
9D008E9C  24631060   ADDIU V1, V1, 4192
9D008EA0  00641821   ADDU V1, V1, A0
9D008FD0  00022142   SRL A0, V0, 5
9D008FD4  00042100   SLL A0, A0, 4
9D008FD8  24631060   ADDIU V1, V1, 4192
9D008FDC  00641821   ADDU V1, V1, A0
82:                      volatile uint32_t *IECxSET = (volatile uint32_t *)(IECx + 2);
83:                  
84:                      *IECxSET = 1 << (source & 0x1f);
9D0030EC  3C06BF88   LUI A2, -16504
9D0030F0  24C61060   ADDIU A2, A2, 4192
9D0030F4  ACC50008   SW A1, 8(A2)
9D003170  ACC40008   SW A0, 8(A2)
9D004910  24040001   ADDIU A0, ZERO, 1
9D004914  00441004   SLLV V0, A0, V0
9D004918  AC620008   SW V0, 8(V1)
9D0056DC  24040001   ADDIU A0, ZERO, 1
9D0056E0  00441004   SLLV V0, A0, V0
9D0056E4  AC620008   SW V0, 8(V1)
9D006050  00431004   SLLV V0, V1, V0
9D006938  24040001   ADDIU A0, ZERO, 1
9D00693C  00441004   SLLV V0, A0, V0
9D006940  AC620008   SW V0, 8(V1)
9D008C60  24040001   ADDIU A0, ZERO, 1
9D008D28  00431004   SLLV V0, V1, V0
9D008D2C  ACA20008   SW V0, 8(A1)
9D008EA4  24040001   ADDIU A0, ZERO, 1
9D008EA8  00441004   SLLV V0, A0, V0
9D008EAC  AC620008   SW V0, 8(V1)
9D008EB0  03E00008   JR RA
9D008EB4  00000000   NOP
9D008FE0  24040001   ADDIU A0, ZERO, 1
85:                  }
86:                  
87:                  //******************************************************************************
88:                  /* Function :  INT_SourceDisable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_INT_SourceDisable 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_INT_SourceDisable function.
95:                  
96:                    Note:
97:                      The source enum encoding is (x * 32) + y, where x is the register number
98:                      (IECx) and y is the bit position. 0b0xxy_yyyy
99:                  */
100:                 PLIB_TEMPLATE void INT_SourceDisable_Default( INT_MODULE_ID index , INT_SOURCE source )
101:                 {
102:                     volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
103:                     volatile uint32_t *IECxCLR = (volatile uint32_t *)(IECx + 1);
104:                 
105:                     *IECxCLR = 1 << (source & 0x1f);
9D009230  24060001   ADDIU A2, ZERO, 1
9D009234  00863004   SLLV A2, A2, A0
9D009238  AC660004   SW A2, 4(V1)
106:                 }
107:                 
108:                 //******************************************************************************
109:                 /* Function :  INT_SourceIsEnabled_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_INT_SourceIsEnabled 
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_INT_SourceIsEnabled function.
116:                 
117:                   Note:
118:                     The source enum encoding is (x * 32) + y, where x is the register number 
119:                     (IECx) and y is the bit position. 0b0xxy_yyyy
120:                 */
121:                 PLIB_TEMPLATE bool INT_SourceIsEnabled_Default( INT_MODULE_ID index , INT_SOURCE source )
122:                 {
123:                     volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
9D009214  00041142   SRL V0, A0, 5
9D009218  00021100   SLL V0, V0, 4
9D00921C  3C03BF88   LUI V1, -16504
9D009220  24631060   ADDIU V1, V1, 4192
9D009224  00621821   ADDU V1, V1, V0
124:                 
125:                     return (bool)((*IECx >> (source & 0x1f)) & 0x01);
9D009228  8C620000   LW V0, 0(V1)
9D00922C  3084001F   ANDI A0, A0, 31
9D009244  00821006   SRLV V0, V0, A0
126:                 }
127:                 
128:                 #endif /*_INT_SOURCECONTROL_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/int/templates/int_enablecontrol_pic32.h
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_EnableControl_PIC32.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : PIC32
14:                      For following APIs :
15:                          PLIB_INT_ExistsEnableControl
16:                          PLIB_INT_Enable
17:                          PLIB_INT_Disable
18:                          PLIB_INT_IsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_ENABLECONTROL_PIC32_H
49:                  #define _INT_ENABLECONTROL_PIC32_H
50:                  
51:                  #include "peripheral/int/plib_int_private_pic32.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  INT_ExistsEnableControl_PIC32
55:                  
56:                    Summary:
57:                      Implements PIC32 variant of PLIB_INT_ExistsEnableControl
58:                  
59:                    Description:
60:                      This template implements the PIC32 variant of the PLIB_INT_ExistsEnableControl function.
61:                  */
62:                  #define PLIB_INT_ExistsEnableControl PLIB_INT_ExistsEnableControl
63:                  PLIB_TEMPLATE bool INT_ExistsEnableControl_PIC32( INT_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  //******************************************************************************
69:                  /* Function :  INT_Enable_PIC32
70:                  
71:                    Summary:
72:                      Implements PIC32 variant of PLIB_INT_Enable 
73:                  
74:                    Description:
75:                      This template implements the PIC32 variant of the PLIB_INT_Enable function.
76:                  */
77:                  PLIB_TEMPLATE __attribute__((nomips16,always_inline)) void INT_Enable_PIC32( INT_MODULE_ID index )
78:                  {
79:                      __builtin_mtc0(12, 0,(__builtin_mfc0(12, 0) | 0x0001));
9D0090E4  40026000   MFC0 V0, Status
9D0090E8  34420001   ORI V0, V0, 1
9D0090EC  40826000   MTC0 V0, Status
9D0090F0  000000C0   EHB
9D00913C  40026000   MFC0 V0, Status
9D009140  34420001   ORI V0, V0, 1
9D009144  40826000   MTC0 V0, Status
9D009148  000000C0   EHB
9D00944C  40026000   MFC0 V0, Status
9D009450  34420001   ORI V0, V0, 1
9D009454  40826000   MTC0 V0, Status
9D009458  000000C0   EHB
80:                      
81:                  }
82:                  
83:                  //******************************************************************************
84:                  /* Function :  INT_Disable_PIC32
85:                  
86:                    Summary:
87:                      Implements PIC32 variant of PLIB_INT_Disable 
88:                  
89:                    Description:
90:                      This template implements the PIC32 variant of the PLIB_INT_Disable function.
91:                  */
92:                  PLIB_TEMPLATE __attribute__((nomips16,always_inline))void INT_Disable_PIC32( INT_MODULE_ID index )
93:                  {
94:                      __builtin_disable_interrupts();
95:                  }
96:                  
97:                  //******************************************************************************
98:                  /* Function :  PLIB_INT_SetState_PIC32
99:                  
100:                   Summary:
101:                     Implements PIC32 variant of PLIB_INT_Enable 
102:                 
103:                   Description:
104:                     This template implements the PIC32 variant of the PLIB_INT_Enable function.
105:                 */
106:                 PLIB_TEMPLATE __attribute__((nomips16,always_inline)) void INT_SetState_PIC32( INT_MODULE_ID index, INT_STATE_GLOBAL interrupt_state )
107:                 {
108:                     __builtin_mtc0(12, 0, interrupt_state);
109:                 }
110:                 
111:                 //******************************************************************************
112:                 /* Function :  PLIB_INT_GetStateAndDisable_PIC32
113:                 
114:                   Summary:
115:                     Implements PIC32 variant of PLIB_INT_Disable 
116:                 
117:                   Description:
118:                     This template implements the PIC32 variant of the PLIB_INT_Disable function.
119:                 */
120:                 INT_STATE_GLOBAL PLIB_TEMPLATE __attribute__((nomips16,always_inline)) INT_GetStateAndDisable_PIC32( INT_MODULE_ID index )
121:                 {
122:                     return (INT_STATE_GLOBAL)__builtin_disable_interrupts();
9D0090B0  41636000   DI V1
9D0090B4  000000C0   EHB
9D009118  41646000   DI A0
9D00911C  000000C0   EHB
9D009428  41626000   DI V0
9D00942C  000000C0   EHB
123:                 }
124:                 
125:                 //******************************************************************************
126:                 /* Function :  INT_IsEnabled_PIC32
127:                 
128:                   Summary:
129:                     Implements PIC32 variant of PLIB_INT_IsEnabled 
130:                 
131:                   Description:
132:                     This template implements the PIC32 variant of the PLIB_INT_IsEnabled function.
133:                 */
134:                 PLIB_TEMPLATE bool __attribute__((nomips16,always_inline)) INT_IsEnabled_PIC32( INT_MODULE_ID index )
135:                 {
136:                     return (bool)(_CP0_GET_STATUS() & 0x01);
137:                 }
138:                 
139:                 #endif /*_INT_ENABLECONTROL_PIC32_H*/
140:                 
141:                 /******************************************************************************
142:                  End of File
143:                 */
144:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/devcon/templates/devcon_syslockunlock_default.h
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_SysLockUnlock_Default.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SysLockUnlock
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DEVCON_SystemUnlock
16:                          PLIB_DEVCON_SystemLock
17:                          PLIB_DEVCON_ExistsSystemLockUnlock
18:                          PLIB_DEVCON_ExistsDeviceVerAndId
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DEVCON_SYSLOCKUNLOCK_DEFAULT_H
49:                  #define _DEVCON_SYSLOCKUNLOCK_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DEVCON_SystemUnlock_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DEVCON_SystemUnlock 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DEVCON_SystemUnlock function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void DEVCON_SystemUnlock_Default( DEVCON_MODULE_ID index )
62:                  {	
63:                  	SYSKEY = 0x00000000;
9D0090B8  3C02BF81   LUI V0, -16511
9D0090BC  AC40F230   SW ZERO, -3536(V0)
64:                  	SYSKEY = 0xAA996655;
9D0090C0  3C04AA99   LUI A0, -21863
9D0090C4  24846655   ADDIU A0, A0, 26197
9D0090C8  AC44F230   SW A0, -3536(V0)
65:                  	SYSKEY = 0x556699AA;
9D0090CC  3C045566   LUI A0, 21862
9D0090D0  348499AA   ORI A0, A0, -26198
9D0090D4  AC44F230   SW A0, -3536(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DEVCON_SystemLock_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DEVCON_SystemLock 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DEVCON_SystemLock function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void DEVCON_SystemLock_Default( DEVCON_MODULE_ID index )
80:                  {
81:                  	SYSKEY = 0x33333333;
9D009430  3C043333   LUI A0, 13107
9D009434  24843333   ADDIU A0, A0, 13107
9D009438  3C03BF81   LUI V1, -16511
9D00943C  AC64F230   SW A0, -3536(V1)
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  DEVCON_ExistsSystemLockUnlock_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_DEVCON_ExistsSystemLockUnlock
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_DEVCON_ExistsSystemLockUnlock function.
93:                  */
94:                  
95:                  #define PLIB_DEVCON_ExistsSystemLockUnlock PLIB_DEVCON_ExistsSystemLockUnlock
96:                  PLIB_TEMPLATE bool DEVCON_ExistsSystemLockUnlock_Default( DEVCON_MODULE_ID index )
97:                  {
98:                      return true;
99:                  }
100:                 
101:                 #endif /*_DEVCON_SYSLOCKUNLOCK_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/bmx/templates/bmx_dataramwaitstate_default.h
1:                   /*******************************************************************************
2:                     BMX Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       bmx_DataRamWaitState_Default.h
6:                   
7:                     Summary:
8:                       BMX PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DataRamWaitState
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_BMX_ExistsDataRamWaitState
16:                          PLIB_BMX_DataRamWaitStateSet
17:                          PLIB_BMX_DataRamWaitStateGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _BMX_DATARAMWAITSTATE_DEFAULT_H
48:                  #define _BMX_DATARAMWAITSTATE_DEFAULT_H
49:                  
50:                  #include "bmx_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  BMX_ExistsDataRamWaitState_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_BMX_ExistsDataRamWaitState
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_BMX_ExistsDataRamWaitState function.
60:                  */
61:                  
62:                  #define PLIB_BMX_ExistsDataRamWaitState PLIB_BMX_ExistsDataRamWaitState
63:                  PLIB_TEMPLATE bool BMX_ExistsDataRamWaitState_Default( BMX_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  BMX_DataRamWaitStateSet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_BMX_DataRamWaitStateSet 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_BMX_DataRamWaitStateSet function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void BMX_DataRamWaitStateSet_Default( BMX_MODULE_ID index , PLIB_BMX_DATA_RAM_WAIT_STATES wait )
80:                  {
81:                      volatile bmx_register_t *bmx = (bmx_register_t *)index;
82:                  
83:                      bmx->BMXCON.BMXWSDRM = wait;
9D009120  3C02BF88   LUI V0, -16504
9D009124  8C432000   LW V1, 8192(V0)
9D009128  7C033184   INS V1, ZERO, 6, 1
9D00912C  AC432000   SW V1, 8192(V0)
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  BMX_DataRamWaitStateGet_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_BMX_DataRamWaitStateGet 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_BMX_DataRamWaitStateGet function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE PLIB_BMX_DATA_RAM_WAIT_STATES BMX_DataRamWaitStateGet_Default( BMX_MODULE_ID index )
98:                  {
99:                      volatile bmx_register_t *bmx = (bmx_register_t *)index;
100:                 
101:                     return (PLIB_BMX_DATA_RAM_WAIT_STATES)bmx->BMXCON.BMXWSDRM;
102:                 }
103:                 
104:                 
105:                 #endif /*_BMX_DATARAMWAITSTATE_DEFAULT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/adc/templates/adc_samplingcontrol_default.h
1:                   /*******************************************************************************
2:                     ADC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adc_SamplingControl_Default.h
6:                   
7:                     Summary:
8:                       ADC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SamplingControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADC_SamplingStart
16:                          PLIB_ADC_SamplingStop
17:                          PLIB_ADC_ExistsSamplingControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _ADC_SAMPLINGCONTROL_DEFAULT_H
48:                  #define _ADC_SAMPLINGCONTROL_DEFAULT_H
49:                  
50:                  #include "adc_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  ADC_SamplingStart_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_ADC_SamplingStart 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_ADC_SamplingStart function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void ADC_SamplingStart_Default( ADC_MODULE_ID index )
63:                  {
64:                   	volatile adc_registers_t * adc = (adc_registers_t *) index;
65:                      adc->AD1CON1SET = _AD1CON1_SAMP_MASK;
9D001698  24030002   ADDIU V1, ZERO, 2
9D00169C  AC430008   SW V1, 8(V0)
9D001770  24030002   ADDIU V1, ZERO, 2
9D001774  AC430008   SW V1, 8(V0)
9D001840  24030002   ADDIU V1, ZERO, 2
9D001844  AC430008   SW V1, 8(V0)
9D001918  24030002   ADDIU V1, ZERO, 2
9D00191C  AC430008   SW V1, 8(V0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  ADC_SamplingStop_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_ADC_SamplingStop 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_ADC_SamplingStop function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void ADC_SamplingStop_Default( ADC_MODULE_ID index )
80:                  {
81:                  	volatile adc_registers_t * adc = (adc_registers_t *) index;
82:                      adc->AD1CON1CLR = _AD1CON1_SAMP_MASK;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  ADC_ExistsSamplingControl_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_ADC_ExistsSamplingControl
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_ADC_ExistsSamplingControl function.
94:                  */
95:                  
96:                  #define PLIB_ADC_ExistsSamplingControl PLIB_ADC_ExistsSamplingControl
97:                  PLIB_TEMPLATE bool ADC_ExistsSamplingControl_Default( ADC_MODULE_ID index )
98:                  {
99:                      return true;
100:                 }
101:                 
102:                 
103:                 #endif /*_ADC_SAMPLINGCONTROL_DEFAULT_H*/
104:                 
105:                 /******************************************************************************
106:                  End of File
107:                 */
108:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/adc/templates/adc_samplingacquisitiontime_default.h
1:                   /*******************************************************************************
2:                     ADC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adc_SamplingAcquisitionTime_Default.h
6:                   
7:                     Summary:
8:                       ADC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SamplingAcquisitionTime
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADC_SampleAcqusitionTimeSet
16:                          PLIB_ADC_ExistsSamplingAcquisitionTime
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _ADC_SAMPLINGACQUISITIONTIME_DEFAULT_H
47:                  #define _ADC_SAMPLINGACQUISITIONTIME_DEFAULT_H
48:                  
49:                  #include "adc_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  ADC_SampleAcqusitionTimeSet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_ADC_SampleAcqusitionTimeSet
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_ADC_SampleAcqusitionTimeSet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void ADC_SampleAcquisitionTimeSet_Default( ADC_MODULE_ID index , ADC_ACQUISITION_TIME acqTime )
62:                  {
63:                   	volatile adc_registers_t * adc = (adc_registers_t *) index;
64:                      adc->AD1CON3.SAMC = acqTime;
9D0031E4  96036020   LHU V1, 24608(S0)
9D0031E8  24040002   ADDIU A0, ZERO, 2
9D0031EC  7C836204   INS V1, A0, 8, 5
9D0031F0  A6036020   SH V1, 24608(S0)
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  ADC_ExistsSamplingAcquisitionTime_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_ADC_ExistsSamplingAcquisitionTime
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_ADC_ExistsSamplingAcquisitionTime function.
76:                  */
77:                  
78:                  #define PLIB_ADC_ExistsSamplingAcquisitionTime PLIB_ADC_ExistsSamplingAcquisitionTime
79:                  PLIB_TEMPLATE bool ADC_ExistsSamplingAcquisitionTime_Default( ADC_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_ADC_SAMPLINGACQUISITIONTIME_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/adc/templates/adc_resultgetbyindex_default.h
1:                   /*******************************************************************************
2:                     ADC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adc_ResultGetByIndex_Default.h
6:                   
7:                     Summary:
8:                       ADC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ResultGetByIndex
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADC_ResultGetByIndex
16:                          PLIB_ADC_ExistsResultGetByIndex
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _ADC_RESULTGETBYINDEX_DEFAULT_H
47:                  #define _ADC_RESULTGETBYINDEX_DEFAULT_H
48:                  
49:                  #include "adc_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  ADC_ResultGetByIndex_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_ADC_ResultGetByIndex 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_ADC_ResultGetByIndex function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE ADC_SAMPLE ADC_ResultGetByIndex_Default( ADC_MODULE_ID index , uint8_t bufferIndex )
62:                  {
63:                   	volatile adc_registers_t * adc = (adc_registers_t *) index;
64:                  	return	(ADC_SAMPLE) adc->ADC1BUFX[bufferIndex].ADC1BUF;
9D0016AC  3C02BF80   LUI V0, -16512
9D0016B0  34429000   ORI V0, V0, -28672
9D0016B4  8C450070   LW A1, 112(V0)
9D001780  3C02BF80   LUI V0, -16512
9D001784  34429000   ORI V0, V0, -28672
9D001788  8C450070   LW A1, 112(V0)
9D001854  3C02BF80   LUI V0, -16512
9D001858  34429000   ORI V0, V0, -28672
9D00185C  8C450070   LW A1, 112(V0)
9D00192C  3C02BF80   LUI V0, -16512
9D001930  34429000   ORI V0, V0, -28672
9D001934  8C450070   LW A1, 112(V0)
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  ADC_ExistsResultGetByIndex_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_ADC_ExistsResultGetByIndex
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_ADC_ExistsResultGetByIndex function.
76:                  */
77:                  
78:                  #define PLIB_ADC_ExistsResultGetByIndex PLIB_ADC_ExistsResultGetByIndex
79:                  PLIB_TEMPLATE bool ADC_ExistsResultGetByIndex_Default( ADC_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_ADC_RESULTGETBYINDEX_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/adc/templates/adc_muxinputscanselect_default.h
1:                   /*******************************************************************************
2:                     ADC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adc_MuxInputScanSelect_Default.h
6:                   
7:                     Summary:
8:                       ADC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : MuxInputScanSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADC_InputScanMaskAdd
16:                          PLIB_ADC_InputScanMaskRemove
17:                          PLIB_ADC_ExistsMuxInputScanSelect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _ADC_MUXINPUTSCANSELECT_DEFAULT_H
48:                  #define _ADC_MUXINPUTSCANSELECT_DEFAULT_H
49:                  
50:                  #include "adc_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  ADC_InputScanMaskAdd_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_ADC_InputScanMaskAdd 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_ADC_InputScanMaskAdd function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void ADC_InputScanMaskAdd_Default( ADC_MODULE_ID index , ADC_INPUTS_SCAN scanInputs )
63:                  {
64:                  	volatile adc_registers_t * adc = (adc_registers_t *) index;
65:                  	adc->AD1CSSLSET = (uint32_t) (adc->AD1CSSL.w | scanInputs);
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  ADC_InputScanMaskRemove_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_ADC_InputScanMaskRemove 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_ADC_InputScanMaskRemove function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void ADC_InputScanMaskRemove_Default( ADC_MODULE_ID index , ADC_INPUTS_SCAN scanInputs )
80:                  {
81:                  	volatile adc_registers_t * adc = (adc_registers_t *) index;
82:                  	adc->AD1CSSLCLR = scanInputs;
9D0031DC  24030400   ADDIU V1, ZERO, 1024
9D0031E0  AE036054   SW V1, 24660(S0)
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  ADC_ExistsMuxInputScanSelect_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_ADC_ExistsMuxInputScanSelect
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_ADC_ExistsMuxInputScanSelect function.
94:                  */
95:                  
96:                  #define PLIB_ADC_ExistsMuxInputScanSelect PLIB_ADC_ExistsMuxInputScanSelect
97:                  PLIB_TEMPLATE bool ADC_ExistsMuxInputScanSelect_Default( ADC_MODULE_ID index )
98:                  {
99:                      return true;
100:                 }
101:                 
102:                 
103:                 #endif /*_ADC_MUXINPUTSCANSELECT_DEFAULT_H*/
104:                 
105:                 /******************************************************************************
106:                  End of File
107:                 */
108:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/adc/templates/adc_muxchannel0positiveinput_default.h
1:                   /*******************************************************************************
2:                     ADC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adc_MuxChannel0PositiveInput_Default.h
6:                   
7:                     Summary:
8:                       ADC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : MuxChannel0PositiveInput
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADC_MuxChannel0InputPositiveSelect
16:                          PLIB_ADC_ExistsMuxChannel0PositiveInput
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _ADC_MUXCHANNEL0POSITIVEINPUT_DEFAULT_H
47:                  #define _ADC_MUXCHANNEL0POSITIVEINPUT_DEFAULT_H
48:                  
49:                  #include "adc_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  ADC_MuxChannel0InputPositiveSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_ADC_MuxChannel0InputPositiveSelect
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_ADC_MuxChannel0InputPositiveSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void ADC_MuxChannel0InputPositiveSelect_Default( ADC_MODULE_ID index , ADC_MUX muxType , ADC_INPUTS_POSITIVE input )
62:                  {
63:                      volatile adc_registers_t * adc = (adc_registers_t *) index;
64:                  	if ( muxType == ADC_MUX_B)
65:                  	{
66:                      	adc->AD1CHS.CH0SB = input;
67:                  	}
68:                  	else
69:                  	{
70:                      	adc->AD1CHS.CH0SA = input;
9D001680  3C02BF80   LUI V0, -16512
9D001684  34429000   ORI V0, V0, -28672
9D001688  8C430040   LW V1, 64(V0)
9D00168C  24040009   ADDIU A0, ZERO, 9
9D001690  7C839C04   INS V1, A0, 16, 4
9D001694  AC430040   SW V1, 64(V0)
9D001758  3C02BF80   LUI V0, -16512
9D00175C  34429000   ORI V0, V0, -28672
9D001760  8C430040   LW V1, 64(V0)
9D001764  2404000A   ADDIU A0, ZERO, 10
9D001768  7C839C04   INS V1, A0, 16, 4
9D00176C  AC430040   SW V1, 64(V0)
9D00182C  3C02BF80   LUI V0, -16512
9D001830  34429000   ORI V0, V0, -28672
9D001834  8C430040   LW V1, 64(V0)
9D001838  7C039C04   INS V1, ZERO, 16, 4
9D00183C  AC430040   SW V1, 64(V0)
9D001900  3C02BF80   LUI V0, -16512
9D001904  34429000   ORI V0, V0, -28672
9D001908  8C430040   LW V1, 64(V0)
9D00190C  24040001   ADDIU A0, ZERO, 1
9D001910  7C839C04   INS V1, A0, 16, 4
9D001914  AC430040   SW V1, 64(V0)
71:                  	}
72:                  }
73:                  
74:                  
75:                  //******************************************************************************
76:                  /* Function :  ADC_ExistsMuxChannel0PositiveInput_Default
77:                  
78:                    Summary:
79:                      Implements Default variant of PLIB_ADC_ExistsMuxChannel0PositiveInput
80:                  
81:                    Description:
82:                      This template implements the Default variant of the PLIB_ADC_ExistsMuxChannel0PositiveInput function.
83:                  */
84:                  
85:                  #define PLIB_ADC_ExistsMuxChannel0PositiveInput PLIB_ADC_ExistsMuxChannel0PositiveInput
86:                  PLIB_TEMPLATE bool ADC_ExistsMuxChannel0PositiveInput_Default( ADC_MODULE_ID index )
87:                  {
88:                      return true;
89:                  }
90:                  
91:                  
92:                  #endif /*_ADC_MUXCHANNEL0POSITIVEINPUT_DEFAULT_H*/
93:                  
94:                  /******************************************************************************
95:                   End of File
96:                  */
97:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/adc/templates/adc_enablecontrol_default.h
1:                   /*******************************************************************************
2:                     ADC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adc_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       ADC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADC_Enable
16:                          PLIB_ADC_Disable
17:                          PLIB_ADC_ExistsEnableControl
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _ADC_ENABLECONTROL_DEFAULT_H
48:                  #define _ADC_ENABLECONTROL_DEFAULT_H
49:                  
50:                  #include "adc_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  ADC_Enable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_ADC_Enable 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_ADC_Enable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void ADC_Enable_Default( ADC_MODULE_ID index )
63:                  {
64:                   	volatile adc_registers_t * adc = (adc_registers_t *) index;
65:                      adc->AD1CON1.ON = 1;
9D0031FC  96026000   LHU V0, 24576(S0)
9D003200  7E227BC4   INS V0, S1, 15, 1
9D003204  A6026000   SH V0, 24576(S0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  ADC_Disable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_ADC_Disable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_ADC_Disable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void ADC_Disable_Default( ADC_MODULE_ID index )
80:                  {
81:                      volatile adc_registers_t * adc = (adc_registers_t *) index;
82:                      adc->AD1CON1.ON = 0;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  ADC_ExistsEnableControl_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_ADC_ExistsEnableControl
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_ADC_ExistsEnableControl function.
94:                  */
95:                  
96:                  #define PLIB_ADC_ExistsEnableControl PLIB_ADC_ExistsEnableControl
97:                  PLIB_TEMPLATE bool ADC_ExistsEnableControl_Default( ADC_MODULE_ID index )
98:                  {
99:                      return true;
100:                 }
101:                 
102:                 
103:                 #endif /*_ADC_ENABLECONTROL_DEFAULT_H*/
104:                 
105:                 /******************************************************************************
106:                  End of File
107:                 */
108:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/adc/templates/adc_conversiontriggersource_default.h
1:                   /*******************************************************************************
2:                     ADC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adc_ConversionTriggerSource_Default.h
6:                   
7:                     Summary:
8:                       ADC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ConversionTriggerSource
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADC_ConversionTriggerSourceSelect
16:                          PLIB_ADC_ExistsConversionTriggerSource
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _ADC_CONVERSIONTRIGGERSOURCE_DEFAULT_H
47:                  #define _ADC_CONVERSIONTRIGGERSOURCE_DEFAULT_H
48:                  
49:                  #include "adc_registers.h"
50:                  
51:                  
52:                  //******************************************************************************
53:                  /* Function :  ADC_ConversionTriggerSourceSelect_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_ADC_ConversionTriggerSourceSelect 
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_ADC_ConversionTriggerSourceSelect function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void ADC_ConversionTriggerSourceSelect_Default( ADC_MODULE_ID index , ADC_CONVERSION_TRIGGER_SOURCE source )
63:                  {
64:                  	volatile adc_registers_t * adc = (adc_registers_t *) index;
65:                  	adc->AD1CON1.SSRC = source;
9D0031CC  96036000   LHU V1, 24576(S0)
9D0031D0  24040007   ADDIU A0, ZERO, 7
9D0031D4  7C833944   INS V1, A0, 5, 3
9D0031D8  A6036000   SH V1, 24576(S0)
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  ADC_ExistsConversionTriggerSource_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_ADC_ExistsConversionTriggerSource
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_ADC_ExistsConversionTriggerSource function.
77:                  */
78:                  
79:                  #define PLIB_ADC_ExistsConversionTriggerSource PLIB_ADC_ExistsConversionTriggerSource
80:                  PLIB_TEMPLATE bool ADC_ExistsConversionTriggerSource_Default( ADC_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_ADC_CONVERSIONTRIGGERSOURCE_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/peripheral/adc/templates/adc_conversionclock_default.h
1:                   /*******************************************************************************
2:                     ADC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       adc_ConversionClock_Default.h
6:                   
7:                     Summary:
8:                       ADC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ConversionClock
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_ADC_ConversionClockSet
16:                          PLIB_ADC_ConversionClockGet
17:                          PLIB_ADC_ExistsConversionClock
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _ADC_CONVERSIONCLOCK_DEFAULT_H
48:                  #define _ADC_CONVERSIONCLOCK_DEFAULT_H
49:                  
50:                  #include "adc_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  ADC_ConversionClockSet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_ADC_ConversionClockSet
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_ADC_ConversionClockSet function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void ADC_ConversionClockSet_Default( ADC_MODULE_ID index , uint32_t baseFrequency , ADC_CONVERSION_CLOCK value )
63:                  {
64:                      char regValue = ((baseFrequency/value)/2) - 1;
65:                  	volatile adc_registers_t * adc = (adc_registers_t *) index;
66:                  	adc->AD1CON3SET = (_AD1CON3_ADCS_MASK & ((uint32_t) regValue << _AD1CON3_ADCS_POSITION));
9D0031F4  24110001   ADDIU S1, ZERO, 1
9D0031F8  AE116028   SW S1, 24616(S0)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  ADC_ConversionClockGet_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_ADC_ConversionClockGet
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_ADC_ConversionClockGet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint32_t ADC_ConversionClockGet_Default( ADC_MODULE_ID index , uint32_t baseFrequency )
81:                  {
82:                      char regValue;
83:                      volatile adc_registers_t * adc = (adc_registers_t *) index;
84:                      
85:                  	regValue = 	adc->AD1CON3.ADCS;
86:                  
87:                  	return 	((baseFrequency/(regValue + 1))/2);
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  ADC_ExistsConversionClock_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_ADC_ExistsConversionClock
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_ADC_ExistsConversionClock function.
99:                  */
100:                 
101:                 #define PLIB_ADC_ExistsConversionClock PLIB_ADC_ExistsConversionClock
102:                 PLIB_TEMPLATE bool ADC_ExistsConversionClock_Default( ADC_MODULE_ID index )
103:                 {
104:                     return true;
105:                 }
106:                 
107:                 
108:                 #endif /*_ADC_CONVERSIONCLOCK_DEFAULT_H*/
109:                 
110:                 /******************************************************************************
111:                  End of File
112:                 */
113:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/osal/osal_impl_basic.h
1:                   /*******************************************************************************
2:                     Operating System Abstraction Layer Basic Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       osal_impl_basic.h
9:                   
10:                    Summary:
11:                      Header file for the OSAL Basic implementation.
12:                  
13:                    Description:
14:                      This file defines the additions or variations to the OSAL base implementation.
15:                   Where it is logical or possible to implement an OSAL function in a simple form
16:                   without an RTOS being present then the function has been defined here and
17:                   implemented either here as an inline or #define. Longer functions that are part
18:                   of the basic implementation may also be found in the file osal.c
19:                   The best way to consider this file is detailing any deviations from the osal.h
20:                   definitions OR as the complete implementation of those functions when pretending
21:                   to support BASIC operations.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  #ifndef _OSAL_IMPL_BASIC_H
50:                  #define _OSAL_IMPL_BASIC_H
51:                  
52:                  #ifdef __cplusplus
53:                  extern "C" {
54:                  #endif
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  #include <stdint.h>
62:                  #include <stdbool.h>
63:                  #include "system/int/sys_int.h"
64:                  
65:                  
66:                  typedef uint8_t                     OSAL_SEM_HANDLE_TYPE;
67:                  typedef uint8_t                     OSAL_MUTEX_HANDLE_TYPE;
68:                  typedef uint32_t                    OSAL_CRITSECT_DATA_TYPE;
69:                  #define OSAL_WAIT_FOREVER           (uint16_t) 0xFFFF
70:                  
71:                  #define OSAL_SEM_DECLARE(semID)         uint8_t    semID
72:                  #define OSAL_MUTEX_DECLARE(mutexID)     uint8_t    mutexID
73:                  
74:                  // *****************************************************************************
75:                  /* Macro: OSAL_ASSERT
76:                   */
77:                  
78:                  #define OSAL_ASSERT(test, message)      test
79:                  
80:                  // *****************************************************************************
81:                  /* OSAL Result type
82:                  
83:                    Summary:
84:                      Enumerated type representing the general return value from OSAL functions.
85:                  
86:                    Description:
87:                      This enum represents possible return types from OSAL functions.
88:                  
89:                    Remarks:
90:                      These enum values are the possible return values from OSAL functions
91:                      where a standard success/fail type response is required. The majority
92:                      of OSAL functions will return this type with a few exceptions.
93:                  */
94:                  
95:                  typedef enum OSAL_SEM_TYPE
96:                  {
97:                      OSAL_SEM_TYPE_BINARY,
98:                      OSAL_SEM_TYPE_COUNTING
99:                  } OSAL_SEM_TYPE;
100:                 
101:                 typedef enum OSAL_CRIT_TYPE
102:                 {
103:                     OSAL_CRIT_TYPE_LOW,
104:                     OSAL_CRIT_TYPE_HIGH
105:                 } OSAL_CRIT_TYPE;
106:                 
107:                 typedef enum OSAL_RESULT
108:                 {
109:                     OSAL_RESULT_NOT_IMPLEMENTED = -1,
110:                     OSAL_RESULT_FALSE = 0,
111:                     OSAL_RESULT_TRUE = 1
112:                 } OSAL_RESULT;
113:                 
114:                 // *****************************************************************************
115:                 // *****************************************************************************
116:                 // Section: Section: Interface Routines Group Declarations
117:                 // *****************************************************************************
118:                 // *****************************************************************************
119:                 static __inline__ OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type, uint8_t maxCount, uint8_t initialCount);
120:                 static __inline__ OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* semID);
121:                 static __inline__ OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS);
122:                 static __inline__ OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID);
123:                 static __inline__ OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID);
124:                 static __inline__ uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID);
125:                 
126:                 static __inline__ OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity);
127:                 static __inline__ void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status);
128:                 
129:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID);
130:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID);
131:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS);
132:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID);
133:                 
134:                 void* OSAL_Malloc(size_t size);
135:                 void OSAL_Free(void* pData);
136:                 
137:                 OSAL_RESULT OSAL_Initialize();
138:                 
139:                 static __inline__ const char* OSAL_Name(void);
140:                 
141:                 // *****************************************************************************
142:                 // *****************************************************************************
143:                 // Section: Interface Routines Group Defintions
144:                 // *****************************************************************************
145:                 // *****************************************************************************
146:                 
147:                 /* Critical Section group */
148:                 // *****************************************************************************
149:                 /* Function: OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
150:                  */
151:                 static OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
152:                 {
153:                    if(severity == OSAL_CRIT_TYPE_LOW)
154:                       return (0);
155:                    /*if priority is set to HIGH the user wants interrupts disabled*/
156:                    return (SYS_INT_StatusGetAndDisable());
9D0028E0  0F40268B   JAL SYS_INT_StatusGetAndDisable
9D0028E4  A2000028   SB ZERO, 40(S0)
9D0029A8  0F40268B   JAL SYS_INT_StatusGetAndDisable
9D0029AC  00000000   NOP
9D004D10  0F40268B   JAL SYS_INT_StatusGetAndDisable
9D004D14  00E0A021   ADDU S4, A3, ZERO
9D004DF4  0F40268B   JAL SYS_INT_StatusGetAndDisable
9D004DF8  00000000   NOP
9D007D90  0F40268B   JAL SYS_INT_StatusGetAndDisable
9D007D94  AE03000C   SW V1, 12(S0)
157:                 }
158:                 
159:                 // *****************************************************************************
160:                 /* Function: void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
161:                  */
162:                 static void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
163:                 {
164:                    if(severity == OSAL_CRIT_TYPE_LOW)
165:                       return;
166:                    /*if priority is set to HIGH the user wants interrupts re-enabled to the state 
167:                    they were before disabling.*/
168:                    SYS_INT_StatusRestore(status);   
9D0028FC  0F402692   JAL SYS_INT_StatusRestore
9D002900  00402021   ADDU A0, V0, ZERO
9D00290C  0F402692   JAL SYS_INT_StatusRestore
9D002910  00402021   ADDU A0, V0, ZERO
9D0029C4  0F402692   JAL SYS_INT_StatusRestore
9D0029C8  00402021   ADDU A0, V0, ZERO
9D004D30  0F402692   JAL SYS_INT_StatusRestore
9D004D34  00402021   ADDU A0, V0, ZERO
9D004D40  0F402692   JAL SYS_INT_StatusRestore
9D004D44  00402021   ADDU A0, V0, ZERO
9D004E10  0F402692   JAL SYS_INT_StatusRestore
9D004E14  00402021   ADDU A0, V0, ZERO
9D007DA0  0F402692   JAL SYS_INT_StatusRestore
9D007DA4  00402021   ADDU A0, V0, ZERO
169:                 }
170:                 
171:                 // *****************************************************************************
172:                 /* Function: OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE semID, OSAL_SEM_TYPE type,
173:                                                 uint8_t maxCount, uint8_t initialCount)
174:                  */
175:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type,
176:                                                 uint8_t maxCount, uint8_t initialCount)
177:                 {
178:                    OSAL_CRITSECT_DATA_TYPE IntState;
179:                    
180:                    IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
181:                  
182:                    if (type == OSAL_SEM_TYPE_COUNTING)
183:                       *semID = initialCount;
184:                    else
185:                       *semID = 1;
9D007D98  24030001   ADDIU V1, ZERO, 1
9D007D9C  A2030029   SB V1, 41(S0)
186:                  
187:                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
188:                    
189:                    return OSAL_RESULT_TRUE;
190:                 }
191:                 
192:                 // *****************************************************************************
193:                 /* Function: OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE semID)
194:                  */
195:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* mutexID)
196:                 {
197:                    return (OSAL_RESULT_TRUE);
198:                 }
199:                 
200:                 // *****************************************************************************
201:                 /* Function: OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE semID, uint16_t waitMS)
202:                  */
203:                 static  OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS)
204:                 {
205:                    OSAL_CRITSECT_DATA_TYPE IntState;
206:                    
207:                    IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
208:                        
209:                    if (*semID > 0)
9D0028E8  92030029   LBU V1, 41(S0)
9D0028EC  10600007   BEQ V1, ZERO, SYS_TMR_Tasks::_UserGblLock
9D0028F0  2463FFFF   ADDIU V1, V1, -1
9D004D18  3C03A000   LUI V1, -24576
9D004D1C  90630135   LBU V1, 309(V1)
9D004D20  10600007   BEQ V1, ZERO, _SYS_TMR_ClientCreate::_UserGblLock
9D004D24  2463FFFF   ADDIU V1, V1, -1
210:                    {
211:                       (*semID)--;
9D0028F4  3C04A000   LUI A0, -24576
9D0028F8  A0830135   SB V1, 309(A0)
9D004D28  3C04A000   LUI A0, -24576
9D004D2C  A0830135   SB V1, 309(A0)
212:                       OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
213:                       
214:                       return OSAL_RESULT_TRUE;
215:                    }
216:                    
217:                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
218:                       
219:                    return OSAL_RESULT_FALSE;
220:                 }
221:                 
222:                 // *****************************************************************************
223:                 /* Function: OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE semID)
224:                  */
225:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID)
226:                 {
227:                    OSAL_CRITSECT_DATA_TYPE IntState;
228:                    
229:                    IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
230:                    (*semID)++;
9D0029B0  3C03A000   LUI V1, -24576
9D0029B4  2463010C   ADDIU V1, V1, 268
9D0029B8  90640029   LBU A0, 41(V1)
9D0029BC  24840001   ADDIU A0, A0, 1
9D0029C0  A0640029   SB A0, 41(V1)
9D004DFC  3C03A000   LUI V1, -24576
9D004E00  2463010C   ADDIU V1, V1, 268
9D004E04  90640029   LBU A0, 41(V1)
9D004E08  24840001   ADDIU A0, A0, 1
9D004E0C  A0640029   SB A0, 41(V1)
231:                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
232:                    
233:                    return OSAL_RESULT_TRUE;
234:                 }
235:                 
236:                 // *****************************************************************************
237:                 /* Function: OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE semID)
238:                  */
239:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID)
240:                 {
241:                     (*semID)++;
242:                     return OSAL_RESULT_TRUE;
243:                 }
244:                 
245:                 // *****************************************************************************
246:                 /* Function: uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE semID)
247:                  */
248:                 static uint8_t __attribute__((always_inline)) OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID)
249:                 {
250:                     return *semID;
251:                 }
252:                 
253:                 // *****************************************************************************
254:                 /* Function: OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE mutexID)
255:                  */
256:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID)
257:                 {
258:                    *mutexID = 1;
9D005E20  24420200   ADDIU V0, V0, 512
9D005E24  A0430030   SB V1, 48(V0)
9D00664C  24636738   ADDIU V1, V1, 26424
9D006650  24020001   ADDIU V0, ZERO, 1
9D006654  A0620014   SB V0, 20(V1)
9D006658  A0620016   SB V0, 22(V1)
9D00665C  A0620015   SB V0, 21(V1)
259:                    return OSAL_RESULT_TRUE;
260:                 }
261:                 
262:                 // *****************************************************************************
263:                 /* Function: OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE mutexID)
264:                  */
265:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID)
266:                 {
267:                    return (OSAL_RESULT_TRUE);
268:                    
269:                 }
270:                 // *****************************************************************************
271:                 /* Function: OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE mutexID, uint16_t waitMS)
272:                  */
273:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS)
274:                 {
275:                     if (*mutexID == 1)
9D002D8C  90890030   LBU T1, 48(A0)
9D002D90  152300A9   BNE T1, V1, 0x9D003038
9D002D94  00000000   NOP
9D0037D4  3C02A000   LUI V0, -24576
9D0037D8  9043674C   LBU V1, 26444(V0)
9D0037DC  24020001   ADDIU V0, ZERO, 1
9D0037E0  14620019   BNE V1, V0, 0x9D003848
9D0037E4  8FBF001C   LW RA, 28(SP)
9D003E40  3C02A000   LUI V0, -24576
9D003E44  9043674E   LBU V1, 26446(V0)
9D003E48  24020001   ADDIU V0, ZERO, 1
9D003E4C  14620045   BNE V1, V0, 0x9D003F64
9D003E50  2410FFFF   ADDIU S0, ZERO, -1
9D004468  9044674D   LBU A0, 26445(V0)
9D00446C  24020001   ADDIU V0, ZERO, 1
9D004470  1482004A   BNE A0, V0, 0x9D00459C
9D004474  2403FF9C   ADDIU V1, ZERO, -100
9D004818  92430030   LBU V1, 48(S2)
9D00481C  24020001   ADDIU V0, ZERO, 1
9D004820  14620054   BNE V1, V0, 0x9D004974
9D004824  8FBF0034   LW RA, 52(SP)
9D005614  92430030   LBU V1, 48(S2)
9D005618  24020001   ADDIU V0, ZERO, 1
9D00561C  14620042   BNE V1, V0, 0x9D005728
9D005620  8FBF0024   LW RA, 36(SP)
9D0068C4  92440030   LBU A0, 48(S2)
9D0068C8  24030001   ADDIU V1, ZERO, 1
9D0068CC  14830028   BNE A0, V1, 0x9D006970
9D0068D0  2402FF81   ADDIU V0, ZERO, -127
276:                     {
277:                         *mutexID = 0;
9D002D98  A0800030   SB ZERO, 48(A0)
9D0037E8  3C02A000   LUI V0, -24576
9D0037EC  A040674C   SB ZERO, 26444(V0)
9D004478  3C02A000   LUI V0, -24576
9D00447C  0B40115D   J 0x9D004574
9D004480  A040674D   SB ZERO, 26445(V0)
9D004828  A2400030   SB ZERO, 48(S2)
9D005624  A2400030   SB ZERO, 48(S2)
9D0068D4  A2400030   SB ZERO, 48(S2)
278:                         return OSAL_RESULT_TRUE;
279:                     }
280:                     return OSAL_RESULT_FALSE;
281:                 }
282:                 
283:                 // *****************************************************************************
284:                 /* Function: OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE mutexID)
285:                  */
286:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID)
287:                 {
288:                     *mutexID = 1;
9D002FBC  24030001   ADDIU V1, ZERO, 1
9D002FC0  03E00008   JR RA
9D002FC4  A0830030   SB V1, 48(A0)
9D003838  24030001   ADDIU V1, ZERO, 1
9D00383C  3C02A000   LUI V0, -24576
9D003840  A043674C   SB V1, 26444(V0)
9D003EA0  3C03A000   LUI V1, -24576
9D003EA4  A062674E   SB V0, 26446(V1)
9D003F58  3C02A000   LUI V0, -24576
9D003F5C  A043674E   SB V1, 26446(V0)
9D0044F0  24030001   ADDIU V1, ZERO, 1
9D0044F4  3C02A000   LUI V0, -24576
9D0044F8  A043674D   SB V1, 26445(V0)
9D00491C  24020001   ADDIU V0, ZERO, 1
9D004920  0B40125C   J 0x9D004970
9D004924  A2420030   SB V0, 48(S2)
9D0056E8  24020001   ADDIU V0, ZERO, 1
9D0056EC  0B4015C9   J 0x9D005724
9D0056F0  A2420030   SB V0, 48(S2)
9D006944  24020001   ADDIU V0, ZERO, 1
9D006948  A2420030   SB V0, 48(S2)
9D00694C  0B401A5C   J 0x9D006970
9D006950  00001021   ADDU V0, ZERO, ZERO
289:                     return OSAL_RESULT_TRUE;
290:                 }
291:                 
292:                 // Miscellaneous functions
293:                 // *****************************************************************************
294:                 /* Function: void* OSAL_Malloc(size_t size)
295:                  */
296:                 #define OSAL_Malloc(size)                               (malloc(size))
297:                 
298:                 // *****************************************************************************
299:                 /* Function: void OSAL_Free(void* pData)
300:                  */
301:                 #define OSAL_Free(pData)                                (free(pData))
302:                 
303:                 // Initialization and Diagnostics
304:                 // *****************************************************************************
305:                 /* Function: OSAL_RESULT OSAL_Initialize()
306:                  */
307:                 #define OSAL_Initialize()
308:                 
309:                 
310:                 // *****************************************************************************
311:                 /* Function: const char* OSAL_Name()
312:                  */
313:                 static const char* __attribute__((always_inline)) OSAL_Name(void)
314:                 {
315:                    return((const char*) "BASIC");
316:                 }
317:                 
318:                 
319:                 #ifdef __cplusplus
320:                 }
321:                 #endif
322:                 
323:                 #endif // _OSAL_IMPL_BASIC_H
324:                 
325:                 /*******************************************************************************
326:                  End of File
327:                  */
328:                 
329:                 
330:                 
331:                 
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/driver/usb/usbfs/src/dynamic/drv_usbfs_host.c
1:                   /*******************************************************************************
2:                     USB Device Driver Definition
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usbfs_host.c
9:                   
10:                    Summary:
11:                      USB Device Driver Implementation
12:                  
13:                    Description:
14:                      This file implements the Host mode operation of the USB Driver. This file
15:                      should be included in the application if USB Host mode operation is desired.
16:                  *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute Software
23:                  only when embedded on a Microchip microcontroller or digital  signal  controller
24:                  that is integrated into your product or third party  product  (pursuant  to  the
25:                  sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
31:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
35:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
37:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
38:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
40:                  *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  #include "system_config.h"
44:                  #include "driver/usb/drv_usb.h"
45:                  #include "driver/usb/usbfs/drv_usbfs.h"
46:                  #include "driver/usb/usbfs/src/drv_usbfs_local.h"
47:                  #include "usb/usb_host.h"
48:                  #include "usb/usb_host_client_driver.h"
49:                  
50:                  /**********************************************************
51:                   * This structure is a set of pointer to the USBFS driver
52:                   * functions. It is provided to the host and device layer
53:                   * as the interface to the driver.
54:                   * *******************************************************/
55:                  
56:                  DRV_USB_HOST_INTERFACE gDrvUSBFSHostInterface =
57:                  {
58:                      .open = DRV_USBFS_Open,
59:                      .close = DRV_USBFS_Close,
60:                      .eventHandlerSet = DRV_USBFS_ClientEventCallBackSet,
61:                      .hostIRPSubmit = DRV_USBFS_HOST_IRPSubmit,
62:                      .hostIRPCancel = DRV_USBFS_HOST_IRPCancel,
63:                      .hostPipeSetup = DRV_USBFS_HOST_PipeSetup,
64:                      .hostPipeClose = DRV_USBFS_HOST_PipeClose,
65:                      .hostEventsDisable = DRV_USBFS_HOST_EventsDisable,
66:                      .hostEventsEnable = DRV_USBFS_HOST_EventsEnable,
67:                      .rootHubInterface.rootHubPortInterface.hubPortReset = DRV_USBFS_HOST_ROOT_HUB_PortReset,
68:                      .rootHubInterface.rootHubPortInterface.hubPortSpeedGet = DRV_USBFS_HOST_ROOT_HUB_PortSpeedGet,
69:                      .rootHubInterface.rootHubPortInterface.hubPortResetIsComplete = DRV_USBFS_HOST_ROOT_HUB_PortResetIsComplete,
70:                      .rootHubInterface.rootHubPortInterface.hubPortSuspend = DRV_USBFS_HOST_ROOT_HUB_PortSuspend,
71:                      .rootHubInterface.rootHubPortInterface.hubPortResume = DRV_USBFS_HOST_ROOT_HUB_PortResume,
72:                      .rootHubInterface.rootHubMaxCurrentGet = DRV_USBFS_HOST_ROOT_HUB_MaximumCurrentGet,
73:                      .rootHubInterface.rootHubPortNumbersGet = DRV_USBFS_HOST_ROOT_HUB_PortNumbersGet,
74:                      .rootHubInterface.rootHubSpeedGet = DRV_USBFS_HOST_ROOT_HUB_BusSpeedGet,
75:                      .rootHubInterface.rootHubInitialize = DRV_USBFS_HOST_ROOT_HUB_Initialize,
76:                      .rootHubInterface.rootHubOperationEnable = DRV_USBFS_HOST_ROOT_HUB_OperationEnable,
77:                      .rootHubInterface.rootHubOperationIsEnabled = DRV_USBFS_HOST_ROOT_HUB_OperationIsEnabled,
78:                  };
79:                  
80:                  /*****************************************************
81:                   * Global Variable used as Pool of pipe objects 
82:                   * that is used by all driver instances.
83:                   *****************************************************/
84:                  DRV_USBFS_HOST_PIPE_OBJ gDrvUSBHostPipeObj[DRV_USBFS_HOST_PIPES_NUMBER];
85:                  
86:                  /******************************************************************************
87:                   * This matrix provides a mapping of the amount of bandwidth left in a frame for
88:                   * a given transfer size. The number in the matrix is the percentage of
89:                   * bandwidth consumer and the index of each entry is the Log2(N) of data payload
90:                   * size. The first entry is for payload size 1, the second for payload size of
91:                   * 2, the third for payload size of 8 and so on.
92:                   ******************************************************************************/
93:                  const unsigned int gDrvUSBFSTableBW[4][11] =
94:                  {
95:                      {3, 3, 3, 4, 4, 5, 7, 0, 0,  0,  0},    /* Control Transfers    */
96:                      {1, 1, 1, 1, 2, 3, 5, 0, 0,  0,  0},    /* Interrupt Transfers  */
97:                      {1, 1, 1, 1, 2, 3, 5, 0, 0,  0,  0},    /* Bulk Transfer        */
98:                      {1, 1, 1, 1, 2, 3, 5, 9, 18, 35, 69}    /* Isochronous Transfer */
99:                  };      
100:                 
101:                 const unsigned int gDrvUSBLSTableBW[2][4] =
102:                 {
103:                     {26, 27, 28,30},    /* Control Transfers    */
104:                     {11, 11, 12, 14}    /* Interrupt Transfers  */
105:                 };   
106:                 
107:                 // *****************************************************************************
108:                 /* Function:
109:                     void _DRV_USBFS_SendTokenToAddress
110:                     (
111:                         USB_MODULE_ID usbID,
112:                         uint8_t address,
113:                         USB_PID pid,
114:                         uint8_t endpoint,
115:                         bool isLowSpeed
116:                     )
117:                 
118:                   Summary:
119:                     Function programs USB token register with required information for sending
120:                     USB token data
121:                 
122:                   Description:
123:                     Function programs USB token register with required information for sending
124:                     USB token data
125:                 
126:                   Remarks:
127:                     This is a local function and should not be called directly by the
128:                     application.
129:                 */
130:                 
131:                 void _DRV_USBFS_SendTokenToAddress
132:                 (
133:                     USB_MODULE_ID usbID,
134:                     uint8_t address,
135:                     USB_PID pid,
136:                     uint8_t endpoint,
137:                     bool isLowSpeed
138:                 )
139:                 {
140:                     /* Created a function call for this because PLIB function are 
141:                      * inline and this function is being called at several locations */
142:                 
143:                     PLIB_USB_TokenSend(usbID, pid, endpoint, address, isLowSpeed);
144:                 }
145:                 
146:                 // *****************************************************************************
147:                 /* Function:
148:                     void _DRV_USBFS_HOST_Initialize
149:                     (
150:                         DRV_USBFS_OBJ * const pUSBDrvObj,
151:                         const SYS_MODULE_INDEX index
152:                     )
153:                 
154:                   Summary:
155:                     This function initializes the driver for host mode operation.
156:                 
157:                   Description:
158:                     Function performs the following tasks:
159:                       - Informs the USB module with SOF threshold in bit times
160:                       - Enables VBUS power and initializes the module in HOST mode
161:                       - Resets the BDT table data structure with init value
162:                       - Configures EP0 register for the specific USB module
163:                       - Enables the USB attach interrupt
164:                 
165:                   Remarks:
166:                     This is a local function and should not be called directly by the
167:                     application.
168:                 */
169:                 
170:                 void _DRV_USBFS_HOST_Initialize
171:                 (
172:                     DRV_USBFS_OBJ * const pUSBDrvObj,
173:                     const SYS_MODULE_INDEX index,
174:                     DRV_USBFS_INIT * init
175:                 )
176:                 {
177:                     uint8_t bdtEntryindex = 0;
178:                 
179:                     /* Set the SOF threshold value in bit times */
180:                     PLIB_USB_SOFThresholdSet(pUSBDrvObj->usbID, 0x4A);
181:                 
182:                     /* Enable the VBUSON bit in the OTGCON register. Even if the actual VBUSON
183:                      * pin is not under USB module control, this bit must be set for host
184:                      * operation */
185:                     PLIB_USB_OTG_VBusPowerOn(pUSBDrvObj->usbID);
186:                 
187:                     /* Select the host mode of operation */
188:                     PLIB_USB_OperatingModeSelect(pUSBDrvObj->usbID, USB_OPMODE_HOST);
189:                 
190:                     /* Clear up the endpoint 0 BDT entries. Note that host performs all
191:                      * transfers through endpoint 0. */
192:                     for(bdtEntryindex = 0; bdtEntryindex < 4; bdtEntryindex ++)
9D005F80  24050020   ADDIU A1, ZERO, 32
9D005F9C  1445FFF9   BNE V0, A1, 0x9D005F84
9D005FA0  AC600004   SW ZERO, 4(V1)
193:                     {
194:                         /* A full duplex endpoint has 4 entries, 2 per EP direction */
195:                         pUSBDrvObj->pBDT[bdtEntryindex].word[0] = 0;
9D005F84  8C83002C   LW V1, 44(A0)
9D005F88  00621821   ADDU V1, V1, V0
9D005F8C  AC600000   SW ZERO, 0(V1)
196:                         pUSBDrvObj->pBDT[bdtEntryindex].word[1] = 0;
9D005F90  8C83002C   LW V1, 44(A0)
9D005F94  00621821   ADDU V1, V1, V0
9D005F98  24420008   ADDIU V0, V0, 8
197:                     }
198:                 
199:                     /* Initialize the odd even buffer pointers */
200:                     PLIB_USB_PingPongReset(pUSBDrvObj->usbID);
201:                     pUSBDrvObj->ep0TxPingPong = USB_BUFFER_EVEN;
9D005FC0  AC800070   SW ZERO, 112(A0)
202:                     pUSBDrvObj->ep0RxPingPong = USB_BUFFER_EVEN;
9D005FC4  AC800074   SW ZERO, 116(A0)
203:                 
204:                     /* Configure endpoint 0 control register for Host operation. */
205:                     PLIB_USB_EP0HostSetup(pUSBDrvObj->usbID);
206:                 
207:                     /* Initialize the host specific members in the driver object */
208:                     pUSBDrvObj->isResetting     = false;
9D005FDC  A08000B8   SB ZERO, 184(A0)
209:                     pUSBDrvObj->isAttached      = false;
9D005FE0  A0800003   SB ZERO, 3(A0)
210:                     pUSBDrvObj->isAttachDebouncing = false;
9D005FE4  A08000D8   SB ZERO, 216(A0)
211:                     pUSBDrvObj->isDetachDebouncing = false;
9D005FE8  A08000D9   SB ZERO, 217(A0)
212:                     pUSBDrvObj->usbHostDeviceInfo = USB_HOST_DEVICE_OBJ_HANDLE_INVALID;
9D005FEC  2402FFFF   ADDIU V0, ZERO, -1
9D005FF0  AC8200DC   SW V0, 220(A0)
213:                     pUSBDrvObj->rootHubInfo.rootHubAvailableCurrent = init->rootHubAvailableCurrent;
9D005FF4  8CC2001C   LW V0, 28(A2)
9D005FF8  AC8200CC   SW V0, 204(A0)
214:                     pUSBDrvObj->rootHubInfo.portIndication = init->portIndication;
9D005FFC  8CC20024   LW V0, 36(A2)
9D006000  AC8200C4   SW V0, 196(A0)
215:                     pUSBDrvObj->rootHubInfo.portOverCurrentDetect = init->portOverCurrentDetect;
9D006004  8CC20028   LW V0, 40(A2)
9D006008  AC8200C0   SW V0, 192(A0)
216:                     pUSBDrvObj->rootHubInfo.portPowerEnable = init->portPowerEnable;
9D00600C  8CC20020   LW V0, 32(A2)
9D006010  AC8200C8   SW V0, 200(A0)
217:                     
218:                     /* Clear and enable the interrupts */
219:                     _DRV_USBFS_InterruptSourceClear(pUSBDrvObj->interruptSource);
9D006014  8C820028   LW V0, 40(A0)
220:                     _DRV_USBFS_InterruptSourceEnable(pUSBDrvObj->interruptSource);
9D006038  8C820028   LW V0, 40(A0)
221:                 }
222:                 
223:                 // *****************************************************************************
224:                 /* Function:
225:                     USB_ERROR DRV_USBFS_HOST_IRPSubmit
226:                     (
227:                         DRV_USBFS_HOST_PIPE_HANDLE  hPipe,
228:                         USB_HOST_IRP * pinputIRP
229:                     )
230:                 
231:                   Summary:
232:                     Submits an IRP on a pipe.
233:                     
234:                   Description:
235:                     This function submits an IRP on the specified pipe. The IRP will be added to
236:                     the queue and will be processed in turn. The data will be transferred on the
237:                     bus based on the USB bus scheduling rules. When the IRP has been processed,
238:                     the callback function specified in the IRP will be called. The IRP status
239:                     will be updated to reflect the completion status of the IRP. 
240:                 
241:                   Remarks:
242:                     See drv_usbfs.h for usage information.
243:                 */
244:                 
245:                 USB_ERROR DRV_USBFS_HOST_IRPSubmit
246:                 (
247:                     DRV_USBFS_HOST_PIPE_HANDLE  hPipe,
248:                     USB_HOST_IRP * pInputIRP
249:                 )
250:                 {
9D00687C  27BDFFE0   ADDIU SP, SP, -32
9D006880  AFBF001C   SW RA, 28(SP)
9D006884  AFB20018   SW S2, 24(SP)
9D006888  AFB10014   SW S1, 20(SP)
9D00688C  AFB00010   SW S0, 16(SP)
251:                     USB_HOST_IRP_LOCAL * pIRPIterator = (USB_HOST_IRP_LOCAL *)NULL;
252:                     bool interruptWasEnabled = false;
253:                     USB_HOST_IRP_LOCAL * pIRP = (USB_HOST_IRP_LOCAL *)pInputIRP;
254:                     DRV_USBFS_HOST_PIPE_OBJ * pPipe = (DRV_USBFS_HOST_PIPE_OBJ *)hPipe;
255:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)NULL;
256:                     USB_ERROR returnValue = USB_ERROR_NONE;
257:                 
258:                     if((pPipe != NULL) && (pPipe != (DRV_USBFS_HOST_PIPE_OBJ *)DRV_USBFS_HOST_PIPE_HANDLE_INVALID))
9D006890  2482FFFF   ADDIU V0, A0, -1
9D006894  2C42FFFE   SLTIU V0, V0, -2
9D006898  1040002E   BEQ V0, ZERO, 0x9D006954
9D00689C  00808821   ADDU S1, A0, ZERO
9D0068A0  00A08021   ADDU S0, A1, ZERO
259:                     {
260:                         pUSBDrvObj = (DRV_USBFS_OBJ *)(pPipe->hClient);
9D0068A4  8C920004   LW S2, 4(A0)
261:                 
262:                         /* Assign owner pipe */
263:                         pIRP->pipe = hPipe;
9D0068A8  AE040030   SW A0, 48(S0)
264:                 
265:                         /* Clear up any temporary state */
266:                         pIRP->tempState = 0;
9D0068AC  ACA00020   SW ZERO, 32(A1)
267:                 
268:                         /* Control transfer IRPs have to be implemented in states. These sub states
269:                          * are maintained in the tempState member of the IRP. A control transfer IRP
270:                          * must start with the SETUP stage */
271:                 
272:                         if(pPipe->pipeType == USB_TRANSFER_TYPE_CONTROL)
273:                         {
274:                             /* Then we setup the IRP for setup stage */
275:                             pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_SETUP_STAGE;
276:                         }
277:                 
278:                         pIRP->status = USB_HOST_IRP_STATUS_PENDING;
9D0068B0  24020002   ADDIU V0, ZERO, 2
9D0068B4  ACA2000C   SW V0, 12(A1)
279:                 
280:                         /* Add the IRP to the pipe. We need to disable the USB interrupt here
281:                          * because the USB interrupt updates the pipe structure asynchronously. */
282:                 
283:                         if(!(pUSBDrvObj->inInterruptContext))
9D0068B8  92420001   LBU V0, 1(S2)
9D0068BC  14400027   BNE V0, ZERO, 0x9D00695C
9D0068C0  00002021   ADDU A0, ZERO, ZERO
284:                         {
285:                             /* The mutex protects the interrupt state from manipulation from other
286:                              * thread that want to submit IRPs. If another thread reaches this point
287:                              * it will block waiting on this mutex. Additionally the mutex should be
288:                              * grabbed only if this function is not executing in an interrupt
289:                              * context. A thread can submit an IRP in an event handler is invoked
290:                              * from the ISR. */
291:                 
292:                             if(OSAL_MUTEX_Lock(&pUSBDrvObj->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
293:                             {
294:                                 /* Disable the interrupt */
295:                                 interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(pUSBDrvObj->interruptSource);
9D0068D8  0F402481   JAL SYS_INT_SourceDisable
9D0068DC  8E440028   LW A0, 40(S2)
9D0068E0  0B401A57   J 0x9D00695C
9D0068E4  00402021   ADDU A0, V0, ZERO
9D0068E8  0B401A40   J 0x9D006900
9D0068EC  AE300010   SW S0, 16(S1)
296:                             }
297:                             else
298:                             {
299:                                 SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex lock failed");
300:                                 returnValue = USB_ERROR_OSAL_FUNCTION;
301:                             }
302:                         }
303:                 
304:                         if(returnValue == USB_ERROR_NONE)
305:                         {
306:                             /* Add the IRP to the queue */
307:                             if(pPipe->irpQueueHead == NULL)
9D00695C  8E260010   LW A2, 16(S1)
9D006960  54C0FFE4   BNEL A2, ZERO, 0x9D0068F4
9D006964  8CC3002C   LW V1, 44(A2)
9D006968  0B401A3A   J 0x9D0068E8
9D00696C  AE00002C   SW ZERO, 44(S0)
308:                             {
309:                                 /* This means that there are no IRPs on this pipe. We can add this IRP
310:                                  * directly */
311:                 
312:                                 pIRP->next = NULL;
313:                                 pPipe->irpQueueHead = pIRP;
314:                             }
315:                             else
316:                             {
317:                                 /* The pipe queue is not empty. Add the IRP to the last IRP in the pipe
318:                                  * queue */
319:                 
320:                                 pIRPIterator = pPipe->irpQueueHead;
321:                 
322:                                 /* Find the last IRP in the linked list*/
323:                                 while(pIRPIterator->next != NULL)
9D0068F0  8CC3002C   LW V1, 44(A2)
9D0068F4  5460FFFE   BNEL V1, ZERO, 0x9D0068F0
9D0068F8  00603021   ADDU A2, V1, ZERO
324:                                 {
325:                                     pIRPIterator = pIRPIterator->next;
326:                                 }
327:                 
328:                                 /* Add the item to the last irp in the linked list */
329:                                 pIRPIterator->next = pIRP;
9D0068FC  ACD0002C   SW S0, 44(A2)
330:                             }
331:                 
332:                             /* Initialize the hidden members */
333:                             pIRP->next = NULL;
9D006900  AE00002C   SW ZERO, 44(S0)
334:                             pIRP->completedBytes = 0;
9D006904  AE000024   SW ZERO, 36(S0)
335:                             pIRP->tempSize = 0;
9D006908  AE00001C   SW ZERO, 28(S0)
336:                 
337:                             if(!(pUSBDrvObj->inInterruptContext))
9D00690C  92430001   LBU V1, 1(S2)
9D006910  14600017   BNE V1, ZERO, 0x9D006970
9D006914  00001021   ADDU V0, ZERO, ZERO
338:                             {
339:                                 /* While exiting the routine, restore the interrupt context and then
340:                                  * release the mutex. Any thread that is blocked on this mutex will be
341:                                  * able to now manipulate the interrupt and submit the IRP */
342:                 
343:                                 if(interruptWasEnabled)
9D006918  5080000B   BEQL A0, ZERO, 0x9D006948
9D00691C  24020001   ADDIU V0, ZERO, 1
344:                                 {
345:                                     _DRV_USBFS_InterruptSourceEnable(pUSBDrvObj->interruptSource);
9D006920  8E420028   LW V0, 40(S2)
346:                                 }
347:                 
348:                                 OSAL_MUTEX_Unlock(&pUSBDrvObj->mutexID);
349:                             }
350:                         }
351:                     }
352:                     else
353:                     {
354:                         /* Pipe is not valid */
355:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: NULL pipe");
356:                         returnValue = USB_ERROR_HOST_PIPE_INVALID;
9D006954  0B401A5C   J 0x9D006970
9D006958  2402FF90   ADDIU V0, ZERO, -112
357:                     }
358:                 
359:                     return (returnValue);
360:                 }
9D006970  8FBF001C   LW RA, 28(SP)
361:                 
362:                 // *****************************************************************************
363:                 /* Function:
364:                     void DRV_USBFS_HOST_IRPCancel(USB_HOST_IRP * pinputIRP)
365:                 
366:                   Summary:
367:                     Cancels the specified IRP.
368:                     
369:                   Description:
370:                     This function attempts to cancel the specified IRP. If the IRP is queued and
371:                     its processing has not started, it will be cancelled successfully. If the
372:                     IRP in progress, the ongoing transaction will be allowed to complete. 
373:                 
374:                   Remarks:
375:                     See drv_usbfs.h for usage information.
376:                 */
377:                 
378:                 void DRV_USBFS_HOST_IRPCancel(USB_HOST_IRP * pInputIRP)
379:                 {
9D0055D4  27BDFFD8   ADDIU SP, SP, -40
9D0055D8  AFBF0024   SW RA, 36(SP)
9D0055DC  AFB30020   SW S3, 32(SP)
9D0055E0  AFB2001C   SW S2, 28(SP)
9D0055E4  AFB10018   SW S1, 24(SP)
9D0055E8  AFB00014   SW S0, 20(SP)
380:                     USB_HOST_IRP_LOCAL * pIRP = (USB_HOST_IRP_LOCAL *) pInputIRP;
381:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)NULL;
382:                     DRV_USBFS_HOST_PIPE_OBJ * pPipe = (DRV_USBFS_HOST_PIPE_OBJ *)NULL;
383:                     USB_HOST_IRP_LOCAL * pIteratorIRP = (USB_HOST_IRP_LOCAL *)NULL;
384:                     bool interruptWasEnabled = false;
385:                     bool irpCancel = false;
386:                     bool thereWasAnError = false;
387:                 
388:                     if((pIRP != NULL) && (pIRP->pipe != DRV_USBFS_HOST_PIPE_HANDLE_INVALID))
9D0055EC  1080004D   BEQ A0, ZERO, 0x9D005724
9D0055F0  00808021   ADDU S0, A0, ZERO
9D0055F4  8C910030   LW S1, 48(A0)
9D0055F8  2402FFFF   ADDIU V0, ZERO, -1
9D0055FC  5222004A   BEQL S1, V0, 0x9D005728
9D005600  8FBF0024   LW RA, 36(SP)
389:                     {
390:                         pPipe = (DRV_USBFS_HOST_PIPE_OBJ *)pIRP->pipe;
391:                         pUSBDrvObj = (DRV_USBFS_OBJ *) pPipe->hClient;
9D005604  8E320004   LW S2, 4(S1)
392:                 
393:                         if(!(pUSBDrvObj->inInterruptContext))
9D005608  92420001   LBU V0, 1(S2)
9D00560C  54400039   BNEL V0, ZERO, 0x9D0056F4
9D005610  00009821   ADDU S3, ZERO, ZERO
394:                         {
395:                             /* Disable the interrupts to prevent asynchronous manipulation of
396:                              * this IRP. In a multi-thread application, this operation should be
397:                              * protected by a mutex. We do not want the status of the IRP to
398:                              * change asynchronously. */
399:                 
400:                             if(OSAL_MUTEX_Lock(&pUSBDrvObj->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
401:                             {
402:                                 /* Disable the interrupt. */
403:                                 interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(pUSBDrvObj->interruptSource);
9D005628  0F402481   JAL SYS_INT_SourceDisable
9D00562C  8E440028   LW A0, 40(S2)
9D005630  0B4015BD   J 0x9D0056F4
9D005634  00409821   ADDU S3, V0, ZERO
404:                             }
405:                             else
406:                             {
407:                                 /* We cannot proceed. Set a flag saying an error has occurred.
408:                                  * */
409:                                 SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex lock failed");
410:                                 thereWasAnError = true;
411:                             }
412:                         }
413:                 
414:                         if(thereWasAnError == false)
415:                         {
416:                             /* There was no error */
417:                             if(pIRP->status > USB_HOST_IRP_STATUS_COMPLETED_SHORT)
9D0056F4  8E03000C   LW V1, 12(S0)
9D0056F8  28630002   SLTI V1, V1, 2
9D0056FC  5060FFCE   BEQL V1, ZERO, 0x9D005638
9D005700  8E240010   LW A0, 16(S1)
9D005704  0B4015AD   J 0x9D0056B4
9D005708  92430001   LBU V1, 1(S2)
418:                             {
419:                                 /* This means the IRP is pending or in progress. Search for the
420:                                  * IRP in the queue. irpCancel will be true if the IRP to be
421:                                  * cancelled was found in the queue. */
422:                 
423:                                 pIteratorIRP = pPipe->irpQueueHead;
424:                 
425:                                 if(pIteratorIRP == pIRP)
9D005638  1604000E   BNE S0, A0, 0x9D005674
9D00563C  00000000   NOP
426:                                 {
427:                                     /* Scenario - IRP to be cancelled is 1st IRP in the pipe */
428:                                     pPipe->irpQueueHead = pIteratorIRP->next;
9D005640  8E02002C   LW V0, 44(S0)
9D005644  0B4015C3   J 0x9D00570C
9D005648  AE220010   SW V0, 16(S1)
429:                                     irpCancel = true;
430:                                 }
431:                                 else
432:                                 {
433:                                     /* Scenario - IRP to be cancelled is NOT the 1st IRP in the pipe.
434:                                      * Start searching with the next IRP in the queue. */
435:                 
436:                                     while(pIteratorIRP != NULL)
9D005658  5460FFFC   BNEL V1, ZERO, 0x9D00564C
9D00565C  8C65002C   LW A1, 44(V1)
9D005660  0B4015AD   J 0x9D0056B4
9D005664  92430001   LBU V1, 1(S2)
9D005674  5080000F   BEQL A0, ZERO, 0x9D0056B4
9D005678  92430001   LBU V1, 1(S2)
437:                                     {
438:                                         if(pIteratorIRP->next == pIRP)
9D00564C  52050007   BEQL S0, A1, 0x9D00566C
9D005650  8CA2002C   LW V0, 44(A1)
9D005654  00A01821   ADDU V1, A1, ZERO
9D00567C  8C83002C   LW V1, 44(A0)
9D005680  1603FFF5   BNE S0, V1, 0x9D005658
9D005684  00602821   ADDU A1, V1, ZERO
9D005688  0B40159A   J 0x9D005668
9D00568C  00801821   ADDU V1, A0, ZERO
9D005690  0B4015AC   J 0x9D0056B0
9D005694  AE020020   SW V0, 32(S0)
439:                                         {
440:                                             /* IRP to be cancelled has been found. The next and
441:                                              * previous pointers in the doubly linked list need
442:                                              * to be manipulated to removed this IRP from the
443:                                              * queue. */
444:                 
445:                                             pIteratorIRP->next = (pIteratorIRP->next)->next;
9D005668  8CA2002C   LW V0, 44(A1)
446:                                             irpCancel = true;
447:                                             break;
9D00566C  0B4015C3   J 0x9D00570C
9D005670  AC62002C   SW V0, 44(V1)
448:                                         }
449:                 
450:                                         pIteratorIRP = pIteratorIRP->next;
451:                                     }
452:                                 }
453:                 
454:                                 /* Have we found the IRP in the queue */
455:                                 if(irpCancel == true)
456:                                 {
457:                                     if(pIRP->status == USB_HOST_IRP_STATUS_IN_PROGRESS)
9D00570C  8E03000C   LW V1, 12(S0)
9D005710  24020003   ADDIU V0, ZERO, 3
9D005714  5462FFE0   BNEL V1, V0, 0x9D005698
9D005718  2402FFFB   ADDIU V0, ZERO, -5
9D00571C  0B4015A4   J 0x9D005690
9D005720  24020007   ADDIU V0, ZERO, 7
458:                                     {
459:                                         /* If the irp is already in progress then we set the
460:                                          * temporary state. This will get caught in
461:                                          * _DRV_USBFS_HOST_ControlXferProcess() and
462:                                          * _DRV_USBFS_HOST_NonControlIRPProcess() functions. */
463:                 
464:                                         pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_ABORTED;
465:                                     }
466:                                     else
467:                                     {
468:                                         /* If the IRP is not in progress, then we can terminate
469:                                          * it immediately. Invoke the callback. */
470:                                         pIRP->status = USB_HOST_IRP_STATUS_ABORTED;
9D005698  AE02000C   SW V0, 12(S0)
471:                                         if(pIRP->callback != NULL)
9D00569C  8E020018   LW V0, 24(S0)
9D0056A0  50400004   BEQL V0, ZERO, 0x9D0056B4
9D0056A4  92430001   LBU V1, 1(S2)
472:                                         {
473:                                             pIRP->callback((USB_HOST_IRP *)pIRP);
9D0056A8  0040F809   JALR V0
9D0056AC  02002021   ADDU A0, S0, ZERO
474:                                         }
475:                                     }
476:                                 }
477:                 
478:                                 if(pIteratorIRP == NULL)
479:                                 {
480:                                     /* Either no IRP at all in the Pipe or particular IRP not
481:                                      * found */
482:                                     SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: IRP not found");
483:                                 }
484:                             }
485:                             else
486:                             {
487:                                 /* IRP is already completed and currently not in any pipe */
488:                                 SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: IRP is not pending or in progress");
489:                             }
490:                 
491:                             if(!(pUSBDrvObj->inInterruptContext))
9D0056B0  92430001   LBU V1, 1(S2)
9D0056B4  1460001C   BNE V1, ZERO, 0x9D005728
9D0056B8  8FBF0024   LW RA, 36(SP)
492:                             {
493:                                 /* Restore the interrupt status and release the mutex */
494:                                 if(interruptWasEnabled)
9D0056BC  1260000B   BEQ S3, ZERO, 0x9D0056EC
9D0056C0  24020001   ADDIU V0, ZERO, 1
495:                                 {
496:                                     _DRV_USBFS_InterruptSourceEnable(pUSBDrvObj->interruptSource);
9D0056C4  8E420028   LW V0, 40(S2)
497:                                 }
498:                 
499:                                 OSAL_MUTEX_Unlock(&pUSBDrvObj->mutexID);
500:                             }
501:                         }
502:                     }
503:                     else
504:                     {
505:                         /* Pipe or IRP is not valid */
506:                         SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid pipe");
507:                     }
508:                 }
9D005724  8FBF0024   LW RA, 36(SP)
509:                 
510:                 // *****************************************************************************
511:                 /* Function:
512:                     bool _DRV_USBFS_HOST_ControlXferProcess
513:                     (
514:                         DRV_USBFS_OBJ * hDriver,
515:                         USB_HOST_IRP_LOCAL * irp,
516:                         DRV_USBFS_TRANSACTION_RESULT deviceResponse,
517:                         unsigned int deviceResponseSize
518:                     )
519:                 
520:                   Summary:
521:                     This function advances the control transfer.
522:                 
523:                   Description:
524:                     Function is used to send\receive CONTROL transfer token, data and status.
525:                     Function returns true if a token was sent at the time when the it exits.
526:                 
527:                   Remarks:
528:                     This is a local function and should not be called directly by the
529:                     application.
530:                 */
531:                 
532:                 bool _DRV_USBFS_HOST_ControlXferProcess
533:                 (
534:                     DRV_USBFS_OBJ * pUSBDrvObj,
535:                     USB_HOST_IRP_LOCAL * pIRP,
536:                     DRV_USBFS_TRANSACTION_RESULT deviceResponse,
537:                     unsigned int deviceResponseSize
538:                 )
539:                 {
9D000A9C  27BDFFD8   ADDIU SP, SP, -40
9D000AA0  AFBF0024   SW RA, 36(SP)
9D000AA4  00801021   ADDU V0, A0, ZERO
540:                     /* This function returns true if a token was sent at the time when the
541:                      * function exits */
542:                 
543:                     DRV_USBFS_BDT_ENTRY * pBDT = (DRV_USBFS_BDT_ENTRY *)NULL;
544:                     DRV_USBFS_HOST_PIPE_OBJ * pipe = (DRV_USBFS_HOST_PIPE_OBJ *)pIRP->pipe;
9D000AA8  8CA30030   LW V1, 48(A1)
545:                     uint8_t endpoint = pipe->endpointAndDirection & 0xF;
9D000AAC  906B0008   LBU T3, 8(V1)
9D000B4C  316B000F   ANDI T3, T3, 15
546:                     uint8_t deviceAddress = pipe->deviceAddress;
9D000AB0  906C0025   LBU T4, 37(V1)
547:                     USB_MODULE_ID usbID = pUSBDrvObj->usbID;
9D000AB4  8C880020   LW T0, 32(A0)
548:                     bool isLowSpeed = (pipe->speed == USB_SPEED_LOW) ?  true : false;
9D000B50  394A0003   XORI T2, T2, 3
549:                     bool tokenSent = false;
9D000D08  0B40042B   J 0x9D0010AC
9D000D0C  00001021   ADDU V0, ZERO, ZERO
9D000FFC  0B40042B   J 0x9D0010AC
9D001000  00001021   ADDU V0, ZERO, ZERO
9D001060  0B40042B   J 0x9D0010AC
9D001064  00001021   ADDU V0, ZERO, ZERO
550:                     bool endIRP = false;
551:                     DRV_USBFS_HOST_SW_EP * softwareEP = NULL;
552:                     DRV_USBFS_HOST_TRANSFER_GROUP * transferGroup = NULL;
553:                 
554:                     if(pIRP->tempState == DRV_USBFS_HOST_IRP_STATE_ABORTED)
9D000AB8  8CA40020   LW A0, 32(A1)
9D000ABC  24090007   ADDIU T1, ZERO, 7
9D000AC0  14890022   BNE A0, T1, 0x9D000B4C
9D000AC4  8C6A0028   LW T2, 40(V1)
555:                     {
556:                         /* This means the application aborted this IRP.  We just invoke the
557:                          * callback. If this function is being called, it means the
558:                          * pUSBDrvObj->numSWEpEntry is pointing to a Software endpoint object
559:                          * that is managing control transfers. We do not process this IRP any
560:                          * more. The tobeDone flag is set to false and the control IRP is
561:                          * removed from the current pipe. */
562:                 
563:                         softwareEP = &pUSBDrvObj->drvUSBHostSWEp[pUSBDrvObj->numSWEpEntry];
9D000AC8  9043006C   LBU V1, 108(V0)
9D000ACC  00032080   SLL A0, V1, 2
9D000AD0  00031900   SLL V1, V1, 4
9D000AD4  00642023   SUBU A0, V1, A0
9D000AD8  24840078   ADDIU A0, A0, 120
9D000ADC  00442021   ADDU A0, V0, A0
9D000AE0  24830004   ADDIU V1, A0, 4
564:                         transferGroup = &pUSBDrvObj->transferGroup[USB_TRANSFER_TYPE_CONTROL];
565:                 
566:                         softwareEP->tobeDone = false;
9D000AE4  A0800004   SB ZERO, 4(A0)
567:                         ((pUSBDrvObj->transferGroup[softwareEP->transferType]).currentPipe)->irpQueueHead = (softwareEP->pIRP)->next;
9D000AE8  8C840008   LW A0, 8(A0)
9D000AEC  00043080   SLL A2, A0, 2
9D000AF0  00042100   SLL A0, A0, 4
9D000AF4  00862023   SUBU A0, A0, A2
9D000AF8  00442021   ADDU A0, V0, A0
9D000AFC  8C840040   LW A0, 64(A0)
9D000B00  8C630008   LW V1, 8(V1)
9D000B04  8C63002C   LW V1, 44(V1)
9D000B08  AC830010   SW V1, 16(A0)
568:                 
569:                         /* We must update the pipe to move to the next pipe in the pipe bundle
570:                          * While doing so, check if we have reached the last pipe in the bundle,
571:                          * if so then wrap around to the first pipe in the bundle. */
572:                 
573:                         if((transferGroup->currentPipe) ->next != NULL)
9D000B0C  8C430040   LW V1, 64(V0)
9D000B10  8C630020   LW V1, 32(V1)
9D000B14  50600003   BEQL V1, ZERO, 0x9D000B24
9D000B18  8C43003C   LW V1, 60(V0)
9D000B1C  0B4002CA   J 0x9D000B28
9D000B20  AC430040   SW V1, 64(V0)
574:                         {
575:                             /* This is not the last PIPE */
576:                             transferGroup->currentPipe = transferGroup->currentPipe->next;
577:                         }
578:                         else
579:                         {
580:                             /* This is the last PIPE. Move to the head pipe */
581:                             transferGroup->currentPipe = transferGroup->pipe;
9D000B24  AC430040   SW V1, 64(V0)
582:                         }
583:                 
584:                         pIRP->status = USB_HOST_IRP_STATUS_ABORTED;
9D000B28  2402FFFB   ADDIU V0, ZERO, -5
9D000B2C  ACA2000C   SW V0, 12(A1)
585:                         if(pIRP->callback != NULL)
9D000B30  8CA20018   LW V0, 24(A1)
9D000B34  5040015D   BEQL V0, ZERO, 0x9D0010AC
9D000B38  00001021   ADDU V0, ZERO, ZERO
586:                         {
587:                             pIRP->callback((USB_HOST_IRP *)pIRP);
9D000B3C  0040F809   JALR V0
9D000B40  00A02021   ADDU A0, A1, ZERO
588:                         }
589:                 
590:                         /* Return false indicating that no token was sent in this frame */
591:                         tokenSent = false;
9D000B44  0B40042B   J 0x9D0010AC
9D000B48  00001021   ADDU V0, ZERO, ZERO
592:                     }
593:                     else
594:                     {
595:                         /* IRP is not aborted. We should continue to process this transfer */
596:                 
597:                         switch(pIRP->tempState)
9D000B54  2C890007   SLTIU T1, A0, 7
9D000B58  11200141   BEQ T1, ZERO, 0x9D001060
9D000B5C  2D4A0001   SLTIU T2, T2, 1
9D000B60  00042080   SLL A0, A0, 2
9D000B64  3C099D00   LUI T1, -25344
9D000B68  25290B7C   ADDIU T1, T1, 2940
9D000B6C  01242021   ADDU A0, T1, A0
9D000B70  8C840000   LW A0, 0(A0)
9D000B74  00800008   JR A0
9D000B78  00000000   NOP
598:                         {
599:                             case DRV_USBFS_HOST_IRP_STATE_SETUP_STAGE:
600:                 
601:                                 /* This means we are at the first step in the control transfer. We
602:                                  * need to send the Setup Packet. Update the IRP status to indicate
603:                                  * that the IRP processing has started */ 
604:                 
605:                                 pIRP->status = USB_HOST_IRP_STATUS_IN_PROGRESS;
9D000B98  24040003   ADDIU A0, ZERO, 3
9D000B9C  ACA4000C   SW A0, 12(A1)
606:                                 pIRP->completedBytes = 0;
9D000BA0  ACA00024   SW ZERO, 36(A1)
607:                 
608:                                 /* A control transfer pipe is unique in the sense that the pipe is
609:                                  * bidirectional. Here we obtain the direction of the pipe based on
610:                                  * the direction specified in the setup packet. This is stored in
611:                                  * the pipe object itself. */
612:                 
613:                                 if((((uint8_t *)(pIRP->setup))[0] & 0x80) != 0)
9D000BA4  8CA40000   LW A0, 0(A1)
9D000BA8  80840000   LB A0, 0(A0)
9D000BAC  04830006   BGEZL A0, 0x9D000BC8
9D000BB0  90640008   LBU A0, 8(V1)
614:                                 {
615:                                     /* Data stage direction is from device to host */
616:                                     pipe->endpointAndDirection |= (USB_DATA_DIRECTION_DEVICE_TO_HOST << 7);
9D000BB4  90660008   LBU A2, 8(V1)
9D000BB8  2404FF80   ADDIU A0, ZERO, -128
9D000BBC  00C42025   OR A0, A2, A0
9D000BC0  0B4002F4   J 0x9D000BD0
9D000BC4  A0640008   SB A0, 8(V1)
617:                                 }
618:                                 else
619:                                 {
620:                                     /* Data stage direction is from host to device */
621:                                     pipe->endpointAndDirection &= 0xF;
9D000BC8  3084000F   ANDI A0, A0, 15
9D000BCC  A0640008   SB A0, 8(V1)
622:                                     pipe->endpointAndDirection |= (USB_DATA_DIRECTION_HOST_TO_DEVICE << 7);
623:                                 }
624:                 
625:                                 /* Keep track of the transaction */
626:                                 pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_SETUP_TOKEN_SENT;
9D000BD0  24030001   ADDIU V1, ZERO, 1
9D000BD4  ACA30020   SW V1, 32(A1)
627:                                 pBDT = pUSBDrvObj->pBDT + 2 + pUSBDrvObj->ep0TxPingPong;
9D000BD8  8C440070   LW A0, 112(V0)
9D000BDC  24840002   ADDIU A0, A0, 2
9D000BE0  000420C0   SLL A0, A0, 3
9D000BE4  8C42002C   LW V0, 44(V0)
9D000BE8  00441021   ADDU V0, V0, A0
628:                 
629:                                 /* Configure the BDT Entry for setup packet and Data 0 toggle */
630:                                 pBDT->shortWord[1]  = 8;
9D000BEC  24040008   ADDIU A0, ZERO, 8
9D000BF0  A4440002   SH A0, 2(V0)
631:                                 pBDT->word[1] = KVA_TO_PA(pIRP->setup);
9D000BF4  8CA40000   LW A0, 0(A1)
9D000BF8  7C84E000   EXT A0, A0, 0, 29
9D000BFC  AC440004   SW A0, 4(V0)
632:                                 pBDT->byte[0] = (USBFS_UOWN|USBFS_DTS_ENABLE);
9D000C00  2404FF88   ADDIU A0, ZERO, -120
9D000C04  A0440000   SB A0, 0(V0)
633:                 
634:                                 /* Enable Handshake */
635:                                 PLIB_USB_EPnHandshakeEnable(usbID, 0);
636:                 
637:                                 /* The BDT is armed. We can send the Setup Token to the device */
638:                                 _DRV_USBFS_SendTokenToAddress(usbID, deviceAddress, USB_PID_SETUP, endpoint, isLowSpeed);
639:                 
640:                                 /* Set the flag to indicate that a token was sent */
641:                                 tokenSent = true;
9D000C34  0B40042B   J 0x9D0010AC
9D000C38  24020001   ADDIU V0, ZERO, 1
642:                                 break;
643:                 
644:                             case DRV_USBFS_HOST_IRP_STATE_SETUP_TOKEN_SENT:
645:                 
646:                                 /* This means we sent the Setup token and received the Transaction
647:                                  * interrupt. Check the device response to the setup token. It
648:                                  * should be always an ACK. */
649:                 
650:                                 if(deviceResponse == USB_TRANSACTION_ACK)
9D000C3C  24040002   ADDIU A0, ZERO, 2
9D000C40  54C40011   BNEL A2, A0, 0x9D000C88
9D000C44  24030006   ADDIU V1, ZERO, 6
651:                                 {
652:                                     if((pIRP->data == NULL) || (pIRP->size == 0))
9D000C48  8CA40004   LW A0, 4(A1)
9D000C4C  50800005   BEQL A0, ZERO, 0x9D000C64
9D000C50  24020004   ADDIU V0, ZERO, 4
9D000C54  8CA40008   LW A0, 8(A1)
9D000C58  14800006   BNE A0, ZERO, 0x9D000C74
9D000C5C  24040001   ADDIU A0, ZERO, 1
653:                                     {
654:                                         /* This means that this is a zero data stage transaction */
655:                 
656:                                         pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_HANDSHAKE;
9D000C60  24020004   ADDIU V0, ZERO, 4
9D000C64  ACA20020   SW V0, 32(A1)
657:                                         pipe->nakCounter = 0;
9D000C68  AC600018   SW ZERO, 24(V1)
658:                                         break;
9D000C6C  0B40042B   J 0x9D0010AC
9D000C70  00001021   ADDU V0, ZERO, ZERO
659:                                     }
660:                 
661:                                     /* Setup the data toggle for the next stage and go to the next
662:                                      * stage directly.  Switch case fall through is intentional. */
663:                 
664:                                     pipe->dataToggle = USB_BUFFER_DATA1;
9D000C74  AC640014   SW A0, 20(V1)
665:                                     pipe->nakCounter = 0;
9D000C78  AC600018   SW ZERO, 24(V1)
666:                                     pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_DATA_STAGE;
9D000C7C  24040002   ADDIU A0, ZERO, 2
9D000C80  0B400326   J 0x9D000C98
9D000C84  ACA40020   SW A0, 32(A1)
667:                                 }
668:                                 else
669:                                 {
670:                                     /* Something is seriously wrong with this device. As per the
671:                                      * specification, the device must ACK the Setup packet. We will
672:                                      * end the control transfer immediately. */
673:                 
674:                                     pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_COMPLETE;
9D000C88  ACA30020   SW V1, 32(A1)
675:                                     pIRP->status = USB_HOST_IRP_STATUS_ERROR_UNKNOWN;
9D000C8C  2403FFFA   ADDIU V1, ZERO, -6
676:                                     endIRP = true;
677:                                     break;
9D000C90  0B40041A   J 0x9D001068
9D000C94  ACA3000C   SW V1, 12(A1)
678:                                 }
679:                                 /* The switch case fall through here is intentional */
680:                 
681:                             case DRV_USBFS_HOST_IRP_STATE_DATA_STAGE:
682:                 
683:                                 /* We have reached here because the Setup stage of an ongoing
684:                                  * control transfer has completed. We now need to start the data
685:                                  * stage. The following function will arm the endpoint in the BDT
686:                                  * and will initiate the data stage. */
687:                 
688:                                 _DRV_USBFS_HOST_ControlSendToken(pIRP, pUSBDrvObj, pipe, endpoint, deviceAddress, usbID, isLowSpeed);
9D000C98  AFAC0010   SW T4, 16(SP)
9D000C9C  AFA80014   SW T0, 20(SP)
9D000CA0  AFAA0018   SW T2, 24(SP)
9D000CA4  00A02021   ADDU A0, A1, ZERO
9D000CA8  00402821   ADDU A1, V0, ZERO
9D000CAC  00603021   ADDU A2, V1, ZERO
9D000CB0  0F401D85   JAL _DRV_USBFS_HOST_ControlSendToken
9D000CB4  01603821   ADDU A3, T3, ZERO
689:                                 tokenSent = true;
690:                                 break;
9D000CB8  0B40042B   J 0x9D0010AC
9D000CBC  24020001   ADDIU V0, ZERO, 1
691:                 
692:                             case DRV_USBFS_HOST_IRP_STATE_DATA_STAGE_SENT:
693:                 
694:                                 /* We have reached here because a control transfer data transaction
695:                                  * has completed. We need to check the device response. The endIRP
696:                                  * flag will be set to true if the IRP has to be terminated. */
697:                                 if(deviceResponse == USB_TRANSACTION_NAK)
9D000CC0  2404000A   ADDIU A0, ZERO, 10
9D000CC4  14C40012   BNE A2, A0, 0x9D000D10
9D000CC8  2404000E   ADDIU A0, ZERO, 14
698:                                 {
699:                                     /* The device response in a NAK. This means the device is not
700:                                      * ready with the data. Rewind the state to the previous state.
701:                                      * We will retry again on the next SOF. Increment the control
702:                                      * transfer NAK counter on this pipe. If the limit is reached
703:                                      * then we should terminate the control transfer. */
704:                 
705:                                     pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_DATA_STAGE;
9D000CCC  24040002   ADDIU A0, ZERO, 2
9D000CD0  ACA40020   SW A0, 32(A1)
706:                                     pipe->nakCounter ++;
9D000CD4  8C640018   LW A0, 24(V1)
9D000CD8  24840001   ADDIU A0, A0, 1
9D000CDC  AC640018   SW A0, 24(V1)
707:                                     if(pipe->nakCounter >= DRV_USBFS_HOST_NAK_LIMIT)
9D000CE0  2C8407D0   SLTIU A0, A0, 2000
9D000CE4  54800007   BNEL A0, ZERO, 0x9D000D04
9D000CE8  24020002   ADDIU V0, ZERO, 2
708:                                     {
709:                                         pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_COMPLETE;
9D000CEC  24040006   ADDIU A0, ZERO, 6
9D000CF0  ACA40020   SW A0, 32(A1)
710:                                         pIRP->status = USB_HOST_IRP_STATUS_ERROR_NAK_TIMEOUT;
9D000CF4  2404FFFE   ADDIU A0, ZERO, -2
9D000CF8  ACA4000C   SW A0, 12(A1)
9D000CFC  0B40041A   J 0x9D001068
9D000D00  AC600018   SW ZERO, 24(V1)
711:                                         endIRP = true;
712:                                         pipe->nakCounter = 0;
713:                                     }
714:                                     else
715:                                     {
716:                                         /* Attempt the data stage again */
717:                                         pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_DATA_STAGE;
9D000D04  ACA20020   SW V0, 32(A1)
718:                                     }
719:                                     break;
720:                 
721:                                 }
722:                                 else if (deviceResponse == USB_TRANSACTION_STALL)
9D000D10  14C40007   BNE A2, A0, 0x9D000D30
9D000D14  2404000F   ADDIU A0, ZERO, 15
723:                                 {
724:                                     /* The device response is a STALL. We should end the control
725:                                      * transfer. */
726:                                     pipe->nakCounter = 0;
9D000D18  AC600018   SW ZERO, 24(V1)
727:                                     pIRP->status = USB_HOST_IRP_STATUS_ERROR_STALL;
9D000D1C  2403FFFF   ADDIU V1, ZERO, -1
9D000D20  ACA3000C   SW V1, 12(A1)
728:                                     pIRP->tempState =  DRV_USBFS_HOST_IRP_STATE_COMPLETE;
9D000D24  24030006   ADDIU V1, ZERO, 6
729:                                     endIRP = true;
730:                                     break;
9D000D28  0B40041A   J 0x9D001068
9D000D2C  ACA30020   SW V1, 32(A1)
731:                                 }
732:                                 else if (deviceResponse == USB_TRANSACTION_DATA_ERROR)
9D000D30  14C40007   BNE A2, A0, 0x9D000D50
9D000D34  2404000B   ADDIU A0, ZERO, 11
733:                                 {
734:                                     /* The device response data error. We should end the control
735:                                      * transfer. */
736:                                     pipe->nakCounter = 0;
9D000D38  AC600018   SW ZERO, 24(V1)
737:                                     pIRP->status = USB_HOST_IRP_STATUS_ERROR_DATA;
9D000D3C  2403FFFD   ADDIU V1, ZERO, -3
9D000D40  ACA3000C   SW V1, 12(A1)
738:                                     pIRP->tempState =  DRV_USBFS_HOST_IRP_STATE_COMPLETE;
9D000D44  24030006   ADDIU V1, ZERO, 6
739:                                     endIRP = true;
740:                                     break;
9D000D48  0B40041A   J 0x9D001068
9D000D4C  ACA30020   SW V1, 32(A1)
741:                                 
742:                                 }
743:                                 else if ((deviceResponse == USB_TRANSACTION_DATA0 ) ||(deviceResponse == USB_TRANSACTION_DATA1) ||(deviceResponse == USB_TRANSACTION_ACK))
9D000D50  10C40004   BEQ A2, A0, 0x9D000D64
9D000D54  24C6FFFE   ADDIU A2, A2, -2
9D000D58  2CC60002   SLTIU A2, A2, 2
9D000D5C  50C00061   BEQL A2, ZERO, 0x9D000EE4
9D000D60  80630008   LB V1, 8(V1)
744:                                 {
745:                                     /* The device has acknowledged the data stage. Update the IRP
746:                                      * with the amount of data received */
747:                                     pipe->nakCounter = 0;
9D000D64  AC600018   SW ZERO, 24(V1)
748:                                     pIRP->completedBytes += deviceResponseSize;
9D000D68  8CA40024   LW A0, 36(A1)
9D000D6C  00E42021   ADDU A0, A3, A0
9D000D70  ACA40024   SW A0, 36(A1)
749:                                     pIRP->completedBytesInThisFrame += deviceResponseSize;
9D000D74  8CA60028   LW A2, 40(A1)
9D000D78  00E63021   ADDU A2, A3, A2
9D000D7C  ACA60028   SW A2, 40(A1)
750:                 
751:                                     if((pipe->endpointAndDirection & 0x80) != 0)
9D000D80  80690008   LB T1, 8(V1)
9D000D84  0523002D   BGEZL T1, 0x9D000E3C
9D000D88  8CA90008   LW T1, 8(A1)
752:                                     {
753:                                         /* Data is moving from device to host Check if the data
754:                                          * stage is done */
755:                 
756:                                         if((deviceResponseSize < pipe->endpointSize) ||(pIRP->completedBytes >= pIRP->size))
9D000D8C  8C69001C   LW T1, 28(V1)
9D000D90  00E9682B   SLTU T5, A3, T1
9D000D94  55A00006   BNEL T5, ZERO, 0x9D000DB0
9D000D98  24040004   ADDIU A0, ZERO, 4
9D000D9C  8CAD0008   LW T5, 8(A1)
9D000DA0  008D202B   SLTU A0, A0, T5
9D000DA4  54800004   BNEL A0, ZERO, 0x9D000DB8
9D000DA8  8CA4001C   LW A0, 28(A1)
757:                                         {
758:                                             /* A host control read transfer is done when the host
759:                                              * has received the amount of data that it was looking
760:                                              * for or when the host receives a less than
761:                                              * maxPacketSize data packet. */
762:                 
763:                                             /* Reset the nak counter for the next data transaction.
764:                                              * Fall through to the handshake stage. */
765:                 
766:                                             pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_HANDSHAKE;
9D000DAC  24040004   ADDIU A0, ZERO, 4
9D000DB0  0B4003B8   J 0x9D000EE0
9D000DB4  ACA40020   SW A0, 32(A1)
767:                                         }
768:                                         else if((deviceResponseSize == pIRP->tempSize) || (deviceResponseSize == pipe->endpointSize))
9D000DB8  50870004   BEQL A0, A3, 0x9D000DCC
9D000DBC  00C4202B   SLTU A0, A2, A0
9D000DC0  54E9004B   BNEL A3, T1, 0x9D000EF0
9D000DC4  8C460070   LW A2, 112(V0)
769:                                         {
770:                                             if(pIRP->tempSize > pIRP->completedBytesInThisFrame)
9D000DC8  00C4202B   SLTU A0, A2, A0
9D000DCC  50800012   BEQL A0, ZERO, 0x9D000E18
9D000DD0  24020002   ADDIU V0, ZERO, 2
771:                                             {
772:                                                 /* More transactions are required in this frame */
773:                                                 pipe->dataToggle ^= 0x1;
9D000DD4  8C640014   LW A0, 20(V1)
9D000DD8  38840001   XORI A0, A0, 1
9D000DDC  AC640014   SW A0, 20(V1)
774:                                                 pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_DATA_STAGE;
9D000DE0  24040002   ADDIU A0, ZERO, 2
9D000DE4  ACA40020   SW A0, 32(A1)
775:                                                 pIRP->status = USB_HOST_IRP_STATUS_IN_PROGRESS;
9D000DE8  24040003   ADDIU A0, ZERO, 3
9D000DEC  ACA4000C   SW A0, 12(A1)
776:                                                 _DRV_USBFS_HOST_ControlSendToken(pIRP,pUSBDrvObj, pipe,endpoint,deviceAddress,usbID, isLowSpeed);
9D000DF0  AFAC0010   SW T4, 16(SP)
9D000DF4  AFA80014   SW T0, 20(SP)
9D000DF8  AFAA0018   SW T2, 24(SP)
9D000DFC  00A02021   ADDU A0, A1, ZERO
9D000E00  00402821   ADDU A1, V0, ZERO
9D000E04  00603021   ADDU A2, V1, ZERO
9D000E08  0F401D85   JAL _DRV_USBFS_HOST_ControlSendToken
9D000E0C  01603821   ADDU A3, T3, ZERO
9D000E10  0B40042B   J 0x9D0010AC
9D000E14  24020001   ADDIU V0, ZERO, 1
777:                                                 tokenSent = true;
778:                                             }
779:                                             else
780:                                             {
781:                                                 /* Whatever planned for this frame has been done 
782:                                                  * Do not Move the IRP Queue head here Do not end the
783:                                                  * IRP */
784:                                                 pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_DATA_STAGE;
9D000E18  ACA20020   SW V0, 32(A1)
785:                                                 pIRP->status = USB_HOST_IRP_STATUS_IN_PROGRESS;
9D000E1C  24020003   ADDIU V0, ZERO, 3
9D000E20  ACA2000C   SW V0, 12(A1)
786:                                                 pipe->dataToggle ^= 0x1;
9D000E24  8C620014   LW V0, 20(V1)
9D000E28  38420001   XORI V0, V0, 1
9D000E2C  AC620014   SW V0, 20(V1)
787:                                                 pipe->nakCounter = 0;
9D000E30  AC600018   SW ZERO, 24(V1)
788:                                                 endIRP = false;
789:                                                 tokenSent = false;
9D000E34  0B40042B   J 0x9D0010AC
9D000E38  00001021   ADDU V0, ZERO, ZERO
790:                                             }
791:                                             break;
792:                                         }
793:                                     }
794:                                     else 
795:                                     {
796:                                         /* Data is moving from host to device */
797:                                         if(pIRP->completedBytes >= pIRP->size)
9D000E3C  0089202B   SLTU A0, A0, T1
9D000E40  54800005   BNEL A0, ZERO, 0x9D000E58
9D000E44  8CA4001C   LW A0, 28(A1)
798:                                         {
799:                                             /* The write transfer is complete. Fall through to the
800:                                              * handshake stage */   
801:                                             pipe->nakCounter = 0;
9D000E48  AC600018   SW ZERO, 24(V1)
802:                                             pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_HANDSHAKE;
9D000E4C  24040004   ADDIU A0, ZERO, 4
9D000E50  0B4003B8   J 0x9D000EE0
9D000E54  ACA40020   SW A0, 32(A1)
803:                                         }
804:                                         else if((deviceResponseSize == pIRP->tempSize) || (deviceResponseSize == pipe->endpointSize))
9D000E58  50870005   BEQL A0, A3, 0x9D000E70
9D000E5C  00C4202B   SLTU A0, A2, A0
9D000E60  8C69001C   LW T1, 28(V1)
9D000E64  55270025   BNEL T1, A3, 0x9D000EFC
9D000E68  8C460074   LW A2, 116(V0)
805:                                         {
806:                                             if(pIRP->tempSize > pIRP->completedBytesInThisFrame)
9D000E6C  00C4202B   SLTU A0, A2, A0
9D000E70  50800012   BEQL A0, ZERO, 0x9D000EBC
9D000E74  24020002   ADDIU V0, ZERO, 2
807:                                             {
808:                                                 /* More transactions are required in this frame */
809:                                                 pipe->dataToggle ^= 0x1;
9D000E78  8C640014   LW A0, 20(V1)
9D000E7C  38840001   XORI A0, A0, 1
9D000E80  AC640014   SW A0, 20(V1)
810:                                                 pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_DATA_STAGE;
9D000E84  24040002   ADDIU A0, ZERO, 2
9D000E88  ACA40020   SW A0, 32(A1)
811:                                                 pIRP->status = USB_HOST_IRP_STATUS_IN_PROGRESS;
9D000E8C  24040003   ADDIU A0, ZERO, 3
9D000E90  ACA4000C   SW A0, 12(A1)
812:                                                 _DRV_USBFS_HOST_ControlSendToken(pIRP,pUSBDrvObj, pipe,endpoint,deviceAddress,usbID, isLowSpeed);
9D000E94  AFAC0010   SW T4, 16(SP)
9D000E98  AFA80014   SW T0, 20(SP)
9D000E9C  AFAA0018   SW T2, 24(SP)
9D000EA0  00A02021   ADDU A0, A1, ZERO
9D000EA4  00402821   ADDU A1, V0, ZERO
9D000EA8  00603021   ADDU A2, V1, ZERO
9D000EAC  0F401D85   JAL _DRV_USBFS_HOST_ControlSendToken
9D000EB0  01603821   ADDU A3, T3, ZERO
9D000EB4  0B40042B   J 0x9D0010AC
9D000EB8  24020001   ADDIU V0, ZERO, 1
813:                                                 tokenSent = true;
814:                                             }
815:                                             else
816:                                             {
817:                                                 /* Whatever planned for this frame has been done */
818:                                                 /* Do not Move the IRP Queue head here */
819:                                                 /* Do not end the IRP */
820:                                                 pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_DATA_STAGE;
9D000EBC  ACA20020   SW V0, 32(A1)
821:                                                 pIRP->status = USB_HOST_IRP_STATUS_IN_PROGRESS;
9D000EC0  24020003   ADDIU V0, ZERO, 3
9D000EC4  ACA2000C   SW V0, 12(A1)
822:                                                 pipe->dataToggle ^= 0x1;
9D000EC8  8C620014   LW V0, 20(V1)
9D000ECC  38420001   XORI V0, V0, 1
9D000ED0  AC620014   SW V0, 20(V1)
823:                                                 pipe->nakCounter = 0;
9D000ED4  AC600018   SW ZERO, 24(V1)
824:                                                 endIRP = false;
825:                                                 tokenSent = false;
9D000ED8  0B40042B   J 0x9D0010AC
9D000EDC  00001021   ADDU V0, ZERO, ZERO
826:                                             }
827:                                             break;
828:                                         }
829:                                     }
830:                                 }
831:                                
832:                 
833:                             case DRV_USBFS_HOST_IRP_STATE_HANDSHAKE:
834:                                 /* Send the Handshake Stage */
835:                                 {
836:                                     USB_BUFFER_DIRECTION direction;
837:                                     USB_BUFFER_PING_PONG pingPong;
838:                                     USB_PID pid;
839:                 
840:                                     if((pipe->endpointAndDirection & 0x80) != 0)
9D000EE0  80630008   LB V1, 8(V1)
9D000EE4  04630005   BGEZL V1, 0x9D000EFC
9D000EE8  8C460074   LW A2, 116(V0)
841:                                     {
842:                                         /* Data is moving from device to host */
843:                                         direction = USB_BUFFER_TX;
844:                                         pingPong = pUSBDrvObj->ep0TxPingPong;
9D000EEC  8C460070   LW A2, 112(V0)
845:                                         pid = USB_PID_OUT;
9D000EF0  24030001   ADDIU V1, ZERO, 1
9D000EF4  0B4003C1   J 0x9D000F04
9D000EF8  24040001   ADDIU A0, ZERO, 1
846:                                     }
847:                                     else 
848:                                     {
849:                                         /* Data is moving from host to device */
850:                                         direction = USB_BUFFER_RX;
9D000F00  00002021   ADDU A0, ZERO, ZERO
851:                                         pingPong = pUSBDrvObj->ep0RxPingPong;
852:                                         pid = USB_PID_IN;
9D000EFC  24030009   ADDIU V1, ZERO, 9
853:                                     }
854:                 
855:                                     pBDT = pUSBDrvObj->pBDT + (direction << 1) + pingPong;
9D000F04  00042040   SLL A0, A0, 1
9D000F08  00862021   ADDU A0, A0, A2
9D000F0C  000420C0   SLL A0, A0, 3
9D000F10  8C42002C   LW V0, 44(V0)
9D000F14  00441021   ADDU V0, V0, A0
856:                 
857:                                     /* Configure the BDT Entry for data packet */
858:                                     pBDT->shortWord[1]  = 0;
9D000F18  A4400002   SH ZERO, 2(V0)
859:                                     pBDT->word[1] = 0;
9D000F1C  AC400004   SW ZERO, 4(V0)
860:                                     pBDT->byte[0] = (USBFS_UOWN|USBFS_DATA1_PID|USBFS_DTS_ENABLE);
9D000F20  2404FFC8   ADDIU A0, ZERO, -56
9D000F24  A0440000   SB A0, 0(V0)
861:                 
862:                                     /* Keep track of the transaction */
863:                                     pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_HANDSHAKE_SENT;
9D000F28  24020005   ADDIU V0, ZERO, 5
9D000F2C  ACA20020   SW V0, 32(A1)
864:                 
865:                                     /* Enable Handshake */
866:                                     PLIB_USB_EPnHandshakeEnable(usbID, 0);
867:                 
868:                                     /* This will cause the Transaction interrupt */
869:                                     _DRV_USBFS_SendTokenToAddress(usbID, deviceAddress, pid, endpoint, isLowSpeed);
870:                 
871:                                     tokenSent = true;
9D000F64  0B40042B   J 0x9D0010AC
9D000F68  24020001   ADDIU V0, ZERO, 1
872:                                     break;
873:                                 }
874:                 
875:                             case DRV_USBFS_HOST_IRP_STATE_HANDSHAKE_SENT:
876:                 
877:                                 /* Check the response */
878:                                 if((USB_TRANSACTION_ACK == deviceResponse) || (USB_TRANSACTION_DATA1 == deviceResponse))
9D000F6C  24040002   ADDIU A0, ZERO, 2
9D000F70  10C40003   BEQ A2, A0, 0x9D000F80
9D000F74  2404000B   ADDIU A0, ZERO, 11
9D000F78  14C40010   BNE A2, A0, 0x9D000FBC
9D000F7C  2404000A   ADDIU A0, ZERO, 10
879:                                 {
880:                                     /* Transfer is complete */
881:                                     pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_COMPLETE;
9D000F80  24040006   ADDIU A0, ZERO, 6
9D000F84  ACA40020   SW A0, 32(A1)
882:                                     pIRP->status = USB_HOST_IRP_STATUS_COMPLETED;
9D000F88  ACA0000C   SW ZERO, 12(A1)
883:                                     if(((pipe->endpointAndDirection & 0x80) != 0) && (pIRP->size > pIRP->completedBytes))
9D000F8C  80630008   LB V1, 8(V1)
9D000F90  04630036   BGEZL V1, 0x9D00106C
9D000F94  9044006C   LBU A0, 108(V0)
9D000F98  8CA30024   LW V1, 36(A1)
9D000F9C  8CA40008   LW A0, 8(A1)
9D000FA0  0064202B   SLTU A0, V1, A0
9D000FA4  50800031   BEQL A0, ZERO, 0x9D00106C
9D000FA8  9044006C   LBU A0, 108(V0)
884:                                     {
885:                                         /* While moving data from device to host, if we received
886:                                          * less data from the device than expected, then indicate a
887:                                          * short packet and set the irp size to to actual size */ 
888:                 
889:                                         pIRP->status = USB_HOST_IRP_STATUS_COMPLETED_SHORT;
9D000FAC  24040001   ADDIU A0, ZERO, 1
9D000FB0  ACA4000C   SW A0, 12(A1)
890:                                         pIRP->size = pIRP->completedBytes;
9D000FB4  0B40041A   J 0x9D001068
9D000FB8  ACA30008   SW V1, 8(A1)
891:                                     }
892:                                     endIRP = true;
893:                                 }
894:                                 else if(USB_TRANSACTION_NAK == deviceResponse)
9D000FBC  14C40011   BNE A2, A0, 0x9D001004
9D000FC0  2404000E   ADDIU A0, ZERO, 14
895:                                 {
896:                                     pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_HANDSHAKE;
9D000FC4  24040004   ADDIU A0, ZERO, 4
9D000FC8  ACA40020   SW A0, 32(A1)
897:                                     pipe->nakCounter ++;
9D000FCC  8C640018   LW A0, 24(V1)
9D000FD0  24840001   ADDIU A0, A0, 1
9D000FD4  AC640018   SW A0, 24(V1)
898:                                     if(pipe->nakCounter > DRV_USBFS_HOST_NAK_LIMIT)
9D000FD8  2C8407D1   SLTIU A0, A0, 2001
9D000FDC  54800006   BNEL A0, ZERO, 0x9D000FF8
9D000FE0  24020004   ADDIU V0, ZERO, 4
899:                                     {
900:                                         pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_COMPLETE;
9D000FE4  24030006   ADDIU V1, ZERO, 6
9D000FE8  ACA30020   SW V1, 32(A1)
901:                                         pIRP->status = USB_HOST_IRP_STATUS_ERROR_NAK_TIMEOUT;
9D000FEC  2403FFFE   ADDIU V1, ZERO, -2
9D000FF0  0B40041A   J 0x9D001068
9D000FF4  ACA3000C   SW V1, 12(A1)
902:                                         endIRP = true;
903:                                     }
904:                                     else
905:                                     {
906:                                         pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_HANDSHAKE;
9D000FF8  ACA20020   SW V0, 32(A1)
907:                                     }
908:                                     break;
909:                                 }
910:                                 else if(USB_TRANSACTION_STALL == deviceResponse)
9D001004  14C40006   BNE A2, A0, 0x9D001020
9D001008  2404000F   ADDIU A0, ZERO, 15
911:                                 {
912:                                     pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_COMPLETE;
9D00100C  24030006   ADDIU V1, ZERO, 6
9D001010  ACA30020   SW V1, 32(A1)
913:                                     pIRP->status = USB_HOST_IRP_STATUS_ERROR_STALL;
9D001014  2403FFFF   ADDIU V1, ZERO, -1
914:                                     endIRP = true;
915:                                     break;
9D001018  0B40041A   J 0x9D001068
9D00101C  ACA3000C   SW V1, 12(A1)
916:                                 }
917:                                 else if(USB_TRANSACTION_DATA_ERROR == deviceResponse)
9D001020  54C40012   BNEL A2, A0, 0x9D00106C
9D001024  9044006C   LBU A0, 108(V0)
918:                                 {
919:                                     /* A data error occurred. End the transfer with an error
920:                                      * code */
921:                                     pipe->nakCounter = 0;
9D001028  AC600018   SW ZERO, 24(V1)
922:                                     pIRP->status = USB_HOST_IRP_STATUS_ERROR_DATA;
9D00102C  2403FFFD   ADDIU V1, ZERO, -3
9D001030  ACA3000C   SW V1, 12(A1)
923:                                     pIRP->tempState =  DRV_USBFS_HOST_IRP_STATE_COMPLETE;
9D001034  24030006   ADDIU V1, ZERO, 6
924:                                     endIRP = true;
925:                                     break;
9D001038  0B40041A   J 0x9D001068
9D00103C  ACA30020   SW V1, 32(A1)
926:                                 }
927:                                     
928:                 
929:                             case DRV_USBFS_HOST_IRP_STATE_COMPLETE:
930:                                 /* Remove the irp from the from the SW EP object. */
931:                                 endIRP = true;
932:                                 break;
933:                 
934:                             default:
935:                                 break;
936:                         }
937:                 
938:                         /* An IRP will end if the handshake stage has completed, or if there was a
939:                          * stall during data or status stage, a NAK time out error or an error in the
940:                          * setup stage. */
941:                 
942:                         if(endIRP == true)
943:                         {
944:                             softwareEP = &pUSBDrvObj->drvUSBHostSWEp[pUSBDrvObj->numSWEpEntry];
9D001068  9044006C   LBU A0, 108(V0)
9D00106C  00041880   SLL V1, A0, 2
9D001070  00042100   SLL A0, A0, 4
9D001074  00831823   SUBU V1, A0, V1
9D001078  24630078   ADDIU V1, V1, 120
9D00107C  00431821   ADDU V1, V0, V1
945:                             transferGroup = &pUSBDrvObj->transferGroup[USB_TRANSFER_TYPE_CONTROL];
946:                             
947:                             softwareEP->tobeDone = false;
9D001080  A0600004   SB ZERO, 4(V1)
948:                 
949:                             /* Update the IRP to move to the next IRP in the pipe */
950:                             (transferGroup->currentPipe)->irpQueueHead = (softwareEP->pIRP)->next;
9D001084  8C440040   LW A0, 64(V0)
9D001088  8C63000C   LW V1, 12(V1)
9D00108C  8C63002C   LW V1, 44(V1)
9D001090  AC830010   SW V1, 16(A0)
951:                 
952:                             /* Update the current pipe to point to the next pipe in the bundle */
953:                             if((transferGroup->currentPipe) ->next != NULL)
9D001094  8C430040   LW V1, 64(V0)
9D001098  8C630020   LW V1, 32(V1)
9D00109C  5460FFE9   BNEL V1, ZERO, 0x9D001044
9D0010A0  AC430040   SW V1, 64(V0)
9D0010A4  0B400410   J 0x9D001040
9D0010A8  8C43003C   LW V1, 60(V0)
954:                             {
955:                                 /* This is not the last PIPE */
956:                                 transferGroup->currentPipe = transferGroup->currentPipe->next;
957:                             }
958:                             else
959:                             {
960:                                 /* This is the last PIPE. Move to the head pipe */
961:                                 transferGroup->currentPipe = transferGroup->pipe;
9D001040  AC430040   SW V1, 64(V0)
962:                             }
963:                 
964:                             /* IRP completed. Call the callback */
965:                             if(pIRP->callback != NULL)
9D001044  8CA20018   LW V0, 24(A1)
9D001048  50400018   BEQL V0, ZERO, 0x9D0010AC
9D00104C  00001021   ADDU V0, ZERO, ZERO
966:                             {
967:                                 pIRP->callback((USB_HOST_IRP *)pIRP);
9D001050  0040F809   JALR V0
9D001054  00A02021   ADDU A0, A1, ZERO
9D001058  0B40042B   J 0x9D0010AC
9D00105C  00001021   ADDU V0, ZERO, ZERO
968:                             }
969:                         }
970:                     }
971:                 
972:                     return(tokenSent);
973:                 } 
9D0010AC  8FBF0024   LW RA, 36(SP)
974:                 
975:                 // *****************************************************************************
976:                 /* Function:
977:                      void DRV_USBFS_HOST_PipeClose(DRV_USBFS_HOST_PIPE_HANDLE pipeHandle)
978:                 
979:                   Summary:
980:                     Closes an open pipe.
981:                 	
982:                   Description:
983:                     This function closes an open pipe. Any IRPs scheduled on the pipe will be
984:                     aborted and IRP callback functions will be called with the status as
985:                     DRV_USB_HOST_IRP_STATE_ABORTED. The pipe handle will become invalid and the
986:                     pipe will not accept IRPs.
987:                 
988:                   Remarks:
989:                     See drv_usbfs.h for usage information.
990:                 */
991:                 
992:                 void DRV_USBFS_HOST_PipeClose
993:                 (
994:                     DRV_USBFS_HOST_PIPE_HANDLE pipeHandle
995:                 )
996:                 {
9D0047C4  27BDFFC8   ADDIU SP, SP, -56
9D0047C8  AFBF0034   SW RA, 52(SP)
9D0047CC  AFB70030   SW S7, 48(SP)
9D0047D0  AFB6002C   SW S6, 44(SP)
9D0047D4  AFB50028   SW S5, 40(SP)
9D0047D8  AFB40024   SW S4, 36(SP)
9D0047DC  AFB30020   SW S3, 32(SP)
9D0047E0  AFB2001C   SW S2, 28(SP)
9D0047E4  AFB10018   SW S1, 24(SP)
9D0047E8  AFB00014   SW S0, 20(SP)
997:                     bool interruptWasEnabled = false;
998:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)NULL;
999:                     USB_HOST_IRP_LOCAL * pIRP = (USB_HOST_IRP_LOCAL *)NULL;
1000:                    DRV_USBFS_HOST_PIPE_OBJ * pPipe = (DRV_USBFS_HOST_PIPE_OBJ *)NULL;
1001:                    DRV_USBFS_HOST_PIPE_OBJ * piteratorPipe = (DRV_USBFS_HOST_PIPE_OBJ *)NULL;
1002:                    DRV_USBFS_HOST_TRANSFER_GROUP * pTransferGroup = (DRV_USBFS_HOST_TRANSFER_GROUP *)NULL ;
1003:                    bool thereWasAnError = false;
1004:                
1005:                    /* Make sure we have a valid pipe */
1006:                    if((pipeHandle != DRV_USBFS_HOST_PIPE_HANDLE_INVALID) && (pipeHandle != (DRV_USBFS_HOST_PIPE_HANDLE)(NULL)))
9D0047EC  2482FFFF   ADDIU V0, A0, -1
9D0047F0  2C42FFFE   SLTIU V0, V0, -2
9D0047F4  1040005E   BEQ V0, ZERO, 0x9D004970
9D0047F8  00808821   ADDU S1, A0, ZERO
1007:                    {
1008:                        pPipe = (DRV_USBFS_HOST_PIPE_OBJ*) pipeHandle;
1009:                
1010:                        /* Make sure that we are working with a pipe in use */
1011:                        if(pPipe->inUse == true)
9D0047FC  90820000   LBU V0, 0(A0)
9D004800  1040005B   BEQ V0, ZERO, 0x9D004970
9D004804  00808021   ADDU S0, A0, ZERO
1012:                        {
1013:                            pUSBDrvObj = (DRV_USBFS_OBJ *)pPipe->hClient;
9D004808  8C920004   LW S2, 4(A0)
1014:                
1015:                            /* Disable the interrupt */
1016:                            if(!(pUSBDrvObj->inInterruptContext))
9D00480C  92420001   LBU V0, 1(S2)
9D004810  54400045   BNEL V0, ZERO, 0x9D004928
9D004814  0000A021   ADDU S4, ZERO, ZERO
1017:                            {
1018:                                /* We have to disable the interrupt because the pipe object can be
1019:                                 * accessed asynchronously from the interrupt service routine. */
1020:                
1021:                                if(OSAL_MUTEX_Lock(&pUSBDrvObj->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1022:                                {
1023:                                    interruptWasEnabled = _DRV_USBFS_InterruptSourceDisable(pUSBDrvObj->interruptSource);
9D00482C  0F402481   JAL SYS_INT_SourceDisable
9D004830  8E440028   LW A0, 40(S2)
9D004834  0B40124A   J 0x9D004928
9D004838  0040A021   ADDU S4, V0, ZERO
9D00483C  0B401257   J 0x9D00495C
9D004840  AC620004   SW V0, 4(V1)
1024:                                }
1025:                                else
1026:                                {
1027:                                    SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex lock failed");
1028:                                    thereWasAnError = true;
1029:                                }
1030:                            }
1031:                
1032:                            if(!thereWasAnError)
1033:                            {
1034:                                /* Get the transfer group that this pipe belongs to. */
1035:                                pTransferGroup = &pUSBDrvObj->transferGroup[pPipe->pipeType];
9D004928  8E22000C   LW V0, 12(S1)
9D00492C  00021880   SLL V1, V0, 2
9D004930  00021100   SLL V0, V0, 4
9D004934  00431823   SUBU V1, V0, V1
9D004938  24630038   ADDIU V1, V1, 56
9D00493C  02431821   ADDU V1, S2, V1
1036:                
1037:                                /* Search for this pipe within this group */ 
1038:                                if(pTransferGroup->pipe == pPipe)
9D004940  8C620004   LW V0, 4(V1)
9D004944  1450FFBF   BNE V0, S0, 0x9D004844
9D004948  24640004   ADDIU A0, V1, 4
9D00494C  0B40120F   J 0x9D00483C
9D004950  8C420020   LW V0, 32(V0)
1039:                                {
1040:                                    /* First pipe in the transfer group needs to be closed */
1041:                                    pTransferGroup->pipe = pPipe->next;
1042:                                }
1043:                                else
1044:                                {
1045:                                    /* Remove this pipe from the linked list */
1046:                                    piteratorPipe = pTransferGroup->pipe;
1047:                                    while((piteratorPipe != NULL) && (piteratorPipe->next != pPipe))
9D004844  50400027   BEQL V0, ZERO, 0x9D0048E4
9D004848  A2200000   SB ZERO, 0(S1)
9D00484C  8C430020   LW V1, 32(V0)
9D004850  14700006   BNE V1, S0, 0x9D00486C
9D004854  00000000   NOP
9D004858  0B401255   J 0x9D004954
9D00485C  00401821   ADDU V1, V0, ZERO
9D004860  50B0003D   BEQL A1, S0, 0x9D004958
9D004864  8E220020   LW V0, 32(S1)
9D004868  00A01821   ADDU V1, A1, ZERO
9D00486C  5460FFFC   BNEL V1, ZERO, 0x9D004860
9D004870  8C650020   LW A1, 32(V1)
9D004874  0B401239   J 0x9D0048E4
9D004878  A2200000   SB ZERO, 0(S1)
1048:                                    {
1049:                                        piteratorPipe = piteratorPipe->next;
1050:                                    }
1051:                
1052:                                    /* Make sure we have a valid pipe */
1053:                                    if(piteratorPipe == NULL)
1054:                                    {
1055:                                        /* This is a strange case. The pipe is in use but is not
1056:                                         * part of transfer group. This would be a orphan pipe. */
1057:                
1058:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Illegal pipe handle");
1059:                                        thereWasAnError = true;
1060:                                    }
1061:                                    else
1062:                                    {
1063:                                        piteratorPipe->next = pPipe->next;
9D004954  8E220020   LW V0, 32(S1)
9D004958  AC620020   SW V0, 32(V1)
1064:                                    }
1065:                                }
1066:                
1067:                                if(!thereWasAnError)
1068:                                {
1069:                                    /* Pipe is not orphan and is part of the transfer group.
1070:                                     * Continue to remove it */
1071:                
1072:                                    if(pTransferGroup->nPipes != 0)
9D00495C  8C820008   LW V0, 8(A0)
9D004960  1440FFC6   BNE V0, ZERO, 0x9D00487C
9D004964  2442FFFF   ADDIU V0, V0, -1
9D004968  0B401221   J 0x9D004884
9D00496C  8E300010   LW S0, 16(S1)
1073:                                    {
1074:                                        /* Reduce the count only if its not zero already */
1075:                                        pTransferGroup->nPipes --;
9D00487C  AC820008   SW V0, 8(A0)
1076:                                    }
1077:                
1078:                                    /* Now we invoke the call back for each IRP in this pipe and
1079:                                     * say that it is aborted.  If the IRP is in progress, then
1080:                                     * that IRP will be actually aborted on the next SOF unless
1081:                                     * the device is being detached. If the device is being
1082:                                     * detached, then we could potentially land in a situatino
1083:                                     * where the IRP temp state says aborted, but the TRNIF will
1084:                                     * never occur and then IRP will never be aborted. Deferring
1085:                                     * the IRP abort allows the USB module to complete any
1086:                                     * transaction that was in progress. */
1087:                
1088:                                    pIRP = (USB_HOST_IRP_LOCAL *)pPipe->irpQueueHead;
9D004880  8E300010   LW S0, 16(S1)
1089:                
1090:                                    while(pIRP != NULL)
9D004884  52000017   BEQL S0, ZERO, 0x9D0048E4
9D004888  A2200000   SB ZERO, 0(S1)
9D0048D8  5600FFF1   BNEL S0, ZERO, 0x9D0048A0
9D0048DC  AE150030   SW S5, 48(S0)
1091:                                    {
1092:                                        pIRP->pipe = DRV_USBFS_HOST_PIPE_HANDLE_INVALID;
9D00488C  2415FFFF   ADDIU S5, ZERO, -1
9D00489C  AE150030   SW S5, 48(S0)
1093:                
1094:                                        if((pIRP->status == USB_HOST_IRP_STATUS_IN_PROGRESS) && (pUSBDrvObj->isDeviceDeenumerating == false))
9D004890  24130003   ADDIU S3, ZERO, 3
9D0048A0  8E02000C   LW V0, 12(S0)
9D0048A4  54530006   BNEL V0, S3, 0x9D0048C0
9D0048A8  AE16000C   SW S6, 12(S0)
9D0048AC  924200DA   LBU V0, 218(S2)
9D0048B0  54400003   BNEL V0, ZERO, 0x9D0048C0
9D0048B4  AE16000C   SW S6, 12(S0)
1095:                                        {
1096:                                            /* If the IRP is in progress and device
1097:                                             * de-enumeration operation is not in progress, then
1098:                                             * we set the temp IRP state.  This will be caught
1099:                                             * in the _DRV_USBFS_HOST_NonControlIRPProcess() and
1100:                                             * _DRV_USBFS_HOST_ControlXferProcess() functions */
1101:                
1102:                                            pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_ABORTED;
9D004898  24170007   ADDIU S7, ZERO, 7
9D0048B8  0B401235   J 0x9D0048D4
9D0048BC  AE170020   SW S7, 32(S0)
1103:                                        }
1104:                                        else
1105:                                        {
1106:                                            /* The IRP is not in progress or the IRP is in
1107:                                             * progress or device de-enumeration is also in
1108:                                             * progress because of device detach, then the IRP
1109:                                             * needs to be aborted. We cannot wait for TRNIF as
1110:                                             * there will be no TRNIF post device detach */
1111:                
1112:                                            pIRP->status = USB_HOST_IRP_STATUS_ABORTED;
9D004894  2416FFFB   ADDIU S6, ZERO, -5
1113:                                            if(pIRP->callback != NULL)
9D0048C0  8E030018   LW V1, 24(S0)
9D0048C4  50600004   BEQL V1, ZERO, 0x9D0048D8
9D0048C8  8E10002C   LW S0, 44(S0)
1114:                                            {
1115:                                                pIRP->callback((USB_HOST_IRP*)pIRP);
9D0048CC  0060F809   JALR V1
9D0048D0  02002021   ADDU A0, S0, ZERO
1116:                                            }
1117:                                        }
1118:                
1119:                                        pIRP = pIRP->next;
9D0048D4  8E10002C   LW S0, 44(S0)
1120:                                    }
1121:                                }
1122:                
1123:                                /* Irrespective of whether the pipe is orphan or not, we return
1124:                                 * the pipe back to the driver */
1125:                
1126:                                pPipe->inUse = false;
9D0048E0  A2200000   SB ZERO, 0(S1)
1127:                
1128:                                /* Restore the interrupts */
1129:                                if(!(pUSBDrvObj->inInterruptContext))
9D0048E4  92420001   LBU V0, 1(S2)
9D0048E8  14400022   BNE V0, ZERO, 0x9D004974
9D0048EC  8FBF0034   LW RA, 52(SP)
1130:                                {
1131:                                    if(interruptWasEnabled)
9D0048F0  1280000B   BEQ S4, ZERO, 0x9D004920
9D0048F4  24020001   ADDIU V0, ZERO, 1
1132:                                    {
1133:                                        _DRV_USBFS_InterruptSourceEnable(pUSBDrvObj->interruptSource);
9D0048F8  8E420028   LW V0, 40(S2)
1134:                                    }
1135:                
1136:                                    OSAL_MUTEX_Unlock(&pUSBDrvObj->mutexID);
1137:                                }
1138:                            }
1139:                        }
1140:                        else
1141:                        {
1142:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Pipe is not in use");
1143:                        }
1144:                    }
1145:                    else
1146:                    {
1147:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid pipe handle");
1148:                    }
1149:                }
9D004970  8FBF0034   LW RA, 52(SP)
1150:                
1151:                // *****************************************************************************
1152:                /* Function:
1153:                    DRV_USBFS_HOST_PIPE_HANDLE DRV_USBFS_HOST_PipeSetup
1154:                    (
1155:                        DRV_HANDLE handle,
1156:                        uint8_t deviceAddress,
1157:                        USB_ENDPOINT endpointAndDirection,
1158:                        uint8_t hubAddress,
1159:                        uint8_t hubPort,
1160:                        USB_TRANSFER_TYPE pipeType,
1161:                        uint8_t bInterval,
1162:                        uint16_t wMaxPacketSize,
1163:                        USB_SPEED speed
1164:                    )
1165:                
1166:                  Summary:
1167:                    Open a pipe with the specified attributes.
1168:                	
1169:                  Description:
1170:                    This function opens a communication pipe between the Host and the device
1171:                    endpoint. The transfer type and other attributes are specified through the
1172:                    function parameters. The driver does not check for available bus bandwidth,
1173:                    which should be done by the application (the USB Host Layer in this case)
1174:                
1175:                  Remarks:
1176:                    See drv_usbfs.h for usage information.
1177:                */
1178:                
1179:                DRV_USBFS_HOST_PIPE_HANDLE DRV_USBFS_HOST_PipeSetup 
1180:                (
1181:                    DRV_HANDLE handle,
1182:                    uint8_t deviceAddress, 
1183:                    USB_ENDPOINT endpointAndDirection,
1184:                    uint8_t hubAddress,
1185:                    uint8_t hubPort,
1186:                    USB_TRANSFER_TYPE pipeType, 
1187:                    uint8_t bInterval, 
1188:                    uint16_t wMaxPacketSize,
1189:                    USB_SPEED speed
1190:                )
1191:                {
9D002D68  93A80018   LBU T0, 24(SP)
1192:                    DRV_USBFS_HOST_PIPE_OBJ * pPipe = (DRV_USBFS_HOST_PIPE_OBJ *)NULL;
1193:                    DRV_USBFS_HOST_PIPE_OBJ * piteratorPipe = (DRV_USBFS_HOST_PIPE_OBJ *)NULL;
1194:                    DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
1195:                    DRV_USBFS_HOST_PIPE_HANDLE returnValue = DRV_USBFS_HOST_PIPE_HANDLE_INVALID;
9D002FB8  2402FFFF   ADDIU V0, ZERO, -1
9D002FC8  03E00008   JR RA
9D002FCC  2402FFFF   ADDIU V0, ZERO, -1
9D002FD0  03E00008   JR RA
9D002FD4  2402FFFF   ADDIU V0, ZERO, -1
9D002FF8  0B400BEF   J DRV_USBFS_HOST_PipeSetup::OSAL_MUTEX_Unlock
9D002FFC  2402FFFF   ADDIU V0, ZERO, -1
1196:                    DRV_USBFS_HOST_TRANSFER_GROUP * pTransferGroup = (DRV_USBFS_HOST_TRANSFER_GROUP *)NULL;
1197:                    unsigned int transferTypeLocal = 0;
1198:                    uint8_t pipeCount = 0;
1199:                    uint8_t bitSetCount = 0;
1200:                    bool thereWasAnError = false;
1201:                
1202:                    if((handle != DRV_HANDLE_INVALID) && (pUSBDrvObj != NULL) && (pUSBDrvObj->isOpened))
9D002D6C  2402FFFF   ADDIU V0, ZERO, -1
9D002D70  10820095   BEQ A0, V0, 0x9D002FC8
9D002D74  97A7001C   LHU A3, 28(SP)
9D002D78  10800095   BEQ A0, ZERO, 0x9D002FD0
9D002D7C  00000000   NOP
9D002D80  90830005   LBU V1, 5(A0)
9D002D84  106000AC   BEQ V1, ZERO, 0x9D003038
9D002D88  24030001   ADDIU V1, ZERO, 1
1203:                    {
1204:                        /* Driver handle is valid. We need to grab a mutex as the pipe pool is a
1205:                         * global object */
1206:                        if(OSAL_MUTEX_Lock(&pUSBDrvObj->mutexID, OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1207:                        {
1208:                            /* Search for a free pipe object */
1209:                            for(pipeCount = 0; pipeCount < DRV_USBFS_HOST_PIPES_NUMBER; pipeCount++)
9D002DB4  240B000A   ADDIU T3, ZERO, 10
9D002FB0  144BFF81   BNE V0, T3, 0x9D002DB8
9D002FB4  2463002C   ADDIU V1, V1, 44
1210:                            {
1211:                                /* Check for free pipe object */
1212:                                if(gDrvUSBHostPipeObj[pipeCount].inUse == false)
9D002D9C  3C02A000   LUI V0, -24576
9D002DA0  90420314   LBU V0, 788(V0)
9D002DA4  10400009   BEQ V0, ZERO, 0x9D002DCC
9D002DA8  3C03A000   LUI V1, -24576
9D002DAC  24630340   ADDIU V1, V1, 832
9D002DB0  24020001   ADDIU V0, ZERO, 1
9D002DB8  90690000   LBU T1, 0(V1)
9D002DBC  1520007B   BNE T1, ZERO, 0x9D002FAC
9D002DC0  00405021   ADDU T2, V0, ZERO
9D002DCC  00005021   ADDU T2, ZERO, ZERO
1213:                                {
1214:                                    /* We found a pipe object that we can use.  Go and grab that
1215:                                     * one.  */
1216:                                    gDrvUSBHostPipeObj[pipeCount].inUse = true;
9D002DC4  0B400B75   J 0x9D002DD4
9D002DC8  000A1880   SLL V1, T2, 2
9D002DD0  000A1880   SLL V1, T2, 2
9D002DD4  000A1100   SLL V0, T2, 4
9D002DD8  00431823   SUBU V1, V0, V1
9D002DDC  006A1823   SUBU V1, V1, T2
9D002DE0  00031880   SLL V1, V1, 2
9D002DE4  3C02A000   LUI V0, -24576
9D002DE8  24420314   ADDIU V0, V0, 788
9D002DEC  00621021   ADDU V0, V1, V0
9D002DF0  24030001   ADDIU V1, ZERO, 1
9D002DF4  A0430000   SB V1, 0(V0)
1217:                
1218:                                    /* Initialize the pipe object */
1219:                                    pPipe = &gDrvUSBHostPipeObj[pipeCount];
1220:                
1221:                                    pPipe->deviceAddress = deviceAddress;
9D002DF8  A0450025   SB A1, 37(V0)
1222:                                    pPipe->irpQueueHead = NULL;
9D002DFC  AC400010   SW ZERO, 16(V0)
1223:                                    pPipe->bInterval = bInterval;
9D002E00  A0480024   SB T0, 36(V0)
1224:                                    pPipe->speed = speed;
9D002E04  8FA30020   LW V1, 32(SP)
9D002E08  AC430028   SW V1, 40(V0)
1225:                                    pPipe->pipeType = pipeType;
9D002E0C  8FA50014   LW A1, 20(SP)
9D002E10  AC45000C   SW A1, 12(V0)
1226:                                    pPipe->hClient = handle;
9D002E14  AC440004   SW A0, 4(V0)
1227:                                    pPipe->endpointSize = wMaxPacketSize;
9D002E18  AC47001C   SW A3, 28(V0)
1228:                                    pPipe->intervalCounter = bInterval;
9D002E1C  A0480026   SB T0, 38(V0)
1229:                                    pPipe->dataToggle = USB_BUFFER_DATA0;
9D002E20  AC400014   SW ZERO, 20(V0)
1230:                
1231:                                    pPipe->endpointAndDirection = endpointAndDirection;
1232:                
1233:                                    /* This pipe should now be added to the pipe bundle. The
1234:                                     * mapping from the transfer type to the way the pipe
1235:                                     * bundles are organized is not a one to one mapping. We
1236:                                     * translate the pipe type to a local type. */
1237:                
1238:                                    switch(pPipe->pipeType)
9D002E24  24030001   ADDIU V1, ZERO, 1
9D002E28  10A3000D   BEQ A1, V1, 0x9D002E60
9D002E2C  A0460008   SB A2, 8(V0)
9D002E30  10A00007   BEQ A1, ZERO, 0x9D002E50
9D002E34  24030002   ADDIU V1, ZERO, 2
9D002E38  10A30007   BEQ A1, V1, 0x9D002E58
9D002E3C  24030003   ADDIU V1, ZERO, 3
9D002E40  10A30008   BEQ A1, V1, 0x9D002E64
9D002E44  24080001   ADDIU T0, ZERO, 1
1239:                                    {
1240:                                        case USB_TRANSFER_TYPE_CONTROL:
1241:                                            transferTypeLocal = USB_TRANSFER_TYPE_LOCAL_CONTROL;
9D002E50  0B400B99   J 0x9D002E64
9D002E54  00004021   ADDU T0, ZERO, ZERO
1242:                                            break;
1243:                                        case USB_TRANSFER_TYPE_ISOCHRONOUS:
1244:                                            transferTypeLocal = USB_TRANSFER_TYPE_LOCAL_ISOC;
9D002E60  24080003   ADDIU T0, ZERO, 3
1245:                                            break;
1246:                                        case USB_TRANSFER_TYPE_BULK:
1247:                                            transferTypeLocal = USB_TRANSFER_TYPE_LOCAL_BULK;
1248:                                            break;
9D002E58  0B400B99   J 0x9D002E64
9D002E5C  24080002   ADDIU T0, ZERO, 2
1249:                                        case USB_TRANSFER_TYPE_INTERRUPT:
1250:                                            transferTypeLocal = USB_TRANSFER_TYPE_LOCAL_INTERRUPT;
1251:                                            break;
1252:                                        default:
1253:                                            return returnValue;
9D002E48  03E00008   JR RA
9D002E4C  2402FFFF   ADDIU V0, ZERO, -1
1254:                                    }
1255:                
1256:                                    /* In a case where the max packet size is a multiple of 2, find
1257:                                     * calculate the log2n. */
1258:                                    if((wMaxPacketSize <= 512) && (wMaxPacketSize != 0))
9D002E64  24E3FFFF   ADDIU V1, A3, -1
9D002E68  3063FFFF   ANDI V1, V1, -1
9D002E6C  2C630200   SLTIU V1, V1, 512
9D002E70  1060000F   BEQ V1, ZERO, 0x9D002EB0
9D002E74  00000000   NOP
1259:                                    {
1260:                                        for(bitSetCount = 0; bitSetCount < 10; bitSetCount++)
9D002E98  24630001   ADDIU V1, V1, 1
9D002E9C  306300FF   ANDI V1, V1, 255
9D002EA0  1466FFFA   BNE V1, A2, 0x9D002E8C
9D002EA4  00073842   SRL A3, A3, 1
9D002EA8  0B400BD1   J 0x9D002F44
9D002EAC  24030001   ADDIU V1, ZERO, 1
9D00302C  24030001   ADDIU V1, ZERO, 1
9D003030  0B400BA3   J 0x9D002E8C
9D003034  2406000A   ADDIU A2, ZERO, 10
1261:                                        {
1262:                                            if((wMaxPacketSize & 0x00000001) == 0x00000001)
9D002E78  30E30001   ANDI V1, A3, 1
9D002E7C  5060006B   BEQL V1, ZERO, 0x9D00302C
9D002E80  00073842   SRL A3, A3, 1
9D002E84  0B400BB4   J 0x9D002ED0
9D002E88  00001821   ADDU V1, ZERO, ZERO
9D002E8C  30E50001   ANDI A1, A3, 1
9D002E90  14A0000B   BNE A1, ZERO, 0x9D002EC0
9D002E94  2405000A   ADDIU A1, ZERO, 10
1263:                                            {
1264:                                                break;
1265:                                            }
1266:                                            wMaxPacketSize = wMaxPacketSize >> 1;
1267:                                        }
1268:                                    }
1269:                                    else if((wMaxPacketSize != 0))
9D002EB0  10E00007   BEQ A3, ZERO, 0x9D002ED0
9D002EB4  00001821   ADDU V1, ZERO, ZERO
9D002EB8  0B400BD1   J 0x9D002F44
9D002EBC  24030001   ADDIU V1, ZERO, 1
1270:                                    {
1271:                                        /* This means the max packet size is greater than 512. This
1272:                                         * is possible for Isochronous transfers */
1273:                
1274:                                        bitSetCount = 10;
1275:                                    }
1276:                
1277:                                    /* The bandwidth required per transaction is calculated
1278:                                     * up front so that we dont have to calculate this in
1279:                                     * the interrupt context when the transaction is in
1280:                                     * progress */
1281:                
1282:                                    if(bitSetCount != 10)
9D002EC0  14650004   BNE V1, A1, 0x9D002ED4
9D002EC4  24050003   ADDIU A1, ZERO, 3
9D002EC8  0B400BD1   J 0x9D002F44
9D002ECC  24030001   ADDIU V1, ZERO, 1
1283:                                    {
1284:                                        if(pPipe->speed == USB_SPEED_LOW)
9D002ED0  24050003   ADDIU A1, ZERO, 3
9D002ED4  8FA60020   LW A2, 32(SP)
9D002ED8  54C5000F   BNEL A2, A1, 0x9D002F18
9D002EDC  00082880   SLL A1, T0, 2
1285:                                        {
1286:                                            if((pPipe->pipeType == USB_TRANSFER_TYPE_INTERRUPT) || (pPipe->pipeType == USB_TRANSFER_TYPE_CONTROL))
9D002EE0  8FA60014   LW A2, 20(SP)
9D002EE4  50C50004   BEQL A2, A1, 0x9D002EF8
9D002EE8  00084080   SLL T0, T0, 2
9D002EEC  54C0003A   BNEL A2, ZERO, 0x9D002FD8
9D002EF0  000A1080   SLL V0, T2, 2
1287:                                            {
1288:                                                pPipe->bwPerTransaction = gDrvUSBLSTableBW[transferTypeLocal][bitSetCount];
9D002EF4  00084080   SLL T0, T0, 2
9D002EF8  01031821   ADDU V1, T0, V1
9D002EFC  00032880   SLL A1, V1, 2
9D002F00  3C039D00   LUI V1, -25344
9D002F04  24637544   ADDIU V1, V1, 30020
9D002F08  00A31821   ADDU V1, A1, V1
9D002F0C  8C630000   LW V1, 0(V1)
9D002F10  0B400C00   J 0x9D003000
9D002F14  A0430027   SB V1, 39(V0)
1289:                                            }
1290:                                            else
1291:                                            {
1292:                                                /* Only control and interrupt pipe can exist in
1293:                                                   low speed */
1294:                                                thereWasAnError = true;
1295:                                            }
1296:                                        }
1297:                                        else
1298:                                        {
1299:                                            pPipe->bwPerTransaction = gDrvUSBFSTableBW[transferTypeLocal][bitSetCount];
9D002F18  00083100   SLL A2, T0, 4
9D002F1C  00C52823   SUBU A1, A2, A1
9D002F20  00A84023   SUBU T0, A1, T0
9D002F24  01031821   ADDU V1, T0, V1
9D002F28  00032880   SLL A1, V1, 2
9D002F2C  3C039D00   LUI V1, -25344
9D002F30  24637564   ADDIU V1, V1, 30052
9D002F34  00A31821   ADDU V1, A1, V1
9D002F38  8C630000   LW V1, 0(V1)
9D002F3C  0B400C00   J 0x9D003000
9D002F40  A0430027   SB V1, 39(V0)
1300:                                        }
1301:                                    }
1302:                                    else if(bitSetCount == 10 && pPipe->pipeType == USB_TRANSFER_TYPE_ISOCHRONOUS && pPipe->speed == USB_SPEED_FULL)
9D002F44  8FA50014   LW A1, 20(SP)
9D002F48  54A30023   BNEL A1, V1, 0x9D002FD8
9D002F4C  000A1080   SLL V0, T2, 2
9D002F50  24030002   ADDIU V1, ZERO, 2
9D002F54  8FA60020   LW A2, 32(SP)
9D002F58  54C3001F   BNEL A2, V1, 0x9D002FD8
9D002F5C  000A1080   SLL V0, T2, 2
1303:                                    {
1304:                                        /* Bandwidth for Isochronous transfers */
1305:                                        pPipe->bwPerTransaction = gDrvUSBFSTableBW[transferTypeLocal][bitSetCount];
9D002F60  3C039D00   LUI V1, -25344
9D002F64  24657564   ADDIU A1, V1, 30052
9D002F68  2403002C   ADDIU V1, ZERO, 44
9D002F6C  71033002   MUL A2, T0, V1
9D002F70  00C51821   ADDU V1, A2, A1
9D002F74  8C630028   LW V1, 40(V1)
9D002F78  0B400C00   J 0x9D003000
9D002F7C  A0430027   SB V1, 39(V0)
9D002F80  0B400BE6   J 0x9D002F98
9D002F84  ACC20004   SW V0, 4(A2)
1306:                                    }
1307:                                    else
1308:                                    {
1309:                                        /* Error */
1310:                                        thereWasAnError = true;
1311:                                    }
1312:                
1313:                                    if(!thereWasAnError)
1314:                                    {
1315:                                        /* This pipe should be added to the respective transfer group */
1316:                
1317:                                        pTransferGroup = &(pUSBDrvObj->transferGroup[pipeType]);
9D003000  8FA50014   LW A1, 20(SP)
9D003004  00051880   SLL V1, A1, 2
9D003008  00052900   SLL A1, A1, 4
9D00300C  00A31823   SUBU V1, A1, V1
9D003010  24630038   ADDIU V1, V1, 56
9D003014  00831821   ADDU V1, A0, V1
1318:                
1319:                                        if(pTransferGroup->pipe == NULL)
9D003018  8C650004   LW A1, 4(V1)
9D00301C  14A0FFDA   BNE A1, ZERO, 0x9D002F88
9D003020  24660004   ADDIU A2, V1, 4
9D003024  0B400BE0   J 0x9D002F80
9D003028  AC620004   SW V0, 4(V1)
1320:                                        {
1321:                                            /* This if the first pipe to be setup */
1322:                                            pTransferGroup->pipe = pPipe;
1323:                                            pTransferGroup->currentPipe = pPipe;
1324:                                        }
1325:                                        else
1326:                                        {
1327:                                            /* This is NOT the first pipe. Find the last pipe in the
1328:                                             * linked list */
1329:                                            piteratorPipe = pTransferGroup->pipe;
1330:                                            while(piteratorPipe->next != NULL)
9D002F88  8CA30020   LW V1, 32(A1)
9D002F8C  5460FFFE   BNEL V1, ZERO, 0x9D002F88
9D002F90  00602821   ADDU A1, V1, ZERO
1331:                                            {
1332:                                                /* This is not the last pipe in this transfer group */
1333:                                                piteratorPipe = piteratorPipe->next;
1334:                                            }
1335:                                            piteratorPipe->next = pPipe;
9D002F94  ACA20020   SW V0, 32(A1)
1336:                                        }
1337:                
1338:                                        pPipe->next = NULL;
9D002F98  AC400020   SW ZERO, 32(V0)
1339:                
1340:                                        /* Update the pipe count in the transfer group */
1341:                                        pTransferGroup->nPipes ++;
9D002F9C  8CC30008   LW V1, 8(A2)
9D002FA0  24630001   ADDIU V1, V1, 1
9D002FA4  0B400BEF   J DRV_USBFS_HOST_PipeSetup::OSAL_MUTEX_Unlock
9D002FA8  ACC30008   SW V1, 8(A2)
9D002FAC  24420001   ADDIU V0, V0, 1
1342:                                        returnValue = (DRV_USBFS_HOST_PIPE_HANDLE)pPipe;
1343:                                    }
1344:                                    else
1345:                                    {
1346:                                        /* There was some error. Return the pipe object */
1347:                                        gDrvUSBHostPipeObj[pipeCount].inUse = false;
9D002FD8  000A1900   SLL V1, T2, 4
9D002FDC  00621823   SUBU V1, V1, V0
9D002FE0  006A1823   SUBU V1, V1, T2
9D002FE4  00031880   SLL V1, V1, 2
9D002FE8  3C02A000   LUI V0, -24576
9D002FEC  24420314   ADDIU V0, V0, 788
9D002FF0  00621021   ADDU V0, V1, V0
9D002FF4  A0400000   SB ZERO, 0(V0)
1348:                                    }
1349:                
1350:                                    /* We found a pipe and allocated it or found it but were not
1351:                                     * able to allocate it due to errors in pipe parameters. In
1352:                                     * either case we must break */
1353:                                    break;
1354:                                }
1355:                            } 
1356:                
1357:                            /* If we could not find a pipe, then just put a message saying so */
1358:                            if(returnValue == DRV_USBFS_HOST_PIPE_HANDLE_INVALID)
1359:                            {
1360:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Could not find a free pipe object");
1361:                            }
1362:                
1363:                            /* Release the mutex */
1364:                            OSAL_MUTEX_Unlock(&pUSBDrvObj->mutexID);
1365:                        }
1366:                        else
1367:                        {
1368:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex lock failed");
1369:                        }
1370:                    }
1371:                    else
1372:                    {
1373:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
1374:                    }
1375:                
1376:                    /* Return the handle */
1377:                    return returnValue;
1378:                }
9D003038  03E00008   JR RA
1379:                
1380:                // *****************************************************************************
1381:                /* Function:
1382:                    void _DRV_USBFS_HOST_ControlSendToken
1383:                    (
1384:                        USB_HOST_IRP_LOCAL * pIRP,
1385:                        DRV_USBFS_OBJ *pUSBDrvObj,
1386:                        DRV_USBFS_HOST_PIPE_OBJ *pipe,
1387:                        bool isLowSpeed
1388:                    )
1389:                
1390:                  Summary:
1391:                    Dynamic implementation of _DRV_USBFS_HOST_ControlSendToken internal
1392:                    function.
1393:                
1394:                  Description:
1395:                    This is the dynamic implementation of _DRV_USBFS_HOST_ControlSendToken
1396:                    function. Function sends token for CONTROL transfer data phase.
1397:                
1398:                  Remarks:
1399:                    This is a local function and should not be called directly by the
1400:                    application.
1401:                
1402:                */
1403:                
1404:                void _DRV_USBFS_HOST_ControlSendToken
1405:                (
1406:                    USB_HOST_IRP_LOCAL * pIRP,
1407:                    DRV_USBFS_OBJ *pUSBDrvObj,
1408:                    DRV_USBFS_HOST_PIPE_OBJ *pipe,
1409:                    uint8_t endpoint,
1410:                    uint8_t deviceAddress,
1411:                    USB_MODULE_ID usbID,
1412:                    bool isLowSpeed
1413:                )
1414:                {
1415:                    USB_BUFFER_DIRECTION direction;
1416:                    USB_BUFFER_PING_PONG pingPong;
1417:                    USB_PID pid;
1418:                    unsigned int size;
1419:                    DRV_USBFS_BDT_ENTRY * pBDT = (DRV_USBFS_BDT_ENTRY *)NULL;
1420:                
1421:                    if((pipe->endpointAndDirection & 0x80)  != 0)
9D007614  80C30008   LB V1, 8(A2)
9D007618  04610005   BGEZ V1, 0x9D007630
9D00761C  8FA20014   LW V0, 20(SP)
1422:                    {
1423:                        /* Direction is device to host */
1424:                
1425:                        direction = USB_BUFFER_RX;
1426:                        pingPong = pUSBDrvObj->ep0RxPingPong;
9D007620  8CAB0074   LW T3, 116(A1)
1427:                        pid = USB_PID_IN;
9D007624  240A0009   ADDIU T2, ZERO, 9
9D007628  0B401D8F   J 0x9D00763C
9D00762C  00001821   ADDU V1, ZERO, ZERO
1428:                    }
1429:                    else
1430:                    {
1431:                        /* Direction is host to device */
1432:                        direction = USB_BUFFER_TX;
9D007638  24030001   ADDIU V1, ZERO, 1
1433:                        pingPong = pUSBDrvObj->ep0TxPingPong;
9D007630  8CAB0070   LW T3, 112(A1)
1434:                        pid = USB_PID_OUT;
9D007634  240A0001   ADDIU T2, ZERO, 1
1435:                    }
1436:                
1437:                    if((pIRP->tempSize - pIRP->completedBytesInThisFrame) >= pipe->endpointSize)
9D00763C  8C89001C   LW T1, 28(A0)
9D007640  8C880028   LW T0, 40(A0)
9D007644  01284823   SUBU T1, T1, T0
9D007648  8CC8001C   LW T0, 28(A2)
1438:                    {
1439:                        /* This means we have to break
1440:                         * up the transfer into transactions */
1441:                        size = pipe->endpointSize;
1442:                    }
1443:                    else
1444:                    {
1445:                        /* Data size is less than endpoint size */
1446:                        size = pIRP->tempSize - pIRP->completedBytesInThisFrame;
1447:                    }
1448:                
1449:                    /* Keep track of the transaction */
1450:                    pIRP->tempState = DRV_USBFS_HOST_IRP_STATE_DATA_STAGE_SENT;
9D00764C  240C0003   ADDIU T4, ZERO, 3
9D007650  AC8C0020   SW T4, 32(A0)
1451:                
1452:                    pBDT = pUSBDrvObj->pBDT + (direction << 1) + pingPong;
9D007654  00031840   SLL V1, V1, 1
9D007658  006B1821   ADDU V1, V1, T3
9D00765C  000318C0   SLL V1, V1, 3
9D007660  8CA5002C   LW A1, 44(A1)
9D007664  00A31821   ADDU V1, A1, V1
9D007668  0109282B   SLTU A1, T0, T1
9D00766C  0125400A   MOVZ T0, T1, A1
1453:                
1454:                    /* Configure the BDT Entry for data packet */
1455:                    pBDT->shortWord[1]  = size;
9D007670  A4680002   SH T0, 2(V1)
1456:                    pBDT->word[1] = KVA_TO_PA((uint8_t *)pIRP->data + pIRP->completedBytes);
9D007674  8C850004   LW A1, 4(A0)
9D007678  8C840024   LW A0, 36(A0)
9D00767C  00A42021   ADDU A0, A1, A0
9D007680  7C84E000   EXT A0, A0, 0, 29
9D007684  AC640004   SW A0, 4(V1)
1457:                    pBDT->byte[0] = (USBFS_UOWN|USBFS_DTS_ENABLE) | (pipe->dataToggle << 6);
9D007688  8CC40014   LW A0, 20(A2)
9D00768C  00042180   SLL A0, A0, 6
9D007690  2405FF88   ADDIU A1, ZERO, -120
9D007694  00852025   OR A0, A0, A1
9D007698  A0640000   SB A0, 0(V1)
1458:                
1459:                    /* Enable Handshake */
1460:                    PLIB_USB_EPnHandshakeEnable(usbID, 0);
1461:                
1462:                    /* This will cause the Transaction interrupt */
1463:                    _DRV_USBFS_SendTokenToAddress(usbID, deviceAddress, pid, endpoint, isLowSpeed);
1464:                }
1465:                
1466:                // *****************************************************************************
1467:                /* Function:
1468:                    void _DRV_USBFS_HOST_NonControlSendToken
1469:                    (
1470:                        USB_HOST_IRP_LOCAL * pIRP,
1471:                        DRV_USBFS_OBJ *pUSBDrvObj,
1472:                        DRV_USBFS_HOST_PIPE_OBJ *pipe,
1473:                        bool isLowSpeed
1474:                    )
1475:                  
1476:                  Summary:
1477:                    This function sends a non control transfer token.
1478:                
1479:                  Description:
1480:                    This function sends a non control transfer token.
1481:                
1482:                  Remarks:
1483:                    This is a local function and should not be called directly by the
1484:                    application.
1485:                */
1486:                
1487:                void _DRV_USBFS_HOST_NonControlSendToken
1488:                (
1489:                    USB_HOST_IRP_LOCAL * pIRP,
1490:                    DRV_USBFS_OBJ *pUSBDrvObj,
1491:                    DRV_USBFS_HOST_PIPE_OBJ *pipe,
1492:                    bool isLowSpeed
1493:                )
1494:                {
1495:                    int direction = 0;
1496:                    int size;
1497:                    USB_PID pid;
1498:                    USB_MODULE_ID usbID;
1499:                    DRV_USBFS_BDT_ENTRY * pBDT   = (DRV_USBFS_BDT_ENTRY *)NULL;
1500:                    USB_BUFFER_PING_PONG pingpong;
1501:                    uint8_t endpoint;
1502:                    uint8_t deviceAddress;
1503:                
1504:                    pBDT = pUSBDrvObj->pBDT;
1505:                    usbID = pUSBDrvObj->usbID;
9D006B7C  8CA20020   LW V0, 32(A1)
1506:                
1507:                    endpoint = pipe->endpointAndDirection & 0xF;
9D006B80  90CA0008   LBU T2, 8(A2)
1508:                    deviceAddress = pipe->deviceAddress;
9D006B84  90CC0025   LBU T4, 37(A2)
1509:                
1510:                    pIRP->status = USB_HOST_IRP_STATUS_IN_PROGRESS;
9D006B88  24030003   ADDIU V1, ZERO, 3
9D006B8C  AC83000C   SW V1, 12(A0)
1511:                    if((pipe->endpointAndDirection & 0x80) != 0)
9D006B90  80C30008   LB V1, 8(A2)
9D006B94  04610005   BGEZ V1, 0x9D006BAC
9D006B98  314A000F   ANDI T2, T2, 15
1512:                    {
1513:                        /* Data is moving from device to host */
1514:                        direction = USB_BUFFER_RX;
1515:                        pingpong = pUSBDrvObj->ep0RxPingPong;
9D006B9C  8CAD0074   LW T5, 116(A1)
1516:                        pid = USB_PID_IN;
9D006BA0  240B0009   ADDIU T3, ZERO, 9
9D006BA4  0B401AEE   J 0x9D006BB8
9D006BA8  00001821   ADDU V1, ZERO, ZERO
1517:                    }
1518:                    else
1519:                    {
1520:                        /* Data is moving from host to device */
1521:                        direction = USB_BUFFER_TX;
9D006BB4  24030001   ADDIU V1, ZERO, 1
1522:                        pingpong = pUSBDrvObj->ep0TxPingPong;
9D006BAC  8CAD0070   LW T5, 112(A1)
1523:                        pid = USB_PID_OUT;
9D006BB0  240B0001   ADDIU T3, ZERO, 1
1524:                    }
1525:                
1526:                    if((pIRP->tempSize - pIRP->completedBytesInThisFrame) >= pipe->endpointSize)
9D006BB8  8C89001C   LW T1, 28(A0)
9D006BBC  8CC8001C   LW T0, 28(A2)
9D006BC0  8C8E0028   LW T6, 40(A0)
9D006BC4  012E7023   SUBU T6, T1, T6
9D006BC8  01C8702B   SLTU T6, T6, T0
1527:                    {
1528:                        size = pipe->endpointSize;
9D006BCC  012E400B   MOVN T0, T1, T6
1529:                    }
1530:                    else
1531:                    {
1532:                        size = pIRP->tempSize;
1533:                    }
1534:                
1535:                    pBDT = pUSBDrvObj->pBDT + (direction << 1) + pingpong;
9D006BD0  00031840   SLL V1, V1, 1
9D006BD4  006D1821   ADDU V1, V1, T5
9D006BD8  000318C0   SLL V1, V1, 3
9D006BDC  8CA5002C   LW A1, 44(A1)
9D006BE0  00A31821   ADDU V1, A1, V1
1536:                
1537:                    /*Configure the BDT Entry for data packet */
1538:                    pBDT->shortWord[1] = size;
9D006BE4  A4680002   SH T0, 2(V1)
1539:                    pBDT->word[1] = KVA_TO_PA((uint8_t *)pIRP->data + pIRP->completedBytes);
9D006BE8  8C850004   LW A1, 4(A0)
9D006BEC  8C840024   LW A0, 36(A0)
9D006BF0  00A42021   ADDU A0, A1, A0
9D006BF4  7C84E000   EXT A0, A0, 0, 29
9D006BF8  AC640004   SW A0, 4(V1)
1540:                    pBDT->byte[0] = (USBFS_UOWN|USBFS_DTS_ENABLE) | (pipe->dataToggle << 6);
9D006BFC  8CC40014   LW A0, 20(A2)
9D006C00  00042180   SLL A0, A0, 6
9D006C04  2405FF88   ADDIU A1, ZERO, -120
9D006C08  00852025   OR A0, A0, A1
9D006C0C  A0640000   SB A0, 0(V1)
1541:                
1542:                    if(pipe->pipeType == USB_TRANSFER_TYPE_ISOCHRONOUS)
9D006C10  8CC4000C   LW A0, 12(A2)
9D006C14  24030001   ADDIU V1, ZERO, 1
9D006C18  14830006   BNE A0, V1, _DRV_USBFS_HOST_NonControlSendToken::PLIB_USB_EPnHandshakeEnable
9D006C1C  00000000   NOP
1543:                    {
1544:                        /* Disable Handshake */
1545:                        PLIB_USB_EPnHandshakeDisable(usbID, 0);
1546:                    }
1547:                    else
1548:                    {
1549:                        /* Enable Handshake */
1550:                        PLIB_USB_EPnHandshakeEnable(usbID, 0);
1551:                    }
1552:                
1553:                    /* This will cause a transaction interrupt */
1554:                    _DRV_USBFS_SendTokenToAddress(usbID, deviceAddress, pid, endpoint, isLowSpeed);
1555:                }
1556:                
1557:                // *****************************************************************************
1558:                /* Function:
1559:                    bool _DRV_USBFS_HOST_NonControlIRPProcess
1560:                    (
1561:                        DRV_USBFS_OBJ * pUSBDrvObj,
1562:                        USB_HOST_IRP_LOCAL * pIRP, 
1563:                        DRV_USBFS_TRANSACTION_RESULT lastTransactionResult,
1564:                        int lastTransactionsize
1565:                    )
1566:                
1567:                  Summary:
1568:                    This function process a non control transfer IRP.
1569:                
1570:                  Description:
1571:                    This function process a non control transfer IRP.
1572:                
1573:                  Remarks:
1574:                    This is a local function and should not be called directly by the
1575:                    application.
1576:                    
1577:                */
1578:                
1579:                bool _DRV_USBFS_HOST_NonControlIRPProcess
1580:                (
1581:                    DRV_USBFS_OBJ * pUSBDrvObj,
1582:                    USB_HOST_IRP_LOCAL * pIRP, 
1583:                    DRV_USBFS_TRANSACTION_RESULT lastTransactionResult,
1584:                    int lastTransactionsize
1585:                )
1586:                {
9D003AE8  27BDFFE8   ADDIU SP, SP, -24
9D003AEC  AFBF0014   SW RA, 20(SP)
9D003AF0  00801821   ADDU V1, A0, ZERO
1587:                    bool endIRP;
1588:                    bool isLowSpeed;
1589:                    DRV_USBFS_HOST_PIPE_OBJ * pipe = (DRV_USBFS_HOST_PIPE_OBJ *)NULL;
1590:                    bool tokenSent = false;
9D003B4C  0B400F54   J 0x9D003D50
9D003B50  00001021   ADDU V0, ZERO, ZERO
1591:                    DRV_USBFS_HOST_SW_EP * softwareEP = NULL;
1592:                
1593:                    /* Get a pointer to the software endpoint */
1594:                    softwareEP = &pUSBDrvObj->drvUSBHostSWEp[pUSBDrvObj->numSWEpEntry];
9D003AF4  9082006C   LBU V0, 108(A0)
9D003AF8  00022080   SLL A0, V0, 2
9D003AFC  00021100   SLL V0, V0, 4
9D003B00  00441023   SUBU V0, V0, A0
9D003B04  24420078   ADDIU V0, V0, 120
9D003B08  00621021   ADDU V0, V1, V0
1595:                
1596:                    if(pIRP->tempState == DRV_USBFS_HOST_IRP_STATE_ABORTED)
9D003B0C  8CA80020   LW T0, 32(A1)
9D003B10  24040007   ADDIU A0, ZERO, 7
9D003B14  1504000F   BNE T0, A0, 0x9D003B54
9D003B18  24490004   ADDIU T1, V0, 4
1597:                    {
1598:                        /* This means that this IRP was aborted by the application while it was
1599:                         * in progress. Terminate it now. */
1600:                
1601:                        softwareEP->tobeDone = false;
9D003B1C  A0400004   SB ZERO, 4(V0)
1602:                
1603:                        /* Remove the IRP from pipe. */ 
1604:                        ((DRV_USBFS_HOST_PIPE_OBJ *)(softwareEP->pIRP->pipe))->irpQueueHead = (softwareEP->pIRP)->next;
9D003B20  8D220008   LW V0, 8(T1)
9D003B24  8C43002C   LW V1, 44(V0)
9D003B28  8C420030   LW V0, 48(V0)
9D003B2C  AC430010   SW V1, 16(V0)
1605:                
1606:                        /* Notify whoever has submitted the IRP that the IRP has been aborted.
1607:                         * */
1608:                        pIRP->status = USB_HOST_IRP_STATUS_ABORTED;
9D003B30  2402FFFB   ADDIU V0, ZERO, -5
9D003B34  ACA2000C   SW V0, 12(A1)
1609:                        if(pIRP->callback != NULL)
9D003B38  8CA20018   LW V0, 24(A1)
9D003B3C  50400084   BEQL V0, ZERO, 0x9D003D50
9D003B40  00001021   ADDU V0, ZERO, ZERO
1610:                        {
1611:                            pIRP->callback((USB_HOST_IRP*)pIRP);
9D003B44  0040F809   JALR V0
9D003B48  00A02021   ADDU A0, A1, ZERO
1612:                        }
1613:                    }
1614:                    else
1615:                    {
1616:                        pipe = (DRV_USBFS_HOST_PIPE_OBJ *)pIRP->pipe;
9D003B54  8CA80030   LW T0, 48(A1)
1617:                        isLowSpeed = (pipe->speed == USB_SPEED_LOW) ? true : false;
9D003B58  8D040028   LW A0, 40(T0)
9D003B5C  38840003   XORI A0, A0, 3
1618:                
1619:                        if(lastTransactionResult == 0)
9D003B60  14C00008   BNE A2, ZERO, 0x9D003B84
9D003B64  2C8C0001   SLTIU T4, A0, 1
1620:                        {
1621:                            /* This means that a token need to be sent */
1622:                            _DRV_USBFS_HOST_NonControlSendToken(pIRP, pUSBDrvObj, pipe, isLowSpeed);
9D003B68  00A02021   ADDU A0, A1, ZERO
9D003B6C  00602821   ADDU A1, V1, ZERO
9D003B70  01003021   ADDU A2, T0, ZERO
9D003B74  0F401ADF   JAL _DRV_USBFS_HOST_NonControlSendToken
9D003B78  01803821   ADDU A3, T4, ZERO
9D003B7C  0B400F54   J 0x9D003D50
9D003B80  24020001   ADDIU V0, ZERO, 1
1623:                            tokenSent = true;
1624:                        }
1625:                        else
1626:                        {
1627:                            /* This means this function was called from the TRNIF interrupt
1628:                             * after the token was sent. Check the transaction result */
1629:                
1630:                            endIRP = false;
1631:                            tokenSent = false;
9D003CFC  0B400F54   J 0x9D003D50
9D003D00  00001021   ADDU V0, ZERO, ZERO
9D003D20  0B400F54   J 0x9D003D50
9D003D24  00001021   ADDU V0, ZERO, ZERO
1632:                
1633:                            if(pipe->pipeType == USB_TRANSFER_TYPE_ISOCHRONOUS)
9D003B84  8D0B000C   LW T3, 12(T0)
9D003B88  240A0001   ADDIU T2, ZERO, 1
9D003B8C  156A0006   BNE T3, T2, 0x9D003BA8
9D003B90  2CC40010   SLTIU A0, A2, 16
1634:                            {
1635:                                pIRP->status = USB_HOST_IRP_STATUS_COMPLETED;
9D003B94  ACA0000C   SW ZERO, 12(A1)
1636:                                pIRP->completedBytes += lastTransactionsize;
9D003B98  8CA30024   LW V1, 36(A1)
9D003B9C  00673821   ADDU A3, V1, A3
9D003BA0  0B400F4A   J 0x9D003D28
9D003BA4  ACA70024   SW A3, 36(A1)
1637:                
1638:                                /* End the IRP */
1639:                                endIRP = true;
1640:                            }
1641:                            else
1642:                            {
1643:                                /* Non ISOC Transfer handling */
1644:                
1645:                                switch(lastTransactionResult)
9D003BA8  1080005D   BEQ A0, ZERO, 0x9D003D20
9D003BAC  00063080   SLL A2, A2, 2
9D003BB0  3C049D00   LUI A0, -25344
9D003BB4  24843BC8   ADDIU A0, A0, 15304
9D003BB8  00863021   ADDU A2, A0, A2
9D003BBC  8CC40000   LW A0, 0(A2)
9D003BC0  00800008   JR A0
9D003BC4  00000000   NOP
1646:                                {
1647:                                    case USB_TRANSACTION_ACK:
1648:                                        /* Fall through is intentional */
1649:                                    case USB_TRANSACTION_DATA0:
1650:                                        /* Fall through is intentional */
1651:                                    case USB_TRANSACTION_DATA1:    
1652:                
1653:                                        pIRP->completedBytes += lastTransactionsize;
9D003C08  00E03021   ADDU A2, A3, ZERO
9D003C0C  8CA40024   LW A0, 36(A1)
9D003C10  00872021   ADDU A0, A0, A3
9D003C14  ACA40024   SW A0, 36(A1)
1654:                                        pIRP->completedBytesInThisFrame += lastTransactionsize;
9D003C18  8CA40028   LW A0, 40(A1)
9D003C1C  00872021   ADDU A0, A0, A3
9D003C20  ACA40028   SW A0, 40(A1)
1655:                                        pipe->dataToggle ^= 0x1;
9D003C24  8D040014   LW A0, 20(T0)
9D003C28  38840001   XORI A0, A0, 1
9D003C2C  AD040014   SW A0, 20(T0)
1656:                                        pipe->nakCounter = 0;
9D003C30  AD000018   SW ZERO, 24(T0)
1657:                                        if((lastTransactionsize < pipe->endpointSize) || (pIRP->size <= pIRP->completedBytes))
9D003C34  8D04001C   LW A0, 28(T0)
9D003C38  00E4382B   SLTU A3, A3, A0
9D003C3C  54E00008   BNEL A3, ZERO, 0x9D003C60
9D003C40  8CA40008   LW A0, 8(A1)
9D003C44  8CAA0008   LW T2, 8(A1)
9D003C48  8CA70024   LW A3, 36(A1)
9D003C4C  00EA382B   SLTU A3, A3, T2
9D003C50  50E00035   BEQL A3, ZERO, 0x9D003D28
9D003C54  ACA0000C   SW ZERO, 12(A1)
9D003C58  0B400F20   J 0x9D003C80
9D003C5C  8CA7001C   LW A3, 28(A1)
1658:                                        {
1659:                                            /* We received data less than endpoint size.  So we
1660:                                             * end the transfer */
1661:                                            if(pIRP->size > pIRP->completedBytes)
9D003C60  8CA30024   LW V1, 36(A1)
9D003C64  0064182B   SLTU V1, V1, A0
9D003C68  10600003   BEQ V1, ZERO, 0x9D003C78
9D003C6C  24030001   ADDIU V1, ZERO, 1
9D003C70  0B400F4A   J 0x9D003D28
9D003C74  ACA3000C   SW V1, 12(A1)
1662:                                            {
1663:                                                pIRP->status = USB_HOST_IRP_STATUS_COMPLETED_SHORT;
1664:                                            }
1665:                                            else
1666:                                            {
1667:                                                pIRP->status = USB_HOST_IRP_STATUS_COMPLETED;
9D003C78  0B400F4A   J 0x9D003D28
9D003C7C  ACA0000C   SW ZERO, 12(A1)
1668:                                            }
1669:                
1670:                                            endIRP = true;
1671:                                        }
1672:                                        else if((lastTransactionsize == pIRP->tempSize) || (lastTransactionsize == pipe->endpointSize))
9D003C80  50C70004   BEQL A2, A3, 0x9D003C94
9D003C84  8CA20028   LW V0, 40(A1)
9D003C88  14C40031   BNE A2, A0, 0x9D003D50
9D003C8C  00001021   ADDU V0, ZERO, ZERO
1673:                                        {
1674:                                            if(pIRP->tempSize > pIRP->completedBytesInThisFrame)
9D003C90  8CA20028   LW V0, 40(A1)
9D003C94  0047382B   SLTU A3, V0, A3
9D003C98  10E0002D   BEQ A3, ZERO, 0x9D003D50
9D003C9C  00001021   ADDU V0, ZERO, ZERO
1675:                                            {
1676:                                                /* Some more transactions are required in this frame */
1677:                                                pIRP->status = USB_HOST_IRP_STATUS_IN_PROGRESS;
9D003CA0  24020003   ADDIU V0, ZERO, 3
9D003CA4  ACA2000C   SW V0, 12(A1)
1678:                                                _DRV_USBFS_HOST_NonControlSendToken(pIRP,pUSBDrvObj, pipe,isLowSpeed);
9D003CA8  00A02021   ADDU A0, A1, ZERO
9D003CAC  00602821   ADDU A1, V1, ZERO
9D003CB0  01003021   ADDU A2, T0, ZERO
9D003CB4  0F401ADF   JAL _DRV_USBFS_HOST_NonControlSendToken
9D003CB8  01803821   ADDU A3, T4, ZERO
9D003CBC  0B400F54   J 0x9D003D50
9D003CC0  24020001   ADDIU V0, ZERO, 1
1679:                                                tokenSent = true;
1680:                                            }
1681:                                            else
1682:                                            {
1683:                                                /* Whatever planned for this frame has been done */
1684:                                                /* Do not Move the IRP Queue head here */
1685:                
1686:                                                /* Do not end the IRP */
1687:                                                endIRP = false;
1688:                                                tokenSent = false;
1689:                                            }
1690:                                        }
1691:                
1692:                                        break;
1693:                
1694:                                    case USB_TRANSACTION_STALL:
1695:                
1696:                                        /* The token was stalled. We end the IRP */
1697:                                        pipe->nakCounter = 0;
9D003CC4  AD000018   SW ZERO, 24(T0)
1698:                                        pipe->dataToggle = USB_BUFFER_DATA0;
9D003CC8  AD000014   SW ZERO, 20(T0)
1699:                                        pIRP->status = USB_HOST_IRP_STATUS_ERROR_STALL;
9D003CCC  2403FFFF   ADDIU V1, ZERO, -1
1700:                                        endIRP = true;
1701:                                        break;
9D003CD0  0B400F4A   J 0x9D003D28
9D003CD4  ACA3000C   SW V1, 12(A1)
1702:                
1703:                                    case USB_TRANSACTION_DATA_ERROR:
1704:                                        pIRP->status = USB_HOST_IRP_STATUS_ERROR_DATA;
9D003CD8  2403FFFD   ADDIU V1, ZERO, -3
1705:                                        endIRP = true;
1706:                                        break;
9D003CDC  0B400F4A   J 0x9D003D28
9D003CE0  ACA3000C   SW V1, 12(A1)
1707:                
1708:                
1709:                                    case USB_TRANSACTION_NAK:
1710:                
1711:                                        /* For non - control transfer we don't implement a 
1712:                                         * NAK time out.Do not do anything here */
1713:                                        if( ++pipe->nakCounter>=10 )
9D003CE4  8D030018   LW V1, 24(T0)
9D003CE8  24630001   ADDIU V1, V1, 1
9D003CEC  2C64000A   SLTIU A0, V1, 10
9D003CF0  50800004   BEQL A0, ZERO, 0x9D003D04
9D003CF4  AD000018   SW ZERO, 24(T0)
9D003CF8  AD030018   SW V1, 24(T0)
1714:                                        {
1715:                                          pipe->nakCounter = 0;
1716:                                          pIRP->status = USB_HOST_IRP_STATUS_COMPLETED_SHORT;
9D003D04  24030001   ADDIU V1, ZERO, 1
9D003D08  0B400F4A   J 0x9D003D28
9D003D0C  ACA3000C   SW V1, 12(A1)
1717:                                          endIRP = true;
1718:                                        }
1719:                                        else
1720:                                          endIRP = false;
1721:                                        break;
1722:                
1723:                                    default:
1724:                                        break;
1725:                                }
1726:                            }
1727:                
1728:                            if(endIRP == true)
1729:                            {
1730:                                /* Remove the irp from the from the SW EP object. */
1731:                                softwareEP->tobeDone = false;
9D003D28  A0400004   SB ZERO, 4(V0)
1732:                
1733:                                ((DRV_USBFS_HOST_PIPE_OBJ *)(softwareEP->pIRP->pipe))->irpQueueHead = (softwareEP->pIRP)->next;
9D003D2C  8D220008   LW V0, 8(T1)
9D003D30  8C43002C   LW V1, 44(V0)
9D003D34  8C420030   LW V0, 48(V0)
9D003D38  AC430010   SW V1, 16(V0)
1734:                
1735:                                /* Update the size field with actual size received\transmitted */
1736:                                pIRP->size = pIRP->completedBytes;
9D003D3C  8CA20024   LW V0, 36(A1)
9D003D40  ACA20008   SW V0, 8(A1)
1737:                
1738:                                if(pIRP->callback != NULL)
9D003D44  8CA20018   LW V0, 24(A1)
9D003D48  1440FFF1   BNE V0, ZERO, 0x9D003D10
9D003D4C  00000000   NOP
1739:                                {
1740:                                    pIRP->callback((USB_HOST_IRP *)pIRP);
9D003D10  0040F809   JALR V0
9D003D14  00A02021   ADDU A0, A1, ZERO
9D003D18  0B400F54   J 0x9D003D50
9D003D1C  00001021   ADDU V0, ZERO, ZERO
1741:                                }
1742:                            }
1743:                        }
1744:                    }
1745:                
1746:                    return tokenSent;
1747:                }
9D003D50  8FBF0014   LW RA, 20(SP)
1748:                
1749:                // *****************************************************************************
1750:                /* Function:
1751:                    void _DRV_USBFS_HOST_CalculateControlBW
1752:                    (
1753:                        DRV_USBFS_OBJ * pUSBDrvObj,
1754:                        DRV_USBFS_HOST_TRANSFER_GROUP * pTransferGroup,
1755:                        USB_HOST_IRP_LOCAL * pControlIRP
1756:                    )
1757:                
1758:                  Summary:
1759:                    This function checks how many transactions of a control transfer can
1760:                    be sent in one frame.
1761:                
1762:                  Description:
1763:                    This is the dynamic implementation of _DRV_USBFS_HOST_CalculateControlBW
1764:                    function. Function performs the following task:
1765:                    - Obtains the bandwidth requirement for the transfer based on pipe
1766:                      and IRP size
1767:                    - Calculates the number of transactions that can be done and updates data
1768:                      structure accordingly
1769:                    - Packs the IRP for processing it in this frame.
1770:                
1771:                  Remarks:
1772:                    This is a local function and should not be called directly by the
1773:                    application.
1774:                
1775:                */
1776:                
1777:                void _DRV_USBFS_HOST_CalculateControlBW
1778:                (
1779:                    DRV_USBFS_OBJ * pUSBDrvObj,
1780:                    DRV_USBFS_HOST_TRANSFER_GROUP * pTransferGroup,
1781:                    USB_HOST_IRP_LOCAL * pControlIRP
1782:                )
1783:                {
1784:                    uint8_t bwAvailable = 0;
1785:                    uint8_t bwPerTransaction = 0;
1786:                    uint8_t nTransactions = 0;
1787:                    uint8_t nPossibleTransactions = 0;
1788:                    DRV_USBFS_HOST_PIPE_OBJ * pPipe = (DRV_USBFS_HOST_PIPE_OBJ *)pControlIRP->pipe;
9D006C70  8CC20030   LW V0, 48(A2)
1789:                
1790:                    /* Checks the BW available out of the max possible for CONTROL transfer */
1791:                    if(pPipe->speed == USB_SPEED_LOW)
9D006C74  8C450028   LW A1, 40(V0)
9D006C78  24030003   ADDIU V1, ZERO, 3
9D006C7C  14A30005   BNE A1, V1, 0x9D006C94
9D006C80  90830078   LBU V1, 120(A0)
1792:                    {
1793:                        bwAvailable = (DRV_USBFS_MAX_CONTROL_BANDWIDTH_LOW_SPEED - pUSBDrvObj->globalBWConsumed);
9D006C84  2405001E   ADDIU A1, ZERO, 30
9D006C88  00A32823   SUBU A1, A1, V1
9D006C8C  0B401B28   J 0x9D006CA0
9D006C90  30A500FF   ANDI A1, A1, 255
1794:                    }
1795:                    else
1796:                    {
1797:                        bwAvailable = (DRV_USBFS_MAX_CONTROL_BANDWIDTH_FULL_SPEED - pUSBDrvObj->globalBWConsumed);
9D006C94  24050014   ADDIU A1, ZERO, 20
9D006C98  00A32823   SUBU A1, A1, V1
9D006C9C  30A500FF   ANDI A1, A1, 255
1798:                    }
1799:                
1800:                    /* Obtain the per bandwidth transaction required from pipe data structure.
1801:                     * The pipe data structure was updated with this information as part of pipe
1802:                     * creation */
1803:                
1804:                    bwPerTransaction = pPipe->bwPerTransaction;
9D006CA0  90430027   LBU V1, 39(V0)
1805:                
1806:                    /* Check if atleast 1 transaction is possible */
1807:                    if(bwPerTransaction <= bwAvailable)
9D006CA4  00A3382B   SLTU A3, A1, V1
9D006CA8  14E0002C   BNE A3, ZERO, 0x9D006D5C
9D006CAC  00000000   NOP
1808:                    {
1809:                        /* Atleast 1 transaction is possible */
1810:                        nTransactions = (pControlIRP->size - pControlIRP->completedBytes)/ pPipe->endpointSize;
9D006CB0  8CC90008   LW T1, 8(A2)
9D006CB4  8CC70024   LW A3, 36(A2)
9D006CB8  01274823   SUBU T1, T1, A3
9D006CBC  8C48001C   LW T0, 28(V0)
9D006CC0  0128001B   DIVU T1, T0
9D006CC4  010001F4   TEQ T0, ZERO
9D006CC8  00003812   MFLO A3
9D006CCC  30E700FF   ANDI A3, A3, 255
1811:                
1812:                        if(nTransactions == 0)
9D006CD0  10E00006   BEQ A3, ZERO, 0x9D006CEC
9D006CD4  00005010   MFHI T2
1813:                        {
1814:                            /* The code will come here only when the HOST is required to send or
1815:                             * receive SHORT PACKET only */
1816:                
1817:                            nTransactions = 1;
9D006CEC  24070001   ADDIU A3, ZERO, 1
1818:                        }
1819:                        else if((pControlIRP->size - pControlIRP->completedBytes) % (pPipe->endpointSize) != 0)
9D006CD8  11400005   BEQ T2, ZERO, 0x9D006CF0
9D006CDC  00000000   NOP
1820:                        {
1821:                            /* The code will come here only when the HOST is required to send or
1822:                             * receive multiple transactions ending with SHORT PACKET */
1823:                            nTransactions++;
9D006CE0  24E70001   ADDIU A3, A3, 1
9D006CE4  0B401B3C   J 0x9D006CF0
9D006CE8  30E700FF   ANDI A3, A3, 255
1824:                        }
1825:                
1826:                        /* Obtain the number of CONTROL transactions really possible in this frame */
1827:                        nPossibleTransactions = bwAvailable/bwPerTransaction;
9D006CF0  00A3001B   DIVU A1, V1
9D006CF4  006001F4   TEQ V1, ZERO
9D006CF8  00004012   MFLO T0
9D006CFC  310800FF   ANDI T0, T0, 255
9D006D00  00E02821   ADDU A1, A3, ZERO
9D006D04  0107382B   SLTU A3, T0, A3
9D006D08  54E00001   BNEL A3, ZERO, 0x9D006D10
9D006D0C  01002821   ADDU A1, T0, ZERO
9D006D10  30A500FF   ANDI A1, A1, 255
1828:                
1829:                        if(nPossibleTransactions < nTransactions)
1830:                        {
1831:                            /* Required number of transactions to end this transfer is more than
1832:                             * maximum number of transactions possible. So the number of transactions
1833:                             * that will be allowed is the maximum possible */
1834:                            nTransactions = nPossibleTransactions;
1835:                        }
1836:                
1837:                        /* Increment the global bandwidth */
1838:                        pUSBDrvObj->globalBWConsumed = pUSBDrvObj->globalBWConsumed + (nTransactions * bwPerTransaction);
9D006D14  90870078   LBU A3, 120(A0)
9D006D18  70A34002   MUL T0, A1, V1
9D006D1C  01071821   ADDU V1, T0, A3
9D006D20  A0830078   SB V1, 120(A0)
1839:                
1840:                        /* Data size in bytes that will be transferred for this IRP */
1841:                        pControlIRP->tempSize = nTransactions * pPipe->endpointSize;
9D006D24  8C42001C   LW V0, 28(V0)
9D006D28  70A22802   MUL A1, A1, V0
9D006D2C  ACC5001C   SW A1, 28(A2)
1842:                
1843:                        /* Based on the above calculation, the size of the data to be
1844:                         * transmitted\received will be always multiple of endpoint size. This
1845:                         * is correct when SHORT PACKET is not there.  But cases where the
1846:                         * transfer will end with SHORT PACKET, the calculated size will be more
1847:                         * than the actual IRP size remaining.  We should consider the actual
1848:                         * data size remaining only.  */
1849:                
1850:                        if((pControlIRP->size - pControlIRP->completedBytes) < pControlIRP->tempSize)
9D006D30  8CC30008   LW V1, 8(A2)
9D006D34  8CC20024   LW V0, 36(A2)
9D006D38  00621023   SUBU V0, V1, V0
9D006D3C  0045282B   SLTU A1, V0, A1
9D006D40  54A00001   BNEL A1, ZERO, 0x9D006D48
9D006D44  ACC2001C   SW V0, 28(A2)
1851:                        {
1852:                            pControlIRP->tempSize = pControlIRP->size - pControlIRP->completedBytes;
1853:                        }
1854:                
1855:                        /* Reset the IRP completed bytes in this frame field */
1856:                        pControlIRP->completedBytesInThisFrame = 0;
9D006D48  ACC00028   SW ZERO, 40(A2)
1857:                
1858:                        /* Now that we have an IRP to be processed, update the global data
1859:                         * structure. This will be caught in transfer scheduler function.  */
1860:                        pUSBDrvObj->drvUSBHostSWEp[0].tobeDone = true;
9D006D4C  24020001   ADDIU V0, ZERO, 1
9D006D50  A082007C   SB V0, 124(A0)
1861:                        pUSBDrvObj->drvUSBHostSWEp[0].transferType = USB_TRANSFER_TYPE_CONTROL;
9D006D54  AC800080   SW ZERO, 128(A0)
1862:                        pUSBDrvObj->drvUSBHostSWEp[0].pIRP = pControlIRP;
9D006D58  AC860084   SW A2, 132(A0)
1863:                    }
1864:                }
1865:                
1866:                // *****************************************************************************
1867:                /* Function:
1868:                    bool _DRV_USBFS_HOST_CalculateNonControlBW
1869:                    (
1870:                        DRV_USBFS_OBJ * pUSBDrvObj,
1871:                        DRV_USBFS_HOST_TRANSFER_GROUP * pTransferGroup,
1872:                        USB_HOST_IRP_LOCAL * ptransferIRP,
1873:                        USB_TRANSFER_TYPE transferType,
1874:                        uint8_t numSWEpEntry
1875:                    )
1876:                
1877:                  Summary:
1878:                    This function check if we have enough bandwidth to complete non control
1879:                    transaction in the frame.
1880:                
1881:                  Description:
1882:                    This is the dynamic implementation of _DRV_USBFS_HOST_CalculateNonControlBW
1883:                    function. Function performs the following task:
1884:                    - Obtains the bandwidth requirement for the transfer based on pipe
1885:                      and IRP size
1886:                    - Calculates the number of transactions that can be done and updates data
1887:                      structure accordingly
1888:                    - Packs the IRP for processing it in this frame.
1889:                
1890:                  Remarks:
1891:                    This is a local function and should not be called directly by the
1892:                    application.
1893:                */
1894:                
1895:                bool _DRV_USBFS_HOST_CalculateNonControlBW
1896:                (
1897:                    DRV_USBFS_OBJ * pUSBDrvObj,
1898:                    DRV_USBFS_HOST_TRANSFER_GROUP * pTransferGroup,
1899:                    USB_HOST_IRP_LOCAL * ptransferIRP,
1900:                    USB_TRANSFER_TYPE transferType,
1901:                    uint8_t numSWEpEntry
1902:                )
1903:                {
9D007104  93AC0010   LBU T4, 16(SP)
1904:                    unsigned int bwAvailable = 0;
1905:                    unsigned int bwPerTransaction = 0;
1906:                    unsigned int nTransactions = 0;
1907:                    unsigned int nPossibleTransactions = 0;
1908:                    DRV_USBFS_HOST_PIPE_OBJ * pPipe = (DRV_USBFS_HOST_PIPE_OBJ *)ptransferIRP->pipe;
9D007108  8CC50030   LW A1, 48(A2)
1909:                    bool irpPacked = false;
1910:                
1911:                    /* Calculate the BW available in this frame */
1912:                    bwAvailable = (DRV_USBFS_MAX_BANDWIDTH_PER_FRAME - pUSBDrvObj->globalBWConsumed);
9D00710C  90890078   LBU T1, 120(A0)
9D007110  24080046   ADDIU T0, ZERO, 70
9D007114  01094023   SUBU T0, T0, T1
1913:                    bwPerTransaction = pPipe->bwPerTransaction;
9D007118  90A30027   LBU V1, 39(A1)
9D00711C  00606821   ADDU T5, V1, ZERO
1914:                
1915:                    /* Check if at least 1 transaction is possible */
1916:                    if(bwPerTransaction <= bwAvailable)
9D007120  0103502B   SLTU T2, T0, V1
9D007124  1540002C   BNE T2, ZERO, 0x9D0071D8
9D007128  00001021   ADDU V0, ZERO, ZERO
1917:                    {
1918:                        /* At least 1 transaction is possible */
1919:                        nTransactions = (ptransferIRP->size - ptransferIRP->completedBytes)/ pPipe->endpointSize;
9D00712C  8CCB0008   LW T3, 8(A2)
9D007130  8CC20024   LW V0, 36(A2)
9D007134  01625823   SUBU T3, T3, V0
9D007138  8CAA001C   LW T2, 28(A1)
9D00713C  016A001B   DIVU T3, T2
9D007140  014001F4   TEQ T2, ZERO
9D007144  00007012   MFLO T6
1920:                
1921:                        if(nTransactions == 0)
9D007148  11C00007   BEQ T6, ZERO, 0x9D007168
9D00714C  00001012   MFLO V0
1922:                        {
1923:                            nTransactions = 1;
9D007168  24020001   ADDIU V0, ZERO, 1
1924:                        }
1925:                        else if((ptransferIRP->size - ptransferIRP->completedBytes) % (pPipe->endpointSize) != 0)
9D007150  016A001B   DIVU T3, T2
9D007154  014001F4   TEQ T2, ZERO
9D007158  00007810   MFHI T7
1926:                        {
1927:                            nTransactions++;
9D00715C  25CE0001   ADDIU T6, T6, 1
9D007160  0B401C5B   J 0x9D00716C
9D007164  01CF100B   MOVN V0, T6, T7
1928:                        }
1929:                
1930:                        nPossibleTransactions = bwAvailable/bwPerTransaction;
9D00716C  010D001B   DIVU T0, T5
9D007170  01A001F4   TEQ T5, ZERO
9D007174  00004012   MFLO T0
9D007178  0102682B   SLTU T5, T0, V0
9D00717C  010D100B   MOVN V0, T0, T5
1931:                        if(nPossibleTransactions < nTransactions)
1932:                        {
1933:                            nTransactions = nPossibleTransactions;
1934:                        }
1935:                
1936:                        /* Increment the global bandwidth */
1937:                        pUSBDrvObj->globalBWConsumed = pUSBDrvObj->globalBWConsumed + (nTransactions * bwPerTransaction);
9D007180  70624002   MUL T0, V1, V0
9D007184  01091821   ADDU V1, T0, T1
9D007188  A0830078   SB V1, 120(A0)
1938:                        ptransferIRP->tempSize = nTransactions * pPipe->endpointSize;
9D00718C  8CA8001C   LW T0, 28(A1)
9D007190  70481002   MUL V0, V0, T0
9D007194  ACC2001C   SW V0, 28(A2)
1939:                
1940:                        /* Based on the above calculation, the size of the data to be
1941:                         * transmitted\received will be always multiple of endpoint size.  But
1942:                         * if this size is more than the actual size, then we should consider
1943:                         * the actual data size remaining.  */
1944:                
1945:                        if((ptransferIRP->size - ptransferIRP->completedBytes) < ptransferIRP->tempSize)
9D007198  8CC50008   LW A1, 8(A2)
9D00719C  8CC30024   LW V1, 36(A2)
9D0071A0  00A31823   SUBU V1, A1, V1
9D0071A4  0062102B   SLTU V0, V1, V0
9D0071A8  54400001   BNEL V0, ZERO, 0x9D0071B0
9D0071AC  ACC3001C   SW V1, 28(A2)
1946:                        {
1947:                            ptransferIRP->tempSize = ptransferIRP->size - ptransferIRP->completedBytes;
1948:                        }
1949:                
1950:                        /* Reset the IRP completed bytes in this frame field */
1951:                        ptransferIRP->completedBytesInThisFrame = 0;
9D0071B0  ACC00028   SW ZERO, 40(A2)
1952:                
1953:                        /* Now that we have an IRP to be processed,
1954:                         * update the global data structure
1955:                         */
1956:                        pUSBDrvObj->drvUSBHostSWEp[numSWEpEntry].tobeDone = true;
9D0071B4  000C1080   SLL V0, T4, 2
9D0071B8  000C6100   SLL T4, T4, 4
9D0071BC  01826023   SUBU T4, T4, V0
9D0071C0  008C2021   ADDU A0, A0, T4
9D0071C4  24020001   ADDIU V0, ZERO, 1
9D0071C8  A082007C   SB V0, 124(A0)
1957:                        pUSBDrvObj->drvUSBHostSWEp[numSWEpEntry].transferType = transferType;
9D0071CC  AC870080   SW A3, 128(A0)
1958:                        pUSBDrvObj->drvUSBHostSWEp[numSWEpEntry].pIRP = ptransferIRP;
9D0071D0  AC860084   SW A2, 132(A0)
1959:                        irpPacked = true;
9D0071D4  24020001   ADDIU V0, ZERO, 1
1960:                    }
1961:                
1962:                    return irpPacked;
1963:                }
9D0071D8  03E00008   JR RA
1964:                
1965:                // *****************************************************************************
1966:                /* Function:
1967:                    void _DRV_USBFS_HOST_TransferPack (DRV_USBFS_OBJ * pUSBDrvObj)
1968:                
1969:                  Summary:
1970:                    Dynamic implementation of _DRV_USBFS_HOST_TransferPack internal
1971:                    function.
1972:                
1973:                  Description:
1974:                    This is the dynamic implementation of _DRV_USBFS_HOST_TransferPack
1975:                    function. Function performs the following task:
1976:                    - Obtains the bandwidth requirement for the transfer based on pipe
1977:                      and IRP size
1978:                    - Calculates the number of transactions that can be done and updates data
1979:                      structure accordingly
1980:                    - Packs the IRP for processing it in this frame.
1981:                
1982:                  Remarks:
1983:                    This is a local function and should not be called directly by the
1984:                    application.
1985:                */
1986:                
1987:                void _DRV_USBFS_HOST_TransferPack (DRV_USBFS_OBJ * pUSBDrvObj)
1988:                {
9D0023E4  27BDFFC8   ADDIU SP, SP, -56
9D0023E8  AFBF0034   SW RA, 52(SP)
9D0023EC  AFB50030   SW S5, 48(SP)
9D0023F0  AFB4002C   SW S4, 44(SP)
9D0023F4  AFB30028   SW S3, 40(SP)
9D0023F8  AFB20024   SW S2, 36(SP)
9D0023FC  AFB10020   SW S1, 32(SP)
9D002400  AFB0001C   SW S0, 28(SP)
9D002404  00808021   ADDU S0, A0, ZERO
1989:                    DRV_USBFS_HOST_TRANSFER_GROUP * pTransferGroup = (DRV_USBFS_HOST_TRANSFER_GROUP *)NULL;
1990:                    DRV_USBFS_HOST_PIPE_OBJ * piteratorPipe = (DRV_USBFS_HOST_PIPE_OBJ *)NULL;
1991:                    USB_HOST_IRP_LOCAL * pControlIRP = (USB_HOST_IRP_LOCAL *)NULL;
1992:                    USB_HOST_IRP_LOCAL * pbulkIRP = (USB_HOST_IRP_LOCAL *)NULL;
1993:                    USB_HOST_IRP_LOCAL * pinterruptIRP = (USB_HOST_IRP_LOCAL *)NULL;
1994:                    USB_HOST_IRP_LOCAL * pisochronousIRP = (USB_HOST_IRP_LOCAL *)NULL;
1995:                    uint8_t numSWEpEntry = 0;
1996:                    uint8_t numIRPProcess = 0;
9D0024A8  0B40092E   J 0x9D0024B8
9D0024AC  0000A021   ADDU S4, ZERO, ZERO
1997:                    bool irpPacked = false;
1998:                    uint8_t loop = 0;
1999:                
2000:                    /* Process the Control pipes first */
2001:                    pTransferGroup = &pUSBDrvObj->transferGroup[USB_TRANSFER_TYPE_CONTROL];
2002:                
2003:                    /* 1st time Current pipe (processing will start from this pipe) will be head
2004:                     * pipe. After that it will rotate through the Control pipe linked list */
2005:                
2006:                    if(pTransferGroup->pipe != NULL)
9D002408  8C82003C   LW V0, 60(A0)
9D00240C  10400026   BEQ V0, ZERO, 0x9D0024A8
9D002410  2492003C   ADDIU S2, A0, 60
2007:                    {
2008:                        if(pUSBDrvObj->drvUSBHostSWEp[0].tobeDone == true)
9D002414  9082007C   LBU V0, 124(A0)
9D002418  14400006   BNE V0, ZERO, 0x9D002434
9D00241C  00008821   ADDU S1, ZERO, ZERO
2009:                        {
2010:                            /* Transfer continuation from last frame. We only need to update the
2011:                             * bandwidth based on the control transfer packet size. */
2012:                
2013:                            pControlIRP = (pTransferGroup->currentPipe)->irpQueueHead;
9D002434  8C820040   LW V0, 64(A0)
2014:                
2015:                            /* Calling this function will update the globalBWConsumed field and
2016:                             * the tobeDone field. Because this is being called at the start of
2017:                             * the frame, we know that bandwidth will always get allocated. */
2018:                
2019:                            _DRV_USBFS_HOST_CalculateControlBW(pUSBDrvObj, pTransferGroup, pControlIRP);
9D002438  02402821   ADDU A1, S2, ZERO
9D00243C  0F401B1C   JAL _DRV_USBFS_HOST_CalculateControlBW
9D002440  8C460010   LW A2, 16(V0)
9D002444  0B40092E   J 0x9D0024B8
9D002448  24140001   ADDIU S4, ZERO, 1
2020:                            numIRPProcess = 1;
2021:                        }
2022:                        else
2023:                        {
2024:                            /* Fresh Transfer starting this frame */
2025:                
2026:                            /* 1st time when this transfer scheduler function will be
2027:                             * called,currentPipe will be equal to transfer group pipe.  From
2028:                             * then onwards,we will rotate through CONTROL pipes linked list for
2029:                             * the existing number of pipes.
2030:                             *
2031:                             * If IRP has been packed for a particular pipe, the current pipe
2032:                             * will be moved in ISR context after the IRP processing has been
2033:                             * done completely. This event of complete CONTROL IRP processing
2034:                             * may require multiple transactions spread over multiple USB frames
2035:                             * as well.
2036:                             * 
2037:                             * On next call to transfer scheduler, the pipe processing will
2038:                             * start from the updated current pipe. */
2039:                
2040:                            /* Search for a CONTROL transfer to schedule till we have an IRP to
2041:                             * process or till we have run out of all open CONTROL transfer
2042:                             * pipes */
2043:                
2044:                            for(loop = 0; loop < pTransferGroup->nPipes; loop++)
9D002420  8C820044   LW V0, 68(A0)
9D002424  18400024   BLEZ V0, 0x9D0024B8
9D002428  0000A021   ADDU S4, ZERO, ZERO
9D002488  26310001   ADDIU S1, S1, 1
9D00248C  323100FF   ANDI S1, S1, 255
9D002490  8E020044   LW V0, 68(S0)
9D002494  0222102A   SLT V0, S1, V0
9D002498  5440FFEC   BNEL V0, ZERO, 0x9D00244C
9D00249C  8E020040   LW V0, 64(S0)
9D0024A0  0B40092E   J 0x9D0024B8
9D0024A4  0000A021   ADDU S4, ZERO, ZERO
2045:                            {
2046:                                pControlIRP = (pTransferGroup->currentPipe)->irpQueueHead;
9D00242C  0B400913   J 0x9D00244C
9D002430  8E020040   LW V0, 64(S0)
9D00244C  8C460010   LW A2, 16(V0)
2047:                
2048:                                /* Check if the CONTROL pipe has valid IRP */
2049:                                if(pControlIRP != NULL)
9D002450  10C00008   BEQ A2, ZERO, 0x9D002474
9D002454  02002021   ADDU A0, S0, ZERO
2050:                                {
2051:                                    /* So the PIPE has valid CONTROL IRP.  Analyze the bandwidth
2052:                                     * requirements for this IRP and calculate the amount of
2053:                                     * data to be processed in this USB frame.  The
2054:                                     * _DRV_USBFS_HOST_CalculateControlBW function will set the
2055:                                     * tobeDone flag true if the transaction could be scheduled
2056:                                     * in this frame.  */
2057:                
2058:                                    _DRV_USBFS_HOST_CalculateControlBW(pUSBDrvObj, pTransferGroup, pControlIRP);
9D002458  0F401B1C   JAL _DRV_USBFS_HOST_CalculateControlBW
9D00245C  02402821   ADDU A1, S2, ZERO
2059:                                    if(pUSBDrvObj->drvUSBHostSWEp[0].tobeDone == true)
9D002460  9202007C   LBU V0, 124(S0)
9D002464  50400009   BEQL V0, ZERO, 0x9D00248C
9D002468  26310001   ADDIU S1, S1, 1
9D00246C  0B40092C   J 0x9D0024B0
9D002470  24140001   ADDIU S4, ZERO, 1
2060:                                    {
2061:                                        /* We have successfully packed a CONTROL IRP.  The
2062:                                         * transfer scheduler processes 1 CONTROL IRP per frame.
2063:                                         * So we increment the IRP counter to 1 and break from
2064:                                         * the for() loop */
2065:                                        numIRPProcess = 1;
2066:                                        break;
2067:                                    }
2068:                                    else
2069:                                    {
2070:                                        /* Not even 1 transaction was possible.  The code
2071:                                         * ideally should NOT come here */
2072:                                    }
2073:                                }
2074:                                else
2075:                                {
2076:                                    /* We only move the current pipe if IRP was not found in the
2077:                                     * last current pipe. This is because for CONTROL transfers
2078:                                     * we cannot do multiple transfers together in a single USB
2079:                                     * BUS. There is no point starting another if the last
2080:                                     * CONTROL transfer has not yet completed completely.  */
2081:                
2082:                                    pTransferGroup->currentPipe = pTransferGroup->currentPipe->next;
9D002474  8C420020   LW V0, 32(V0)
2083:                                    if(pTransferGroup->currentPipe == NULL)
9D002478  14400003   BNE V0, ZERO, 0x9D002488
9D00247C  AE020040   SW V0, 64(S0)
2084:                                    {
2085:                                        /* Reached the end of list. Move the pipe pointer to
2086:                                         * HEAD of the list*/
2087:                                        pTransferGroup->currentPipe = pTransferGroup->pipe;
9D002480  8E02003C   LW V0, 60(S0)
9D002484  AE020040   SW V0, 64(S0)
2088:                                    }
2089:                                }
2090:                            } 
2091:                        } 
2092:                    }
2093:                
2094:                
2095:                    /* Reset the numSWEpEntry to 1 as NON CONTROL transfers can grab the pool
2096:                     * from index 1 only. 0 reserved for CONTROL transfer.  */
2097:                    numSWEpEntry = 1;
9D0024F0  24130001   ADDIU S3, ZERO, 1
9D00258C  24130001   ADDIU S3, ZERO, 1
2098:                
2099:                    /* ISOCHRONOUS transfer scheduling */
2100:                    pTransferGroup = &pUSBDrvObj->transferGroup[USB_TRANSFER_TYPE_ISOCHRONOUS];
9D0024B0  0B40092F   J 0x9D0024BC
9D0024B4  26150048   ADDIU S5, S0, 72
9D0024B8  26150048   ADDIU S5, S0, 72
2101:                    piteratorPipe = pTransferGroup->pipe;
9D0024BC  8E020048   LW V0, 72(S0)
2102:                
2103:                    /* Pipes will be scanned only if:
2104:                     * 1. There is at least 1 open ISOCHRONOUS Pipe
2105:                     * 2. Number of IRPs to be packed has not yet exceeded the maximum allowed
2106:                     * 3. Index into global IRP pool has not yet exceeded the maximum allowed */
2107:                
2108:                    if((pTransferGroup->pipe != NULL) && (numIRPProcess < _DRV_USBFS_HOST_IRP_PER_FRAME_NUMBER) && (numSWEpEntry < _DRV_USBFS_SW_EP_NUMBER))
9D0024C0  10400033   BEQ V0, ZERO, 0x9D002590
9D0024C4  24130001   ADDIU S3, ZERO, 1
2109:                    {
2110:                        /* Decrement the interval counter for all ISOCHRONOUS pipes */
2111:                        do
2112:                        {
2113:                            piteratorPipe->intervalCounter--;
9D0024C8  90430026   LBU V1, 38(V0)
9D0024CC  2463FFFF   ADDIU V1, V1, -1
9D0024D0  A0430026   SB V1, 38(V0)
2114:                
2115:                            if(piteratorPipe->intervalCounter == 0)
2116:                            {
2117:                                /* ISOCHRONOUS IRP, if present, will be scheduled from this pipe */
2118:                            }
2119:                            else
2120:                            {
2121:                                /* IRP will not be scheduled from this pipe */
2122:                            }
2123:                
2124:                            piteratorPipe = piteratorPipe->next;
9D0024D4  8C420020   LW V0, 32(V0)
2125:                
2126:                        } while(piteratorPipe != NULL);
9D0024D8  5440FFFC   BNEL V0, ZERO, 0x9D0024CC
9D0024DC  90430026   LBU V1, 38(V0)
2127:                        
2128:                        /* Scan all the available ISOCHRONOUS pipes starting from HEAD pipe */
2129:                        pisochronousIRP = pTransferGroup->pipe->irpQueueHead;
2130:                        piteratorPipe = pTransferGroup->pipe;
2131:                
2132:                        for(loop = 0; loop < (pTransferGroup->nPipes) && (numIRPProcess < _DRV_USBFS_HOST_IRP_PER_FRAME_NUMBER) && (numSWEpEntry < _DRV_USBFS_SW_EP_NUMBER); loop++)
9D0024E0  8E020050   LW V0, 80(S0)
9D0024E4  18400029   BLEZ V0, 0x9D00258C
9D0024E8  8E110048   LW S1, 72(S0)
9D0024EC  00009021   ADDU S2, ZERO, ZERO
9D00255C  26520001   ADDIU S2, S2, 1
9D002560  325200FF   ANDI S2, S2, 255
9D002564  8E020050   LW V0, 80(S0)
9D002568  0242102A   SLT V0, S2, V0
9D00256C  10400008   BEQ V0, ZERO, 0x9D002590
9D002570  2E820005   SLTIU V0, S4, 5
9D002574  1040006F   BEQ V0, ZERO, 0x9D002734
9D002578  2E620005   SLTIU V0, S3, 5
9D00257C  5440FFDE   BNEL V0, ZERO, 0x9D0024F8
9D002580  8E260010   LW A2, 16(S1)
9D002584  0B4009CE   J 0x9D002738
9D002588  8FBF0034   LW RA, 52(SP)
2133:                        {
2134:                            pisochronousIRP = piteratorPipe->irpQueueHead;
9D0024F4  8E260010   LW A2, 16(S1)
2135:                
2136:                            if((pisochronousIRP != NULL) && (piteratorPipe->intervalCounter == 0))
9D0024F8  10C00011   BEQ A2, ZERO, 0x9D002540
9D0024FC  92220026   LBU V0, 38(S1)
9D002500  54400014   BNEL V0, ZERO, 0x9D002554
9D002504  8E310020   LW S1, 32(S1)
2137:                            {
2138:                                piteratorPipe->intervalCounter = piteratorPipe->bInterval;
9D002508  92220024   LBU V0, 36(S1)
9D00250C  A2220026   SB V0, 38(S1)
2139:                                
2140:                                /* Check BW and pack IRP */
2141:                                irpPacked = _DRV_USBFS_HOST_CalculateNonControlBW ( pUSBDrvObj, pTransferGroup, pisochronousIRP, USB_TRANSFER_TYPE_ISOCHRONOUS, numSWEpEntry);
9D002510  AFB30010   SW S3, 16(SP)
9D002514  02002021   ADDU A0, S0, ZERO
9D002518  02A02821   ADDU A1, S5, ZERO
9D00251C  0F401C41   JAL _DRV_USBFS_HOST_CalculateNonControlBW
9D002520  24070001   ADDIU A3, ZERO, 1
2142:                
2143:                                if(irpPacked == true)
9D002524  5040000B   BEQL V0, ZERO, 0x9D002554
9D002528  8E310020   LW S1, 32(S1)
2144:                                {
2145:                                    /* Increment the IRP counter */
2146:                                    numIRPProcess++;
9D00252C  26940001   ADDIU S4, S4, 1
9D002530  329400FF   ANDI S4, S4, 255
2147:                
2148:                                    /* Increment SWEP index */
2149:                                    numSWEpEntry++;
9D002534  26730001   ADDIU S3, S3, 1
9D002538  0B400954   J 0x9D002550
9D00253C  327300FF   ANDI S3, S3, 255
2150:                                }
2151:                                else
2152:                                {
2153:                                    /* The IRP from this ISOCHRONOUS pipe cannot be processed
2154:                                     * because of bandwidth limitation. We will try the next
2155:                                     * ISOCHRONOUS pipe in the next iteration.  */
2156:                                }
2157:                            }
2158:                            else if(piteratorPipe->intervalCounter == 0)
9D002540  54400004   BNEL V0, ZERO, 0x9D002554
9D002544  8E310020   LW S1, 32(S1)
2159:                            {
2160:                                /* The code will come here when IRP was not there in the pipe
2161:                                 * but interval has become 0. We need to reset the interval
2162:                                 * counter to original bInterval value */
2163:                
2164:                                piteratorPipe->intervalCounter = piteratorPipe->bInterval;
9D002548  92220024   LBU V0, 36(S1)
9D00254C  A2220026   SB V0, 38(S1)
2165:                            }
2166:                
2167:                            piteratorPipe = piteratorPipe->next;
9D002550  8E310020   LW S1, 32(S1)
2168:                            if(piteratorPipe == NULL)
9D002554  52200001   BEQL S1, ZERO, 0x9D00255C
9D002558  8E110048   LW S1, 72(S0)
2169:                            {
2170:                                /* Reached the end of list.  Move the pipe pointer to HEAD of
2171:                                 * the list*/
2172:                                piteratorPipe = pTransferGroup->pipe;
2173:                            }
2174:                        } 
2175:                    }
2176:                
2177:                    /* INTERRUPT transfer scheduling */
2178:                    pTransferGroup = &pUSBDrvObj->transferGroup[USB_TRANSFER_TYPE_INTERRUPT];
9D0025D8  26150060   ADDIU S5, S0, 96
2179:                    piteratorPipe = pTransferGroup->pipe;
9D002590  8E020060   LW V0, 96(S0)
2180:                
2181:                    /* Pipes will be scanned only if:
2182:                     * 1. There is at least 1 open INTERRUPT Pipe
2183:                     * 2. Number of IRPs to be packed has not yet exceeded the maximum allowed
2184:                     * 3. Index into global IRP pool has not yet exceeded the maximum allowed */
2185:                
2186:                    if((pTransferGroup->pipe != NULL) && (numIRPProcess < _DRV_USBFS_HOST_IRP_PER_FRAME_NUMBER) && (numSWEpEntry < _DRV_USBFS_SW_EP_NUMBER))
9D002594  10400037   BEQ V0, ZERO, 0x9D002674
9D002598  2E830005   SLTIU V1, S4, 5
9D00259C  10600066   BEQ V1, ZERO, 0x9D002738
9D0025A0  8FBF0034   LW RA, 52(SP)
9D0025A4  2E630005   SLTIU V1, S3, 5
9D0025A8  10600064   BEQ V1, ZERO, 0x9D00273C
9D0025AC  8FB50030   LW S5, 48(SP)
2187:                    {
2188:                        /* Decrement the interval counter for all INTERRUPT pipes */
2189:                        do
2190:                        {
2191:                            piteratorPipe->intervalCounter--;
9D0025B0  90430026   LBU V1, 38(V0)
9D0025B4  2463FFFF   ADDIU V1, V1, -1
9D0025B8  A0430026   SB V1, 38(V0)
2192:                
2193:                            if(piteratorPipe->intervalCounter == 0)
2194:                            {
2195:                                /* INTERRUPT IRP, if present, will be scheduled from this pipe */
2196:                            }
2197:                            else
2198:                            {
2199:                                /* IRP will not be scheduled from this pipe */
2200:                            }
2201:                
2202:                            piteratorPipe = piteratorPipe->next;
9D0025BC  8C420020   LW V0, 32(V0)
2203:                
2204:                        } while(piteratorPipe != NULL);
9D0025C0  5440FFFC   BNEL V0, ZERO, 0x9D0025B4
9D0025C4  90430026   LBU V1, 38(V0)
2205:                
2206:                        /* Scan all the available INTERRUPT pipes starting from HEAD pipe */
2207:                        pinterruptIRP = pTransferGroup->pipe->irpQueueHead;
2208:                        piteratorPipe = pTransferGroup->pipe;
2209:                
2210:                        for(loop = 0; loop < (pTransferGroup->nPipes) && (numIRPProcess < _DRV_USBFS_HOST_IRP_PER_FRAME_NUMBER) && (numSWEpEntry < _DRV_USBFS_SW_EP_NUMBER); loop++)
9D0025C8  8E020068   LW V0, 104(S0)
9D0025CC  18400056   BLEZ V0, 0x9D002728
9D0025D0  8E110060   LW S1, 96(S0)
9D0025D4  00009021   ADDU S2, ZERO, ZERO
9D002644  26520001   ADDIU S2, S2, 1
9D002648  325200FF   ANDI S2, S2, 255
9D00264C  8E020068   LW V0, 104(S0)
9D002650  0242102A   SLT V0, S2, V0
9D002654  10400007   BEQ V0, ZERO, 0x9D002674
9D002658  2E820005   SLTIU V0, S4, 5
9D00265C  10400035   BEQ V0, ZERO, 0x9D002734
9D002660  2E620005   SLTIU V0, S3, 5
9D002664  5440FFDE   BNEL V0, ZERO, 0x9D0025E0
9D002668  8E260010   LW A2, 16(S1)
9D00266C  0B4009CE   J 0x9D002738
9D002670  8FBF0034   LW RA, 52(SP)
2211:                        {
2212:                            pinterruptIRP = piteratorPipe->irpQueueHead;
9D0025DC  8E260010   LW A2, 16(S1)
2213:                
2214:                            if((pinterruptIRP != NULL) && (piteratorPipe->intervalCounter == 0))
9D0025E0  10C00011   BEQ A2, ZERO, 0x9D002628
9D0025E4  92220026   LBU V0, 38(S1)
9D0025E8  54400014   BNEL V0, ZERO, 0x9D00263C
9D0025EC  8E310020   LW S1, 32(S1)
2215:                            {
2216:                
2217:                                piteratorPipe->intervalCounter = piteratorPipe->bInterval;
9D0025F0  92220024   LBU V0, 36(S1)
9D0025F4  A2220026   SB V0, 38(S1)
2218:                                /* Check BW and pack IRP */
2219:                                irpPacked = _DRV_USBFS_HOST_CalculateNonControlBW ( pUSBDrvObj, pTransferGroup, pinterruptIRP, USB_TRANSFER_TYPE_INTERRUPT, numSWEpEntry);
9D0025F8  AFB30010   SW S3, 16(SP)
9D0025FC  02002021   ADDU A0, S0, ZERO
9D002600  02A02821   ADDU A1, S5, ZERO
9D002604  0F401C41   JAL _DRV_USBFS_HOST_CalculateNonControlBW
9D002608  24070003   ADDIU A3, ZERO, 3
2220:                
2221:                                if(irpPacked == true)
9D00260C  5040000B   BEQL V0, ZERO, 0x9D00263C
9D002610  8E310020   LW S1, 32(S1)
2222:                                {
2223:                                    /* Increment the IRP counter */
2224:                                    numIRPProcess++;
9D002614  26940001   ADDIU S4, S4, 1
9D002618  329400FF   ANDI S4, S4, 255
2225:                
2226:                                    /* Increment SWEP index */
2227:                                    numSWEpEntry++;
9D00261C  26730001   ADDIU S3, S3, 1
9D002620  0B40098E   J 0x9D002638
9D002624  327300FF   ANDI S3, S3, 255
2228:                                }
2229:                                else
2230:                                {
2231:                                    /* The IRP from this INTERRUPT pipe cannot be processed
2232:                                     * because of bandwidth limitation. We will try the 
2233:                                     * next INTERRUPT pipe in the next iteration.  */
2234:                                }
2235:                            }
2236:                            else if(piteratorPipe->intervalCounter == 0)
9D002628  54400004   BNEL V0, ZERO, 0x9D00263C
9D00262C  8E310020   LW S1, 32(S1)
2237:                            {
2238:                                /* The code will come here when IRP was not there in the pipe
2239:                                 * but interval has become 0. We need to reset the interval
2240:                                 * counter to original bInterval value */
2241:                
2242:                                piteratorPipe->intervalCounter = piteratorPipe->bInterval;
9D002630  92220024   LBU V0, 36(S1)
9D002634  A2220026   SB V0, 38(S1)
2243:                            }
2244:                
2245:                            piteratorPipe = piteratorPipe->next;
9D002638  8E310020   LW S1, 32(S1)
2246:                            if(piteratorPipe == NULL)
9D00263C  52200001   BEQL S1, ZERO, 0x9D002644
9D002640  8E110060   LW S1, 96(S0)
2247:                            {
2248:                                /* Reached the end of list. Move the pipe pointer to HEAD of
2249:                                 * list*/
2250:                                piteratorPipe = pTransferGroup->pipe;
2251:                            }
2252:                        }
2253:                    }
2254:                
2255:                    /* SW EP processing for BULK transfer */
2256:                    pTransferGroup = &pUSBDrvObj->transferGroup[USB_TRANSFER_TYPE_BULK];
2257:                
2258:                    /* Pipes will be scanned and IRP will be processed only if:
2259:                     * 1. There is at least 1 open BULK Pipe
2260:                     * 2. Number of IRPs to be packed has not yet exceeded the maximum allowed
2261:                     * 3. Index into global IRP pool has not yet exceeded the maximum allowed
2262:                     */
2263:                
2264:                    if((pTransferGroup->pipe != NULL) && (numIRPProcess < _DRV_USBFS_HOST_IRP_PER_FRAME_NUMBER) && (numSWEpEntry < _DRV_USBFS_SW_EP_NUMBER))
9D002674  8E020054   LW V0, 84(S0)
9D002678  1040002E   BEQ V0, ZERO, 0x9D002734
9D00267C  2E820005   SLTIU V0, S4, 5
9D002680  1040002C   BEQ V0, ZERO, 0x9D002734
9D002684  2E620005   SLTIU V0, S3, 5
9D002688  1040002A   BEQ V0, ZERO, 0x9D002734
9D00268C  26150054   ADDIU S5, S0, 84
9D002728  8E020054   LW V0, 84(S0)
9D00272C  1440FFD8   BNE V0, ZERO, 0x9D002690
9D002730  26150054   ADDIU S5, S0, 84
2265:                    {
2266:                        pbulkIRP = pTransferGroup->currentPipe->irpQueueHead;
2267:                        piteratorPipe = pTransferGroup->currentPipe;
2268:                
2269:                        /* Scan all the available BULK pipes starting from the current pipe.
2270:                         * 1st time current pipe will be same as pipe. After that current pipe
2271:                         * will move within the BULK pipe list as per IRP processed */
2272:                        for(loop = 0; loop < (pTransferGroup->nPipes) && (numIRPProcess < _DRV_USBFS_HOST_IRP_PER_FRAME_NUMBER) && (numSWEpEntry < _DRV_USBFS_SW_EP_NUMBER); loop++)
9D002690  8E02005C   LW V0, 92(S0)
9D002694  18400027   BLEZ V0, 0x9D002734
9D002698  8E110058   LW S1, 88(S0)
9D00269C  00009021   ADDU S2, ZERO, ZERO
9D0026F8  26520001   ADDIU S2, S2, 1
9D0026FC  325200FF   ANDI S2, S2, 255
9D002700  8E02005C   LW V0, 92(S0)
9D002704  0242102A   SLT V0, S2, V0
9D002708  1040000A   BEQ V0, ZERO, 0x9D002734
9D00270C  2E820005   SLTIU V0, S4, 5
9D002710  10400008   BEQ V0, ZERO, 0x9D002734
9D002714  2E620005   SLTIU V0, S3, 5
9D002718  5440FFE2   BNEL V0, ZERO, 0x9D0026A4
9D00271C  8E260010   LW A2, 16(S1)
9D002720  0B4009CE   J 0x9D002738
9D002724  8FBF0034   LW RA, 52(SP)
2273:                        {
2274:                            pbulkIRP = piteratorPipe->irpQueueHead;
9D0026A0  8E260010   LW A2, 16(S1)
2275:                
2276:                            if(pbulkIRP != NULL)
9D0026A4  10C00011   BEQ A2, ZERO, 0x9D0026EC
9D0026A8  02002021   ADDU A0, S0, ZERO
2277:                            {
2278:                                /* So the PIPE has valid BULK IRP */
2279:                                irpPacked = _DRV_USBFS_HOST_CalculateNonControlBW ( pUSBDrvObj, pTransferGroup, pbulkIRP, USB_TRANSFER_TYPE_BULK, numSWEpEntry);
9D0026AC  AFB30010   SW S3, 16(SP)
9D0026B0  02A02821   ADDU A1, S5, ZERO
9D0026B4  0F401C41   JAL _DRV_USBFS_HOST_CalculateNonControlBW
9D0026B8  24070002   ADDIU A3, ZERO, 2
2280:                
2281:                                if(irpPacked == true)
9D0026BC  5040000C   BEQL V0, ZERO, 0x9D0026F0
9D0026C0  8E310020   LW S1, 32(S1)
2282:                                {
2283:                                    /* We have successfully packed a BULK IRP */
2284:                
2285:                                    /* Increment the IRP counter */
2286:                                    numIRPProcess++;
9D0026C4  26940001   ADDIU S4, S4, 1
9D0026C8  329400FF   ANDI S4, S4, 255
2287:                
2288:                                    /* Increment SWEP index */
2289:                                    numSWEpEntry++;
9D0026CC  26730001   ADDIU S3, S3, 1
9D0026D0  327300FF   ANDI S3, S3, 255
2290:                
2291:                                    pTransferGroup->currentPipe = pTransferGroup->currentPipe->next;
9D0026D4  8E020058   LW V0, 88(S0)
9D0026D8  8C420020   LW V0, 32(V0)
2292:                                    if(pTransferGroup->currentPipe == NULL)
9D0026DC  14400003   BNE V0, ZERO, 0x9D0026EC
9D0026E0  AE020058   SW V0, 88(S0)
2293:                                    {
2294:                                        /* Reached the end of list.  Move the pipe pointer to
2295:                                         * HEAD of the list*/
2296:                                        pTransferGroup->currentPipe = pTransferGroup->pipe;
9D0026E4  8E020054   LW V0, 84(S0)
9D0026E8  AE020058   SW V0, 88(S0)
2297:                                    }
2298:                                }
2299:                                else
2300:                                {
2301:                                    /* The IRP from this BULK pipe cannot be processed because
2302:                                     * of bandwidth limitation. We will try the next BULK pipe
2303:                                     * in the next iteration.  */
2304:                                }
2305:                            }
2306:                
2307:                            piteratorPipe = piteratorPipe->next;
9D0026EC  8E310020   LW S1, 32(S1)
2308:                            if(piteratorPipe == NULL)
9D0026F0  52200001   BEQL S1, ZERO, 0x9D0026F8
9D0026F4  8E110054   LW S1, 84(S0)
2309:                            {
2310:                                /* Reached the end of list.  Move the pipe pointer to HEAD of
2311:                                 * the list*/
2312:                                piteratorPipe = pTransferGroup->pipe;
2313:                            }
2314:                        } 
2315:                    }
2316:                }
9D002734  8FBF0034   LW RA, 52(SP)
2317:                
2318:                // *****************************************************************************
2319:                /* Function:
2320:                    bool _DRV_USBFS_HOST_TransferSchedule
2321:                    (
2322:                        DRV_USBFS_OBJ * pUSBDrvObj,
2323:                        DRV_USBFS_TRANSACTION_RESULT lastResult,
2324:                        unsigned int transactionSize,
2325:                        bool frameExpiry
2326:                    )
2327:                
2328:                  Summary:
2329:                    Dynamic implementation of _DRV_USBFS_HOST_TransferSchedule internal function.
2330:                
2331:                  Description:
2332:                    This is the dynamic implementation of _DRV_USBFS_HOST_TransferSchedule
2333:                    function. Function performs the following task:
2334:                    - Traverses through all the different transfer pipes.
2335:                    - Prepares the SW EP buffer with the transfer details that will be
2336:                      processed in the frame.
2337:                    - Updates the SW EP buffer object that can be done in frame
2338:                    - Triggers the transfer start operation
2339:                
2340:                  Remarks:
2341:                    This is a local function and should not be called directly by the
2342:                    application.
2343:                */
2344:                
2345:                bool _DRV_USBFS_HOST_TransferSchedule
2346:                (
2347:                    DRV_USBFS_OBJ * pUSBDrvObj,
2348:                    DRV_USBFS_TRANSACTION_RESULT lastResult,
2349:                    unsigned int transactionSize,
2350:                    bool frameExpiry
2351:                )
2352:                {
9D004E60  27BDFFE8   ADDIU SP, SP, -24
9D004E64  AFBF0014   SW RA, 20(SP)
9D004E68  AFB00010   SW S0, 16(SP)
9D004E6C  00808021   ADDU S0, A0, ZERO
2353:                    uint8_t numSWEpEntry = 0;
2354:                    bool tokenSent  = false;
9D004F64  0B4013F6   J 0x9D004FD8
9D004F68  00001021   ADDU V0, ZERO, ZERO
9D004F6C  00C04021   ADDU T0, A2, ZERO
2355:                    DRV_USBFS_HOST_SW_EP * softwareEP = NULL;
2356:                
2357:                    /* This function will called from 3 points in the code:
2358:                     * 1. From the SOF interrupt:  
2359:                     *      frameExpiry = true, 
2360:                     *      lastResult = 0, 
2361:                     *      transactionSize = 0
2362:                     *
2363:                     * 2. From 2 points in the transaction complete interrupt.
2364:                     *    a. On every TRNIF event generated: 
2365:                     *      frameExpiry = false, 
2366:                     *      lastResult = Transaction result e.g. ACK,NAK,etc.,
2367:                     *      transactionSize = Size of data received/transferred
2368:                     *
2369:                     *    b. No new transaction was scheduled after the last TRNIF: 
2370:                     *      frameExpiry = false, 
2371:                     *      lastResult = 0, 
2372:                     *      transactionSize = 0 */
2373:                
2374:                    if(lastResult == 0)
9D004E70  14A0003E   BNE A1, ZERO, 0x9D004F6C
9D004E74  00A01821   ADDU V1, A1, ZERO
2375:                    {
2376:                        /* This means that a transfer has completed and we are not continuing a
2377:                         * transfer. This can happen either if a SOF duration has completed or
2378:                         * if the transfer has completed after a transaction interrupt has
2379:                         * occurred */
2380:                
2381:                        if(frameExpiry)
9D004E78  50E00009   BEQL A3, ZERO, 0x9D004EA0
9D004E7C  9083006C   LBU V1, 108(A0)
2382:                        {
2383:                            /* This means the frame duration has completed. This will only
2384:                             * happen when this function is called from a SOF event. Clear all
2385:                             * the NON CONTROL IRPs which may be still there from the previous
2386:                             * frame even if they are not completed. Control transfer that was
2387:                             * in progress will be allowed to continue. Note how the
2388:                             * numSWEpEntry index (index into the software endpoints) in the
2389:                             * loop below starts with 1 and not 0. 0 index is always allocated
2390:                             * for control transfers. */
2391:                
2392:                            for(numSWEpEntry = 1; numSWEpEntry < _DRV_USBFS_SW_EP_NUMBER; numSWEpEntry++)
2393:                            {
2394:                                /* Clearing the tobeDone flags will indicate that all the
2395:                                 * transfers scheduled on these software endpoints need to be
2396:                                 * re-scheduled in this frame. */
2397:                                pUSBDrvObj->drvUSBHostSWEp[numSWEpEntry].tobeDone = false;
9D004E80  A0800088   SB ZERO, 136(A0)
9D004E84  A0800094   SB ZERO, 148(A0)
9D004E88  A08000A0   SB ZERO, 160(A0)
9D004E8C  A08000AC   SB ZERO, 172(A0)
2398:                            }
2399:                
2400:                            /* Reset the frame bandwidth consumed number */
2401:                            pUSBDrvObj->globalBWConsumed = 0;
2402:                
2403:                            /* This function call will help in:
2404:                             * 
2405:                             * 1. Traversing across all different transfer IRPs and packing of
2406:                             *    those IRPs to be scheduled in this frame.
2407:                             *
2408:                             * 2. The global IRP SW pool will be updated accordingly with
2409:                             *    the packed IRPs information.
2410:                             *
2411:                             * 3. Bandwidth management will also be done.
2412:                             *
2413:                             */
2414:                
2415:                            _DRV_USBFS_HOST_TransferPack(pUSBDrvObj);
9D004E90  0F4008F9   JAL _DRV_USBFS_HOST_TransferPack
9D004E94  A0800078   SB ZERO, 120(A0)
2416:                
2417:                            /* Reset numSWEpEntry to 0 to make sure processing of Global IRP
2418:                             * SW pool starts from index 0 for frame expiry case. */
2419:                            numSWEpEntry = 0;
9D004E98  0B4013AD   J 0x9D004EB4
9D004E9C  00001821   ADDU V1, ZERO, ZERO
2420:                
2421:                        }
2422:                        else
2423:                        {
2424:                            /* The code flow comes here when IRP processing is over and we need
2425:                             * to move to the next IRP that has been scheduled in this frame.
2426:                             * Increment the numSWEpEntry tracker to point to the next software
2427:                             * endpoint.*/
2428:                
2429:                            numSWEpEntry = pUSBDrvObj->numSWEpEntry + 1;
9D004EA0  24630001   ADDIU V1, V1, 1
9D004EA4  306300FF   ANDI V1, V1, 255
2430:                        }
2431:                
2432:                        if(numSWEpEntry < _DRV_USBFS_SW_EP_NUMBER)
9D004EA8  2C640005   SLTIU A0, V1, 5
9D004EAC  1080004A   BEQ A0, ZERO, 0x9D004FD8
9D004EB0  00001021   ADDU V0, ZERO, ZERO
2433:                        {
2434:                
2435:                            /* Call appropriate transfer function to process.  Please note how
2436:                             * numSWEpEntry is not initialized to 0 here here in the for() loop. For
2437:                             * Frame expiry case numSWEpEntry will be initialized to 0 before only.
2438:                             * For starting of the next transfer within frame, numSWEpEntry has been
2439:                             * incremented by 1 before. So this helps in reducing unnecessary loop
2440:                             * check and increases the scheduler through put.  */
2441:                
2442:                            for(;(numSWEpEntry < _DRV_USBFS_SW_EP_NUMBER);numSWEpEntry++)
9D004F54  306300FF   ANDI V1, V1, 255
9D004F58  2C620005   SLTIU V0, V1, 5
9D004F5C  5440FFE0   BNEL V0, ZERO, 0x9D004EE0
9D004F60  00031080   SLL V0, V1, 2
2443:                            {
2444:                                /* Obtain a pointer to the software endpoint being analyzed. */
2445:                
2446:                                softwareEP = &pUSBDrvObj->drvUSBHostSWEp[numSWEpEntry];
9D004EB4  00031080   SLL V0, V1, 2
9D004EB8  00032100   SLL A0, V1, 4
9D004EBC  00821023   SUBU V0, A0, V0
9D004EC0  24420078   ADDIU V0, V0, 120
9D004EC4  02021021   ADDU V0, S0, V0
9D004EC8  24450004   ADDIU A1, V0, 4
9D004EE0  00032100   SLL A0, V1, 4
9D004EE4  00821023   SUBU V0, A0, V0
9D004EE8  24420078   ADDIU V0, V0, 120
9D004EEC  02021021   ADDU V0, S0, V0
9D004EF0  24450004   ADDIU A1, V0, 4
2447:                                if((softwareEP->tobeDone) == true)
9D004ECC  90420004   LBU V0, 4(V0)
9D004ED0  50400020   BEQL V0, ZERO, 0x9D004F54
9D004ED4  24630001   ADDIU V1, V1, 1
9D004EF4  90420004   LBU V0, 4(V0)
9D004EF8  50400016   BEQL V0, ZERO, 0x9D004F54
9D004EFC  24630001   ADDIU V1, V1, 1
2448:                                {
2449:                                    /* Update the global IRP pool index into USB DRV object.
2450:                                     * This will be useful while TRNIF is handled */
2451:                                    pUSBDrvObj->numSWEpEntry = numSWEpEntry;
9D004ED8  0B4013C1   J 0x9D004F04
9D004EDC  A203006C   SB V1, 108(S0)
9D004F00  A203006C   SB V1, 108(S0)
2452:                
2453:                                    if(softwareEP->transferType == USB_TRANSFER_TYPE_CONTROL) 
9D004F04  8CA20004   LW V0, 4(A1)
9D004F08  54400008   BNEL V0, ZERO, 0x9D004F2C
9D004F0C  2442FFFF   ADDIU V0, V0, -1
2454:                                    {
2455:                                        /* Control transfer */
2456:                                        tokenSent = _DRV_USBFS_HOST_ControlXferProcess ( pUSBDrvObj, softwareEP->pIRP, (DRV_USBFS_TRANSACTION_RESULT) 0, 0);
9D004F10  02002021   ADDU A0, S0, ZERO
9D004F14  8CA50008   LW A1, 8(A1)
9D004F18  00003021   ADDU A2, ZERO, ZERO
9D004F1C  0F4002A7   JAL _DRV_USBFS_HOST_ControlXferProcess
9D004F20  00003821   ADDU A3, ZERO, ZERO
9D004F24  0B4013F7   J 0x9D004FDC
9D004F28  8FBF0014   LW RA, 20(SP)
2457:                                    }
2458:                                    else if((softwareEP->transferType == USB_TRANSFER_TYPE_ISOCHRONOUS) ||
9D004F2C  2C430003   SLTIU V1, V0, 3
9D004F30  10600029   BEQ V1, ZERO, 0x9D004FD8
9D004F34  00001021   ADDU V0, ZERO, ZERO
2459:                                            (softwareEP->transferType == USB_TRANSFER_TYPE_INTERRUPT) ||
2460:                                            (softwareEP->transferType == USB_TRANSFER_TYPE_BULK))
2461:                                    {
2462:                                        /* Non Control transfers */
2463:                                        tokenSent = _DRV_USBFS_HOST_NonControlIRPProcess ( pUSBDrvObj, softwareEP->pIRP, (DRV_USBFS_TRANSACTION_RESULT) 0, 0);
9D004F38  02002021   ADDU A0, S0, ZERO
9D004F3C  8CA50008   LW A1, 8(A1)
9D004F40  00003021   ADDU A2, ZERO, ZERO
9D004F44  0F400EBA   JAL _DRV_USBFS_HOST_NonControlIRPProcess
9D004F48  00003821   ADDU A3, ZERO, ZERO
2464:                                    }
2465:                                    else
2466:                                    {
2467:                                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Error IRP schedule");
2468:                                    }
2469:                
2470:                                    /* Note that we are not checking the tokenSent value here.
2471:                                     * If there was a IRP to be processed in the software EP,
2472:                                     * this would have been checked and sent. Noting that the
2473:                                     * token has been sent, we stop and wait for the token to
2474:                                     * complete */
2475:                
2476:                                    break;
2477:                                } 
2478:                            }
2479:                        }
2480:                        else
2481:                        {
2482:                            /* If here means that we have processed all the software endpoint
2483:                             * and dont need to send any thing more in this frame. */
2484:                            tokenSent = false;
2485:                        }
2486:                    }
2487:                    else
2488:                    {
2489:                        /* The code flow comes here for every TRNIF generated for an IRP.  The
2490:                         * below code helps in processing for multiple transaction transfers as
2491:                         * per the USB transfer type.  */
2492:                
2493:                        softwareEP = &pUSBDrvObj->drvUSBHostSWEp[pUSBDrvObj->numSWEpEntry];
9D004F70  9082006C   LBU V0, 108(A0)
9D004F74  00022080   SLL A0, V0, 2
9D004F78  00022900   SLL A1, V0, 4
9D004F7C  00A42023   SUBU A0, A1, A0
9D004F80  02042021   ADDU A0, S0, A0
2494:                
2495:                        if(pUSBDrvObj->numSWEpEntry == 0)
9D004F84  14400008   BNE V0, ZERO, 0x9D004FA8
9D004F88  2486007C   ADDIU A2, A0, 124
2496:                        {
2497:                            /* The last scheduled in this frame was CONTROL. So this is
2498:                             * continuation of Control transfer */
2499:                            tokenSent = _DRV_USBFS_HOST_ControlXferProcess ( pUSBDrvObj, softwareEP->pIRP, (DRV_USBFS_TRANSACTION_RESULT) lastResult, transactionSize);
9D004F8C  02002021   ADDU A0, S0, ZERO
9D004F90  8CC50008   LW A1, 8(A2)
9D004F94  00603021   ADDU A2, V1, ZERO
9D004F98  0F4002A7   JAL _DRV_USBFS_HOST_ControlXferProcess
9D004F9C  01003821   ADDU A3, T0, ZERO
9D004FA0  0B4013F7   J 0x9D004FDC
9D004FA4  8FBF0014   LW RA, 20(SP)
2500:                        }
2501:                        else
2502:                        {
2503:                            if((pUSBDrvObj->drvUSBHostSWEp[pUSBDrvObj->numSWEpEntry].tobeDone == true))
9D004FA8  00022880   SLL A1, V0, 2
9D004FAC  00021100   SLL V0, V0, 4
9D004FB0  00451023   SUBU V0, V0, A1
9D004FB4  02021021   ADDU V0, S0, V0
9D004FB8  9045007C   LBU A1, 124(V0)
9D004FBC  10A00006   BEQ A1, ZERO, 0x9D004FD8
9D004FC0  00001021   ADDU V0, ZERO, ZERO
2504:                            {
2505:                                /* Last scheduled was Isochronous, interrupt or BULK transfer */
2506:                                tokenSent = _DRV_USBFS_HOST_NonControlIRPProcess ( pUSBDrvObj, softwareEP->pIRP, (DRV_USBFS_TRANSACTION_RESULT) lastResult, transactionSize);
9D004FC4  02002021   ADDU A0, S0, ZERO
9D004FC8  8CC50008   LW A1, 8(A2)
9D004FCC  00603021   ADDU A2, V1, ZERO
9D004FD0  0F400EBA   JAL _DRV_USBFS_HOST_NonControlIRPProcess
9D004FD4  01003821   ADDU A3, T0, ZERO
2507:                            }
2508:                        }
2509:                    }
2510:                
2511:                    /* true: A token has been sent in this call of the function
2512:                     * false: No new token has been sent in this call of the function */
2513:                
2514:                    return tokenSent;
2515:                }
9D004F4C  0B4013F7   J 0x9D004FDC
9D004F50  8FBF0014   LW RA, 20(SP)
9D004FD8  8FBF0014   LW RA, 20(SP)
2516:                
2517:                // *****************************************************************************
2518:                /* Function:
2519:                    void _DRV_USBFS_HOST_Tasks_ISR(DRV_USBFS_OBJ * pUSBDrvObj)
2520:                
2521:                  Summary:
2522:                    Dynamic implementation of _DRV_USBFS_HOST_Tasks_ISR function.
2523:                
2524:                  Description:
2525:                    This is the dynamic implementation of _DRV_USBFS_HOST_Tasks_ISR internal
2526:                    function. Function is an interrupt handler which does necessary processing
2527:                    based on the interrupt.
2528:                
2529:                  Remarks:
2530:                    This is local function and should not be called directly by the client.
2531:                
2532:                */
2533:                
2534:                void _DRV_USBFS_HOST_Tasks_ISR(DRV_USBFS_OBJ * pUSBDrvObj)
2535:                {
9D001AEC  27BDFFD8   ADDIU SP, SP, -40
9D001AF0  AFBF0024   SW RA, 36(SP)
9D001AF4  AFB30020   SW S3, 32(SP)
9D001AF8  AFB2001C   SW S2, 28(SP)
9D001AFC  AFB10018   SW S1, 24(SP)
9D001B00  AFB00014   SW S0, 20(SP)
9D001B04  00808821   ADDU S1, A0, ZERO
2536:                    DRV_USBFS_BDT_ENTRY *pBDTEntry = (DRV_USBFS_BDT_ENTRY *) NULL;
2537:                    bool tokenWasSent = false;
2538:                    uint8_t lastEndpoint = 0;
2539:                    uint8_t swEpCount = 0;
2540:                    unsigned int transactionSize = 0;
2541:                    USB_MODULE_ID usbID;
2542:                    USB_INTERRUPTS usbInterrupts = 0;
2543:                    USB_INTERRUPTS enabledUSBInterrupts = 0;
2544:                    USB_PING_PONG_STATE lastPingPong = 0;
2545:                    USB_BUFFER_DIRECTION lastDirection = 0;
2546:                     
2547:                    DRV_USBFS_TRANSACTION_RESULT  transactionResult = 0;
2548:                
2549:                    usbID = pUSBDrvObj->usbID;
2550:                
2551:                    usbInterrupts = PLIB_USB_InterruptFlagAllGet(usbID);
2552:                    enabledUSBInterrupts = PLIB_USB_InterruptEnableGet(usbID);
2553:                
2554:                    if((PLIB_USB_OTG_InterruptIsEnabled(usbID, USB_OTG_INT_ONE_MS_TIMEOUT)) && (PLIB_USB_OTG_InterruptFlagGet(usbID, USB_OTG_INT_ONE_MS_TIMEOUT)))
9D001B1C  1040006A   BEQ V0, ZERO, 0x9D001CC8
9D001B20  32420002   ANDI V0, S2, 2
9D001B2C  10400066   BEQ V0, ZERO, 0x9D001CC8
9D001B30  32420002   ANDI V0, S2, 2
2555:                    {
2556:                        PLIB_USB_OTG_InterruptFlagClear(usbID, USB_OTG_INT_ONE_MS_TIMEOUT);
2557:                
2558:                        /* This means the 1 millisecond timeout has occurred. This interrupt
2559:                         * is enabled for timing needs from reset, attach and detach cases */
2560:                
2561:                        if(pUSBDrvObj->isAttachDebouncing)
9D001B3C  908200D8   LBU V0, 216(A0)
9D001B40  50400021   BEQL V0, ZERO, 0x9D001BC8
9D001B44  908200B8   LBU V0, 184(A0)
2562:                        {
2563:                            /* This means an attach was detected and it is being debounced.
2564:                             * Update the debounce counter. If count has expired, then check
2565:                             * again if the Attach condition exists. If so then the attach
2566:                             * is a valid attach. */
2567:                
2568:                            pUSBDrvObj->attachDebounceCounter ++;
9D001B48  8C8200D0   LW V0, 208(A0)
9D001B4C  24420001   ADDIU V0, V0, 1
9D001B50  AC8200D0   SW V0, 208(A0)
2569:                            if(DRV_USBFS_HOST_ATTACH_DEBOUNCE_DURATION <= pUSBDrvObj->attachDebounceCounter)
9D001B54  2C4201F4   SLTIU V0, V0, 500
9D001B58  1440005B   BNE V0, ZERO, 0x9D001CC8
9D001B5C  32420002   ANDI V0, S2, 2
2570:                            {
2571:                                /* The timer interrupt needs to be stopped and the
2572:                                 * attachDebouncing flag needs to be reset. This stops attach
2573:                                 * debouncing. */
2574:                                PLIB_USB_OTG_InterruptDisable(usbID, USB_OTG_INT_ONE_MS_TIMEOUT);
2575:                                pUSBDrvObj->isAttachDebouncing = false;
9D001B6C  A08000D8   SB ZERO, 216(A0)
2576:                
2577:                                /* Debounce time over. Is the device still attached */
2578:                                if(PLIB_USB_InterruptFlagGet(usbID, USB_INT_ATTACH))
9D001B78  1040000E   BEQ V0, ZERO, _DRV_USBFS_HOST_Tasks_ISR::PLIB_USB_InterruptEnable
9D001B7C  00000000   NOP
2579:                                {
2580:                                    /* We can treat this as a valid attach. We then clear the
2581:                                     * detach flag and enable the detach interrupt. We enable
2582:                                     * the Transaction interrupt */
2583:                
2584:                                    PLIB_USB_InterruptFlagClear(usbID, USB_INT_HOST_DETACH);
2585:                                    PLIB_USB_InterruptEnable(usbID, USB_INT_HOST_DETACH);
2586:                                    PLIB_USB_InterruptEnable(usbID, USB_INT_TOKEN_DONE);
2587:                
2588:                                    /* Ask the host layer to enumerate this device. While calling
2589:                                     * this function, the UHD of the parent device which is the
2590:                                     * root hub in this case.
2591:                                     * */
2592:                                    pUSBDrvObj->attachedDeviceObjHandle = USB_HOST_DeviceEnumerate (pUSBDrvObj->usbHostDeviceInfo, 0);
9D001BA0  8C8400DC   LW A0, 220(A0)
9D001BA4  0F401172   JAL USB_HOST_DeviceEnumerate
9D001BA8  00002821   ADDU A1, ZERO, ZERO
9D001BAC  0B400731   J 0x9D001CC4
9D001BB0  AE2200E0   SW V0, 224(S1)
2593:                                }
2594:                                else
2595:                                {
2596:                                    /* After the de-bounce the attach interrupt was not present
2597:                                     * We should treat this as a spurious event. Re-enable the
2598:                                     * disabled attach interrupt. This makes us ready for the
2599:                                     * next attach. */
2600:                                    PLIB_USB_InterruptEnable(usbID, USB_INT_ATTACH);
2601:                                }
2602:                            }
2603:                        }
2604:                        else if(pUSBDrvObj->isResetting)
9D001BC8  50400030   BEQL V0, ZERO, 0x9D001C8C
9D001BCC  908200D9   LBU V0, 217(A0)
2605:                        {
2606:                            /* The HCD is presently generating reset signalling */
2607:                            pUSBDrvObj->resetDuration ++;
9D001BD0  8C8200BC   LW V0, 188(A0)
9D001BD4  24420001   ADDIU V0, V0, 1
2608:                
2609:                            if(DRV_USBFS_HOST_RESET_DURATION ==  pUSBDrvObj->resetDuration)
9D001BD8  24030064   ADDIU V1, ZERO, 100
9D001BDC  14430004   BNE V0, V1, 0x9D001BF0
9D001BE0  AC8200BC   SW V0, 188(A0)
2610:                            {
2611:                                /* This controller seems to need some time to detect speed after
2612:                                 * resetting is complete to detect speed. So what we will do is
2613:                                 * stop the reset signalling here and then wait for 10 more
2614:                                 * milliseconds */
2615:                
2616:                                PLIB_USB_ResetSignalDisable(usbID);
2617:                            }
2618:                
2619:                            if((DRV_USBFS_HOST_RESET_DURATION + 1) <= pUSBDrvObj->resetDuration)
9D001BF0  8E2200BC   LW V0, 188(S1)
9D001BF4  2C420065   SLTIU V0, V0, 101
9D001BF8  14400033   BNE V0, ZERO, 0x9D001CC8
9D001BFC  32420002   ANDI V0, S2, 2
2620:                            {
2621:                                /* The resetting has completed and we are ready to detect the
2622:                                 * speed of the attached device. */
2623:                
2624:                                pUSBDrvObj->resetDuration = 0;
9D001C00  AE2000BC   SW ZERO, 188(S1)
2625:                                PLIB_USB_OTG_InterruptDisable(usbID, USB_OTG_INT_ONE_MS_TIMEOUT);
2626:                
2627:                               /* After the reset is deactivated, we can find out if the J state is
2628:                                * active, which means that the D- line is pulled up and hence this a
2629:                                * low speed device.
2630:                                */
2631:                                if(!PLIB_USB_JStateIsActive(pUSBDrvObj->usbID))
9D001C1C  1460000C   BNE V1, ZERO, 0x9D001C50
9D001C20  24030002   ADDIU V1, ZERO, 2
2632:                                {
2633:                                    /* This means that low speed device was attached. All tokens should
2634:                                     * be executed at low speed. Also enable direct connection to LS
2635:                                     * speed bit in the EP0 control register.  */
2636:                
2637:                                    pUSBDrvObj->deviceSpeed = USB_SPEED_LOW;
9D001C24  24030003   ADDIU V1, ZERO, 3
9D001C28  AE230038   SW V1, 56(S1)
2638:                                    PLIB_USB_TokenSpeedSelect(pUSBDrvObj->usbID, USB_LOWSPEED_TOKENS);
2639:                                    PLIB_USB_EP0LSDirectConnectEnable(pUSBDrvObj->usbID);
2640:                                }
2641:                                else
2642:                                {
2643:                                    /* This means this is a full speed device. Setup token speed
2644:                                     * for speed and disable the direction connect to low speed
2645:                                     * bit. */
2646:                                    pUSBDrvObj->deviceSpeed = USB_SPEED_FULL;
9D001C50  AE230038   SW V1, 56(S1)
2647:                                    PLIB_USB_TokenSpeedSelect(pUSBDrvObj->usbID, USB_FULLSPEED_TOKENS);
2648:                                    PLIB_USB_EP0LSDirectConnectDisable(pUSBDrvObj->usbID);
2649:                                }
2650:                
2651:                                /* The reset recovery time must be provided by the Host Layer.
2652:                                 * We can enable the SOF now. */
2653:                
2654:                                PLIB_USB_SOFEnable(usbID);
2655:                                PLIB_USB_InterruptEnable(usbID, USB_INT_SOF);
2656:                                pUSBDrvObj->isResetting = false;
9D001C84  0B400731   J 0x9D001CC4
9D001C88  A22000B8   SB ZERO, 184(S1)
2657:                            }
2658:                        }
2659:                        else if(pUSBDrvObj->isDetachDebouncing)
9D001C8C  1040000E   BEQ V0, ZERO, 0x9D001CC8
9D001C90  32420002   ANDI V0, S2, 2
2660:                        {
2661:                            /* This means a detach was detected. Some time delay is to be
2662:                             * provided so that any false attaches which may trigger while the
2663:                             * device is being detached is avoided. */
2664:                             
2665:                            pUSBDrvObj->detachDebounceCounter++;
9D001C94  8C8200D4   LW V0, 212(A0)
9D001C98  24420001   ADDIU V0, V0, 1
9D001C9C  AC8200D4   SW V0, 212(A0)
2666:                            if(DRV_USBFS_POST_DETACH_DELAY <= pUSBDrvObj->detachDebounceCounter)
9D001CA0  2C4207D0   SLTIU V0, V0, 2000
9D001CA4  14400008   BNE V0, ZERO, 0x9D001CC8
9D001CA8  32420002   ANDI V0, S2, 2
2667:                            {
2668:                                /* The post detach delay is completed. We can re-enable the
2669:                                 * attach interrupt now. */
2670:                
2671:                                pUSBDrvObj->isDetachDebouncing = false;
9D001CAC  A08000D9   SB ZERO, 217(A0)
2672:                                PLIB_USB_InterruptFlagClear(usbID, USB_INT_ATTACH);
2673:                                PLIB_USB_InterruptEnable(usbID, USB_INT_ATTACH);
2674:                            }
2675:                        }
2676:                    }
2677:                
2678:                    /* Check if an error has occurred */
2679:                    if (( usbInterrupts & USB_INT_ERROR ) && (enabledUSBInterrupts & USB_INT_ERROR))
9D001BC0  0B400732   J 0x9D001CC8
9D001BC4  32420002   ANDI V0, S2, 2
9D001CC4  32420002   ANDI V0, S2, 2
9D001CC8  10400009   BEQ V0, ZERO, 0x9D001CF0
9D001CCC  32420004   ANDI V0, S2, 4
9D001CD0  32620002   ANDI V0, S3, 2
9D001CD4  10400006   BEQ V0, ZERO, 0x9D001CF0
9D001CD8  32420004   ANDI V0, S2, 4
2680:                    { 
2681:                        USB_ERROR_INTERRUPTS errorType;
2682:                
2683:                        errorType = PLIB_USB_ErrorInterruptFlagAllGet(usbID); 
2684:                
2685:                        /* Clear the errors */
2686:                        PLIB_USB_ErrorInterruptFlagClear( usbID, errorType ); 
2687:                
2688:                        /* Clear the error flag */
2689:                        PLIB_USB_InterruptFlagClear( usbID, USB_INT_ERROR ); 
2690:                    }
2691:                
2692:                    if (( usbInterrupts & USB_INT_SOF ) && (enabledUSBInterrupts & USB_INT_SOF))
9D001CEC  32420004   ANDI V0, S2, 4
9D001CF0  1040000C   BEQ V0, ZERO, 0x9D001D24
9D001CF4  32420080   ANDI V0, S2, 128
9D001CF8  32620004   ANDI V0, S3, 4
9D001CFC  10400009   BEQ V0, ZERO, 0x9D001D24
9D001D00  32420080   ANDI V0, S2, 128
2693:                    { 
2694:                        /* SOF threshold reached by Host. Call the transaction scheduler so that
2695:                         * we schedule the next set of transfers */
2696:                
2697:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_SOF);
2698:                         
2699:                        /* Call the transfer scheduler */
2700:                        _DRV_USBFS_HOST_TransferSchedule(pUSBDrvObj, (DRV_USBFS_TRANSACTION_RESULT)0, (unsigned int)0, true);
9D001D0C  02202021   ADDU A0, S1, ZERO
9D001D10  00002821   ADDU A1, ZERO, ZERO
9D001D14  00003021   ADDU A2, ZERO, ZERO
9D001D18  0F401398   JAL _DRV_USBFS_HOST_TransferSchedule
9D001D1C  24070001   ADDIU A3, ZERO, 1
2701:                    }
2702:                
2703:                    if ((usbInterrupts & USB_INT_STALL) && (enabledUSBInterrupts & USB_INT_STALL))
9D001D20  32420080   ANDI V0, S2, 128
9D001D24  10400007   BEQ V0, ZERO, 0x9D001D44
9D001D28  32420020   ANDI V0, S2, 32
9D001D2C  32620080   ANDI V0, S3, 128
9D001D30  10400004   BEQ V0, ZERO, 0x9D001D44
9D001D34  32420020   ANDI V0, S2, 32
2704:                    {
2705:                        /* The device stalled the request. At this point we don't know yet what
2706:                         * to do with this interrupt. Clearing the flag for now */
2707:                
2708:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_STALL);
2709:                    }
2710:                
2711:                    if((usbInterrupts & USB_INT_RESUME) && (enabledUSBInterrupts & USB_INT_RESUME))
9D001D40  32420020   ANDI V0, S2, 32
9D001D44  10400007   BEQ V0, ZERO, 0x9D001D64
9D001D48  32420010   ANDI V0, S2, 16
9D001D4C  32620020   ANDI V0, S3, 32
9D001D50  10400004   BEQ V0, ZERO, 0x9D001D64
9D001D54  32420010   ANDI V0, S2, 16
2712:                    {
2713:                        /* Device sent resume signalling to the host */
2714:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_RESUME);
2715:                    }
2716:                
2717:                    if ((usbInterrupts & USB_INT_IDLE_DETECT) && (enabledUSBInterrupts & USB_INT_IDLE_DETECT))
9D001D60  32420010   ANDI V0, S2, 16
9D001D64  10400007   BEQ V0, ZERO, 0x9D001D84
9D001D68  32420040   ANDI V0, S2, 64
9D001D6C  32620010   ANDI V0, S3, 16
9D001D70  10400004   BEQ V0, ZERO, 0x9D001D84
9D001D74  32420040   ANDI V0, S2, 64
2718:                    {
2719:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_IDLE_DETECT);
2720:                    }
2721:                
2722:                    if ((usbInterrupts & USB_INT_ATTACH) && (enabledUSBInterrupts & USB_INT_ATTACH))
9D001D80  32420040   ANDI V0, S2, 64
9D001D84  50400010   BEQL V0, ZERO, 0x9D001DC8
9D001D88  32520001   ANDI S2, S2, 1
9D001D8C  32620040   ANDI V0, S3, 64
9D001D90  5040000D   BEQL V0, ZERO, 0x9D001DC8
9D001D94  32520001   ANDI S2, S2, 1
2723:                    {
2724:                        /* Host got a device attach */
2725:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_ATTACH);
2726:                
2727:                        /* The attach interrupt is persistent. Clearing it will not have any
2728:                         * effect while the device is attached. We will start an attach
2729:                         * debounce timer and disable the attach interrupt for now. The rest
2730:                         * of the processing takes place in the 1 msec time out handling.
2731:                         * Reset the attach debounce timer. Set the attach checking flag. */
2732:                
2733:                        PLIB_USB_InterruptDisable(usbID, USB_INT_ATTACH);
2734:                        pUSBDrvObj->attachDebounceCounter = 0;
9D001DAC  AE2000D0   SW ZERO, 208(S1)
2735:                        pUSBDrvObj->isAttachDebouncing = true;
9D001DB0  24020001   ADDIU V0, ZERO, 1
9D001DB4  A22200D8   SB V0, 216(S1)
2736:                        PLIB_USB_OTG_InterruptEnable(usbID, USB_OTG_INT_ONE_MS_TIMEOUT);
2737:                    }
2738:                
2739:                    if((usbInterrupts & USB_INT_HOST_DETACH) && (enabledUSBInterrupts & USB_INT_HOST_DETACH))
9D001DC4  32520001   ANDI S2, S2, 1
9D001DC8  12400040   BEQ S2, ZERO, _DRV_USBFS_HOST_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D001DCC  32620001   ANDI V0, S3, 1
9D001DD0  1040003E   BEQ V0, ZERO, _DRV_USBFS_HOST_Tasks_ISR::PLIB_USB_InterruptFlagGet
9D001DD4  24030001   ADDIU V1, ZERO, 1
2740:                    {
2741:                        /* Host got a device detach */
2742:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_HOST_DETACH);
2743:                
2744:                        /* The detach interrupt is not persistent. Unlike the attach interrupt,
2745:                         * clearing the detach interrupt will clear the flag. We dont debounce
2746:                         * this. */
2747:                
2748:                        PLIB_USB_InterruptDisable(usbID, USB_INT_HOST_DETACH);
2749:                
2750:                        /* We disable the token done interrupt. This will prevent the control
2751:                         * transfer process and the non control transfer process from getting a
2752:                         * null irp to process. We then clear the interrupt. To clear the token
2753:                         * interrupt, the stat register should be read once. */
2754:                
2755:                        PLIB_USB_InterruptDisable(usbID, USB_INT_TOKEN_DONE);
2756:                        PLIB_USB_LastTransactionDetailsGet(usbID, &lastDirection, &lastPingPong, &lastEndpoint );
2757:                        PLIB_USB_InterruptFlagClear(usbID, USB_INT_TOKEN_DONE);
2758:                
2759:                        /* Disable SOF */
2760:                        PLIB_USB_SOFDisable(usbID);
2761:                        PLIB_USB_InterruptDisable(usbID, USB_INT_SOF);
2762:                
2763:                        /* Reset the BDT ping pong hardware and software indicators */
2764:                        PLIB_USB_PingPongReset(pUSBDrvObj->usbID);
2765:                        pUSBDrvObj->ep0TxPingPong = USB_BUFFER_EVEN;
9D001E3C  AE200070   SW ZERO, 112(S1)
2766:                        pUSBDrvObj->ep0RxPingPong = USB_BUFFER_EVEN;
9D001E40  AE200074   SW ZERO, 116(S1)
2767:                
2768:                        /* Clear up all the endpoint 0 BDT entries.*/
2769:                        pUSBDrvObj->pBDT[0].word[0] = 0x0;
9D001E44  8E22002C   LW V0, 44(S1)
9D001E48  AC400000   SW ZERO, 0(V0)
2770:                        pUSBDrvObj->pBDT[0].word[1] = 0x0;
9D001E4C  8E22002C   LW V0, 44(S1)
9D001E50  AC400004   SW ZERO, 4(V0)
2771:                        pUSBDrvObj->pBDT[1].word[0] = 0x0;
9D001E54  8E22002C   LW V0, 44(S1)
9D001E58  AC400008   SW ZERO, 8(V0)
2772:                        pUSBDrvObj->pBDT[1].word[1] = 0x0;
9D001E5C  8E22002C   LW V0, 44(S1)
9D001E60  AC40000C   SW ZERO, 12(V0)
2773:                        pUSBDrvObj->pBDT[2].word[0] = 0x0;
9D001E64  8E22002C   LW V0, 44(S1)
9D001E68  AC400010   SW ZERO, 16(V0)
2774:                        pUSBDrvObj->pBDT[2].word[1] = 0x0;
9D001E6C  8E22002C   LW V0, 44(S1)
9D001E70  AC400014   SW ZERO, 20(V0)
2775:                        pUSBDrvObj->pBDT[3].word[0] = 0x0;
9D001E74  8E22002C   LW V0, 44(S1)
9D001E78  AC400018   SW ZERO, 24(V0)
2776:                        pUSBDrvObj->pBDT[3].word[1] = 0x0;
9D001E7C  8E22002C   LW V0, 44(S1)
9D001E80  AC40001C   SW ZERO, 28(V0)
2777:                
2778:                        /* Un-initialize the SWEP data structure */
2779:                        for(swEpCount = 0; swEpCount < _DRV_USBFS_SW_EP_NUMBER; swEpCount++)
2780:                        {
2781:                            pUSBDrvObj->drvUSBHostSWEp[swEpCount].tobeDone = false;
9D001E84  A220007C   SB ZERO, 124(S1)
9D001E88  A2200088   SB ZERO, 136(S1)
9D001E8C  A2200094   SB ZERO, 148(S1)
9D001E90  A22000A0   SB ZERO, 160(S1)
9D001E94  A22000AC   SB ZERO, 172(S1)
2782:                        }
2783:                
2784:                        pUSBDrvObj->isDeviceDeenumerating = true;
9D001E98  A22300DA   SB V1, 218(S1)
2785:                        
2786:                        /* Ask the host layer to de-enumerate this device. */
2787:                        USB_HOST_DeviceDenumerate (pUSBDrvObj->attachedDeviceObjHandle);
9D001E9C  0F4015D0   JAL USB_HOST_DeviceDenumerate
9D001EA0  8E2400E0   LW A0, 224(S1)
2788:                        
2789:                        pUSBDrvObj->isDeviceDeenumerating = false;
9D001EA4  A22000DA   SB ZERO, 218(S1)
2790:                        
2791:                        /* Disable the LS Direct Connect. It may have been enabled if the last
2792:                         attach was for low speed device. */
2793:                        PLIB_USB_EP0LSDirectConnectDisable(pUSBDrvObj->usbID);
2794:                
2795:                        /* Start the detach debouncing */
2796:                        pUSBDrvObj->isDetachDebouncing = true;
9D001EB4  24020001   ADDIU V0, ZERO, 1
9D001EB8  A22200D9   SB V0, 217(S1)
2797:                        pUSBDrvObj->detachDebounceCounter = 0;
9D001EBC  AE2000D4   SW ZERO, 212(S1)
2798:                        PLIB_USB_OTG_InterruptEnable(usbID, USB_OTG_INT_ONE_MS_TIMEOUT);
2799:                    }
2800:                
2801:                    /* Now check if the token was completed */
2802:                    if(PLIB_USB_InterruptFlagGet(usbID, USB_INT_TOKEN_DONE) && ((enabledUSBInterrupts & USB_INT_TOKEN_DONE) != 0))
9D001ED4  10400024   BEQ V0, ZERO, 0x9D001F68
9D001ED8  32730008   ANDI S3, S3, 8
9D001EDC  12600023   BEQ S3, ZERO, 0x9D001F6C
9D001EE0  8FBF0024   LW RA, 36(SP)
2803:                    {
2804:                        /* Get the last transaction status */
2805:                        PLIB_USB_LastTransactionDetailsGet(usbID, &lastDirection, &lastPingPong, &lastEndpoint );
2806:                
2807:                        /* Clear the flag */
2808:                        PLIB_USB_InterruptFlagClear(usbID,USB_INT_TOKEN_DONE);
2809:                
2810:                        /* Get the result of the last transaction */
2811:                
2812:                        pBDTEntry = pUSBDrvObj->pBDT + (lastDirection << 1) + lastPingPong;
9D001F00  00022040   SLL A0, V0, 1
9D001F04  00831821   ADDU V1, A0, V1
9D001F08  000318C0   SLL V1, V1, 3
9D001F0C  8E24002C   LW A0, 44(S1)
9D001F10  00831821   ADDU V1, A0, V1
2813:                        transactionResult = (pBDTEntry->byte[0] & 0x3C) >> 2;
9D001F14  90650000   LBU A1, 0(V1)
9D001F18  7CA51880   EXT A1, A1, 2, 4
2814:                        transactionSize = pBDTEntry->shortWord[1];
2815:                
2816:                        if(lastDirection == USB_BUFFER_RX)
9D001F1C  14400005   BNE V0, ZERO, 0x9D001F34
9D001F20  94660002   LHU A2, 2(V1)
2817:                        {
2818:                            /* Update the RX ping pong buffer indicator */
2819:                            pUSBDrvObj->ep0RxPingPong ^= 0x1;
9D001F24  8E220074   LW V0, 116(S1)
9D001F28  38420001   XORI V0, V0, 1
9D001F2C  0B4007D0   J 0x9D001F40
9D001F30  AE220074   SW V0, 116(S1)
2820:                        }
2821:                        else
2822:                        {
2823:                            /* Update the even ping pong buffer indicator */
2824:                            pUSBDrvObj->ep0TxPingPong ^= 0x1;
9D001F34  8E220070   LW V0, 112(S1)
9D001F38  38420001   XORI V0, V0, 1
9D001F3C  AE220070   SW V0, 112(S1)
2825:                        }
2826:                
2827:                        /* The _DRV_USBFS_HOST_TransferSchedule function will check for the
2828:                         * available bandwidth in this frame and will update the current
2829:                         * transfer. The return value will be true if the function sent a token.
2830:                         * */
2831:                        tokenWasSent = _DRV_USBFS_HOST_TransferSchedule(pUSBDrvObj, transactionResult, transactionSize, false);
9D001F40  02202021   ADDU A0, S1, ZERO
9D001F44  0F401398   JAL _DRV_USBFS_HOST_TransferSchedule
9D001F48  00003821   ADDU A3, ZERO, ZERO
2832:                
2833:                        if(tokenWasSent == false)
9D001F4C  14400007   BNE V0, ZERO, 0x9D001F6C
9D001F50  8FBF0024   LW RA, 36(SP)
2834:                        {
2835:                            /* This means the transfer that caused this interrupt is completed.
2836:                             * We call the _DRV_USBFS_HOST_TransferSchedule() function with last
2837:                             * transaction result and lastTransactionsize as 0. This lets the
2838:                             * function know that it must try to schedule a new transfer.
2839:                             * Note: No more than 1 IRP when isochronous IRP is present in 1 frame */
2840:                
2841:                            _DRV_USBFS_HOST_TransferSchedule(pUSBDrvObj, (DRV_USBFS_TRANSACTION_RESULT)0, (unsigned int)0, false);
9D001F54  02202021   ADDU A0, S1, ZERO
9D001F58  00002821   ADDU A1, ZERO, ZERO
9D001F5C  00003021   ADDU A2, ZERO, ZERO
9D001F60  0F401398   JAL _DRV_USBFS_HOST_TransferSchedule
9D001F64  00003821   ADDU A3, ZERO, ZERO
2842:                        }
2843:                    }
2844:                }
9D001F68  8FBF0024   LW RA, 36(SP)
2845:                
2846:                // ****************************************************************************
2847:                /* Function:
2848:                    bool DRV_USBFS_HOST_EventDisable
2849:                    (
2850:                        DRV_HANDLE handle
2851:                    );
2852:                    
2853:                  Summary:
2854:                    Disables host mode events.
2855:                    
2856:                  Description:
2857:                    This function disables the host mode events. This function is called by the
2858:                    Host Layer when it wants to execute code atomically. 
2859:                    
2860:                  Remarks:
2861:                    Refer to drv_usbfs.h for usage information.
2862:                */
2863:                
2864:                bool DRV_USBFS_HOST_EventsDisable
2865:                (
2866:                    DRV_HANDLE handle
2867:                )
2868:                {
9D0096F8  27BDFFE8   ADDIU SP, SP, -24
9D0096FC  AFBF0014   SW RA, 20(SP)
2869:                    DRV_USBFS_OBJ * pUSBDrvObj;
2870:                    bool result = false;
2871:                
2872:                    if((DRV_HANDLE_INVALID != handle) && (0 != handle))
9D0096E8  2483FFFF   ADDIU V1, A0, -1
9D0096EC  2C63FFFE   SLTIU V1, V1, -2
9D0096F0  10600007   BEQ V1, ZERO, 0x9D009710
9D0096F4  00001021   ADDU V0, ZERO, ZERO
2873:                    {
2874:                        pUSBDrvObj = (DRV_USBFS_OBJ *)(handle);
2875:                        result = _DRV_USBFS_InterruptSourceDisable(pUSBDrvObj->interruptSource);
9D009700  0F402481   JAL SYS_INT_SourceDisable
9D009704  8C840028   LW A0, 40(A0)
2876:                    }
2877:                
2878:                    return(result);
2879:                }
9D009708  8FBF0014   LW RA, 20(SP)
2880:                
2881:                // ****************************************************************************
2882:                /* Function:
2883:                    void DRV_USBFS_HOST_EventsDisable
2884:                    (
2885:                        DRV_HANDLE handle
2886:                        bool eventRestoreContext
2887:                    );
2888:                    
2889:                  Summary:
2890:                    Restores the events to the specified the original value.
2891:                    
2892:                  Description:
2893:                    This function will restore the enable disable state of the events.
2894:                    eventRestoreContext should be equal to the value returned by the
2895:                    DRV_USBFS_HOST_EventsDisable() function.
2896:                    
2897:                  Remarks:
2898:                    Refer to drv_usbfs.h for usage information.
2899:                */
2900:                
2901:                void DRV_USBFS_HOST_EventsEnable
2902:                (
2903:                    DRV_HANDLE handle, 
2904:                    bool eventContext
2905:                )
2906:                {
9D008EB8  27BDFFE8   ADDIU SP, SP, -24
9D008EBC  AFBF0014   SW RA, 20(SP)
2907:                    DRV_USBFS_OBJ * pUSBDrvObj;
2908:                   
2909:                    if((DRV_HANDLE_INVALID != handle) && (0 != handle))
9D008E78  2482FFFF   ADDIU V0, A0, -1
9D008E7C  2C42FFFE   SLTIU V0, V0, -2
9D008E80  10400013   BEQ V0, ZERO, 0x9D008ED0
9D008E84  00000000   NOP
2910:                    {
2911:                        pUSBDrvObj = (DRV_USBFS_OBJ *)(handle);
2912:                        if(eventContext == true)
9D008E88  10A0000B   BEQ A1, ZERO, 0x9D008EB8
9D008E8C  3C03BF88   LUI V1, -16504
2913:                        {
2914:                            _DRV_USBFS_InterruptSourceEnable(pUSBDrvObj->interruptSource);
9D008E90  8C820028   LW V0, 40(A0)
2915:                        }
2916:                        else
2917:                        {
2918:                            _DRV_USBFS_InterruptSourceDisable(pUSBDrvObj->interruptSource);
9D008EC0  0F402481   JAL SYS_INT_SourceDisable
9D008EC4  8C840028   LW A0, 40(A0)
2919:                        }
2920:                    }
2921:                }
9D008EC8  8FBF0014   LW RA, 20(SP)
2922:                
2923:                // *****************************************************************************
2924:                // *****************************************************************************
2925:                // Root Hub Driver Routines
2926:                // *****************************************************************************
2927:                // *****************************************************************************
2928:                
2929:                // *****************************************************************************
2930:                /* Function:
2931:                    void DRV_USBFS_HOST_ROOT_HUB_OperationEnable(DRV_HANDLE handle, bool enable)
2932:                
2933:                  Summary:
2934:                    Dynamic implementation of DRV_USBFS_HOST_ROOT_HUB_OperationEnable() function.
2935:                
2936:                  Description:
2937:                    This function enables the Root Hub Operation. When enabled the root hub will
2938:                    supply power to the port thus enablling device attach detection.
2939:                
2940:                  Remarks:
2941:                    Refer to drv_usbfs.h for usage information.
2942:                */
2943:                
2944:                void DRV_USBFS_HOST_ROOT_HUB_OperationEnable(DRV_HANDLE handle, bool enable)
2945:                {
9D007ACC  27BDFFE8   ADDIU SP, SP, -24
9D007AD0  AFBF0014   SW RA, 20(SP)
9D007AD4  AFB00010   SW S0, 16(SP)
2946:                    DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
2947:                
2948:                    /* Check if the handle is valid or opened */
2949:                    if((handle != DRV_HANDLE_INVALID) && (handle != (DRV_HANDLE)(NULL)) && (pUSBDrvObj->isOpened))
9D007AD8  2482FFFF   ADDIU V0, A0, -1
9D007ADC  2C42FFFE   SLTIU V0, V0, -2
9D007AE0  10400027   BEQ V0, ZERO, 0x9D007B80
9D007AE4  00808021   ADDU S0, A0, ZERO
9D007AE8  90820005   LBU V0, 5(A0)
9D007AEC  50400025   BEQL V0, ZERO, 0x9D007B84
9D007AF0  8FBF0014   LW RA, 20(SP)
2950:                    {
2951:                        if(true == enable)
9D007AF4  50A0000E   BEQL A1, ZERO, DRV_USBFS_HOST_ROOT_HUB_OperationEnable::PLIB_INT_SourceFlagClear
9D007AF8  8C820028   LW V0, 40(A0)
2952:                        {
2953:                            /* The USB Global interrupt and USB module is already enabled at
2954:                             * this point. We enable the attach interrupt to detect attach
2955:                             * First we enable port power */
2956:                            
2957:                            if(pUSBDrvObj->rootHubInfo.portPowerEnable != NULL)
9D007AFC  8C8200C8   LW V0, 200(A0)
9D007B00  10400003   BEQ V0, ZERO, DRV_USBFS_HOST_ROOT_HUB_OperationEnable::PLIB_USB_InterruptEnable
9D007B04  00002021   ADDU A0, ZERO, ZERO
2958:                            {
2959:                                /* This USB module has only one port. So we call this function
2960:                                 * once to enable the port power on port 0*/
2961:                                
2962:                               pUSBDrvObj->rootHubInfo.portPowerEnable(0 /* Port 0 */, true); 
9D007B08  0040F809   JALR V0
9D007B0C  24050001   ADDIU A1, ZERO, 1
2963:                            }
2964:                
2965:                            /* Enable the attach interrupt */
2966:                            PLIB_USB_InterruptEnable(pUSBDrvObj->usbID, USB_INT_ATTACH);
2967:                            pUSBDrvObj->driverFlags |= DRV_USBFS_FLAG_HOST_MODE_ENABLED;
9D007B20  8E020008   LW V0, 8(S0)
9D007B24  34420010   ORI V0, V0, 16
9D007B28  0B401EE0   J 0x9D007B80
9D007B2C  AE020008   SW V0, 8(S0)
2968:                
2969:                        }
2970:                        else
2971:                        {
2972:                            /* If the root hub operation is disable, we disable detach event
2973:                             * and switch off the port power. */
2974:                
2975:                            SYS_INT_SourceStatusClear(pUSBDrvObj->interruptSource);
2976:                            PLIB_USB_InterruptDisable(pUSBDrvObj->usbID, USB_INT_ATTACH);
2977:                            pUSBDrvObj->driverFlags &= ~DRV_USBFS_FLAG_HOST_MODE_ENABLED;
9D007B60  8E020008   LW V0, 8(S0)
9D007B64  7C022104   INS V0, ZERO, 4, 1
9D007B68  AE020008   SW V0, 8(S0)
2978:                            if(pUSBDrvObj->rootHubInfo.portPowerEnable != NULL)
9D007B6C  8E0200C8   LW V0, 200(S0)
9D007B70  10400003   BEQ V0, ZERO, 0x9D007B80
9D007B74  00002021   ADDU A0, ZERO, ZERO
2979:                            {
2980:                                /* This USB module has only one port. So we call this function
2981:                                 * once to disable the port power on port 0*/
2982:                                
2983:                               pUSBDrvObj->rootHubInfo.portPowerEnable(0 /* Port 0 */, false); 
9D007B78  0040F809   JALR V0
9D007B7C  00002821   ADDU A1, ZERO, ZERO
2984:                            }
2985:                        }
2986:                    }
2987:                    else
2988:                    {
2989:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
2990:                    }
2991:                }
9D007B80  8FBF0014   LW RA, 20(SP)
2992:                
2993:                // *****************************************************************************
2994:                /* Function:
2995:                    bool DRV_USBFS_HOST_ROOT_HUB_OperationIsEnabled(DRV_HANDLE handle)
2996:                
2997:                  Summary:
2998:                    Dynamic implementation of DRV_USBFS_HOST_OperationIsEnabled function.
2999:                
3000:                  Description:
3001:                    Function returns true if the root hub enable operation has completed.
3002:                
3003:                  Remarks:
3004:                    Refer to drv_usbfs.h for usage information.
3005:                
3006:                */
3007:                
3008:                bool DRV_USBFS_HOST_ROOT_HUB_OperationIsEnabled(DRV_HANDLE handle)
3009:                {
3010:                    DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
3011:                    bool returnValue = false;
3012:                
3013:                    /* Check if the handle is valid or opened */
3014:                    if((handle != DRV_HANDLE_INVALID) && (handle != (DRV_HANDLE)(NULL)) && (pUSBDrvObj->isOpened))
9D009834  2483FFFF   ADDIU V1, A0, -1
9D009838  2C63FFFE   SLTIU V1, V1, -2
9D00983C  10600006   BEQ V1, ZERO, 0x9D009858
9D009840  00001021   ADDU V0, ZERO, ZERO
9D009844  90830005   LBU V1, 5(A0)
9D009848  10600003   BEQ V1, ZERO, 0x9D009858
9D00984C  00000000   NOP
3015:                    {
3016:                        returnValue = (pUSBDrvObj->driverFlags & DRV_USBFS_FLAG_HOST_MODE_ENABLED) ? true : false;
9D009850  8C820008   LW V0, 8(A0)
9D009854  7C420100   EXT V0, V0, 4, 1
3017:                    }
3018:                    else
3019:                    {
3020:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3021:                    }
3022:                
3023:                    return returnValue;
3024:                }
9D009858  03E00008   JR RA
3025:                
3026:                // ****************************************************************************
3027:                /* Function:
3028:                    void DRV_USBFS_ROOT_HUB_PortReset(DRV_HANDLE handle, uint8_t port );
3029:                    
3030:                  Summary:
3031:                    Resets the specified root hub port.
3032:                    
3033:                  Description:
3034:                    This function resets the root hub port. The reset duration is defined by
3035:                    DRV_USBFS_ROOT_HUB_RESET_DURATION. The status of the reset signalling can be
3036:                    checked using the DRV_USBFS_ROOT_HUB_PortResetIsComplete() function.
3037:                    
3038:                  Remarks:
3039:                    Refer to drv_usbfs.h for usage information.
3040:                */
3041:                
3042:                USB_ERROR DRV_USBFS_HOST_ROOT_HUB_PortReset(DRV_HANDLE handle, uint8_t port)
3043:                {
3044:                    DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
3045:                    USB_ERROR result = USB_ERROR_NONE;
9D008CC8  03E00008   JR RA
9D008CCC  00001021   ADDU V0, ZERO, ZERO
3046:                
3047:                    if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
9D008C74  2482FFFF   ADDIU V0, A0, -1
9D008C78  2C42FFFE   SLTIU V0, V0, -2
9D008C7C  10400014   BEQ V0, ZERO, 0x9D008CD0
9D008C80  00000000   NOP
3048:                    {
3049:                        if(pUSBDrvObj->isOpened)
9D008C84  90820005   LBU V0, 5(A0)
9D008C88  50400013   BEQL V0, ZERO, 0x9D008CD8
9D008C8C  2402FF83   ADDIU V0, ZERO, -125
3050:                        {
3051:                            if(!pUSBDrvObj->isResetting)
9D008C90  908300B8   LBU V1, 184(A0)
9D008C94  14600010   BNE V1, ZERO, 0x9D008CD8
9D008C98  00001021   ADDU V0, ZERO, ZERO
3052:                            {
3053:                                /* Start the reset signal. Set the driver flag to indicate the
3054:                                 * reset signal is in progress. Enable the 1 millisecond timer
3055:                                 * interrupt to count the reset duration. Clear the reset
3056:                                 * duration counter. This counter will be updated in the
3057:                                 * interrupt. Start generating the reset signal. */
3058:                
3059:                                pUSBDrvObj->isResetting = true;
9D008C9C  24020001   ADDIU V0, ZERO, 1
9D008CA0  A08200B8   SB V0, 184(A0)
3060:                                pUSBDrvObj->resetDuration = 0;
9D008CA4  AC8000BC   SW ZERO, 188(A0)
3061:                                PLIB_USB_ResetSignalEnable(pUSBDrvObj->usbID);
3062:                                PLIB_USB_OTG_InterruptEnable(pUSBDrvObj->usbID, USB_OTG_INT_ONE_MS_TIMEOUT);
3063:                            }
3064:                            else
3065:                            {
3066:                                /* This means a reset is alredy in progress. Lets not do anything. */
3067:                                SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Reset already in progress");
3068:                            }
3069:                        }
3070:                        else
3071:                        {
3072:                            /* Driver handle is not valid */
3073:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3074:                            result = USB_ERROR_PARAMETER_INVALID;
3075:                        }
3076:                    }
3077:                    else
3078:                    {
3079:                        /* Driver handle is not valid */
3080:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3081:                        result = USB_ERROR_PARAMETER_INVALID;
9D008CD0  03E00008   JR RA
9D008CD4  2402FF83   ADDIU V0, ZERO, -125
3082:                    }
3083:                    
3084:                    return(result);
3085:                }
9D008CD8  03E00008   JR RA
3086:                
3087:                // ****************************************************************************
3088:                /* Function:
3089:                    USB_SPEED DRV_USBFS_HOST_ROOT_HUB_PortSpeedGet
3090:                    (
3091:                        DRV_HANDLE handle,
3092:                        uint8_t port
3093:                    );
3094:                
3095:                  Summary:
3096:                    Returns the speed of at which the port is operating.
3097:                
3098:                  Description:
3099:                    This function returns the speed at which the port is operating.
3100:                
3101:                  Remarks:
3102:                    Refer to drv_usbfs.h for usage information.
3103:                */
3104:                
3105:                USB_SPEED DRV_USBFS_HOST_ROOT_HUB_PortSpeedGet(DRV_HANDLE handle, uint8_t port)
3106:                {
3107:                    DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
3108:                    USB_SPEED speed = USB_SPEED_ERROR;
3109:                
3110:                    if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
9D0098E4  2483FFFF   ADDIU V1, A0, -1
9D0098E8  2C63FFFE   SLTIU V1, V1, -2
9D0098EC  10600004   BEQ V1, ZERO, 0x9D009900
9D0098F0  00001021   ADDU V0, ZERO, ZERO
3111:                    {
3112:                        if(pUSBDrvObj->isOpened)
9D0098F4  90830005   LBU V1, 5(A0)
9D0098F8  54600001   BNEL V1, ZERO, 0x9D009900
9D0098FC  8C820038   LW V0, 56(A0)
3113:                        {
3114:                            /* The driver will not check if a device is connected. It is assumed
3115:                             * that the client has issued a port reset before calling this function
3116:                             */
3117:                
3118:                            speed = pUSBDrvObj->deviceSpeed;
3119:                        }
3120:                        else
3121:                        {
3122:                            /* Driver handle is not valid */
3123:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3124:                        }
3125:                    }
3126:                    else
3127:                    {
3128:                        /* Driver has not been opened. Handle could be stale */
3129:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3130:                    }
3131:                
3132:                    return(speed);
3133:                }
9D009900  03E00008   JR RA
3134:                
3135:                // ****************************************************************************
3136:                /* Function:
3137:                    void DRV_USBFS_ROOT_HUB_PortResetIsComplete
3138:                    (
3139:                        DRV_HANDLE handle,
3140:                        uint8_t port
3141:                    );
3142:                
3143:                  Summary:
3144:                    Returns true if the root hub has completed the port reset operation.
3145:                
3146:                  Description:
3147:                    This function returns true if the port reset operation has completed. It
3148:                    should be called after the DRV_USB_HOST_ROOT_HUB_PortReset() function to
3149:                    check if the reset operation has completed.
3150:                
3151:                  Remarks:
3152:                    Refer to drv_usbfs.h for usage information.
3153:                 */
3154:                
3155:                bool DRV_USBFS_HOST_ROOT_HUB_PortResetIsComplete
3156:                (
3157:                    DRV_HANDLE handle,
3158:                    uint8_t port
3159:                )
3160:                {
3161:                    DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
3162:                    bool result = true;
3163:                
3164:                    if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
9D009860  2483FFFF   ADDIU V1, A0, -1
9D009864  2C63FFFE   SLTIU V1, V1, -2
9D009868  10600006   BEQ V1, ZERO, 0x9D009884
9D00986C  24020001   ADDIU V0, ZERO, 1
3165:                    {
3166:                        if(pUSBDrvObj->isOpened)
9D009870  90830005   LBU V1, 5(A0)
9D009874  10600003   BEQ V1, ZERO, 0x9D009884
9D009878  00000000   NOP
3167:                        {
3168:                            /* Return false if the driver is still resetting*/
3169:                            result = (pUSBDrvObj->isResetting) ? false : true;
9D00987C  908200B8   LBU V0, 184(A0)
9D009880  38420001   XORI V0, V0, 1
3170:                        }
3171:                        else
3172:                        {
3173:                            /* Driver handle is not valid */
3174:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3175:                        }
3176:                    }
3177:                    else
3178:                    {
3179:                        /* Driver has not been opened. Handle could be stale */
3180:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3181:                    }
3182:                
3183:                    return(result);
3184:                }
9D009884  03E00008   JR RA
3185:                
3186:                // ****************************************************************************
3187:                /* Function:
3188:                    void DRV_USBFS_ROOT_HUB_PortResume(DRV_HANDLE handle, uint8_t port );
3189:                
3190:                  Summary:
3191:                    Resumes the specified root hub port.
3192:                
3193:                  Description:
3194:                    This function resumes the root hub. The resume duration is defined by
3195:                    DRV_USBFS_ROOT_HUB_RESUME_DURATION. The status of the resume signalling can
3196:                    be checked using the DRV_USBFS_ROOT_HUB_PortResumeIsComplete() function.
3197:                
3198:                  Remarks:
3199:                    The root hub on this particular hardware only contains one port - port 0.
3200:                */
3201:                
3202:                USB_ERROR DRV_USBFS_HOST_ROOT_HUB_PortResume(DRV_HANDLE handle, uint8_t port)
3203:                {
3204:                    /* The functionality is yet to be implemented. */
3205:                    return(USB_ERROR_NONE);
3206:                }
9D009B0C  03E00008   JR RA
3207:                
3208:                // ****************************************************************************
3209:                /* Function:
3210:                    void DRV_USBFS_ROOT_HUB_PortSuspend(DRV_HANDLE handle, uint8_t port );
3211:                
3212:                  Summary:
3213:                    Suspends the specified root hub port.
3214:                
3215:                  Description:
3216:                    This function suspends the root hub port.
3217:                
3218:                  Remarks:
3219:                    The root hub on this particular hardware only contains one port - port 0.
3220:                */
3221:                
3222:                USB_ERROR DRV_USBFS_HOST_ROOT_HUB_PortSuspend(DRV_HANDLE handle, uint8_t port)
3223:                {
3224:                    /* The functionality is yet to be implemented. */
3225:                    return (USB_ERROR_NONE);
3226:                }
9D009B14  03E00008   JR RA
3227:                
3228:                // ****************************************************************************
3229:                /* Function:
3230:                    USB_SPEED DRV_USBFS_HOST_ROOT_HUB_BusSpeedGet(DRV_HANDLE handle);
3231:                
3232:                  Summary:
3233:                    Returns the speed at which the bus to which this root hub is connected is
3234:                    operating.
3235:                
3236:                  Description:
3237:                    This function returns the speed at which the bus to which this root hub is
3238:                    connected is operating.
3239:                
3240:                 Remarks:
3241:                    None.
3242:                */
3243:                
3244:                USB_SPEED DRV_USBFS_HOST_ROOT_HUB_BusSpeedGet(DRV_HANDLE handle)
3245:                {
3246:                    DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
3247:                    USB_SPEED speed = USB_SPEED_ERROR;
9D00991C  24020002   ADDIU V0, ZERO, 2
9D009920  0003100A   MOVZ V0, ZERO, V1
3248:                
3249:                    if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
9D009908  2483FFFF   ADDIU V1, A0, -1
9D00990C  2C63FFFE   SLTIU V1, V1, -2
9D009910  10600004   BEQ V1, ZERO, 0x9D009924
9D009914  00001021   ADDU V0, ZERO, ZERO
3250:                    {
3251:                        if(pUSBDrvObj->isOpened)
9D009918  90830005   LBU V1, 5(A0)
3252:                        {
3253:                            speed = USB_SPEED_FULL;
3254:                        }
3255:                        else
3256:                        {
3257:                            /* Driver handle is not valid */
3258:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3259:                        }
3260:                    }
3261:                    else
3262:                    {
3263:                        /* Driver has not been opened. Handle could be stale */
3264:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3265:                    }
3266:                
3267:                    return(speed);
3268:                }
9D009924  03E00008   JR RA
3269:                
3270:                // ****************************************************************************
3271:                /* Function:
3272:                    uint32_t DRV_USBFS_HOST_ROOT_HUB_MaximumCurrentGet(DRV_HANDLE);
3273:                
3274:                  Summary:
3275:                    Returns the maximum amount of current that this root hub can provide on the
3276:                    bus.
3277:                
3278:                  Description:
3279:                    This function returns the maximum amount of current that this root hubn can
3280:                    provide on the bus.
3281:                
3282:                  Remarks:
3283:                    Refer to drv_usbfs.h for usage information.
3284:                */
3285:                
3286:                uint32_t DRV_USBFS_HOST_ROOT_HUB_MaximumCurrentGet(DRV_HANDLE handle)
3287:                {
3288:                    DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
3289:                    uint32_t result = 0;
3290:                
3291:                    if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
9D00992C  2483FFFF   ADDIU V1, A0, -1
9D009930  2C63FFFE   SLTIU V1, V1, -2
9D009934  10600004   BEQ V1, ZERO, 0x9D009948
9D009938  00001021   ADDU V0, ZERO, ZERO
3292:                    {
3293:                        if(pUSBDrvObj->isOpened)
9D00993C  90830005   LBU V1, 5(A0)
9D009940  54600001   BNEL V1, ZERO, 0x9D009948
9D009944  8C8200CC   LW V0, 204(A0)
3294:                        {
3295:                            result = pUSBDrvObj->rootHubInfo.rootHubAvailableCurrent;
3296:                        }
3297:                        else
3298:                        {
3299:                            /* Driver handle is not valid */
3300:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3301:                        }
3302:                    }
3303:                    else
3304:                    {
3305:                        /* Driver has not been opened. Handle could be stale */
3306:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3307:                    }
3308:                
3309:                    return(result);
3310:                }
9D009948  03E00008   JR RA
3311:                
3312:                // ****************************************************************************
3313:                /* Function:
3314:                    uint8_t DRV_USBFS_HOST_ROOT_HUB_PortNumbersGet(DRV_HANDLE handle);
3315:                
3316:                  Summary:
3317:                    Returns the number of ports this root hub contains.
3318:                
3319:                  Description:
3320:                    This function returns the number of ports that this root hub contains.
3321:                
3322:                  Remarks:
3323:                    None.
3324:                */
3325:                
3326:                uint8_t DRV_USBFS_HOST_ROOT_HUB_PortNumbersGet(DRV_HANDLE handle)
3327:                {
3328:                    DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
3329:                    uint8_t result = 0;
9D009A20  90820005   LBU V0, 5(A0)
3330:                
3331:                    if((DRV_HANDLE_INVALID != handle) && (handle != (DRV_HANDLE)(NULL)))
9D009A10  2483FFFF   ADDIU V1, A0, -1
9D009A14  2C63FFFE   SLTIU V1, V1, -2
9D009A18  10600002   BEQ V1, ZERO, 0x9D009A24
9D009A1C  00001021   ADDU V0, ZERO, ZERO
3332:                    {
3333:                        if(pUSBDrvObj->isOpened)
3334:                        {
3335:                            result = 1;
3336:                        }
3337:                        else
3338:                        {
3339:                            /* Driver handle is not valid */
3340:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3341:                        }
3342:                    }
3343:                    else
3344:                    {
3345:                        /* Driver has not been opened. Handle could be stale */
3346:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3347:                    }
3348:                
3349:                    return(result);
3350:                }
9D009A24  03E00008   JR RA
3351:                
3352:                // ****************************************************************************
3353:                /* Function:
3354:                    void DRV_USBFS_HOST_ROOT_HUB_Initialize
3355:                    (
3356:                        DRV_HANDLE handle,
3357:                        USB_HOST_DEVICE_INFO usbHostDeviceInfo,
3358:                    )
3359:                
3360:                  Summary:
3361:                    This function instantiates the root hub driver.
3362:                
3363:                  Description:
3364:                    This function initializes the root hub driver. It is called by the host
3365:                    layer at the time of processing root hub devices. The host layer assigns a
3366:                    USB_HOST_DEVICE_INFO reference to this root hub driver. This identifies the
3367:                    relationship between the root hub and the host layer.
3368:                
3369:                  Remarks:
3370:                    None.
3371:                */
3372:                
3373:                void DRV_USBFS_HOST_ROOT_HUB_Initialize
3374:                (
3375:                    DRV_HANDLE handle,
3376:                    USB_HOST_DEVICE_OBJ_HANDLE usbHostDeviceInfo
3377:                )
3378:                {
3379:                    DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
3380:                
3381:                    if((handle != DRV_HANDLE_INVALID) && (handle != (DRV_HANDLE)(NULL)))
9D009950  2482FFFF   ADDIU V0, A0, -1
9D009954  2C42FFFE   SLTIU V0, V0, -2
9D009958  10400004   BEQ V0, ZERO, 0x9D00996C
9D00995C  00000000   NOP
3382:                    {
3383:                        if(pUSBDrvObj->isOpened)
9D009960  90820005   LBU V0, 5(A0)
3384:                        {
3385:                            pUSBDrvObj->usbHostDeviceInfo = usbHostDeviceInfo;
3386:                        }
3387:                        else
3388:                        {
3389:                            /* Driver has not been opened. Handle could be stale */
3390:                            SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3391:                        }
3392:                    }
3393:                    else
3394:                    {
3395:                        /* Driver handle is not valid */
3396:                        SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
3397:                    }
3398:                }
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/driver/usb/usbfs/src/dynamic/drv_usbfs.c
1:                   /*******************************************************************************
2:                     USB Controller Driver Core Routines.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usbfs.c
9:                   
10:                    Summary:
11:                      USB Controller Driver Core Routines intended for Dynamic implementation.
12:                  
13:                    Description:
14:                      The USB Controller driver provides a simple interface to manage the USB
15:                      modules on Microchip microcontrollers.  This file Implements the core
16:                      interface routines to be used both by the client(USB Host or Device layer)
17:                      and the system for communicating with USB Contoller driver.  While building
18:                      the driver from source, ALWAYS use this file in the build.
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute Software
26:                  only when embedded on a Microchip microcontroller or digital  signal  controller
27:                  that is integrated into your product or third party  product  (pursuant  to  the
28:                  sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
34:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
38:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
40:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
41:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
43:                  *******************************************************************************/
44:                  //DOM-IGNORE-END
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Include Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "system_config.h"
53:                  #include "driver/usb/usbfs/src/drv_usbfs_local.h"
54:                  
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  // Section: Global Data
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  
61:                  /******************************************************
62:                   * Hardware instance, endpoint table and client object
63:                   * lumped together as group to save memory.
64:                   ******************************************************/
65:                  DRV_USBFS_GROUP gDrvUSBGroup[DRV_USBFS_INSTANCES_NUMBER];
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: USB Controller Driver Interface Implementations
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  // *****************************************************************************
74:                  /* Function:
75:                      SYS_MODULE_OBJ DRV_USBFS_Initialize
76:                      ( 
77:                          const SYS_MODULE_INDEX index,
78:                          const SYS_MODULE_INIT * const init
79:                      )
80:                  
81:                    Summary:
82:                      Initializes the USB Driver.
83:                     
84:                    Description:
85:                      This function initializes the USB Driver, making it ready for clients to
86:                      open. The driver initialization does not complete when this function
87:                      returns. The DRV_USBFS_Tasks function must called periodically to complete
88:                      the driver initialization. The DRV_USBHS_Open function will fail if the
89:                      driver was not initialized or if initialization has not completed.
90:                    
91:                    Remarks:
92:                      See drv_usbfs.h for usage information.
93:                  */
94:                  
95:                  SYS_MODULE_OBJ DRV_USBFS_Initialize 
96:                  (
97:                      const SYS_MODULE_INDEX  drvIndex,
98:                      const SYS_MODULE_INIT * const init
99:                  )
100:                 {
9D005E00  27BDFFE8   ADDIU SP, SP, -24
9D005E04  AFBF0014   SW RA, 20(SP)
9D005E08  AFB00010   SW S0, 16(SP)
9D005E0C  00A03021   ADDU A2, A1, ZERO
101:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)NULL;
102:                     USB_MODULE_ID usbID = USB_NUMBER_OF_MODULES;
103:                     DRV_USBFS_INIT * pusbInit = (DRV_USBFS_INIT *)NULL;
104:                     SYS_MODULE_OBJ returnValue = SYS_MODULE_OBJ_INVALID;
105:                 
106:                     if(drvIndex < DRV_USBFS_INSTANCES_NUMBER)
9D005DE8  1480004D   BNE A0, ZERO, 0x9D005F20
9D005DEC  2402FFFF   ADDIU V0, ZERO, -1
107:                     {
108:                         /* Driver index is valid */
109:                         if(gDrvUSBGroup[drvIndex].gDrvUSBObj.inUse == false)
9D005DF0  3C02A000   LUI V0, -24576
9D005DF4  90430200   LBU V1, 512(V0)
9D005DF8  14600049   BNE V1, ZERO, 0x9D005F20
9D005DFC  2402FFFF   ADDIU V0, ZERO, -1
110:                         {
111:                             /* Driver object is available. Grab the particular USB instance
112:                              * object*/
113:                             gDrvUSBGroup[drvIndex].gDrvUSBObj.inUse = true;
9D005E10  3C02A000   LUI V0, -24576
9D005E14  24030001   ADDIU V1, ZERO, 1
9D005E18  A0430200   SB V1, 512(V0)
114:                 
115:                             /* Assign to the local pointer the init data passed */
116:                             pusbInit = (DRV_USBFS_INIT *) init;
117:                             usbID = pusbInit->usbID;
9D005E1C  8CB00004   LW S0, 4(A1)
118:                             pUSBDrvObj = &gDrvUSBGroup[drvIndex].gDrvUSBObj;
119:                 
120:                             /* If this being built in an OS application, then create a mutex */
121:                             if(OSAL_MUTEX_Create(&pUSBDrvObj->mutexID) == OSAL_RESULT_TRUE)
122:                             {
123:                                 /* Populate the driver instance object with required data */
124:                                 pUSBDrvObj->status = SYS_STATUS_BUSY;
9D005E28  24030001   ADDIU V1, ZERO, 1
9D005E2C  AC430014   SW V1, 20(V0)
125:                                 pUSBDrvObj->usbID = usbID;
9D005E30  AC500020   SW S0, 32(V0)
126:                                 pUSBDrvObj->operationMode = pusbInit->operationMode;
9D005E34  8CA40014   LW A0, 20(A1)
9D005E38  AC440024   SW A0, 36(V0)
127:                                 pUSBDrvObj->pBDT = (DRV_USBFS_BDT_ENTRY *)(pusbInit->endpointTable);
9D005E3C  8CA40018   LW A0, 24(A1)
9D005E40  AC44002C   SW A0, 44(V0)
128:                                 pUSBDrvObj->isOpened = false;
9D005E44  A0400005   SB ZERO, 5(V0)
129:                                 pUSBDrvObj->pEventCallBack = NULL;
9D005E48  AC400010   SW ZERO, 16(V0)
130:                 
131:                                 /* Assign the endpoint table */
132:                                 pUSBDrvObj->endpointTable = &gDrvUSBGroup[drvIndex].gDrvUSBEndpoints[0];
9D005E4C  3C04A000   LUI A0, -24576
9D005E50  248402E4   ADDIU A0, A0, 740
9D005E54  AC440034   SW A0, 52(V0)
133:                                 pUSBDrvObj->interruptSource  = pusbInit->interruptSource;
9D005E58  8CA4000C   LW A0, 12(A1)
9D005E5C  AC440028   SW A0, 40(V0)
134:                 
135:                                 /* Enable USB module(U1PWRC<0>). This internally does the following:
136:                                  * - Start the USB clock
137:                                  * - Allow the USB interrupt to be activated
138:                                  * - Select USB as the owner of the necessary I/O pins
139:                                  * - Enable the USB transceiver
140:                                  * - Enable the USB comparators */
141:                 
142:                                 PLIB_USB_Enable(usbID);
143:                 
144:                                 /* Setup the Hardware */
145:                                 if(pusbInit->stopInIdle)
9D005E6C  90A20008   LBU V0, 8(A1)
9D005E70  10400006   BEQ V0, ZERO, DRV_USBFS_Initialize::PLIB_USB_StopInIdleDisable
9D005E74  00000000   NOP
146:                                 {
147:                                     PLIB_USB_StopInIdleEnable( usbID );
148:                                 }
149:                                 else
150:                                 {
151:                                     PLIB_USB_StopInIdleDisable( usbID );
152:                                 }
153:                 
154:                 #ifdef PLIB_USB_ExistsAutomaticSuspend
155:                                 if(PLIB_USB_ExistsAutomaticSuspend(usbID))
156:                                 {
157:                                     if(pusbInit->suspendInSleep)
9D005E84  0B4017A8   J 0x9D005EA0
9D005E88  90C20009   LBU V0, 9(A2)
9D005E9C  90C20009   LBU V0, 9(A2)
9D005EA0  10400004   BEQ V0, ZERO, DRV_USBFS_Initialize::PLIB_USB_AutoSuspendDisable
9D005EA4  24020001   ADDIU V0, ZERO, 1
158:                                     {
159:                                         PLIB_USB_AutoSuspendEnable( usbID );
160:                                     }
161:                                     else
162:                                     {
163:                                         PLIB_USB_AutoSuspendDisable( usbID );
164:                                     }
165:                                 }
166:                 #endif
167:                                 /* Setup the USB Module as per selected mode */
168:                                 switch(pusbInit->operationMode)
9D005EAC  0B4017AF   J 0x9D005EBC
9D005EB0  8CC30014   LW V1, 20(A2)
9D005EB8  8CC30014   LW V1, 20(A2)
9D005EBC  24020002   ADDIU V0, ZERO, 2
9D005EC0  14620006   BNE V1, V0, 0x9D005EDC
9D005EC4  3C03A000   LUI V1, -24576
169:                                 {
170:                                     case DRV_USBFS_OPMODE_DEVICE:
171:                 
172:                                         /* Initialize USB Controller for Device mode */
173:                                         _DRV_USBFS_DEVICE_INIT(pUSBDrvObj, drvIndex);
174:                                         break;
175:                 
176:                                     case DRV_USBFS_OPMODE_HOST:
177:                 
178:                                         /* Initialize USB Controller for Host mode */
179:                                         _DRV_USBFS_HOST_INIT(pUSBDrvObj, drvIndex, pusbInit);
9D005EC8  3C04A000   LUI A0, -24576
9D005ECC  24840200   ADDIU A0, A0, 512
9D005ED0  0F4017CA   JAL _DRV_USBFS_HOST_Initialize
9D005ED4  00002821   ADDU A1, ZERO, ZERO
180:                                         break;
181:                 
182:                                     case DRV_USBFS_OPMODE_OTG:
183:                                         /* Not implemented at this point of time*/
184:                                         break;
185:                 
186:                                     default:
187:                                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: What mode are you trying?");
188:                                         break;
189:                                 }
190:                 
191:                                 /* Assign the BDT table base address */
192:                                 PLIB_USB_BDTBaseAddressSet(usbID , (void *)((uint32_t)KVA_TO_PA(pUSBDrvObj->pBDT)));    
9D005ED8  3C03A000   LUI V1, -24576
9D005EDC  24630200   ADDIU V1, V1, 512
9D005EE0  8C62002C   LW V0, 44(V1)
9D005EE4  7C42E000   EXT V0, V0, 0, 29
193:                 
194:                                 /* Indicate that the object is ready and in use and return the driver
195:                                  * handle */
196:                 
197:                                 pUSBDrvObj->status = SYS_STATUS_READY;
9D005F08  24020002   ADDIU V0, ZERO, 2
9D005F0C  AC620014   SW V0, 20(V1)
198:                                 returnValue = drvIndex;
9D005F10  00001021   ADDU V0, ZERO, ZERO
199:                             }
200:                             else
201:                             {
202:                                 /* Could not create mutex. Return the object. */
203:                                 gDrvUSBGroup[drvIndex].gDrvUSBObj.inUse = false;
204:                                 SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Mutex create failed");
205:                             } 
206:                         }
207:                         else
208:                         {
209:                             /* Cannot initialize an object that is already in use. */
210:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Hardware Instance already in use");
211:                         }
212:                     }
213:                     else
214:                     {
215:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid driver index");
216:                     }
217:                 
218:                     return (returnValue);
219:                 }
9D005F14  8FBF0014   LW RA, 20(SP)
220:                 
221:                 // *****************************************************************************
222:                 /* Function:
223:                     void DRV_USBFS_Deinitialize( const SYS_MODULE_OBJ object )
224:                 
225:                   Summary:
226:                     This function deinitializes the USBFS driver instance. 
227:                 
228:                   Description:
229:                     This function deinitializes the USBFS driver instance. 
230:                 
231:                   Remarks:
232:                     A typicall USB application may not to called this function.
233:                 */
234:                 
235:                 void DRV_USBFS_Deinitialize
236:                 ( 
237:                     const SYS_MODULE_OBJ  object
238:                 )
239:                 {
240:                     DRV_USBFS_OBJ * pUSBDrvObj = NULL;
241:                 
242:                     if((object != SYS_MODULE_OBJ_INVALID) && (object < DRV_USBFS_INSTANCES_NUMBER))
243:                     {
244:                         /* Object is valid */
245:                         if(gDrvUSBGroup[object].gDrvUSBObj.inUse == true)
246:                         {
247:                             pUSBDrvObj = &gDrvUSBGroup[object].gDrvUSBObj;
248:                 
249:                             /* Release the USB instance object */
250:                             pUSBDrvObj->inUse = false;
251:                 
252:                             /* Reset the open flag */
253:                             pUSBDrvObj->isOpened = false;
254:                 
255:                             /* Delete the mutex */
256:                             OSAL_MUTEX_Delete(&pUSBDrvObj->mutexID);
257:                 
258:                             /* Uninitialize the status*/
259:                             pUSBDrvObj->status = SYS_STATUS_UNINITIALIZED;
260:                 
261:                             pUSBDrvObj->pEventCallBack = NULL;
262:                 
263:                             /* Clear and disable the interrupts */
264:                             _DRV_USBFS_InterruptSourceDisable(pUSBDrvObj->interruptSource);
265:                             _DRV_USBFS_InterruptSourceClear(pUSBDrvObj->interruptSource);
266:                 
267:                             /* Turn off USB module */
268:                             PLIB_USB_Disable(pUSBDrvObj->usbID);
269:                         }
270:                         else
271:                         {
272:                             /* Cannot deinitialize an object that is not in use. */
273:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Instance not in use");
274:                         }
275:                     }
276:                     else
277:                     {
278:                         /* Invalid object */
279:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid System Module Object");
280:                     }
281:                 } 
282:                 
283:                 // *****************************************************************************
284:                 /* Function:
285:                     SYS_STATUS DRV_USBFS_Status( const SYS_MODULE_OBJ object )
286:                 
287:                   Summary:
288:                     Provides the current status of the USB Driver module.
289:                 
290:                   Description:
291:                     This function provides the current status of the USB Driver module.
292:                 
293:                   Remarks:
294:                     See drv_usbfs.h for usage information.
295:                 */
296:                 
297:                 SYS_STATUS DRV_USBFS_Status
298:                 (
299:                     const SYS_MODULE_OBJ object
300:                 )
301:                 {
302:                     SYS_STATUS returnValue = SYS_STATUS_UNINITIALIZED;
303:                 
304:                     /* Check if USB instance object is valid */
305:                     if((object != SYS_MODULE_OBJ_INVALID) || (object < DRV_USBFS_INSTANCES_NUMBER))
306:                     {
307:                         returnValue = gDrvUSBGroup[object].gDrvUSBObj.status;
308:                     }
309:                     else
310:                     {
311:                         /* Invalid object */
312:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Invalid object");
313:                     }
314:                 
315:                     /* Return the status of the driver object */
316:                     return returnValue;
317:                 }
318:                 
319:                 // *****************************************************************************
320:                 /* Function:
321:                     DRV_HANDLE DRV_USBFS_Open
322:                     (
323:                         const SYS_MODULE_INDEX drvIndex,
324:                         const DRV_IO_INTENT ioIntent 
325:                     )
326:                 
327:                   Summary:
328:                     Opens the specified USB Driver instance and returns a handle to it.
329:                    
330:                   Description:
331:                     This function opens the specified USB Driver instance and provides a handle
332:                     that must be provided to all other client-level operations to identify the
333:                     caller and the instance of the driver. The intent flag is ignored.  Any
334:                     other setting of the intent flag will return a invalid driver handle. A
335:                     driver instance can only support one client. Trying to open a driver that
336:                     has an existing client will result in an unsuccessful function call.
337:                 
338:                   Remarks:
339:                     See drv_usbfs.h for usage information.
340:                 */
341:                 
342:                 DRV_HANDLE DRV_USBFS_Open
343:                 (
344:                     const SYS_MODULE_INDEX drvIndex,
345:                     const DRV_IO_INTENT ioIntent 
346:                 )
347:                 {
348:                     DRV_HANDLE handle = DRV_HANDLE_INVALID;
349:                 
350:                     /* Check if the specified driver index is in valid range */
351:                     if(drvIndex < DRV_USBFS_INSTANCES_NUMBER)
9D0094F8  1480000E   BNE A0, ZERO, 0x9D009534
9D0094FC  2402FFFF   ADDIU V0, ZERO, -1
352:                     {
353:                         if(gDrvUSBGroup[drvIndex].gDrvUSBObj.status == SYS_STATUS_READY)
9D009500  3C02A000   LUI V0, -24576
9D009504  8C440214   LW A0, 532(V0)
9D009508  24030002   ADDIU V1, ZERO, 2
9D00950C  14830009   BNE A0, V1, 0x9D009534
9D009510  2402FFFF   ADDIU V0, ZERO, -1
354:                         {
355:                             if(gDrvUSBGroup[drvIndex].gDrvUSBObj.isOpened == false)
9D009514  3C02A000   LUI V0, -24576
9D009518  90430205   LBU V1, 517(V0)
9D00951C  14600005   BNE V1, ZERO, 0x9D009534
9D009520  2402FFFF   ADDIU V0, ZERO, -1
356:                             {
357:                                 gDrvUSBGroup[drvIndex].gDrvUSBObj.isOpened = true;
9D009524  3C02A000   LUI V0, -24576
9D009528  24420200   ADDIU V0, V0, 512
9D00952C  24030001   ADDIU V1, ZERO, 1
9D009530  A0430005   SB V1, 5(V0)
358:                                 
359:                                 /* Handle is the pointer to the client object */
360:                                 handle = ((DRV_HANDLE)&(gDrvUSBGroup[drvIndex].gDrvUSBObj));
361:                             }
362:                             else
363:                             {
364:                                 /* Driver supports exclusive open only */
365:                                 SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Driver already opened once. Cannot open again");
366:                             }
367:                         }
368:                         else
369:                         {
370:                             /* The USB module should be ready */
371:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Was the driver initialized?");
372:                         }
373:                     }
374:                     else
375:                     {
376:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Driver Index");
377:                     }
378:                 
379:                     /* Return invalid handle */
380:                     return handle;
381:                 }
9D009534  03E00008   JR RA
382:                 
383:                 // *****************************************************************************
384:                 /* Function:
385:                     void DRV_USBFS_Close( DRV_HANDLE client )
386:                 
387:                   Summary:
388:                     Closes an opened-instance of the  USB Driver.
389:                 
390:                   Description:
391:                     This function closes an opened-instance of the  USB Driver, invalidating the
392:                     handle.
393:                 
394:                   Remarks:
395:                     See drv_usbfs.h for usage information.
396:                 */
397:                 
398:                 void DRV_USBFS_Close
399:                 (
400:                     DRV_HANDLE handle
401:                 )
402:                 {
403:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)NULL;
404:                 
405:                     /* Check if the handle is valid */
406:                     if((handle != DRV_HANDLE_INVALID) && (handle != (DRV_HANDLE)(NULL)))
9D009808  2482FFFF   ADDIU V0, A0, -1
9D00980C  2C42FFFE   SLTIU V0, V0, -2
9D009810  10400006   BEQ V0, ZERO, 0x9D00982C
9D009814  00000000   NOP
407:                     {
408:                         /* Reset the relevant parameters */
409:                         pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
410:                         if(pUSBDrvObj->isOpened)
9D009818  90820005   LBU V0, 5(A0)
9D00981C  10400003   BEQ V0, ZERO, 0x9D00982C
9D009820  00000000   NOP
411:                         {
412:                             pUSBDrvObj->isOpened = false;
9D009824  A0800005   SB ZERO, 5(A0)
413:                             pUSBDrvObj->pEventCallBack = NULL;
9D009828  AC800010   SW ZERO, 16(A0)
414:                         }
415:                         else
416:                         {
417:                             SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Client Handle already closed");
418:                         }
419:                     }
420:                     else
421:                     {
422:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client Handle");
423:                     }
424:                 }
425:                 
426:                 // *****************************************************************************
427:                 /* Function:
428:                     DRV_HANDLE DRV_USBFS_Tasks_ISR( SYS_MODULE_OBJ object )
429:                 
430:                   Summary:
431:                     Maintains the driver's Interrupt state machine and implements its ISR.
432:                 
433:                   Description:
434:                     This function is used to maintain the driver's internal Interrupt state
435:                     machine and implement its ISR for interrupt-driven implementations.
436:                 
437:                   Remarks:
438:                     See drv_usbfs.h for usage information.
439:                 */
440:                 
441:                 void DRV_USBFS_Tasks_ISR
442:                 (
443:                     SYS_MODULE_OBJ object
444:                 )
445:                 {
9D0085E0  27BDFFE8   ADDIU SP, SP, -24
9D0085E4  AFBF0014   SW RA, 20(SP)
9D0085E8  AFB00010   SW S0, 16(SP)
446:                     DRV_USBFS_OBJ * pUSBDriver = (DRV_USBFS_OBJ *)NULL;
447:                 
448:                     pUSBDriver = &gDrvUSBGroup[object].gDrvUSBObj;
9D0085EC  00048080   SLL S0, A0, 2
9D0085F0  00041180   SLL V0, A0, 6
9D0085F4  02028021   ADDU S0, S0, V0
9D0085F8  02042021   ADDU A0, S0, A0
9D0085FC  00042080   SLL A0, A0, 2
9D008600  3C10A000   LUI S0, -24576
9D008604  26100200   ADDIU S0, S0, 512
9D008608  02048021   ADDU S0, S0, A0
449:                 
450:                     /* We are entering an interrupt context */
451:                     pUSBDriver->inInterruptContext = true;
9D00860C  24020001   ADDIU V0, ZERO, 1
9D008610  A2020001   SB V0, 1(S0)
452:                 
453:                     /* Clear the interrupt */
454:                     _DRV_USBFS_InterruptSourceClear(pUSBDriver->interruptSource);
9D008614  8E020028   LW V0, 40(S0)
455:                    
456:                     switch(pUSBDriver->operationMode)
9D008638  8E030024   LW V1, 36(S0)
9D00863C  24020002   ADDIU V0, ZERO, 2
9D008640  54620004   BNEL V1, V0, 0x9D008654
9D008644  A2000001   SB ZERO, 1(S0)
457:                     {
458:                         case DRV_USBFS_OPMODE_DEVICE:
459:                             
460:                             /* Driver is running in Device Mode */
461:                             _DRV_USBFS_DEVICE_TASKS_ISR(pUSBDriver);
462:                             break;
463:                         
464:                         case DRV_USBFS_OPMODE_HOST:
465:                 
466:                             /* Driver is running in Host Mode */
467:                             _DRV_USBFS_HOST_TASKS_ISR(pUSBDriver);
9D008648  0F4006BB   JAL _DRV_USBFS_HOST_Tasks_ISR
9D00864C  02002021   ADDU A0, S0, ZERO
468:                             break;
469:                 
470:                         case DRV_USBFS_OPMODE_OTG:
471:                             /* OTG mode is not supported yet */
472:                             break;
473:                 
474:                         default:
475:                             SYS_DEBUG_MESSAGE(SYS_ERROR_INFO, "\r\nUSBFS Driver: What mode are you trying?");
476:                             break;
477:                     }
478:                   
479:                     pUSBDriver->inInterruptContext = false;
9D008650  A2000001   SB ZERO, 1(S0)
480:                 }
9D008654  8FBF0014   LW RA, 20(SP)
481:                 
482:                 // *****************************************************************************
483:                 /* Function:
484:                     void DRV_USBFS_ClientEventCallBackSet
485:                     (
486:                         DRV_HANDLE handle,
487:                         uintptr_t hReferenceData,
488:                         DRV_USBFS_EVENT_CALLBACK eventCallBack
489:                     )
490:                 
491:                   Summary:
492:                     This function sets up the event callback function that is invoked by the USB
493:                     controller driver to notify the client of USB bus events.
494:                    
495:                   Description:
496:                     This function sets up the event callback function that is invoked by the USB
497:                     controller driver to notify the client of USB bus events. The callback is
498:                     disabled by either not calling this function after the DRV_USBFS_Open
499:                     function has been called or by setting the myEventCallBack argument as NULL.
500:                     When the callback function is called, the hReferenceData argument is
501:                     returned.
502:                 
503:                   Remarks:
504:                     See drv_usbfs.h for usage information.
505:                 */
506:                 
507:                 void DRV_USBFS_ClientEventCallBackSet
508:                 ( 
509:                     DRV_HANDLE handle,
510:                     uintptr_t hReferenceData,
511:                     DRV_USB_EVENT_CALLBACK eventCallBack 
512:                 )
513:                 {
514:                     DRV_USBFS_OBJ * pUSBDrvObj = (DRV_USBFS_OBJ *)handle;
515:                     
516:                     /* Check if the handle is valid or opened */
517:                     if((handle != DRV_HANDLE_INVALID) && (handle != (DRV_HANDLE)(NULL)) && (pUSBDrvObj->isOpened == true))
9D008C08  2482FFFF   ADDIU V0, A0, -1
9D008C0C  2C42FFFE   SLTIU V0, V0, -2
9D008C10  10400016   BEQ V0, ZERO, 0x9D008C6C
9D008C14  00000000   NOP
9D008C18  90820005   LBU V0, 5(A0)
9D008C1C  10400013   BEQ V0, ZERO, 0x9D008C6C
9D008C20  24020001   ADDIU V0, ZERO, 1
518:                     {
519:                         /* Assign event call back and reference data */
520:                         pUSBDrvObj->hClientArg = hReferenceData;
9D008C24  AC85000C   SW A1, 12(A0)
521:                         pUSBDrvObj->pEventCallBack = eventCallBack;
9D008C28  AC860010   SW A2, 16(A0)
522:                 
523:                         /* If the driver is operating in device mode, this is the time we enable
524:                          * the USB interrupt */
525:                 
526:                         if(pUSBDrvObj->operationMode == USB_OPMODE_DEVICE)
9D008C2C  8C830024   LW V1, 36(A0)
9D008C30  1462000E   BNE V1, V0, 0x9D008C6C
9D008C34  00000000   NOP
527:                         {
528:                             /* Enable the session valid interrupt */
529:                             PLIB_USB_OTG_InterruptEnable(pUSBDrvObj->usbID, USB_OTG_INT_SESSION_VALID);
530:                             
531:                             /* Enable the interrupt */
532:                             _DRV_USBFS_InterruptSourceEnable(pUSBDrvObj->interruptSource);
9D008C48  8C820028   LW V0, 40(A0)
533:                         }
534:                     }
535:                     else
536:                     {
537:                         SYS_DEBUG(SYS_ERROR_INFO, "\r\nUSBFS Driver: Bad Client or client closed");
538:                     }
539:                 } 
540:                 
541:                 // *****************************************************************************
542:                 /* Function:
543:                     void DRV_USBFS_Tasks( SYS_MODULE_OBJ object )
544:                 
545:                   Summary:
546:                     Maintains the driver's state machine when the driver is configured for 
547:                     polled mode.
548:                 
549:                   Description:
550:                     Maintains the driver's state machine when the driver is configured for 
551:                     polled mode. This function should be called from the system tasks routine.
552:                 
553:                   Remarks:
554:                     Refer to drv_usbfs.h for usage information.
555:                 */
556:                 
557:                 void DRV_USBFS_Tasks(SYS_MODULE_OBJ object)
558:                 {
9D009B04  03E00008   JR RA
559:                     /* This driver does not have any non interrupt tasks. When the driver
560:                      * is configured for polled mode operation, the _DRV_USBFS_Tasks_ISR function
561:                      * will map to DRV_USBFS_Tasks_ISR function. In interrupt mode, this function
562:                      * will be mapped to nothing and hence this function will not have any
563:                      * effect. */
564:                 
565:                     _DRV_USBFS_Tasks_ISR(object);
566:                 }
567:                 
568:                 void DRV_USBFS_Tasks_ISR_USBDMA( SYS_MODULE_OBJ object )
569:                 {
570:                     /* This function is implemented to only maintain compatibility with the
571:                      * PIC32MZ High Speed USB Driver. This function does not do anything on the
572:                      * PIC32MX USB driver and is not required to be called in a PIC32MX USB
573:                      * applicaiton */
574:                 }
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/system_config/default/framework/driver/tmr/src/dynamic/drv_tmr.c
1:                   /*******************************************************************************
2:                     Timer Device Driver dynamic implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_tmr.c
9:                   
10:                    Summary:
11:                      Timer device driver dynamic implementation.
12:                  
13:                    Description:
14:                      The Timer device driver provides a simple interface to manage the Timer 
15:                      modules on Microchip micro controllers.  This file implements the core 
16:                      interface routines for the Timer driver in dynamic mode. 
17:                      
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Include Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include <stddef.h>
53:                  #include <string.h>
54:                  #include "driver/tmr/src/drv_tmr_local.h"
55:                  #include "system/clk/sys_clk.h"
56:                  
57:                  // *****************************************************************************
58:                  // *****************************************************************************
59:                  // Section: File Scope Variables
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  
63:                  // each driver module can support multiple clients
64:                  //
65:                  typedef struct
66:                  {
67:                      DRV_TMR_MODULE_INSTANCE         tmrInstance;     // the current timer module
68:                      DRV_TMR_CLIENT_OBJ              tmrClients[1];   // Timer driver supports only Single Client. If you have multiple clients looking for timer, then use Timer System Service.
69:                  }DRV_TMR_MODULE_DESCRIPTOR;
70:                  
71:                  
72:                  static DRV_TMR_MODULE_DESCRIPTOR    gDrvTmrDcpt[DRV_TMR_INSTANCES_NUMBER];       // the supported timer modules
73:                  static unsigned int                 gDrvTmrInstances = 0;                        // current number of initialized instances 
74:                  
75:                  static const DRV_TMR_INIT defaultTmrInit = 
76:                  {
77:                      {SYS_MODULE_POWER_RUN_FULL},
78:                      TMR_ID_2,
79:                      DRV_TMR_CLKSOURCE_INTERNAL,
80:                      TMR_PRESCALE_VALUE_256,
81:                      INT_SOURCE_TIMER_2,
82:                      DRV_TMR_OPERATION_MODE_16_BIT,
83:                      false,
84:                  };
85:                  
86:                  
87:                  // *****************************************************************************
88:                  // *****************************************************************************
89:                  // Section: File Scope Functions
90:                  // *****************************************************************************
91:                  // *****************************************************************************
92:                  
93:                  static void DRV_TMR_ProcessEvents ( DRV_TMR_MODULE_DESCRIPTOR* pDcpt );
94:                  
95:                  
96:                  // sets a clean status
97:                  static void _DRV_TMR_ClientClear(DRV_TMR_CLIENT_OBJ* pObj)
98:                  {
99:                      pObj->alarmCallback = 0 ;
9D007910  AE000034   SW ZERO, 52(S0)
100:                     pObj->alarmPeriodic = false;
9D007914  A2000028   SB ZERO, 40(S0)
101:                     pObj->pModInst->timerPeriod = 0;
9D007918  8E020024   LW V0, 36(S0)
102:                     pObj->alarmCount = 0;
9D007920  AE000030   SW ZERO, 48(S0)
103:                 
104:                     pObj->clientStatus = DRV_TMR_CLIENT_OBJ_READY;
9D007924  24020001   ADDIU V0, ZERO, 1
105:                 }
106:                 
107:                 // sets a client parameters
108:                 static void _DRV_TMR_ClientSetParams(
109:                         DRV_TMR_CLIENT_OBJ* pObj, 
110:                         uint32_t period, 
111:                         bool isPeriodic,                        
112:                         uintptr_t context, 
113:                         DRV_TMR_CALLBACK callBack
114:                 )
115:                 {
116:                     pObj->alarmCallback = callBack ;
9D006348  8FA40038   LW A0, 56(SP)
117:                     pObj->alarmPeriodic = isPeriodic;
9D006350  A2140004   SB S4, 4(S0)
118:                     pObj->context = context;
9D006354  AE130014   SW S3, 20(S0)
119:                     pObj->pModInst->timerPeriod = period;
9D006358  8E040000   LW A0, 0(S0)
120:                     pObj->alarmCount = 0;
121:                 }
122:                 
123:                 
124:                 static bool _DRV_TMR_Suspend(DRV_TMR_CLIENT_OBJ* pObj)
125:                 {
9D009258  27BDFFE8   ADDIU SP, SP, -24
9D00925C  AFBF0014   SW RA, 20(SP)
9D009260  AFB00010   SW S0, 16(SP)
9D009264  00808021   ADDU S0, A0, ZERO
126:                     if(pObj->clientStatus == DRV_TMR_CLIENT_OBJ_RUNNING)
9D009268  8C840008   LW A0, 8(A0)
9D00926C  24030003   ADDIU V1, ZERO, 3
9D009270  14830009   BNE A0, V1, 0x9D009298
9D009274  00001021   ADDU V0, ZERO, ZERO
127:                     {
128:                         SYS_INT_SourceDisable( pObj->pModInst->interruptSource );
9D009278  8E020000   LW V0, 0(S0)
9D00927C  0F402481   JAL SYS_INT_SourceDisable
9D009280  8C440014   LW A0, 20(V0)
129:                         PLIB_TMR_Stop ( pObj->pModInst->tmrId );
9D009284  8E020000   LW V0, 0(S0)
130:                         return true;
9D009294  24020001   ADDIU V0, ZERO, 1
131:                     }
132:                 
133:                     return false;
134:                 }
9D009298  8FBF0014   LW RA, 20(SP)
135:                 
136:                 static void _DRV_TMR_Resume(DRV_TMR_CLIENT_OBJ* pObj, bool resume)
137:                 {
138:                     if(resume)
9D008CE0  10A00017   BEQ A1, ZERO, 0x9D008D40
9D008CE4  3C05BF88   LUI A1, -16504
139:                     {
140:                         SYS_INT_SourceStatusClear ( pObj->pModInst->interruptSource );
9D008CE8  8C820000   LW V0, 0(A0)
9D008CEC  8C420014   LW V0, 20(V0)
141:                         SYS_INT_SourceEnable( pObj->pModInst->interruptSource );
9D008D0C  8C820000   LW V0, 0(A0)
9D008D10  8C420014   LW V0, 20(V0)
142:                 
143:                         /* Start the Timer */
144:                         PLIB_TMR_Start ( pObj->pModInst->tmrId );
9D008D30  8C820000   LW V0, 0(A0)
145:                     }
146:                 }
147:                 
148:                 // releases a client
149:                 static __inline__ void __attribute__((always_inline)) _DRV_TMR_ClientDelete(DRV_TMR_CLIENT_OBJ* pObj, bool suspend)
150:                 {
151:                     if(suspend)
152:                     {
153:                         _DRV_TMR_Suspend(pObj);
9D0093BC  0F402496   JAL _DRV_TMR_Suspend
9D0093C0  00000000   NOP
154:                     }
155:                     // add other delete code here
156:                     pObj->clientStatus = DRV_TMR_CLIENT_OBJ_CLOSED;
9D0093C4  AE000008   SW ZERO, 8(S0)
157:                 }
158:                 
159:                 static bool _DRV_TMR_ClockSourceSet(TMR_MODULE_ID timerId, DRV_TMR_CLK_SOURCES clockSource)
160:                 {
9D006A88  27BDFFE8   ADDIU SP, SP, -24
161:                     bool clockSet = true;
9D006AA0  0B401ADC   J 0x9D006B70
9D006AA4  24020001   ADDIU V0, ZERO, 1
9D006B0C  0B401ADC   J 0x9D006B70
9D006B10  24020001   ADDIU V0, ZERO, 1
9D006B5C  0B401ADC   J 0x9D006B70
9D006B60  24020001   ADDIU V0, ZERO, 1
9D006B6C  24020001   ADDIU V0, ZERO, 1
162:                     /* Clock Source Selection */
163:                     if(clockSource == DRV_TMR_CLKSOURCE_INTERNAL)
9D006A8C  14A00006   BNE A1, ZERO, 0x9D006AA8
9D006A90  AFBF0014   SW RA, 20(SP)
164:                     {
165:                         if ( PLIB_TMR_ExistsClockSource ( timerId ) )
166:                         {               
167:                             PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );           
168:                         }
169:                         else
170:                         {
171:                             /* If clock source feature doesn't exist for any specific timer module instance,
172:                             then by default internal peripheral clock is considered as timer source, so do nothing */ 
173:                         }
174:                     }
175:                     /* External Synchronous Clock Source Selection */
176:                     else if(!(clockSource & 0x10))
9D006AA8  30A20010   ANDI V0, A1, 16
9D006AAC  14400019   BNE V0, ZERO, 0x9D006B14
9D006AB0  3C03BF80   LUI V1, -16512
177:                     {
178:                         if ( PLIB_TMR_ExistsClockSource ( timerId ) )
179:                         {               
180:                             if ( PLIB_TMR_ExistsClockSourceSync ( timerId )  )
9D006AB4  3C02BF80   LUI V0, -16512
9D006AB8  24420600   ADDIU V0, V0, 1536
9D006ABC  1482000E   BNE A0, V0, 0x9D006AF8
9D006AC0  24030001   ADDIU V1, ZERO, 1
181:                             {
182:                                 _DRV_TMR_CLOCK_SOURCE_SELECT ( timerId, clockSource );               
9D006AD8  30A5000F   ANDI A1, A1, 15
9D006ADC  24020002   ADDIU V0, ZERO, 2
9D006AE0  54A2001C   BNEL A1, V0, _DRV_TMR_ClockSourceSet::PLIB_TMR_ClockSourceExternalSyncEnable
9D006AE4  24030004   ADDIU V1, ZERO, 4
9D006AE8  0F4024F6   JAL SYS_CLK_SecondaryOscillatorEnable
9D006AEC  00000000   NOP
183:                                 PLIB_TMR_ClockSourceExternalSyncEnable ( timerId );                    
184:                             }
185:                             /* If Synchronization feature doesn't exist for any specific timer module 
186:                             instance with external clock source then it is synchronous by default */
187:                             else if (clockSource == DRV_TMR_CLKSOURCE_EXTERNAL_SYNCHRONOUS)
9D006AF8  14A3001D   BNE A1, V1, 0x9D006B70
9D006AFC  00001021   ADDU V0, ZERO, ZERO
188:                             {
189:                                 PLIB_TMR_ClockSourceSelect ( timerId, TMR_CLOCK_SOURCE_EXTERNAL_INPUT_PIN );
190:                             }
191:                             else
192:                             {
193:                                 clockSet = false;
194:                             }  
195:                         }
196:                         else
197:                         {
198:                             clockSet = false;
199:                         }        
200:                     }
201:                     /* External Asynchronous Clock Source Selection */
202:                     else if(clockSource & 0x10)
203:                     {
204:                         if ( PLIB_TMR_ExistsClockSourceSync ( timerId ) )
9D006B14  24630600   ADDIU V1, V1, 1536
9D006B18  14830015   BNE A0, V1, 0x9D006B70
9D006B1C  00001021   ADDU V0, ZERO, ZERO
205:                         {
206:                             _DRV_TMR_CLOCK_SOURCE_SELECT ( timerId, clockSource );               
9D006B34  30A5000F   ANDI A1, A1, 15
9D006B38  24020002   ADDIU V0, ZERO, 2
9D006B3C  54A20009   BNEL A1, V0, _DRV_TMR_ClockSourceSet::PLIB_TMR_ClockSourceExternalSyncDisable
9D006B40  24030004   ADDIU V1, ZERO, 4
9D006B44  0F4024F6   JAL SYS_CLK_SecondaryOscillatorEnable
9D006B48  00000000   NOP
207:                             PLIB_TMR_ClockSourceExternalSyncDisable ( timerId );
208:                         }
209:                         else
210:                         {
211:                             clockSet = false;
212:                         }        
213:                     }
214:                     
215:                     return clockSet;
216:                 }
9D006B70  8FBF0014   LW RA, 20(SP)
217:                 
218:                 // Prescaler selection
219:                 static bool _DRV_TMR_ClockPrescaleSet(TMR_MODULE_ID timerId, TMR_PRESCALE  prescale)
220:                 {
221:                     if( PLIB_TMR_ExistsPrescale( timerId ) )
222:                     {
223:                         PLIB_TMR_PrescaleSelect( timerId , prescale );
224:                         return true;
225:                     }
226:                     return false;
227:                 }
9D0077DC  03E00008   JR RA
9D0077E0  24020001   ADDIU V0, ZERO, 1
9D0077F8  03E00008   JR RA
9D0077FC  24020001   ADDIU V0, ZERO, 1
9D00780C  03E00008   JR RA
9D007810  24020001   ADDIU V0, ZERO, 1
9D007824  03E00008   JR RA
9D007828  24020001   ADDIU V0, ZERO, 1
9D00783C  03E00008   JR RA
9D007840  24020001   ADDIU V0, ZERO, 1
9D007854  03E00008   JR RA
9D007858  24020001   ADDIU V0, ZERO, 1
9D007868  24020001   ADDIU V0, ZERO, 1
228:                 
229:                 // Timer operation mode
230:                 static bool _DRV_TMR_OperModeSet(TMR_MODULE_ID timerId, DRV_TMR_OPERATION_MODE  operMode, bool update)
231:                 {
232:                 
233:                     if(operMode == DRV_TMR_OPERATION_MODE_16_BIT)
9D004A70  24030001   ADDIU V1, ZERO, 1
9D004A74  54430008   BNEL V0, V1, DRV_TMR_Initialize::_DRV_TMR_InstanceSetup
9D004A78  24030002   ADDIU V1, ZERO, 2
234:                     {
235:                 #if defined(PLIB_TMR_ExistsMode16Bit)
236:                         if ( PLIB_TMR_ExistsMode16Bit ( timerId ) )
237:                         {
238:                             if(update)
239:                             {
240:                                 PLIB_TMR_Mode16BitEnable( timerId );
241:                             }
242:                         }
243:                 #endif
244:                         // assume that 16 bit mode is always supported!
245:                         return true;
246:                     }
247:                     else if(operMode == DRV_TMR_OPERATION_MODE_32_BIT)
9D004A98  14430018   BNE V0, V1, 0x9D004AFC
9D004A9C  3C02A000   LUI V0, -24576
248:                     {
249:                 #if defined(PLIB_TMR_ExistsMode32Bit)
250:                         if ( PLIB_TMR_ExistsMode32Bit ( timerId ) )
9D004AA4  54400015   BNEL V0, ZERO, 0x9D004AFC
9D004AA8  3C02A000   LUI V0, -24576
251:                         {
252:                             if(update)
253:                             {
254:                                 PLIB_TMR_Mode32BitEnable ( timerId );
255:                             }
256:                             return true;
257:                         }
258:                 #endif
259:                     }
260:                 
261:                     // unsupported mode
262:                     return false;
263:                 }
264:                 
265:                 static bool _DRV_TMR_InstanceSetup ( DRV_TMR_MODULE_INSTANCE *pTmrInst)
266:                 {    
267:                     TMR_MODULE_ID timerId = pTmrInst->tmrId;
268:                 
269:                     /* 1. Clock Source Selection and prescaler */
270:                     if(!_DRV_TMR_ClockSourceSet(timerId, pTmrInst->clockSource))
9D004A40  0F401AA2   JAL _DRV_TMR_ClockSourceSet
9D004A44  02002021   ADDU A0, S0, ZERO
9D004A48  1040002C   BEQ V0, ZERO, 0x9D004AFC
9D004A4C  3C02A000   LUI V0, -24576
271:                     {
272:                         return false;
273:                     }
274:                 
275:                     /* 2. Prescaler */
276:                     if(!_DRV_TMR_ClockPrescaleSet(timerId, pTmrInst->prescale))
9D004A50  02002021   ADDU A0, S0, ZERO
9D004A54  3C02A000   LUI V0, -24576
9D004A58  0F401DEB   JAL _DRV_TMR_ClockPrescaleSet
9D004A5C  8C4567A8   LW A1, 26536(V0)
9D004A60  10400026   BEQ V0, ZERO, 0x9D004AFC
9D004A64  3C02A000   LUI V0, -24576
277:                     {
278:                         return false;
279:                     }
280:                 
281:                     /* 3. Timer operation mode */
282:                     if(!_DRV_TMR_OperModeSet(timerId, pTmrInst->operMode, true))
9D004A68  3C02A000   LUI V0, -24576
9D004A6C  8C4267BC   LW V0, 26556(V0)
283:                     {
284:                         return false;
285:                     }
286:                 
287:                     /* 4. Asynchronous Write Control */
288:                 #if defined(PLIB_TMR_ExistsCounterAsyncWriteControl)
289:                     if( PLIB_TMR_ExistsCounterAsyncWriteControl ( timerId ) )
9D004A90  0B4012BA   J DRV_TMR_Initialize::_DRV_TMR_InstanceSetup
9D004A94  3C02BF80   LUI V0, -16512
9D004AB4  0B4012BA   J DRV_TMR_Initialize::_DRV_TMR_InstanceSetup
9D004AB8  3C02BF80   LUI V0, -16512
9D004AE8  24420600   ADDIU V0, V0, 1536
9D004AEC  1202FFF3   BEQ S0, V0, DRV_TMR_Initialize::_DRV_TMR_InstanceSetup
9D004AF0  3C02A000   LUI V0, -24576
290:                     {
291:                         if( pTmrInst->asyncWriteEnable)
9D004ABC  904267C0   LBU V0, 26560(V0)
9D004AC0  10400005   BEQ V0, ZERO, DRV_TMR_Initialize::_DRV_TMR_InstanceSetup
9D004AC4  24031000   ADDIU V1, ZERO, 4096
292:                         {
293:                             PLIB_TMR_CounterAsyncWriteEnable ( timerId );
294:                         }
295:                         else 
296:                         {
297:                             PLIB_TMR_CounterAsyncWriteDisable ( timerId );
298:                         }
299:                     }
300:                 #endif
301:                 
302:                 
303:                     /* Successfully initialized */
304:                     return true;
305:                 
306:                 }
307:                 
308:                 static bool _DRV_TMR_RootInitialize(void)
309:                 {
310:                     memset(&gDrvTmrDcpt, 0, sizeof(gDrvTmrDcpt));
9D0049BC  3C04A000   LUI A0, -24576
311:                 
312:                     return true;
313:                 }
314:                 
315:                 static /*__inline__*/ DRV_TMR_MODULE_DESCRIPTOR* /*__attribute__((always_inline))*/ _DRV_TMR_ModuleObj(SYS_MODULE_OBJ object, bool checkReady)
316:                 {
317:                     if(gDrvTmrInstances != 0)
9D00855C  8F828034   LW V0, -32716(GP)
9D008560  10400019   BEQ V0, ZERO, 0x9D0085C8
9D008564  00000000   NOP
318:                     {   // module initialized
319:                         DRV_TMR_MODULE_DESCRIPTOR* pDcpt = (DRV_TMR_MODULE_DESCRIPTOR*)object;
320:                 
321:                         /* check the validity of the handle */
322:                         if(pDcpt - gDrvTmrDcpt  <= sizeof(gDrvTmrDcpt)/sizeof(*gDrvTmrDcpt))
9D008568  3C02A000   LUI V0, -24576
9D00856C  244267A0   ADDIU V0, V0, 26528
9D008570  00821023   SUBU V0, A0, V0
9D008574  00021083   SRA V0, V0, 2
9D008578  00021900   SLL V1, V0, 4
9D00857C  00621021   ADDU V0, V1, V0
9D008580  00021A00   SLL V1, V0, 8
9D008584  00431021   ADDU V0, V0, V1
9D008588  00021C00   SLL V1, V0, 16
9D00858C  00431021   ADDU V0, V0, V1
9D008590  00021023   SUBU V0, ZERO, V0
9D008594  2C420002   SLTIU V0, V0, 2
9D008598  1040000D   BEQ V0, ZERO, 0x9D0085D0
9D00859C  00000000   NOP
323:                         {
324:                             if(pDcpt->tmrInstance.inUse != false)
9D0085A0  90820018   LBU V0, 24(A0)
9D0085A4  5040000C   BEQL V0, ZERO, 0x9D0085D8
9D0085A8  00001021   ADDU V0, ZERO, ZERO
325:                             {
326:                                 if(checkReady == false || pDcpt->tmrInstance.status == SYS_STATUS_READY)
9D0085AC  10A0000A   BEQ A1, ZERO, 0x9D0085D8
9D0085B0  00801021   ADDU V0, A0, ZERO
9D0085B4  8C820000   LW V0, 0(A0)
327:                                 {   // success
328:                                     return pDcpt;
329:                                 }
330:                             }
331:                         }
332:                     }
333:                 
334:                     return 0;
9D0085B8  38420002   XORI V0, V0, 2
9D0085BC  0002200B   MOVN A0, ZERO, V0
9D0085C0  03E00008   JR RA
9D0085C4  00801021   ADDU V0, A0, ZERO
9D0085C8  03E00008   JR RA
9D0085CC  00001021   ADDU V0, ZERO, ZERO
9D0085D0  03E00008   JR RA
9D0085D4  00001021   ADDU V0, ZERO, ZERO
335:                 }
9D0085D8  03E00008   JR RA
336:                 
337:                 static void DRV_TMR_ProcessEvents ( DRV_TMR_MODULE_DESCRIPTOR* pDcpt )
338:                 {
339:                     DRV_TMR_MODULE_INSTANCE* pTmrInst = &pDcpt->tmrInstance;
340:                 
341:                     /* Check if the Timer Interrupt/Status is set */
342:                     if ( SYS_INT_SourceStatusGet ( pTmrInst->interruptSource ) != false )
9D007890  8C420014   LW V0, 20(V0)
9D0078B8  1080001D   BEQ A0, ZERO, 0x9D007930
343:                     {
344:                         /* Clear Timer Interrupt/Status Flag */
345:                         SYS_INT_SourceStatusClear ( pTmrInst->interruptSource );
346:                 
347:                         // process clients
348:                         int ix;
349:                         DRV_TMR_CLIENT_OBJ* pClient = pDcpt->tmrClients;
350:                         for(ix = 0; ix < sizeof(pDcpt->tmrClients) / sizeof(*pDcpt->tmrClients); ix++, pClient++)
351:                         {
352:                             if(pClient->clientStatus == DRV_TMR_CLIENT_OBJ_RUNNING)
9D0078CC  8E03002C   LW V1, 44(S0)
353:                             {
354:                                 /* increment the alarm */
355:                                 pClient->alarmCount++;
9D0078DC  8E050030   LW A1, 48(S0)
356:                 
357:                                 /* callback the application routine */
358:                                 if( pClient->alarmCallback != NULL )
9D0078E8  8E020034   LW V0, 52(S0)
359:                                 {
360:                                     (*pClient->alarmCallback)( pClient->context, pClient->alarmCount);
9D0078F4  0040F809   JALR V0
361:                                 }
362:                 
363:                                 /* Alarm in one shot mode */
364:                                 if ( pClient->alarmPeriodic != true )
9D0078FC  92020028   LBU V0, 40(S0)
365:                                 {
366:                                     _DRV_TMR_Suspend(pClient);     // Stop Timer
9D007908  0F402496   JAL _DRV_TMR_Suspend
367:                                     _DRV_TMR_ClientClear(pClient); // Clear timer client
368:                                 }
369:                             }
370:                         }
371:                 
372:                     }
373:                 } 
374:                 
375:                 static __inline__ DRV_TMR_CLIENT_OBJ* __attribute__((always_inline)) _DRV_TMR_ClientObj(DRV_HANDLE handle)
376:                 {
377:                     /* check the validity of the handle */
378:                     if(handle != DRV_HANDLE_INVALID)
9D0062E4  2402FFFF   ADDIU V0, ZERO, -1
9D0062E8  10820039   BEQ A0, V0, 0x9D0063D0
9D0062EC  00808021   ADDU S0, A0, ZERO
9D0073A4  2402FFFF   ADDIU V0, ZERO, -1
9D0073A8  1082002C   BEQ A0, V0, 0x9D00745C
9D0073AC  00808021   ADDU S0, A0, ZERO
9D008DBC  2402FFFF   ADDIU V0, ZERO, -1
9D008DC0  1082000F   BEQ A0, V0, 0x9D008E00
9D008DC4  00808021   ADDU S0, A0, ZERO
9D008F98  2402FFFF   ADDIU V0, ZERO, -1
9D008F9C  10820013   BEQ A0, V0, 0x9D008FEC
9D008FA0  00000000   NOP
9D00939C  2402FFFF   ADDIU V0, ZERO, -1
9D0093A0  10820009   BEQ A0, V0, 0x9D0093C8
9D0093A4  00808021   ADDU S0, A0, ZERO
379:                     {
380:                         DRV_TMR_CLIENT_OBJ* pObj = (DRV_TMR_CLIENT_OBJ*)handle;
381:                         if(pObj->clientStatus > 0)
9D0062F0  8C820008   LW V0, 8(A0)
9D0062F4  18400037   BLEZ V0, 0x9D0063D4
9D0062F8  00001021   ADDU V0, ZERO, ZERO
9D0073B0  8C820008   LW V0, 8(A0)
9D0073B4  1840002A   BLEZ V0, 0x9D007460
9D0073B8  00001021   ADDU V0, ZERO, ZERO
9D008DC8  8E030008   LW V1, 8(S0)
9D008DCC  1860000D   BLEZ V1, 0x9D008E04
9D008DD0  00001021   ADDU V0, ZERO, ZERO
9D008FA4  8C820008   LW V0, 8(A0)
9D008FA8  18400010   BLEZ V0, 0x9D008FEC
9D008FAC  00000000   NOP
9D0093A8  8C820008   LW V0, 8(A0)
9D0093AC  18400007   BLEZ V0, 0x9D0093CC
9D0093B0  8FBF0014   LW RA, 20(SP)
382:                         {
383:                             return pObj;
384:                         }
385:                     }
386:                 
387:                     return 0;
388:                 }
389:                 
390:                 // *****************************************************************************
391:                 // *****************************************************************************
392:                 // Section: Driver System Interface Function Definitions
393:                 // *****************************************************************************
394:                 // *****************************************************************************
395:                 
396:                 // *****************************************************************************
397:                 /* Function:
398:                     SYS_MODULE_OBJ DRV_TMR_Initialize 
399:                     ( 
400:                         const SYS_MODULE_INDEX drvIndex,
401:                         const SYS_MODULE_INIT * const init 
402:                     )
403:                 
404:                   Summary:
405:                     Initializes the Timer driver.
406:                 
407:                   Description:
408:                     This function initializes the Timer driver, making it ready for clients to
409:                     open and use it.
410:                 
411:                   Remarks:
412:                     Refer to drv_tmr.h for usage information.
413:                 */
414:                 
415:                 SYS_MODULE_OBJ DRV_TMR_Initialize 
416:                 ( 
417:                     const SYS_MODULE_INDEX drvIndex,
418:                     const SYS_MODULE_INIT  * const init 
419:                 )
420:                 {
9D00499C  27BDFFE0   ADDIU SP, SP, -32
9D0049A0  AFBF001C   SW RA, 28(SP)
9D0049A4  AFB10018   SW S1, 24(SP)
9D0049A8  AFB00014   SW S0, 20(SP)
9D0049AC  00808021   ADDU S0, A0, ZERO
421:                     if(gDrvTmrInstances == 0)
9D0049B0  8F828034   LW V0, -32716(GP)
9D0049B4  14400006   BNE V0, ZERO, 0x9D0049D0
9D0049B8  00A08821   ADDU S1, A1, ZERO
422:                     {
423:                         if(!_DRV_TMR_RootInitialize())
424:                         {   // failed to initialize
425:                             return SYS_MODULE_OBJ_INVALID;
426:                         }
427:                     }
428:                 
429:                     DRV_TMR_MODULE_DESCRIPTOR* pTmrDcpt;
430:                     DRV_TMR_MODULE_INSTANCE*   pTmrInst;
431:                     const DRV_TMR_INIT * tmrInit;
432:                     
433:                     /* Validate the driver index. Check if the specified driver
434:                     index is in valid range */
435:                     if ( drvIndex >= DRV_TMR_INSTANCES_NUMBER )
9D0049D0  16000056   BNE S0, ZERO, 0x9D004B2C
9D0049D4  2402FFFF   ADDIU V0, ZERO, -1
436:                     {
437:                         return SYS_MODULE_OBJ_INVALID;
438:                     }
439:                 
440:                     /* Check if this hardware instance was already initialized */
441:                     pTmrDcpt = gDrvTmrDcpt + drvIndex; 
442:                     if ( pTmrDcpt->tmrInstance.inUse != false )
9D0049D8  3C02A000   LUI V0, -24576
9D0049DC  904267B8   LBU V0, 26552(V0)
9D0049E0  10400003   BEQ V0, ZERO, 0x9D0049F0
9D0049E4  3C02A000   LUI V0, -24576
443:                     {
444:                         return (SYS_MODULE_OBJ)pTmrDcpt;
9D0049E8  0B4012CB   J 0x9D004B2C
9D0049EC  244267A0   ADDIU V0, V0, 26528
445:                     }
446:                 
447:                     /* Copy to local variables */
448:                     tmrInit = ( const DRV_TMR_INIT * ) init;
449:                     if(tmrInit == 0)
9D0049F0  16200005   BNE S1, ZERO, 0x9D004A08
9D0049F4  244267A0   ADDIU V0, V0, 26528
450:                     {
451:                         tmrInit = &defaultTmrInit;
9D0049F8  3C119D01   LUI S1, -25343
9D0049FC  263199F4   ADDIU S1, S1, -26124
452:                     }
453:                 
454:                     // TODO: verify the validity of the passed in tmrId!
455:                 
456:                     /* Object is valid, set it in use */
457:                     pTmrInst = &pTmrDcpt->tmrInstance;
458:                     pTmrInst->inUse = true;
9D004A00  3C02A000   LUI V0, -24576
9D004A04  244267A0   ADDIU V0, V0, 26528
9D004A08  24030001   ADDIU V1, ZERO, 1
9D004A0C  A0430018   SB V1, 24(V0)
459:                 
460:                     /* Initialize the Interrupt Source */
461:                     pTmrInst->tmrId = tmrInit->tmrId;
9D004A10  8E300004   LW S0, 4(S1)
9D004A14  AC50000C   SW S0, 12(V0)
462:                     pTmrInst->clockSource = tmrInit->clockSource;
9D004A18  8E250008   LW A1, 8(S1)
9D004A1C  AC450010   SW A1, 16(V0)
463:                     pTmrInst->prescale = tmrInit->prescale;
9D004A20  8E23000C   LW V1, 12(S1)
9D004A24  AC430008   SW V1, 8(V0)
464:                     pTmrInst->interruptSource = tmrInit->interruptSource;
9D004A28  8E230010   LW V1, 16(S1)
9D004A2C  AC430014   SW V1, 20(V0)
465:                     pTmrInst->operMode = tmrInit->mode;
9D004A30  8E230014   LW V1, 20(S1)
9D004A34  AC43001C   SW V1, 28(V0)
466:                     pTmrInst->asyncWriteEnable = tmrInit->asyncWriteEnable;
9D004A38  92230018   LBU V1, 24(S1)
9D004A3C  A0430020   SB V1, 32(V0)
467:                 
468:                     /* Setup the Hardware */
469:                     if ( _DRV_TMR_InstanceSetup (pTmrInst) == false )
470:                     {   /* Hardware update fail. Set the status. */
471:                         pTmrInst->inUse = false;
9D004AFC  A04067B8   SB ZERO, 26552(V0)
472:                         return SYS_MODULE_OBJ_INVALID;
9D004B00  0B4012CB   J 0x9D004B2C
9D004B04  2402FFFF   ADDIU V0, ZERO, -1
473:                     }
474:                 
475:                     SYS_INT_SourceDisable( pTmrInst->interruptSource );
9D004AD0  0B4012C2   J 0x9D004B08
9D004AD4  3C11A000   LUI S1, -24576
9D004AE0  0B4012C2   J 0x9D004B08
9D004AE4  3C11A000   LUI S1, -24576
9D004AF4  0B4012C2   J 0x9D004B08
9D004AF8  3C11A000   LUI S1, -24576
9D004B08  263067A0   ADDIU S0, S1, 26528
9D004B0C  0F402481   JAL SYS_INT_SourceDisable
9D004B10  8E040014   LW A0, 20(S0)
476:                 
477:                     /* Set the current driver state */
478:                     pTmrInst->status = SYS_STATUS_READY;
9D004B14  24020002   ADDIU V0, ZERO, 2
9D004B18  AE2267A0   SW V0, 26528(S1)
479:                 
480:                     gDrvTmrInstances++;
9D004B1C  8F828034   LW V0, -32716(GP)
9D004B20  24420001   ADDIU V0, V0, 1
9D004B24  AF828034   SW V0, -32716(GP)
481:                 
482:                     /* Return the driver handle */
483:                     return (SYS_MODULE_OBJ)pTmrDcpt;
9D004B28  02001021   ADDU V0, S0, ZERO
484:                 
485:                 } /* DRV_TMR_Initialize */
9D004B2C  8FBF001C   LW RA, 28(SP)
486:                 
487:                 // *****************************************************************************
488:                 /* Function:
489:                     void DRV_TMR_Deinitialize ( SYS_MODULE_OBJ object )
490:                 
491:                   Summary:
492:                     Deinitializes the specified instance of the Timer driver.
493:                 
494:                   Description:
495:                     Deinitializes the specified instance of the Timer driver, disabling
496:                     its operation (and any hardware). All internal data is invalidated.
497:                 
498:                   Remarks:
499:                     Refer to drv_tmr.h for usage information.
500:                 */
501:                 
502:                 void DRV_TMR_Deinitialize ( SYS_MODULE_OBJ object )
503:                 {
504:                     int ix;
505:                     DRV_TMR_MODULE_DESCRIPTOR* pDcpt = _DRV_TMR_ModuleObj(object, false);
506:                 
507:                     if(pDcpt)
508:                     {
509:                         SYS_INT_SourceDisable(pDcpt->tmrInstance.interruptSource);
510:                 
511:                         DRV_TMR_CLIENT_OBJ* pObj = pDcpt->tmrClients; 
512:                         for(ix = 0; ix < sizeof(pDcpt->tmrClients) / sizeof(*pDcpt->tmrClients); ix++, pObj++)
513:                         {
514:                             if(pObj->clientStatus > 0)
515:                             {
516:                                 _DRV_TMR_ClientDelete(pObj, true);
517:                             }
518:                         }
519:                 
520:                         pDcpt->tmrInstance.inUse = false;
521:                         /* Update the Timer Driver status */
522:                         pDcpt->tmrInstance.status =  SYS_STATUS_UNINITIALIZED ;
523:                     }
524:                 } 
525:                 
526:                 // *****************************************************************************
527:                 /* Function:
528:                     SYS_STATUS DRV_TMR_Status ( SYS_MODULE_OBJ object )
529:                 
530:                   Summary:
531:                     Provides the current status of the Timer driver.
532:                 
533:                   Description:
534:                     This function provides the current status of the Timer driver.
535:                 
536:                   Remarks:
537:                     Refer to drv_tmr.h for usage information.
538:                 */
539:                 
540:                 SYS_STATUS DRV_TMR_Status ( SYS_MODULE_OBJ object )
541:                 {
542:                     DRV_TMR_MODULE_DESCRIPTOR* pDcpt = _DRV_TMR_ModuleObj(object, false);
543:                 
544:                     return pDcpt ? pDcpt->tmrInstance.status : SYS_STATUS_ERROR;
545:                 
546:                 }
547:                 
548:                 // *****************************************************************************
549:                 /* Function:
550:                     void DRV_TMR_Tasks ( SYS_MODULE_OBJ object )
551:                 
552:                   Summary:
553:                     Maintains the driver's state machine.
554:                 
555:                   Description:
556:                     This function is used to maintain the driver's internal state machine and
557:                     processes the timer events.
558:                 
559:                   Remarks:
560:                     Refer to drv_tmr.h for usage information.
561:                 */
562:                 
563:                 void DRV_TMR_Tasks ( SYS_MODULE_OBJ object )
564:                 {
9D007874  27BDFFE8   ADDIU SP, SP, -24
9D007878  AFBF0014   SW RA, 20(SP)
9D00787C  AFB00010   SW S0, 16(SP)
565:                     DRV_TMR_MODULE_DESCRIPTOR* pDcpt = _DRV_TMR_ModuleObj(object, true);
9D007880  0F402157   JAL _DRV_TMR_ModuleObj
9D007884  24050001   ADDIU A1, ZERO, 1
566:                 
567:                     if(pDcpt)
9D007888  10400028   BEQ V0, ZERO, 0x9D00792C
9D00788C  00408021   ADDU S0, V0, ZERO
568:                     {
569:                         DRV_TMR_ProcessEvents(pDcpt);
570:                     }
571:                 
572:                 }
9D00792C  8FBF0014   LW RA, 20(SP)
573:                 
574:                 // *****************************************************************************
575:                 // *****************************************************************************
576:                 // Section: TMR Driver Client Functions
577:                 // *****************************************************************************
578:                 // *****************************************************************************
579:                 
580:                 // *****************************************************************************
581:                 /* Function:
582:                     DRV_HANDLE DRV_TMR_Open 
583:                     ( 
584:                         const SYS_MODULE_INDEX index,
585:                         const DRV_IO_INTENT    intent
586:                     )
587:                 
588:                   Summary:
589:                     Opens the specified Timer driver instance and returns a handle to it.
590:                   
591:                   Description:
592:                     This function opens the specified Timer driver instance and provides a
593:                     handle that must be provided to all other client-level operations to
594:                     identify the caller and the instance of the driver.  Timer driver does not
595:                     support multiple clients. If two tasks want to use the timer, one should
596:                     wait until the other one gets closed. 
597:                 
598:                   Remarks:
599:                     Refer to drv_tmr.h for usage information.
600:                 */
601:                 
602:                 DRV_HANDLE DRV_TMR_Open 
603:                 ( 
604:                     const SYS_MODULE_INDEX index, 
605:                     const DRV_IO_INTENT ioIntent 
606:                 )
607:                 {
608:                 
609:                     if (index >= DRV_TMR_INSTANCES_NUMBER || ( ioIntent & DRV_IO_INTENT_SHARED ) != 0)
9D009050  14800013   BNE A0, ZERO, 0x9D0090A0
9D009054  2402FFFF   ADDIU V0, ZERO, -1
610:                     {   // only exclusive access for now.
611:                         return DRV_HANDLE_INVALID;
612:                     }
613:                 
614:                     if(gDrvTmrInstances != 0)
9D009058  8F838034   LW V1, -32716(GP)
9D00905C  10600010   BEQ V1, ZERO, 0x9D0090A0
9D009060  00000000   NOP
615:                     {   // module initialized
616:                         DRV_TMR_MODULE_DESCRIPTOR* pDcpt = gDrvTmrDcpt + index;
617:                         if(pDcpt->tmrInstance.inUse != false)
9D009064  3C02A000   LUI V0, -24576
9D009068  904367B8   LBU V1, 26552(V0)
9D00906C  1060000C   BEQ V1, ZERO, 0x9D0090A0
9D009070  2402FFFF   ADDIU V0, ZERO, -1
618:                         {   // search a free client
619:                             int ix;
620:                 
621:                             DRV_TMR_CLIENT_OBJ* dObj = pDcpt->tmrClients + 0;
622:                             for(ix = 0; ix < sizeof(pDcpt->tmrClients) / sizeof(*pDcpt->tmrClients); ix++, dObj++)
623:                             {
624:                                 if(dObj->clientStatus == DRV_TMR_CLIENT_OBJ_CLOSED)
9D009074  3C02A000   LUI V0, -24576
9D009078  8C4367CC   LW V1, 26572(V0)
9D00907C  14600008   BNE V1, ZERO, 0x9D0090A0
9D009080  2402FFFF   ADDIU V0, ZERO, -1
625:                                 {   // found free client
626:                                     dObj->pModInst = &pDcpt->tmrInstance;
9D009084  3C02A000   LUI V0, -24576
9D009088  244267A0   ADDIU V0, V0, 26528
9D00908C  AC420024   SW V0, 36(V0)
627:                                     dObj->clientStatus = DRV_TMR_CLIENT_OBJ_READY;
9D009090  24030001   ADDIU V1, ZERO, 1
9D009094  AC43002C   SW V1, 44(V0)
628:                                     return ( ( DRV_HANDLE ) dObj );
9D009098  3C02A000   LUI V0, -24576
9D00909C  244267C4   ADDIU V0, V0, 26564
629:                                 }
630:                             }
631:                         }
632:                     }
633:                 
634:                     return DRV_HANDLE_INVALID;
635:                 }
9D0090A0  03E00008   JR RA
636:                 
637:                 // *****************************************************************************
638:                 /* Function:
639:                     void DRV_TMR_Close ( DRV_HANDLE handle )
640:                 
641:                   Summary:
642:                     Closes an opened instance of the Timer driver.
643:                 
644:                   Description:
645:                     This function closes an opened instance of the Timer driver, invalidating
646:                     the handle.
647:                   
648:                   Remarks:
649:                     Refer to drv_tmr.h for usage information.
650:                 */
651:                 
652:                 void DRV_TMR_Close ( DRV_HANDLE handle )
653:                 {
9D009390  27BDFFE8   ADDIU SP, SP, -24
9D009394  AFBF0014   SW RA, 20(SP)
9D009398  AFB00010   SW S0, 16(SP)
654:                     DRV_TMR_CLIENT_OBJ *pObj = _DRV_TMR_ClientObj(handle);
655:                 
656:                     if (pObj)
9D0093B4  50800006   BEQL A0, ZERO, 0x9D0093D0
9D0093B8  8FB00010   LW S0, 16(SP)
657:                     {
658:                         _DRV_TMR_ClientDelete(pObj, true);
659:                     }
660:                 } 
9D0093C8  8FBF0014   LW RA, 20(SP)
661:                 
662:                 // *****************************************************************************
663:                 /* Function:
664:                     DRV_TMR_CLIENT_STATUS DRV_TMR_ClientStatus ( DRV_HANDLE handle )
665:                 
666:                   Summary:
667:                     Gets the status of the client operation.
668:                 
669:                   Description:
670:                     This function gets the status of the recently completed client level
671:                     operation.
672:                 
673:                   Remarks:
674:                     Refer to drv_tmr.h for usage information.
675:                 */
676:                 
677:                 DRV_TMR_CLIENT_STATUS DRV_TMR_ClientStatus ( DRV_HANDLE handle )
678:                 {
679:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
680:                     DRV_TMR_CLIENT_STATUS cliStat = DRV_TMR_CLIENT_STATUS_INVALID;
681:                     
682:                     if(dObj)
683:                     {
684:                         if( dObj->clientStatus == DRV_TMR_CLIENT_OBJ_RUNNING)
685:                         {
686:                             cliStat = DRV_TMR_CLIENT_STATUS_RUNNING;
687:                         }
688:                         else
689:                         {
690:                             cliStat = DRV_TMR_CLIENT_STATUS_READY;
691:                         }
692:                     }
693:                    
694:                    return cliStat;
695:                 
696:                 }
697:                 
698:                 // *****************************************************************************
699:                 // *****************************************************************************
700:                 // Section: TMR Driver Counter functions
701:                 // *****************************************************************************
702:                 // *****************************************************************************
703:                 
704:                 // *****************************************************************************
705:                 /* Function:
706:                     void DRV_TMR_CounterValueSet ( DRV_HANDLE handle, uint32_t counterPeriod )
707:                 
708:                   Summary:
709:                     Updates the Timer's counter register.
710:                 
711:                   Description:
712:                     This function updates the Timer's value in the counter register.
713:                 
714:                   Remarks:
715:                     Refer to drv_tmr.h for usage information.
716:                 */
717:                 
718:                 void DRV_TMR_CounterValueSet ( DRV_HANDLE handle, uint32_t value )
719:                 {
720:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
721:                 
722:                     if(dObj)
723:                     {
724:                         if(dObj->pModInst->operMode == DRV_TMR_OPERATION_MODE_16_BIT)
725:                         {   
726:                             PLIB_TMR_Counter16BitSet ( dObj->pModInst->tmrId, (uint16_t)value );
727:                         }
728:                         else
729:                         {
730:                             PLIB_TMR_Counter32BitSet ( dObj->pModInst->tmrId, value );
731:                         }
732:                     }
733:                 }
734:                 
735:                 // *****************************************************************************
736:                 /* Function:
737:                     uint32_t DRV_TMR_CounterValueGet ( DRV_HANDLE handle )
738:                 
739:                   Summary:
740:                     Reads the Timer's counter register.
741:                 
742:                   Description:
743:                     This function returns the Timer's value in the counter register.
744:                 
745:                   Remarks:
746:                     Refer to drv_tmr.h for usage information.
747:                 */
748:                 
749:                 uint32_t DRV_TMR_CounterValueGet ( DRV_HANDLE handle )
750:                 {
751:                 
752:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
753:                 
754:                     if(dObj)
755:                     {
756:                         if(dObj->pModInst->operMode == DRV_TMR_OPERATION_MODE_32_BIT)
757:                         {
758:                             return PLIB_TMR_Counter32BitGet ( dObj->pModInst->tmrId );
759:                         }
760:                         else
761:                         {
762:                             return PLIB_TMR_Counter16BitGet ( dObj->pModInst->tmrId );
763:                         }
764:                     }
765:                 
766:                     return 0;
767:                 }
768:                 
769:                 // *****************************************************************************
770:                 /* Function:
771:                     void DRV_TMR_CounterClear ( DRV_HANDLE handle )
772:                 
773:                   Summary:
774:                     Clears the Timer's counter register.
775:                 
776:                   Description:
777:                     This function clears the Timer's value in the counter register.
778:                 
779:                   Remarks:
780:                     Refer to drv_tmr.h for usage information.
781:                 */
782:                 
783:                 void DRV_TMR_CounterClear ( DRV_HANDLE handle )
784:                 {
785:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
786:                 
787:                     if(dObj)
788:                     {
789:                         if(dObj && dObj->pModInst->operMode == DRV_TMR_OPERATION_MODE_16_BIT)
790:                         {   
791:                             PLIB_TMR_Counter16BitClear ( dObj->pModInst->tmrId );
792:                         }
793:                         else
794:                         {
795:                             PLIB_TMR_Counter32BitClear ( dObj->pModInst->tmrId );
796:                         }
797:                     }
798:                 }
799:                 
800:                 // *****************************************************************************
801:                 // *****************************************************************************
802:                 // Section: TMR Driver Alarm functions
803:                 // *****************************************************************************
804:                 // *****************************************************************************
805:                 
806:                 // *****************************************************************************
807:                 /* Function:
808:                     bool DRV_TMR_AlarmRegister 
809:                     ( 
810:                         DRV_HANDLE handle, 
811:                         uint32_t divider, 
812:                         bool isPeriodic, 
813:                         uintptr_t context, 
814:                         DRV_TMR_CALLBACK callBack 
815:                     )
816:                 
817:                   Summary:
818:                     Sets up an alarm.
819:                 
820:                   Description:
821:                     This function sets up an alarm, allowing the client to receive a callback
822:                     from the driver when the timer counter reaches zero.  Alarms can be one-shot
823:                     or periodic.  A periodic alarm will reload the timer and generate alarm
824:                     until stopped.  The alarm frequency is: DRV_TMR_CounterFrequencyGet() /
825:                     divider;
826:                 
827:                   Remarks:
828:                     Refer to drv_tmr.h for usage information.
829:                 */
830:                 
831:                 bool DRV_TMR_AlarmRegister 
832:                 ( 
833:                     DRV_HANDLE handle, 
834:                     uint32_t divider, 
835:                     bool isPeriodic,
836:                     uintptr_t context, 
837:                     DRV_TMR_CALLBACK callBack 
838:                 )
839:                 {
9D0062C8  27BDFFD8   ADDIU SP, SP, -40
9D0062CC  AFBF0024   SW RA, 36(SP)
9D0062D0  AFB40020   SW S4, 32(SP)
9D0062D4  AFB3001C   SW S3, 28(SP)
9D0062D8  AFB20018   SW S2, 24(SP)
9D0062DC  AFB10014   SW S1, 20(SP)
9D0062E0  AFB00010   SW S0, 16(SP)
840:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
841:                 
842:                     if(dObj == 0)
9D0062FC  10800035   BEQ A0, ZERO, 0x9D0063D4
9D006300  00A08821   ADDU S1, A1, ZERO
9D006304  00C0A021   ADDU S4, A2, ZERO
843:                     {
844:                         return false;
845:                     }
846:                 
847:                     DRV_TMR_OPERATION_MODE operMode = dObj->pModInst->operMode;
9D006308  8C820000   LW V0, 0(A0)
9D00630C  8C52001C   LW S2, 28(V0)
848:                     bool success = false;
849:                 
850:                     if(operMode == DRV_TMR_OPERATION_MODE_32_BIT)
9D006310  24020002   ADDIU V0, ZERO, 2
9D006314  16420004   BNE S2, V0, 0x9D006328
9D006318  00E09821   ADDU S3, A3, ZERO
851:                     {
852:                         success = (divider >= DRV_TIMER_DIVIDER_MIN_32BIT && divider <= DRV_TIMER_DIVIDER_MAX_32BIT);
9D00631C  2CA30002   SLTIU V1, A1, 2
9D006320  0B4018CD   J 0x9D006334
9D006324  38630001   XORI V1, V1, 1
853:                     }
854:                     else
855:                     {
856:                         success = (divider >= DRV_TIMER_DIVIDER_MIN_16BIT && divider <= DRV_TIMER_DIVIDER_MAX_16BIT);
9D006328  24A3FFFE   ADDIU V1, A1, -2
9D00632C  3402FFFF   ORI V0, ZERO, -1
9D006330  0062182B   SLTU V1, V1, V0
857:                     }
858:                 
859:                     if(success)
9D006334  10600027   BEQ V1, ZERO, 0x9D0063D4
9D006338  00601021   ADDU V0, V1, ZERO
860:                     {
861:                         bool resume = _DRV_TMR_Suspend(dObj);
9D00633C  0F402496   JAL _DRV_TMR_Suspend
9D006340  02002021   ADDU A0, S0, ZERO
862:                         _DRV_TMR_ClientSetParams(dObj, divider - 1, isPeriodic, context, callBack);
9D006344  2623FFFF   ADDIU V1, S1, -1
863:                 
864:                         if(operMode == DRV_TMR_OPERATION_MODE_32_BIT)
9D006360  24040002   ADDIU A0, ZERO, 2
9D006364  1644000B   BNE S2, A0, 0x9D006394
9D006368  AE00000C   SW ZERO, 12(S0)
865:                         {
866:                             PLIB_TMR_Period32BitSet ( dObj->pModInst->tmrId, divider - 1);
9D00636C  8E040000   LW A0, 0(S0)
9D006370  8C84000C   LW A0, 12(A0)
867:                         }
868:                         else
869:                         {
870:                             PLIB_TMR_Period16BitSet ( dObj->pModInst->tmrId, (uint16_t)divider - 1 );
9D006394  8E030000   LW V1, 0(S0)
9D00639C  2631FFFF   ADDIU S1, S1, -1
871:                         }
872:                         if(resume)
9D0063A8  50400006   BEQL V0, ZERO, 0x9D0063C4
9D0063AC  24020002   ADDIU V0, ZERO, 2
873:                         {
874:                             _DRV_TMR_Resume(dObj, resume);
9D0063B0  02002021   ADDU A0, S0, ZERO
9D0063B4  0F402338   JAL _DRV_TMR_Resume
9D0063B8  24050001   ADDIU A1, ZERO, 1
9D0063BC  0B4018F5   J 0x9D0063D4
9D0063C0  24020001   ADDIU V0, ZERO, 1
875:                         }
876:                         else
877:                         {
878:                             dObj->clientStatus = DRV_TMR_CLIENT_OBJ_ARMED;
9D0063C4  AE020008   SW V0, 8(S0)
879:                         }
880:                     }
881:                 
882:                 
883:                     return success;
9D0063C8  0B4018F5   J 0x9D0063D4
9D0063CC  24020001   ADDIU V0, ZERO, 1
9D0063D0  00001021   ADDU V0, ZERO, ZERO
884:                 }
9D0063D4  8FBF0024   LW RA, 36(SP)
885:                 
886:                 // *****************************************************************************
887:                 /* Function:
888:                     bool DRV_TMR_AlarmDisable ( DRV_HANDLE handle);
889:                 
890:                   Summary:
891:                     Disables an alarm signal.
892:                 
893:                   Description:
894:                     This function allows the client to disable an alarm generation.
895:                     Use DRV_TMR_AlarmEnable to re-enable.
896:                 
897:                   Remarks:
898:                     Refer to drv_tmr.h for usage information.
899:                 */
900:                 
901:                 
902:                 bool DRV_TMR_AlarmDisable ( DRV_HANDLE handle)
903:                 {
904:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
905:                 
906:                     if(dObj && dObj->clientStatus == DRV_TMR_CLIENT_OBJ_RUNNING)
907:                     {
908:                         return SYS_INT_SourceDisable ( dObj->pModInst->interruptSource ) ;
909:                     }
910:                 
911:                     return false;
912:                 }
913:                 
914:                 // *****************************************************************************
915:                 /* Function:
916:                     void DRV_TMR_AlarmEnable ( DRV_HANDLE handle, bool enable );
917:                 
918:                   Summary:
919:                     Re-enables an alarm signal.
920:                 
921:                   Description:
922:                     This function allows the client to re-enable an alarm after it has been
923:                     disabled by a DRV_TMR_AlarmDisable call.
924:                 
925:                   Remarks:
926:                     Refer to drv_tmr.h for usage information.
927:                 */
928:                 
929:                 void DRV_TMR_AlarmEnable ( DRV_HANDLE handle, bool enable )
930:                 {
931:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
932:                 
933:                     if(dObj && dObj->clientStatus == DRV_TMR_CLIENT_OBJ_RUNNING && enable)
9D008FB0  1080000E   BEQ A0, ZERO, 0x9D008FEC
9D008FB4  24030003   ADDIU V1, ZERO, 3
9D008FB8  1443000C   BNE V0, V1, 0x9D008FEC
9D008FBC  00000000   NOP
9D008FC0  10A0000A   BEQ A1, ZERO, 0x9D008FEC
9D008FC4  3C03BF88   LUI V1, -16504
934:                     {
935:                         SYS_INT_SourceEnable ( dObj->pModInst->interruptSource ) ;
9D008FC8  8C820000   LW V0, 0(A0)
9D008FCC  8C420014   LW V0, 20(V0)
936:                     }
937:                 }
938:                 
939:                 // *****************************************************************************
940:                 /* Function:
941:                     void DRV_TMR_AlarmPeriodSet ( DRV_HANDLE handle, uint32_t value )
942:                 
943:                   Summary:
944:                     Updates the Timer's period.
945:                 
946:                   Description:
947:                     This function updates the Timer's period.
948:                 
949:                   Remarks:
950:                     Refer to drv_tmr.h for usage information.
951:                 */
952:                 
953:                 void DRV_TMR_AlarmPeriodSet ( DRV_HANDLE handle, uint32_t   period )
954:                 {
955:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
956:                 
957:                     if(dObj)
958:                     {
959:                         bool resume = _DRV_TMR_Suspend(dObj);
960:                         /* Client update with the new count value */
961:                         dObj->pModInst->timerPeriod = period;
962:                 
963:                         if(dObj->pModInst->operMode == DRV_TMR_OPERATION_MODE_32_BIT)
964:                         {
965:                             PLIB_TMR_Period32BitSet ( dObj->pModInst->tmrId, period);
966:                         }
967:                         else
968:                         {
969:                             PLIB_TMR_Period16BitSet ( dObj->pModInst->tmrId, (uint16_t)period );
970:                         }
971:                         if(resume)
972:                         {
973:                             _DRV_TMR_Resume(dObj, resume);
974:                         }
975:                         else
976:                         {
977:                             dObj->clientStatus = DRV_TMR_CLIENT_OBJ_ARMED;
978:                         }
979:                     }
980:                 } 
981:                 
982:                 // *****************************************************************************
983:                 /* Function:
984:                     uint32_t DRV_TMR_AlarmPeriodGet ( DRV_HANDLE handle )
985:                 
986:                   Summary:
987:                     Provides the Timer's period.
988:                 
989:                   Description:
990:                     This function gets the Timer's period.
991:                 
992:                   Remarks:
993:                     Refer to drv_tmr.h for usage information.
994:                 */
995:                 
996:                 uint32_t DRV_TMR_AlarmPeriodGet ( DRV_HANDLE handle )
997:                 {
998:                     DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
999:                 
1000:                    if(dObj)
1001:                    {
1002:                        return  dObj->pModInst->timerPeriod;
1003:                    }
1004:                
1005:                    return 0;
1006:                } 
1007:                
1008:                // *****************************************************************************
1009:                /* Function:
1010:                    void DRV_TMR_AlarmDeregister ( DRV_HANDLE handle )
1011:                
1012:                  Summary:
1013:                    Removes a previously set alarm.
1014:                
1015:                  Description:
1016:                    This function removes a previously set alarm.
1017:                
1018:                  Remarks:
1019:                    Refer to drv_tmr.h for usage information.
1020:                */
1021:                
1022:                void DRV_TMR_AlarmDeregister ( DRV_HANDLE handle )
1023:                {
1024:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1025:                
1026:                    if(dObj)
1027:                    {
1028:                        _DRV_TMR_Suspend(dObj);
1029:                        _DRV_TMR_ClientClear(dObj);
1030:                    }
1031:                } 
1032:                
1033:                // *****************************************************************************
1034:                // *****************************************************************************
1035:                // Section: TMR Driver Operation Control functions
1036:                // *****************************************************************************
1037:                // *****************************************************************************
1038:                
1039:                // *****************************************************************************
1040:                /* Function:
1041:                    bool DRV_TMR_Start ( DRV_HANDLE handle )
1042:                
1043:                  Summary:
1044:                    Starts the Timer counting.
1045:                
1046:                  Description:
1047:                    This function starts the Timer counting.
1048:                
1049:                  Remarks:
1050:                    Refer to drv_tmr.h for usage information.
1051:                */
1052:                
1053:                bool DRV_TMR_Start ( DRV_HANDLE handle )
1054:                {
9D008DB0  27BDFFE8   ADDIU SP, SP, -24
9D008DB4  AFBF0014   SW RA, 20(SP)
9D008DB8  AFB00010   SW S0, 16(SP)
1055:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1056:                
1057:                    if(dObj && dObj->clientStatus == DRV_TMR_CLIENT_OBJ_ARMED)
9D008DD4  1080000B   BEQ A0, ZERO, 0x9D008E04
9D008DD8  24040002   ADDIU A0, ZERO, 2
9D008DDC  1464000A   BNE V1, A0, 0x9D008E08
9D008DE0  8FBF0014   LW RA, 20(SP)
1058:                    {
1059:                        _DRV_TMR_Resume(dObj, true);
9D008DE4  02002021   ADDU A0, S0, ZERO
9D008DE8  0F402338   JAL _DRV_TMR_Resume
9D008DEC  24050001   ADDIU A1, ZERO, 1
1060:                
1061:                        /* Update the Client Status */
1062:                        dObj->clientStatus = DRV_TMR_CLIENT_OBJ_RUNNING;
9D008DF0  24020003   ADDIU V0, ZERO, 3
9D008DF4  AE020008   SW V0, 8(S0)
1063:                        return true;
9D008DF8  0B402381   J 0x9D008E04
9D008DFC  24020001   ADDIU V0, ZERO, 1
9D008E00  00001021   ADDU V0, ZERO, ZERO
1064:                    }
1065:                    return false;
1066:                }
9D008E04  8FBF0014   LW RA, 20(SP)
1067:                
1068:                // *****************************************************************************
1069:                /* Function:
1070:                    void DRV_TMR_Stop ( DRV_HANDLE handle )
1071:                
1072:                  Summary:
1073:                    Stops the Timer from counting.
1074:                
1075:                  Description:
1076:                    This function stops the running Timer from counting.
1077:                
1078:                  Remarks:
1079:                    Refer to drv_tmr.h for usage information.
1080:                */
1081:                
1082:                void DRV_TMR_Stop ( DRV_HANDLE handle )
1083:                {
1084:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1085:                
1086:                    if(dObj && dObj->clientStatus == DRV_TMR_CLIENT_OBJ_RUNNING)
1087:                    {   /* Stop the Timer from running */
1088:                        _DRV_TMR_Suspend(dObj);
1089:                        SYS_INT_SourceStatusClear ( dObj->pModInst->interruptSource );
1090:                        /* Update the Client Status */
1091:                        dObj->clientStatus = DRV_TMR_CLIENT_OBJ_ARMED;
1092:                    }
1093:                }
1094:                
1095:                // *****************************************************************************
1096:                /* Function:
1097:                    uint32_t DRV_TMR_AlarmHasElapsed ( DRV_HANDLE handle )
1098:                
1099:                  Summary:
1100:                    Provides the status of Timer's period elapse.
1101:                
1102:                  Description:
1103:                    This function returns the number of times Timer's period has elapsed since
1104:                    last call to this API has made. On calling this API, the internally
1105:                    maintained counter will be cleared and count will be started again from next
1106:                    elapse.
1107:                
1108:                  Remarks:
1109:                    Refer to drv_tmr.h for usage information.
1110:                */
1111:                
1112:                uint32_t DRV_TMR_AlarmHasElapsed ( DRV_HANDLE handle )
1113:                {
1114:                    uint32_t alarmCountTemp;
1115:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1116:                
1117:                    if(dObj)
1118:                    {
1119:                        alarmCountTemp = dObj->alarmCount;
1120:                        dObj->alarmCount = 0;
1121:                        return( alarmCountTemp );
1122:                    }
1123:                
1124:                    return 0;
1125:                }
1126:                
1127:                // *****************************************************************************
1128:                /* Function:
1129:                    DRV_TMR_OPERATION_MODE DRV_TMR_OperationModeGet(DRV_HANDLE handle)
1130:                
1131:                  Summary:
1132:                    This function gets the currently selected operation mode.
1133:                
1134:                  Description:
1135:                    This function gets the currently selected 16/32 bit operation mode.
1136:                
1137:                  Remarks:
1138:                    Refer to drv_tmr.h for usage information.
1139:                */
1140:                
1141:                DRV_TMR_OPERATION_MODE DRV_TMR_OperationModeGet(DRV_HANDLE handle)
1142:                {
1143:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1144:                
1145:                    if(dObj)
1146:                    {
1147:                        return dObj->pModInst->operMode;
1148:                    }
1149:                
1150:                    return DRV_TMR_OPERATION_MODE_NONE;
1151:                }
1152:                
1153:                // *****************************************************************************
1154:                // *****************************************************************************
1155:                // Section: TMR Driver Miscellaneous information functions
1156:                // *****************************************************************************
1157:                // *****************************************************************************
1158:                
1159:                // *****************************************************************************
1160:                /* Function:
1161:                    uint32_t DRV_TMR_CounterFrequencyGet ( DRV_HANDLE handle )
1162:                
1163:                  Summary:
1164:                    Provides the Timer input frequency.
1165:                
1166:                  Description:
1167:                    This function provides the Timer input frequency. Input frequency is the
1168:                    clock to the Timer register and it is considering the prescaler divisor. 
1169:                
1170:                  Remarks:
1171:                    Refer to drv_tmr.h for usage information.
1172:                */
1173:                
1174:                uint32_t DRV_TMR_CounterFrequencyGet ( DRV_HANDLE handle )
1175:                {
9D007398  27BDFFE8   ADDIU SP, SP, -24
9D00739C  AFBF0014   SW RA, 20(SP)
9D0073A0  AFB00010   SW S0, 16(SP)
1176:                    uint32_t prescale, tmrBaseFreq ;
1177:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1178:                
1179:                    if(dObj)
9D0073BC  10800029   BEQ A0, ZERO, 0x9D007464
9D0073C0  8FBF0014   LW RA, 20(SP)
1180:                    {
1181:                        if(dObj->pModInst->clockSource == DRV_TMR_CLKSOURCE_INTERNAL)
9D0073C4  8C820000   LW V0, 0(A0)
9D0073C8  8C430010   LW V1, 16(V0)
9D0073CC  14600024   BNE V1, ZERO, 0x9D007460
9D0073D0  00001021   ADDU V0, ZERO, ZERO
1182:                        {
1183:                            tmrBaseFreq = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_FOR_TIMER_PERIPHERAL);
9D0073D4  0F4026BB   JAL SYS_CLK_PeripheralFrequencyGet
9D0073D8  00002021   ADDU A0, ZERO, ZERO
1184:                            prescale = PLIB_TMR_PrescaleGet ( dObj->pModInst->tmrId );
9D0073DC  8E030000   LW V1, 0(S0)
9D0073E0  8C64000C   LW A0, 12(V1)
1185:                            return ( tmrBaseFreq / prescale );
9D00744C  0043001B   DIVU V0, V1
9D007450  006001F4   TEQ V1, ZERO
9D007454  0B401D18   J 0x9D007460
9D007458  00001012   MFLO V0
9D00745C  00001021   ADDU V0, ZERO, ZERO
1186:                        }
1187:                    }
1188:                
1189:                    return 0;
1190:                }
9D007460  8FBF0014   LW RA, 20(SP)
1191:                
1192:                // *****************************************************************************
1193:                /* Function:
1194:                    DRV_TMR_OPERATION_MODE DRV_TMR_DividerRangeGet 
1195:                    ( 
1196:                        DRV_HANDLE handle, 
1197:                        DRV_TMR_DIVIDER_RANGE* pDivRange
1198:                    )
1199:                
1200:                  Summary:
1201:                    Returns the Timer divider values.
1202:                
1203:                  Description:
1204:                    This function provides the Timer operating mode and divider range.
1205:                
1206:                  Remarks:
1207:                    Refer to drv_tmr.h for usage information.
1208:                */
1209:                
1210:                DRV_TMR_OPERATION_MODE DRV_TMR_DividerRangeGet 
1211:                ( 
1212:                    DRV_HANDLE handle,
1213:                    DRV_TMR_DIVIDER_RANGE * pDivRange
1214:                )
1215:                {
1216:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1217:                
1218:                    if(dObj)
1219:                    {
1220:                        DRV_TMR_OPERATION_MODE operMode = dObj->pModInst->operMode;
1221:                
1222:                        if(pDivRange)
1223:                        {
1224:                
1225:                            if(operMode == DRV_TMR_OPERATION_MODE_32_BIT)
1226:                            {
1227:                                pDivRange->dividerMax = DRV_TIMER_DIVIDER_MAX_32BIT;
1228:                                pDivRange->dividerMin = DRV_TIMER_DIVIDER_MIN_32BIT;
1229:                            }
1230:                            else
1231:                            {
1232:                                pDivRange->dividerMax = DRV_TIMER_DIVIDER_MAX_16BIT;
1233:                                pDivRange->dividerMin = DRV_TIMER_DIVIDER_MIN_16BIT;
1234:                            }
1235:                            pDivRange->dividerStep = 1;
1236:                        }
1237:                        return operMode;
1238:                    }
1239:                
1240:                    return DRV_TMR_OPERATION_MODE_NONE;
1241:                
1242:                }
1243:                
1244:                // *****************************************************************************
1245:                /* Function:
1246:                    bool DRV_TMR_GateModeSet ( DRV_HANDLE handle )
1247:                
1248:                  Summary:
1249:                    Enables the Gate mode.
1250:                
1251:                  Description:
1252:                    This function enables the Gated mode of Timer. User can measure the duration
1253:                    of an external signal in this mode. Once the Gate mode is enabled, Timer
1254:                    will start on the raising edge of the external signal. It will keep counting
1255:                    until the next falling edge. 
1256:                
1257:                  Remarks:
1258:                    Refer to drv_tmr.h for usage information.
1259:                */
1260:                
1261:                bool DRV_TMR_GateModeSet ( DRV_HANDLE handle )
1262:                {
1263:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1264:                    if(dObj)
1265:                    {
1266:                #if defined(PLIB_TMR_ExistsGatedTimeAccumulation)
1267:                        if(PLIB_TMR_ExistsGatedTimeAccumulation( dObj->pModInst->tmrId))
1268:                        {
1269:                            bool resume = _DRV_TMR_Suspend(dObj);
1270:                            PLIB_TMR_GateEnable( dObj->pModInst->tmrId );
1271:                            _DRV_TMR_Resume(dObj, resume);
1272:                            return true;
1273:                        }
1274:                #endif
1275:                    }
1276:                
1277:                    return false;
1278:                }
1279:                 
1280:                // *****************************************************************************
1281:                /* Function:
1282:                    bool DRV_TMR_GateModeClear ( DRV_HANDLE handle )
1283:                
1284:                  Summary:
1285:                    Enables the Gate mode.
1286:                
1287:                  Description:
1288:                    This function enables the Gated mode of Timer. User can measure the duration
1289:                    of an external signal in this mode. Once the Gate mode is enabled, Timer
1290:                    will start on the raising edge of the external signal. It will keep counting
1291:                    until the next falling edge. 
1292:                
1293:                  Remarks:
1294:                    Refer to drv_tmr.h for usage information.
1295:                */
1296:                
1297:                bool DRV_TMR_GateModeClear ( DRV_HANDLE handle )
1298:                {
1299:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1300:                    if(dObj)
1301:                    {
1302:                #if defined(PLIB_TMR_ExistsGatedTimeAccumulation)
1303:                        if(PLIB_TMR_ExistsGatedTimeAccumulation( dObj->pModInst->tmrId))
1304:                        {
1305:                            bool resume = _DRV_TMR_Suspend(dObj);
1306:                            PLIB_TMR_GateDisable( dObj->pModInst->tmrId );
1307:                            _DRV_TMR_Resume(dObj, resume);
1308:                            return true;
1309:                        }
1310:                #endif
1311:                    }
1312:                    return false;
1313:                }
1314:                
1315:                // *****************************************************************************
1316:                /* Function:
1317:                    bool DRV_TMR_ClockSet 
1318:                    ( 
1319:                        DRV_HANDLE handle, 
1320:                        DRV_TMR_CLK_SOURCES clockSource, 
1321:                        TMR_PRESCALE  preScale 
1322:                    )
1323:                
1324:                  Summary:
1325:                    Sets the timers clock by selecting the source and prescaler.
1326:                
1327:                  Description:
1328:                    This function sets the timers clock by selecting the source and prescaler.
1329:                
1330:                  Remarks:
1331:                    Refer to drv_tmr.h for usage information.
1332:                */
1333:                
1334:                bool DRV_TMR_ClockSet 
1335:                ( 
1336:                    DRV_HANDLE handle, 
1337:                    DRV_TMR_CLK_SOURCES clockSource, 
1338:                    TMR_PRESCALE  prescale 
1339:                )
1340:                {
1341:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1342:                
1343:                
1344:                    if(dObj)
1345:                    {
1346:                        bool success = false;
1347:                        bool resume = _DRV_TMR_Suspend(dObj);
1348:                
1349:                        if(_DRV_TMR_ClockSourceSet(dObj->pModInst->tmrId, clockSource))
1350:                        {
1351:                            if(_DRV_TMR_ClockPrescaleSet(dObj->pModInst->tmrId, prescale))
1352:                            {   
1353:                                success = true;
1354:                            }
1355:                        }
1356:                
1357:                        _DRV_TMR_Resume(dObj, resume);
1358:                        return success;
1359:                    }
1360:                
1361:                    return false;
1362:                }
1363:                
1364:                // *****************************************************************************
1365:                /* Function:
1366:                    TMR_PRESCALE DRV_TMR_PrescalerGet ( DRV_HANDLE handle )
1367:                
1368:                  Summary:
1369:                    This function gets the currently selected prescaler.
1370:                
1371:                  Description:
1372:                    This function gets the currently selected prescaler.
1373:                
1374:                  Remarks:
1375:                    Refer to drv_tmr.h for usage information.
1376:                */
1377:                
1378:                TMR_PRESCALE DRV_TMR_PrescalerGet ( DRV_HANDLE handle )
1379:                {
1380:                    DRV_TMR_CLIENT_OBJ *dObj = _DRV_TMR_ClientObj(handle);
1381:                
1382:                    if(dObj)
1383:                    {
1384:                        uint16_t prescale_value;
1385:                        /* Call the PLIB directly */
1386:                        prescale_value = PLIB_TMR_PrescaleGet( dObj->pModInst->tmrId );
1387:                        
1388:                
1389:                        switch(prescale_value)
1390:                        {
1391:                            case 1: return TMR_PRESCALE_VALUE_1;
1392:                                                        
1393:                            case 2: return TMR_PRESCALE_VALUE_2;
1394:                                                        
1395:                            case 4: return TMR_PRESCALE_VALUE_4;
1396:                                                        
1397:                            case 8: return TMR_PRESCALE_VALUE_8;
1398:                            
1399:                            case 16: return TMR_PRESCALE_VALUE_16;
1400:                                                        
1401:                            case 32: return TMR_PRESCALE_VALUE_32;
1402:                                                        
1403:                            case 64: return TMR_PRESCALE_VALUE_64;
1404:                                                        
1405:                            case 256: return TMR_PRESCALE_VALUE_256;            
1406:                
1407:                            default: return TMR_PRESCALE_VALUE_1;
1408:                        }
1409:                    }
1410:                
1411:                    return -1;
1412:                
1413:                } 
1414:                
1415:                
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/main.c  -----------------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Project Main Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       main.c
9:                   
10:                    Summary:
11:                      This file contains the "main" function for an MPLAB Harmony project.
12:                  
13:                    Description:
14:                      This file contains the "main" function for an MPLAB Harmony project.  The
15:                      "main" function calls the "SYS_Initialize" function to initialize the state 
16:                      machines of all MPLAB Harmony modules in the system and it calls the 
17:                      "SYS_Tasks" function from within a system-wide "super" loop to maintain 
18:                      their correct operation. These two functions are implemented in 
19:                      configuration-specific files (usually "system_init.c" and "system_tasks.c")
20:                      in a configuration-specific folder under the "src/system_config" folder 
21:                      within this project's top-level folder.  An MPLAB Harmony project may have
22:                      more than one configuration, each contained within it's own folder under
23:                      the "system_config" folder.
24:                   *******************************************************************************/
25:                  
26:                  // DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  //Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                   *******************************************************************************/
49:                  // DOM-IGNORE-END
50:                  
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Included Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include <stddef.h>                     // Defines NULL
59:                  #include <stdbool.h>                    // Defines true
60:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
61:                  #include "system/common/sys_module.h"   // SYS function prototypes
62:                  
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Main Entry Point
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  int main ( void )
71:                  {
9D0099D4  27BDFFE8   ADDIU SP, SP, -24
9D0099D8  AFBF0014   SW RA, 20(SP)
72:                      /* Initialize all MPLAB Harmony modules, including application(s). */
73:                      SYS_Initialize ( NULL );
9D0099DC  0F4018FD   JAL SYS_Initialize
9D0099E0  00002021   ADDU A0, ZERO, ZERO
74:                  
75:                  
76:                      while ( true )
77:                      {
78:                          /* Maintain state machines of all polled MPLAB Harmony modules. */
79:                          SYS_Tasks ( );
9D0099E4  0F40254F   JAL SYS_Tasks
80:                  
81:                      }
82:                  
83:                      /* Execution should not come here during normal operation */
84:                  
85:                      return ( EXIT_FAILURE );
86:                  }
87:                  
88:                  
89:                  /*******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/users/hansel/home/projects/dazzler/pic32/firmware/src/app.c  ------------------------------------
1:                   // -----------------------------------------------------------------------------
2:                   // Cromemco Dazzler emulation for PIC32MX device
3:                   // Copyright (C) 2018 David Hansel
4:                   //
5:                   // This program is free software; you can redistribute it and/or modify
6:                   // it under the terms of the GNU General Public License as published by
7:                   // the Free Software Foundation; either version 3 of the License, or
8:                   // (at your option) any later version.
9:                   //
10:                  // This program is distributed in the hope that it will be useful,
11:                  // but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                  // GNU General Public License for more details.
14:                  //
15:                  // You should have received a copy of the GNU General Public License
16:                  // along with this program; if not, write to the Free Software Foundation,
17:                  // Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
18:                  // -----------------------------------------------------------------------------
19:                  
20:                  
21:                  #include "app.h"
22:                  
23:                  #include "peripheral/oc/plib_oc.h"
24:                  #include "peripheral/tmr/plib_tmr.h"
25:                  #include "peripheral/int/plib_int.h"
26:                  #include "peripheral/adc/plib_adc.h"
27:                  #include "peripheral/usart/plib_usart.h"
28:                  
29:                  
30:                  // If 1, talk to Arduino Due Native port via USB. Pins 21 and 22 are USB D+/D- pins
31:                  // If 0, talk to a 3.3v serial connection 750000 baud 8N1. Pins 21 and 22 are TX and RX
32:                  #define USE_USB 1
33:                  
34:                  // 0=do not produce any signals unless Dazzler control register is set to "on"
35:                  // 1=produce sync signals but black screen if Dazzler control register is off
36:                  #define ALWAYS_ON 1
37:                  
38:                  
39:                  // The following Microchip USB host stack source files have been modified from their original:
40:                  //
41:                  // File: firmware\src\system_config\default\framework\usb\src\dynamic\usb_host_cdc.c
42:                  // line 790: changed USB_CDC_PROTOCOL_AT_V250 to USB_CDC_PROTOCOL_NO_CLASS_SPECIFIC
43:                  // (Arduino Due reports CDC protocol as NO_CLASS_SPECIFIC)
44:                  //
45:                  // File: firmware\src\system_config\default\framework\usb\src\dynamic\usb_host.c
46:                  // added line 5391: if( transferType==USB_TRANSFER_TYPE_BULK && maxPacketSize>64 ) maxPacketSize=64;
47:                  //(Arduino Due always sends the high speed descriptor when configuration is requested, should
48:                  // send full speed descriptor if the host is full speed. Will send full speed descriptor when OTHER 
49:                  // configuration is requested. maxPacketSize for full speed bulk transfer is 64 bytes, high speed is 512)
50:                  // 
51:                  // File: firmware\src\system_config\default\framework\driver\usb\usbfs\src\dynamic\drv_usbfs_host.c
52:                  // added starting in line 1713:
53:                  // if( ++pipe->nakCounter>=10 )
54:                  //   { pIRP->status = USB_HOST_IRP_STATUS_COMPLETED_SHORT; pipe->nakCounter = 0; endIRP = true; }
55:                  //  else
56:                  //  (to end a read request if no data is received after waiting for 10ms, necessary
57:                  //   so we can still send joystick data when the Arduino is not sending)
58:                  
59:                  
60:                  // VGA picture generation: We produce the timings for a SVGA 800x600 picture.
61:                  // However, we only have to display 128x128 actual pixels. Vertically, lines
62:                  // are scaled up by factor 4 for a total of 512 visible lines.
63:                  // Horizontally, the code for writing out pixel data (in function IntHandlerTimer2)
64:                  // outputs pixels at a ~9.7MHz rate. Since the expected pixel clock for this VGA
65:                  // mode is 40MHz, each horizontal pixel is also scaled up by about factor 4,
66:                  // resulting in (mostly) square pixels. 
67:                  // Timings were taken from: http://www.tinyvga.com/vga-timing/800x600@60Hz
68:                  
69:                  // Horizontal pixels are counted by timer2 which runs at 24MHz
70:                  // - back porch ends (visible area starts) at 0 (i.e. when timer2 runs
71:                  //   over and causes the interrupt that writes pixel data to PORTB)
72:                  // - front porch starts when interrupt routine is finished writing data
73:                  // - front porch ends at HSYNC_START
74:                  // - back porch starts at HSYNC_START+HSYNC_LENGTH
75:                  // Vertical lines are counted by g_current_line, which is incremented
76:                  // at the end of the interrupt routine that outputs a line.
77:                  // - back porch ends (and visible area starts) at line VBP_LENGTH
78:                  // - front porch starts at VBP_LENGTH+DISPLAY_LINES
79:                  // - front porch ends at NUM_LINES-VSYNC_LENGTH
80:                  // - back porch starts at NUM_LINES (=0)
81:                  
82:                  // All numbers for horizontal timing are cycles of the peripheral clock @24MHz,
83:                  // 1 cycle at 24MHz is ~0.0416667us.
84:                  // The pixel counts do not line up with the 800x600 spec since per spec the clock
85:                  // should be 40MHz and we have only 24MHz. But the actual times do (mostly) 
86:                  // match the spec.  HFP_LENGTH is not used - the front porch is just the time
87:                  // between when the timer2 interrupt finishes and the next sync pulse.
88:                  // Since we use only a portion of horizontally visible area, we split up the 
89:                  // remainder (margin) between front and back porch. We don't split evenly since
90:                  // the back porch is actually longer than what we specify here due to the time
91:                  // it takes between the timer overrun and the interrupt routine actually
92:                  // starting to push out pixels. The exact timing values were determined 
93:                  // experimentally such that the display appears in the middle of the screen.
94:                  #define NUM_PIXELS	   634			   // =26.417us/line (spec: 26.4us)
95:                  #define HFP_LENGTH     (24+110)        // (1us + 4.583us) front porch plus margin
96:                  #define HBP_LENGTH     (53+50)         // (2.208us + 2.083us(+x)) back porch plus margin
97:                  #define HSYNC_LENGTH   77			   // =3.208us  (spec: 3.2us)
98:                  #define DISPLAY_PIXELS 320             // =13.3us (128px @ 9.7MHz=13.196us)
99:                  #define HSYNC_START	   (NUM_PIXELS-HBP_LENGTH-HSYNC_LENGTH)
100:                 
101:                 // sanity check
102:                 #if (HFP_LENGTH+HBP_LENGTH+HSYNC_LENGTH+DISPLAY_PIXELS) != NUM_PIXELS
103:                 #error Inconsistent horizontal timing!
104:                 #endif
105:                 
106:                 
107:                 // All numbers for vertical timing are numbers of horizontal lines,
108:                 // each horizontal line is 0.026417ms.
109:                 // The 800x600 resolution gives us 600 visible lines but we only need 512
110:                 // (Dazzler has 128 lines which we scale up by 4). So there are 88 lines
111:                 // of margin, which we split between the front and back porches.
112:                 #define NUM_LINES     628               // =16.59ms/frame (spec: 16.579ms)
113:                 #define VFP_LENGTH    (1+44)            // front porch plus margin
114:                 #define VBP_LENGTH    (23+44) 	        // back porch plus margin
115:                 #define VSYNC_LENGTH  4                 // =0.10567ms (spec: 0.1056ms)
116:                 #define DISPLAY_LINES (128*4)
117:                 
118:                 // sanity check
119:                 #if (VFP_LENGTH+VBP_LENGTH+VSYNC_LENGTH+DISPLAY_LINES) != NUM_LINES
120:                 #error Inconsistent vertical timing!
121:                 #endif
122:                 
123:                 
124:                 // current scan line
125:                 volatile int g_current_line = 0;
126:                 
127:                 
128:                 // Dazzler control register:
129:                 // D7: on/off
130:                 // D6-D0: screen memory location (not used in client)
131:                 uint8_t dazzler_ctrl = 0x00;
132:                 
133:                 
134:                 // Dazzler picture control register:
135:                 // D7: not used
136:                 // D6: 1=resolution x4, 0=normal resolution
137:                 // D5: 1=2k memory, 0=512byte memory
138:                 // D4: 1=color, 0=monochrome
139:                 // D3-D0: color info for x4 high res mode
140:                 uint8_t dazzler_picture_ctrl = 0x10;
141:                 
142:                 
143:                 // frame buffer has 128 lines of 128+1 columns (one extra 0 at the end)
144:                 // (use 132 bytes per line to stay 32-bit aligned)
145:                 uint8_t framebuffer[128][132] __attribute__((aligned(32)));
146:                 
147:                 
148:                 // dazzler video memory, really only necessary so we can update the
149:                 // frame buffer properly if the dazzler_picture_ctrl register is changed
150:                 uint8_t dazzler_mem[2048];
151:                 
152:                 
153:                 // test mode (see function draw_test_screen)
154:                 int test_mode = 0;
155:                 
156:                 // dazzler commands received from the Altair simulator
157:                 #define DAZ_MEMBYTE   0x10
158:                 #define DAZ_FULLFRAME 0x20
159:                 #define DAZ_CTRL      0x30
160:                 #define DAZ_CTRLPIC   0x40
161:                 
162:                 // dazzler commands sent to the Altair simulator
163:                 #define DAZ_JOY1      0x10
164:                 #define DAZ_JOY2      0x20
165:                 
166:                 // receiver states
167:                 #define ST_IDLE      0
168:                 #define ST_MEMBYTE1  1
169:                 #define ST_MEMBYTE2  2
170:                 #define ST_CTRL      3
171:                 #define ST_CTRLPIC   4
172:                 #define ST_FULLFRAME 5
173:                 
174:                 
175:                 // -----------------------------------------------------------------------------
176:                 // --------------- display routines (updating the frame buffer) ----------------
177:                 // -----------------------------------------------------------------------------
178:                 
179:                 
180:                 void update_byte_bigmem_single(int i, uint8_t b)
181:                 {
182:                   // 2K RAM, high resolution (128x128 pixels, common color)
183:                   int x, y;
184:                   uint8_t color, *fb;
185:                 
186:                   // determine position within quadrant
187:                   x = (i & 0x000f)*4;
9D006E4C  3087000F   ANDI A3, A0, 15
9D006E50  00073880   SLL A3, A3, 2
188:                   y = (i & 0x01f0)/8;
9D006E54  308601F0   ANDI A2, A0, 496
9D006E58  000630C3   SRA A2, A2, 3
189:                 
190:                   // determine quadrant
191:                   if( i & 0x0200 ) x += 64;
9D006E5C  30830200   ANDI V1, A0, 512
9D006E60  24E20040   ADDIU V0, A3, 64
9D006E64  0043380B   MOVN A3, V0, V1
192:                   if( i & 0x0400 ) y += 64; 
9D006E68  30840400   ANDI A0, A0, 1024
9D006E6C  24C20040   ADDIU V0, A2, 64
9D006E70  0044300B   MOVN A2, V0, A0
193:                 
194:                   fb    = &(framebuffer[y][x]);
9D006E74  00061880   SLL V1, A2, 2
9D006E78  000611C0   SLL V0, A2, 7
9D006E7C  00621021   ADDU V0, V1, V0
9D006E80  00471021   ADDU V0, V0, A3
9D006E84  3C03A000   LUI V1, -24576
9D006E88  24630640   ADDIU V1, V1, 1600
9D006E8C  00621821   ADDU V1, V1, V0
195:                   color = dazzler_picture_ctrl & 0x0f;
9D006E90  93828030   LBU V0, -32720(GP)
9D006E94  3042000F   ANDI V0, V0, 15
196:                 
197:                   fb[0] = b & 0x01 ? color : 0;
9D006E98  30A40001   ANDI A0, A1, 1
9D006E9C  00004021   ADDU T0, ZERO, ZERO
9D006EA0  0044400B   MOVN T0, V0, A0
9D006EA4  01002021   ADDU A0, T0, ZERO
9D006EA8  A0640000   SB A0, 0(V1)
198:                   fb[1] = b & 0x02 ? color : 0;
9D006EAC  30A40002   ANDI A0, A1, 2
9D006EB0  308400FF   ANDI A0, A0, 255
9D006EB4  00003021   ADDU A2, ZERO, ZERO
9D006EB8  0044300B   MOVN A2, V0, A0
9D006EBC  A0660001   SB A2, 1(V1)
199:                   fb[2] = b & 0x10 ? color : 0;
9D006EC0  30A40010   ANDI A0, A1, 16
9D006EC4  308400FF   ANDI A0, A0, 255
9D006EC8  00004021   ADDU T0, ZERO, ZERO
9D006ECC  0044400B   MOVN T0, V0, A0
9D006ED0  A0680002   SB T0, 2(V1)
200:                   fb[3] = b & 0x20 ? color : 0;
9D006ED4  30A40020   ANDI A0, A1, 32
9D006ED8  308400FF   ANDI A0, A0, 255
9D006EDC  00003021   ADDU A2, ZERO, ZERO
9D006EE0  0044300B   MOVN A2, V0, A0
9D006EE4  A0660003   SB A2, 3(V1)
201:                   fb += sizeof(framebuffer[0]); // next line
202:                   fb[0] = b & 0x04 ? color : 0;
9D006EE8  30A40004   ANDI A0, A1, 4
9D006EEC  308400FF   ANDI A0, A0, 255
9D006EF0  00004021   ADDU T0, ZERO, ZERO
9D006EF4  0044400B   MOVN T0, V0, A0
9D006EF8  A0680084   SB T0, 132(V1)
203:                   fb[1] = b & 0x08 ? color : 0;
9D006EFC  30A40008   ANDI A0, A1, 8
9D006F00  308400FF   ANDI A0, A0, 255
9D006F04  00003021   ADDU A2, ZERO, ZERO
9D006F08  0044300B   MOVN A2, V0, A0
9D006F0C  A0660085   SB A2, 133(V1)
204:                   fb[2] = b & 0x40 ? color : 0;
9D006F10  30A40040   ANDI A0, A1, 64
9D006F14  308400FF   ANDI A0, A0, 255
9D006F18  00004021   ADDU T0, ZERO, ZERO
9D006F1C  0044400B   MOVN T0, V0, A0
9D006F20  A0680086   SB T0, 134(V1)
205:                   fb[3] = b & 0x80 ? color : 0;
9D006F24  000529C2   SRL A1, A1, 7
206:                 }
207:                 
208:                 
209:                 void update_byte_bigmem_multi(int i, uint8_t b)
210:                 {
211:                   // 2K RAM, low resolution (64x64 pixels, individual color)
212:                   int x, y;
213:                   uint8_t color1, color2, *fb; 
214:                 
215:                   // determine position within quadrant
216:                   x = (i & 0x000f)*4;
9D008B98  3086000F   ANDI A2, A0, 15
9D008B9C  00063080   SLL A2, A2, 2
217:                   y = (i & 0x01f0)/8;
9D008BA0  308301F0   ANDI V1, A0, 496
9D008BA4  000318C3   SRA V1, V1, 3
218:                 
219:                   // determine quadrant
220:                   if( i & 0x0200 ) x += 64;
9D008BA8  30870200   ANDI A3, A0, 512
9D008BAC  24C20040   ADDIU V0, A2, 64
9D008BB0  0047300B   MOVN A2, V0, A3
221:                   if( i & 0x0400 ) y += 64; 
9D008BB4  30840400   ANDI A0, A0, 1024
9D008BB8  24620040   ADDIU V0, V1, 64
9D008BBC  0044180B   MOVN V1, V0, A0
222:                 
223:                   fb     = &(framebuffer[y][x]);
9D008BC0  00031080   SLL V0, V1, 2
9D008BC4  000319C0   SLL V1, V1, 7
9D008BC8  00431821   ADDU V1, V0, V1
9D008BCC  00663021   ADDU A2, V1, A2
9D008BD0  3C02A000   LUI V0, -24576
9D008BD4  24420640   ADDIU V0, V0, 1600
9D008BD8  00461021   ADDU V0, V0, A2
224:                   color1 = b & 0x0f;
9D008BDC  30A3000F   ANDI V1, A1, 15
225:                   color2 = (b & 0xf0)/16;
9D008BE0  00052902   SRL A1, A1, 4
226:                 
227:                   fb[0] = color1; fb[1] = color1;
9D008BE4  A0430000   SB V1, 0(V0)
9D008BE8  A0430001   SB V1, 1(V0)
228:                   fb[2] = color2; fb[3] = color2;
9D008BEC  A0450002   SB A1, 2(V0)
9D008BF0  A0450003   SB A1, 3(V0)
229:                   fb += sizeof(framebuffer[0]); // next line
230:                   fb[0] = color1; fb[1] = color1;
9D008BF4  A0430084   SB V1, 132(V0)
9D008BF8  A0430085   SB V1, 133(V0)
231:                   fb[2] = color2; fb[3] = color2;
9D008BFC  A0450086   SB A1, 134(V0)
232:                 }
233:                 
234:                 
235:                 void update_byte_smallmem_single(int i, uint8_t b)
236:                 {
237:                   // 512 bytes RAM, high resolution (64x64 pixels, common color)
238:                   int x, y;
239:                   uint8_t color, *fb;
240:                   uint8_t color0, color1, color2, color3, color4, color5, color6, color7;
241:                 
242:                   // determine position
243:                   x = (i & 0x000f)*8;
9D005CA4  308D000F   ANDI T5, A0, 15
9D005CA8  000D68C0   SLL T5, T5, 3
244:                   y = (i & 0x01f0)/4;
9D005CAC  308401F0   ANDI A0, A0, 496
9D005CB0  00042083   SRA A0, A0, 2
245:                 
246:                   fb     = &(framebuffer[y][x]);
9D005CB4  00041880   SLL V1, A0, 2
9D005CB8  000411C0   SLL V0, A0, 7
9D005CBC  00621821   ADDU V1, V1, V0
9D005CC0  006D1821   ADDU V1, V1, T5
9D005CC4  3C02A000   LUI V0, -24576
9D005CC8  24420640   ADDIU V0, V0, 1600
9D005CCC  00431021   ADDU V0, V0, V1
247:                   color  = dazzler_picture_ctrl & 0x0f;
9D005CD0  93838030   LBU V1, -32720(GP)
9D005CD4  3063000F   ANDI V1, V1, 15
248:                   color0 = b & 0x01 ? color : 0;
9D005CD8  30AC0001   ANDI T4, A1, 1
9D005CDC  00003021   ADDU A2, ZERO, ZERO
9D005CE0  006C300B   MOVN A2, V1, T4
9D005CE4  00C06021   ADDU T4, A2, ZERO
249:                   color1 = b & 0x02 ? color : 0;
9D005CE8  30AB0002   ANDI T3, A1, 2
9D005CEC  316B00FF   ANDI T3, T3, 255
9D005CF0  00007021   ADDU T6, ZERO, ZERO
9D005CF4  006B700B   MOVN T6, V1, T3
9D005CF8  01C05821   ADDU T3, T6, ZERO
250:                   color2 = b & 0x04 ? color : 0;
9D005CFC  30A80004   ANDI T0, A1, 4
9D005D00  310800FF   ANDI T0, T0, 255
9D005D04  00003021   ADDU A2, ZERO, ZERO
9D005D08  0068300B   MOVN A2, V1, T0
9D005D0C  00C04021   ADDU T0, A2, ZERO
251:                   color3 = b & 0x08 ? color : 0;
9D005D10  30A70008   ANDI A3, A1, 8
9D005D14  30E700FF   ANDI A3, A3, 255
9D005D18  00007021   ADDU T6, ZERO, ZERO
9D005D1C  0067700B   MOVN T6, V1, A3
9D005D20  01C03821   ADDU A3, T6, ZERO
252:                   color4 = b & 0x10 ? color : 0;
9D005D24  30AA0010   ANDI T2, A1, 16
9D005D28  314A00FF   ANDI T2, T2, 255
9D005D2C  00003021   ADDU A2, ZERO, ZERO
9D005D30  006A300B   MOVN A2, V1, T2
9D005D34  00C05021   ADDU T2, A2, ZERO
253:                   color5 = b & 0x20 ? color : 0;
9D005D38  30A90020   ANDI T1, A1, 32
9D005D3C  312900FF   ANDI T1, T1, 255
9D005D40  00007021   ADDU T6, ZERO, ZERO
9D005D44  0069700B   MOVN T6, V1, T1
9D005D48  01C04821   ADDU T1, T6, ZERO
254:                   color6 = b & 0x40 ? color : 0;
9D005D4C  30A60040   ANDI A2, A1, 64
9D005D50  30C600FF   ANDI A2, A2, 255
9D005D54  00007021   ADDU T6, ZERO, ZERO
9D005D58  0066700B   MOVN T6, V1, A2
255:                   color7 = b & 0x80 ? color : 0;
9D005D5C  000529C2   SRL A1, A1, 7
9D005D60  0005180A   MOVZ V1, ZERO, A1
256:                 
257:                   fb[0] = color0; fb[1] = color0;
9D005D64  A04C0000   SB T4, 0(V0)
9D005D68  A04C0001   SB T4, 1(V0)
258:                   fb[2] = color1; fb[3] = color1;
9D005D6C  A04B0002   SB T3, 2(V0)
9D005D70  A04B0003   SB T3, 3(V0)
259:                   fb[4] = color4; fb[5] = color4;
9D005D74  A04A0004   SB T2, 4(V0)
9D005D78  A04A0005   SB T2, 5(V0)
260:                   fb[6] = color5; fb[7] = color5;
9D005D7C  A0490006   SB T1, 6(V0)
9D005D80  A0490007   SB T1, 7(V0)
261:                   fb += sizeof(framebuffer[0]); // next line
262:                   fb[0] = color0; fb[1] = color0;
9D005D84  A04C0084   SB T4, 132(V0)
9D005D88  A04C0085   SB T4, 133(V0)
263:                   fb[2] = color1; fb[3] = color1;
9D005D8C  A04B0086   SB T3, 134(V0)
9D005D90  A04B0087   SB T3, 135(V0)
264:                   fb[4] = color4; fb[5] = color4;
9D005D94  A04A0088   SB T2, 136(V0)
9D005D98  A04A0089   SB T2, 137(V0)
265:                   fb[6] = color5; fb[7] = color5;
9D005D9C  A049008A   SB T1, 138(V0)
9D005DA0  A049008B   SB T1, 139(V0)
266:                   fb += sizeof(framebuffer[0]); // next line
267:                   fb[0] = color2; fb[1] = color2;
9D005DA4  A0480108   SB T0, 264(V0)
9D005DA8  A0480109   SB T0, 265(V0)
268:                   fb[2] = color3; fb[3] = color3;
9D005DAC  A047010A   SB A3, 266(V0)
9D005DB0  A047010B   SB A3, 267(V0)
269:                   fb[4] = color6; fb[5] = color6;
9D005DB4  A04E010C   SB T6, 268(V0)
9D005DB8  A04E010D   SB T6, 269(V0)
270:                   fb[6] = color7; fb[7] = color7;
9D005DBC  A043010E   SB V1, 270(V0)
9D005DC0  A043010F   SB V1, 271(V0)
271:                   fb += sizeof(framebuffer[0]); // next line
272:                   fb[0] = color2; fb[1] = color2;
9D005DC4  A048018C   SB T0, 396(V0)
9D005DC8  A048018D   SB T0, 397(V0)
273:                   fb[2] = color3; fb[3] = color3;
9D005DCC  A047018E   SB A3, 398(V0)
9D005DD0  A047018F   SB A3, 399(V0)
274:                   fb[4] = color6; fb[5] = color6;
9D005DD4  A04E0190   SB T6, 400(V0)
9D005DD8  A04E0191   SB T6, 401(V0)
275:                   fb[6] = color7; fb[7] = color7;
9D005DDC  A0430192   SB V1, 402(V0)
276:                 }
277:                 
278:                 
279:                 
280:                 void update_byte_smallmem_multi(int i, uint8_t b)
281:                 {
282:                   // 512 bytes RAM, low resolution (32x32 pixels, individual color)
283:                   int x, y;
284:                   uint8_t color1, color2, *fb;
285:                 
286:                   // determine position
287:                   x = (i & 0x000f)*8;
9D007DD8  3083000F   ANDI V1, A0, 15
9D007DDC  000318C0   SLL V1, V1, 3
288:                   y = (i & 0x01f0)/4;
9D007DE0  308401F0   ANDI A0, A0, 496
9D007DE4  00042083   SRA A0, A0, 2
289:                 
290:                   fb     = &(framebuffer[y][x]);
9D007DE8  00041080   SLL V0, A0, 2
9D007DEC  000421C0   SLL A0, A0, 7
9D007DF0  00442021   ADDU A0, V0, A0
9D007DF4  00832021   ADDU A0, A0, V1
9D007DF8  3C02A000   LUI V0, -24576
9D007DFC  24420640   ADDIU V0, V0, 1600
9D007E00  00441021   ADDU V0, V0, A0
291:                   color1 = b & 0x0f;
9D007E04  30A3000F   ANDI V1, A1, 15
292:                   color2 = (b & 0xf0)/16;
9D007E08  00052902   SRL A1, A1, 4
293:                 
294:                   fb[0] = color1; fb[1] = color1;
9D007E0C  A0430000   SB V1, 0(V0)
9D007E10  A0430001   SB V1, 1(V0)
295:                   fb[2] = color1; fb[3] = color1;
9D007E14  A0430002   SB V1, 2(V0)
9D007E18  A0430003   SB V1, 3(V0)
296:                   fb[4] = color2; fb[5] = color2;
9D007E1C  A0450004   SB A1, 4(V0)
9D007E20  A0450005   SB A1, 5(V0)
297:                   fb[6] = color2; fb[7] = color2;
9D007E24  A0450006   SB A1, 6(V0)
9D007E28  A0450007   SB A1, 7(V0)
298:                   fb += sizeof(framebuffer[0]); // next line
299:                   fb[0] = color1; fb[1] = color1;
9D007E2C  A0430084   SB V1, 132(V0)
9D007E30  A0430085   SB V1, 133(V0)
300:                   fb[2] = color1; fb[3] = color1;
9D007E34  A0430086   SB V1, 134(V0)
9D007E38  A0430087   SB V1, 135(V0)
301:                   fb[4] = color2; fb[5] = color2;
9D007E3C  A0450088   SB A1, 136(V0)
9D007E40  A0450089   SB A1, 137(V0)
302:                   fb[6] = color2; fb[7] = color2;
9D007E44  A045008A   SB A1, 138(V0)
9D007E48  A045008B   SB A1, 139(V0)
303:                   fb += sizeof(framebuffer[0]); // next line
304:                   fb[0] = color1; fb[1] = color1;
9D007E4C  A0430108   SB V1, 264(V0)
9D007E50  A0430109   SB V1, 265(V0)
305:                   fb[2] = color1; fb[3] = color1;
9D007E54  A043010A   SB V1, 266(V0)
9D007E58  A043010B   SB V1, 267(V0)
306:                   fb[4] = color2; fb[5] = color2;
9D007E5C  A045010C   SB A1, 268(V0)
9D007E60  A045010D   SB A1, 269(V0)
307:                   fb[6] = color2; fb[7] = color2;
9D007E64  A045010E   SB A1, 270(V0)
9D007E68  A045010F   SB A1, 271(V0)
308:                   fb += sizeof(framebuffer[0]); // next line
309:                   fb[0] = color1; fb[1] = color1;
9D007E6C  A043018C   SB V1, 396(V0)
9D007E70  A043018D   SB V1, 397(V0)
310:                   fb[2] = color1; fb[3] = color1;
9D007E74  A043018E   SB V1, 398(V0)
9D007E78  A043018F   SB V1, 399(V0)
311:                   fb[4] = color2; fb[5] = color2;
9D007E7C  A0450190   SB A1, 400(V0)
9D007E80  A0450191   SB A1, 401(V0)
312:                   fb[6] = color2; fb[7] = color2;
9D007E84  A0450192   SB A1, 402(V0)
313:                 }
314:                 
315:                 
316:                 void (*update_byte)(int, uint8_t) = &update_byte_smallmem_multi;
317:                 
318:                 void set_update_byte()
319:                 {
320:                   switch( dazzler_picture_ctrl & 0x60 )
9D0087E4  93828030   LBU V0, -32720(GP)
9D0087E8  30420060   ANDI V0, V0, 96
9D0087EC  24030020   ADDIU V1, ZERO, 32
9D0087F0  1043000D   BEQ V0, V1, 0x9D008828
9D0087F4  2C430021   SLTIU V1, V0, 33
9D0087F8  50600005   BEQL V1, ZERO, 0x9D008810
9D0087FC  24030040   ADDIU V1, ZERO, 64
9D008800  10400010   BEQ V0, ZERO, 0x9D008844
9D008804  3C029D00   LUI V0, -25344
9D008808  03E00008   JR RA
9D00880C  00000000   NOP
9D008810  1043000F   BEQ V0, V1, 0x9D008850
9D008814  24030060   ADDIU V1, ZERO, 96
9D008818  10430007   BEQ V0, V1, 0x9D008838
9D00881C  3C029D00   LUI V0, -25344
9D008820  03E00008   JR RA
9D008824  00000000   NOP
321:                     {
322:                     case 0x20 : update_byte = update_byte_bigmem_multi;    break;
9D008828  3C029D01   LUI V0, -25343
9D00882C  24428B98   ADDIU V0, V0, -29800
9D008830  03E00008   JR RA
9D008834  AF82802C   SW V0, -32724(GP)
323:                     case 0x60 : update_byte = update_byte_bigmem_single;   break;
9D008838  24426E4C   ADDIU V0, V0, 28236
9D00883C  03E00008   JR RA
9D008840  AF82802C   SW V0, -32724(GP)
324:                     case 0x00 : update_byte = update_byte_smallmem_multi;  break;
9D008844  24427DD8   ADDIU V0, V0, 32216
9D008848  03E00008   JR RA
9D00884C  AF82802C   SW V0, -32724(GP)
325:                     case 0x40 : update_byte = update_byte_smallmem_single; break;
9D008850  3C029D00   LUI V0, -25344
326:                     }
327:                 }
328:                 
329:                 
330:                 void update_frame()
331:                 {
9D008950  27BDFFE0   ADDIU SP, SP, -32
9D008954  AFBF001C   SW RA, 28(SP)
9D008958  AFB20018   SW S2, 24(SP)
9D00895C  AFB10014   SW S1, 20(SP)
9D008960  AFB00010   SW S0, 16(SP)
332:                   int i, w = (dazzler_picture_ctrl & 0x20) ? 2048 : 512;
9D008964  93928030   LBU S2, -32720(GP)
9D008968  32520020   ANDI S2, S2, 32
9D00896C  325200FF   ANDI S2, S2, 255
9D008970  24020200   ADDIU V0, ZERO, 512
9D008974  24030800   ADDIU V1, ZERO, 2048
9D008978  0072100B   MOVN V0, V1, S2
9D00897C  00409021   ADDU S2, V0, ZERO
333:                   for(i=0; i<w; i++) update_byte(i, dazzler_mem[i]);
9D008980  00008021   ADDU S0, ZERO, ZERO
9D008984  3C11A000   LUI S1, -24576
9D008988  26315840   ADDIU S1, S1, 22592
9D00898C  02301021   ADDU V0, S1, S0
9D008990  90450000   LBU A1, 0(V0)
9D008994  8F82802C   LW V0, -32724(GP)
9D008998  0040F809   JALR V0
9D00899C  02002021   ADDU A0, S0, ZERO
9D0089A0  26100001   ADDIU S0, S0, 1
9D0089A4  0212102A   SLT V0, S0, S2
9D0089A8  5440FFF9   BNEL V0, ZERO, 0x9D008990
9D0089AC  02301021   ADDU V0, S1, S0
334:                 }
9D0089B0  8FBF001C   LW RA, 28(SP)
335:                 
336:                 
337:                 void dazzler_receive(uint8_t data)
338:                 {
9D0041A8  27BDFFE8   ADDIU SP, SP, -24
9D0041AC  AFBF0014   SW RA, 20(SP)
9D0041B0  AFB00010   SW S0, 16(SP)
339:                   static int state = ST_IDLE, addr, cnt;
340:                 
341:                   switch( state )
9D0041B4  8F828080   LW V0, -32640(GP)
9D0041B8  2C420006   SLTIU V0, V0, 6
9D0041BC  1040007D   BEQ V0, ZERO, 0x9D0043B4
9D0041C0  8F838080   LW V1, -32640(GP)
9D0041C4  00031880   SLL V1, V1, 2
9D0041C8  3C029D00   LUI V0, -25344
9D0041CC  244241E0   ADDIU V0, V0, 16864
9D0041D0  00431021   ADDU V0, V0, V1
9D0041D4  8C420000   LW V0, 0(V0)
9D0041D8  00400008   JR V0
9D0041DC  00808021   ADDU S0, A0, ZERO
342:                     {
343:                     case ST_IDLE:
344:                       {
345:                         switch( data & 0xf0 )
9D0041F8  308200F0   ANDI V0, A0, 240
9D0041FC  24030020   ADDIU V1, ZERO, 32
9D004200  10430018   BEQ V0, V1, 0x9D004264
9D004204  2C430021   SLTIU V1, V0, 33
9D004208  10600006   BEQ V1, ZERO, 0x9D004224
9D00420C  24030030   ADDIU V1, ZERO, 48
9D004210  24030010   ADDIU V1, ZERO, 16
9D004214  10430009   BEQ V0, V1, 0x9D00423C
9D004218  24020001   ADDIU V0, ZERO, 1
9D004224  1043000A   BEQ V0, V1, 0x9D004250
9D004228  24030040   ADDIU V1, ZERO, 64
9D00422C  1043000B   BEQ V0, V1, 0x9D00425C
9D004230  24020004   ADDIU V0, ZERO, 4
346:                           {
347:                           case DAZ_MEMBYTE: 
348:                             state = ST_MEMBYTE1;
9D00423C  AF828080   SW V0, -32640(GP)
349:                             addr  = (data & 0x07) * 256;
9D004240  30900007   ANDI S0, A0, 7
9D004244  00108200   SLL S0, S0, 8
350:                             break;
9D004248  0B4010ED   J 0x9D0043B4
9D00424C  AF90807C   SW S0, -32644(GP)
351:                 
352:                           case DAZ_CTRL:
353:                             state = ST_CTRL;
9D004250  24020003   ADDIU V0, ZERO, 3
354:                             break;
9D004254  0B4010ED   J 0x9D0043B4
9D004258  AF828080   SW V0, -32640(GP)
355:                 
356:                           case DAZ_CTRLPIC:
357:                             state = ST_CTRLPIC;
358:                             break;
9D00425C  0B4010ED   J 0x9D0043B4
9D004260  AF828080   SW V0, -32640(GP)
359:                 
360:                           case DAZ_FULLFRAME:
361:                             state = ST_FULLFRAME;
9D004264  24020005   ADDIU V0, ZERO, 5
9D004268  AF828080   SW V0, -32640(GP)
362:                             addr  = 0;
9D00426C  AF80807C   SW ZERO, -32644(GP)
363:                             cnt   = (data & 0x0f) ? 2048 : 512;
9D004270  3090000F   ANDI S0, A0, 15
9D004274  24020800   ADDIU V0, ZERO, 2048
9D004278  24030200   ADDIU V1, ZERO, 512
9D00427C  0070100A   MOVZ V0, V1, S0
364:                             break;
9D004280  0B4010ED   J 0x9D0043B4
9D004284  AF828078   SW V0, -32648(GP)
365:                           }
366:                         break;
367:                       }
368:                       
369:                     case ST_MEMBYTE1:
370:                       addr += data;
9D004288  8F82807C   LW V0, -32644(GP)
9D00428C  00448021   ADDU S0, V0, A0
9D004290  AF90807C   SW S0, -32644(GP)
371:                       state = ST_MEMBYTE2;
9D004294  24020002   ADDIU V0, ZERO, 2
372:                       break;
9D004298  0B4010ED   J 0x9D0043B4
9D00429C  AF828080   SW V0, -32640(GP)
373:                 
374:                     case ST_MEMBYTE2:
375:                       update_byte(addr, data);
9D0042A0  8F84807C   LW A0, -32644(GP)
9D0042A4  8F82802C   LW V0, -32724(GP)
9D0042A8  0040F809   JALR V0
9D0042AC  02002821   ADDU A1, S0, ZERO
376:                       dazzler_mem[addr] = data;
9D0042B0  3C02A000   LUI V0, -24576
9D0042B4  24425840   ADDIU V0, V0, 22592
9D0042B8  8F83807C   LW V1, -32644(GP)
9D0042BC  00621021   ADDU V0, V1, V0
9D0042C0  A0500000   SB S0, 0(V0)
377:                       state = ST_IDLE;
378:                       break;
9D0042C4  0B4010ED   J 0x9D0043B4
9D0042C8  AF808080   SW ZERO, -32640(GP)
379:                 
380:                     case ST_CTRL:
381:                       dazzler_ctrl = data;
9D0042CC  A38480A4   SB A0, -32604(GP)
382:                 #if ALWAYS_ON==0
383:                       // start/stop generating the output signal
384:                       g_current_line = 0;
385:                       if( dazzler_ctrl & 0x80 )
386:                         PLIB_TMR_Start(TMR_ID_2);
387:                       else
388:                         PLIB_TMR_Stop(TMR_ID_2);
389:                 #endif      
390:                       state = ST_IDLE;
391:                       break;
9D0042D0  0B4010ED   J 0x9D0043B4
9D0042D4  AF808080   SW ZERO, -32640(GP)
392:                 
393:                     case ST_CTRLPIC:
394:                       if( data != dazzler_picture_ctrl )
9D0042D8  93828030   LBU V0, -32720(GP)
9D0042DC  10820018   BEQ A0, V0, 0x9D004340
9D0042E0  00821826   XOR V1, A0, V0
395:                         {
396:                           // must redraw the frame if
397:                           // either the resolution or memory size setting has changed or
398:                           // we are in 4x resolution mode and the (common) color has changed
399:                           bool redraw_frame = (data & 0x60)!=(dazzler_picture_ctrl & 0x60) || 
9D0042E4  30640060   ANDI A0, V1, 96
9D0042E8  14800028   BNE A0, ZERO, 0x9D00438C
9D0042EC  00000000   NOP
9D0042F4  304200FF   ANDI V0, V0, 255
9D0042F8  1040002A   BEQ V0, ZERO, 0x9D0043A4
9D0042FC  3063000F   ANDI V1, V1, 15
400:                             ((dazzler_picture_ctrl & 0x40) && (data & 0x0f)!=(dazzler_picture_ctrl & 0x0f));
9D0042F0  30420040   ANDI V0, V0, 64
9D004300  14600022   BNE V1, ZERO, 0x9D00438C
9D004304  00000000   NOP
9D004308  0B4010E9   J 0x9D0043A4
9D00430C  00000000   NOP
401:                                  
402:                           dazzler_picture_ctrl = data;
403:                           set_update_byte();
9D00438C  0F4021F9   JAL set_update_byte
9D004390  A3908030   SB S0, -32720(GP)
9D0043A4  0F4021F9   JAL set_update_byte
9D0043A8  A3908030   SB S0, -32720(GP)
404:                           if( redraw_frame ) update_frame();
9D004394  0F402254   JAL update_frame
9D004398  00000000   NOP
405:                 
406:                           ColorStateSet((dazzler_picture_ctrl & 0x10)!=0);
9D004310  30420010   ANDI V0, V0, 16
9D00439C  0B4010C4   J 0x9D004310
9D0043A0  93828030   LBU V0, -32720(GP)
9D0043AC  0B4010C4   J 0x9D004310
9D0043B0  93828030   LBU V0, -32720(GP)
407:                         }
408:                 
409:                       state = ST_IDLE;
9D00432C  0B4010ED   J 0x9D0043B4
9D004330  AF808080   SW ZERO, -32640(GP)
410:                       break;
9D004340  0B4010ED   J 0x9D0043B4
9D004344  AF808080   SW ZERO, -32640(GP)
411:                 
412:                     case ST_FULLFRAME:
413:                       update_byte(addr, data);
9D004348  8F84807C   LW A0, -32644(GP)
9D00434C  8F82802C   LW V0, -32724(GP)
9D004350  0040F809   JALR V0
9D004354  02002821   ADDU A1, S0, ZERO
414:                       dazzler_mem[addr++] = data;
9D004358  8F82807C   LW V0, -32644(GP)
9D00435C  24430001   ADDIU V1, V0, 1
9D004360  AF83807C   SW V1, -32644(GP)
9D004364  3C03A000   LUI V1, -24576
9D004368  24635840   ADDIU V1, V1, 22592
9D00436C  00431021   ADDU V0, V0, V1
9D004370  A0500000   SB S0, 0(V0)
415:                       if( --cnt==0 ) state = ST_IDLE; 
9D004374  8F828078   LW V0, -32648(GP)
9D004378  2442FFFF   ADDIU V0, V0, -1
9D00437C  1440000D   BNE V0, ZERO, 0x9D0043B4
9D004380  AF828078   SW V0, -32648(GP)
9D004384  0B4010ED   J 0x9D0043B4
9D004388  AF808080   SW ZERO, -32640(GP)
416:                       break;
417:                     }
418:                 }
9D00421C  0B4010EE   J 0x9D0043B8
9D004220  8FBF0014   LW RA, 20(SP)
9D004234  0B4010EE   J 0x9D0043B8
9D004238  8FBF0014   LW RA, 20(SP)
9D0043B4  8FBF0014   LW RA, 20(SP)
419:                 
420:                 
421:                 // -----------------------------------------------------------------------------
422:                 // --------------------------- ring-buffer handling ----------------------------
423:                 // -----------------------------------------------------------------------------
424:                 
425:                 
426:                 uint32_t ringbuffer_start = 0, ringbuffer_end = 0;
427:                 uint8_t  ringbuffer[0x1000];
428:                 
429:                 #define ringbuffer_full()     (((ringbuffer_end+1)&0x0fff) == ringbuffer_start)
430:                 #define ringbuffer_empty()      (ringbuffer_start==ringbuffer_end)
431:                 #define ringbuffer_available() ((ringbuffer_start-ringbuffer_end-1)&0x0fff)
432:                 
433:                 
434:                 inline void ringbuffer_enqueue(uint8_t b)
435:                 {
436:                   // There's really not much we can do if we receive a byte of data
437:                   // when the ring buffer is full. Overwriting the beginning of the buffer
438:                   // is about as bad as dropping the newly received byte. So we save
439:                   // the time to check whether the buffer is full and just overwrite.
440:                   ringbuffer[ringbuffer_end] = b;
9D007C9C  3C08A000   LUI T0, -24576
9D007CA0  25084840   ADDIU T0, T0, 18496
9D007CA4  3C07A000   LUI A3, -24576
9D007CA8  24E70188   ADDIU A3, A3, 392
9D007CAC  00682021   ADDU A0, V1, T0
9D007CB0  00E22821   ADDU A1, A3, V0
9D007CB4  90A50000   LBU A1, 0(A1)
9D007CB8  A0850000   SB A1, 0(A0)
441:                   ringbuffer_end = (ringbuffer_end+1) & 0x0fff;
9D007CBC  24630001   ADDIU V1, V1, 1
442:                 }
443:                 
444:                 inline uint8_t ringbuffer_dequeue()
445:                 {
446:                   if( !ringbuffer_empty() )
9D00702C  8F82809C   LW V0, -32612(GP)
9D007030  8F838098   LW V1, -32616(GP)
9D007034  1043001F   BEQ V0, V1, 0x9D0070B4
9D007038  3C03A000   LUI V1, -24576
9D00705C  8F838098   LW V1, -32616(GP)
9D007060  10430014   BEQ V0, V1, 0x9D0070B4
9D007064  3C03A000   LUI V1, -24576
9D007088  8F838098   LW V1, -32616(GP)
9D00708C  10430009   BEQ V0, V1, 0x9D0070B4
9D007090  3C03A000   LUI V1, -24576
447:                     {
448:                       dazzler_receive(ringbuffer[ringbuffer_start]);
9D00703C  24634840   ADDIU V1, V1, 18496
9D007040  00431021   ADDU V0, V0, V1
9D007044  0F40106A   JAL dazzler_receive
9D007048  90440000   LBU A0, 0(V0)
9D007068  24634840   ADDIU V1, V1, 18496
9D00706C  00431021   ADDU V0, V0, V1
9D007070  0F40106A   JAL dazzler_receive
9D007074  90440000   LBU A0, 0(V0)
9D007094  24634840   ADDIU V1, V1, 18496
9D007098  00431021   ADDU V0, V0, V1
9D00709C  0F40106A   JAL dazzler_receive
9D0070A0  90440000   LBU A0, 0(V0)
449:                       ringbuffer_start = (ringbuffer_start+1) & 0x0fff;
9D00704C  8F82809C   LW V0, -32612(GP)
9D007050  24420001   ADDIU V0, V0, 1
9D007054  30420FFF   ANDI V0, V0, 4095
9D007058  AF82809C   SW V0, -32612(GP)
9D007078  8F82809C   LW V0, -32612(GP)
9D00707C  24420001   ADDIU V0, V0, 1
9D007080  30420FFF   ANDI V0, V0, 4095
9D007084  AF82809C   SW V0, -32612(GP)
9D0070A4  8F82809C   LW V0, -32612(GP)
9D0070A8  24420001   ADDIU V0, V0, 1
9D0070AC  30420FFF   ANDI V0, V0, 4095
9D0070B0  AF82809C   SW V0, -32612(GP)
450:                     }
451:                 }
452:                 
453:                 
454:                 #if USE_USB==0
455:                 inline void ringbuffer_enqueue_usart()
456:                 {
457:                   if( PLIB_USART_ReceiverDataIsAvailable(USART_ID_2) )
458:                     ringbuffer_enqueue(PLIB_USART_ReceiverByteReceive(USART_ID_2));
459:                 }
460:                 #endif
461:                 
462:                 
463:                 // -----------------------------------------------------------------------------
464:                 // ----------------------------- test mode handling ----------------------------
465:                 // -----------------------------------------------------------------------------
466:                 
467:                 
468:                 void draw_joystick_pixel(int x, int y)
469:                 {
470:                   static int px, py, pc = -1;
471:                   x = x/2+64;
9D0083C0  00041FC2   SRL V1, A0, 31
9D0083C4  00642021   ADDU A0, V1, A0
9D0083C8  00041843   SRA V1, A0, 1
472:                   y = 63-y/2;
9D0083CC  000517C2   SRL V0, A1, 31
9D0083D0  00452821   ADDU A1, V0, A1
9D0083D4  00051043   SRA V0, A1, 1
9D0083D8  2404003F   ADDIU A0, ZERO, 63
9D0083DC  00821023   SUBU V0, A0, V0
473:                   if( pc>=0 ) framebuffer[py][px] = pc;
9D0083E0  8F848024   LW A0, -32732(GP)
9D0083E4  0480000B   BLTZ A0, 0x9D008414
9D0083E8  24630040   ADDIU V1, V1, 64
9D0083EC  8F858074   LW A1, -32652(GP)
9D0083F0  00053080   SLL A2, A1, 2
9D0083F4  000529C0   SLL A1, A1, 7
9D0083F8  00C52821   ADDU A1, A2, A1
9D0083FC  8F868070   LW A2, -32656(GP)
9D008400  00A62821   ADDU A1, A1, A2
9D008404  3C06A000   LUI A2, -24576
9D008408  24C60640   ADDIU A2, A2, 1600
9D00840C  00A62821   ADDU A1, A1, A2
9D008410  A0A40000   SB A0, 0(A1)
474:                   pc = framebuffer[y][x];
9D008414  00022880   SLL A1, V0, 2
9D008418  000221C0   SLL A0, V0, 7
9D00841C  00A42021   ADDU A0, A1, A0
9D008420  00832021   ADDU A0, A0, V1
9D008424  3C05A000   LUI A1, -24576
9D008428  24A50640   ADDIU A1, A1, 1600
9D00842C  00852021   ADDU A0, A0, A1
9D008430  90850000   LBU A1, 0(A0)
9D008434  AF858024   SW A1, -32732(GP)
475:                   px = x;
9D008438  AF838070   SW V1, -32656(GP)
476:                   py = y;
9D00843C  AF828074   SW V0, -32652(GP)
477:                   framebuffer[y][x] = 0x0f;
9D008440  2402000F   ADDIU V0, ZERO, 15
478:                 }
479:                 
480:                 
481:                 void draw_joystick_buttons(uint8_t buttons)
482:                 {
483:                   framebuffer[0][61] = (buttons & 0x01) ? 0x04 : 0x02;
9D0089C8  30850001   ANDI A1, A0, 1
9D0089CC  24020004   ADDIU V0, ZERO, 4
9D0089D0  24030002   ADDIU V1, ZERO, 2
9D0089D4  0045180B   MOVN V1, V0, A1
9D0089D8  3C02A000   LUI V0, -24576
9D0089DC  A043067D   SB V1, 1661(V0)
484:                   framebuffer[0][63] = (buttons & 0x02) ? 0x04 : 0x02;
9D0089E0  30830002   ANDI V1, A0, 2
9D0089E4  306300FF   ANDI V1, V1, 255
9D0089E8  24020004   ADDIU V0, ZERO, 4
9D0089EC  24050002   ADDIU A1, ZERO, 2
9D0089F0  00A3100A   MOVZ V0, A1, V1
9D0089F4  00401821   ADDU V1, V0, ZERO
9D0089F8  3C02A000   LUI V0, -24576
9D0089FC  A043067F   SB V1, 1663(V0)
485:                   framebuffer[0][65] = (buttons & 0x04) ? 0x04 : 0x02;
9D008A00  30830004   ANDI V1, A0, 4
9D008A04  306300FF   ANDI V1, V1, 255
9D008A08  24020004   ADDIU V0, ZERO, 4
9D008A0C  00A3100A   MOVZ V0, A1, V1
9D008A10  00401821   ADDU V1, V0, ZERO
9D008A14  3C02A000   LUI V0, -24576
9D008A18  A0430681   SB V1, 1665(V0)
486:                   framebuffer[0][67] = (buttons & 0x08) ? 0x04 : 0x02;
9D008A1C  30840008   ANDI A0, A0, 8
487:                 }
488:                 
489:                 
490:                 void draw_test_screen()
491:                 {
9D00330C  27BDFFC8   ADDIU SP, SP, -56
9D003310  AFBF0034   SW RA, 52(SP)
9D003314  AFB70030   SW S7, 48(SP)
9D003318  AFB6002C   SW S6, 44(SP)
9D00331C  AFB50028   SW S5, 40(SP)
9D003320  AFB40024   SW S4, 36(SP)
9D003324  AFB30020   SW S3, 32(SP)
9D003328  AFB2001C   SW S2, 28(SP)
9D00332C  AFB10018   SW S1, 24(SP)
9D003330  AFB00014   SW S0, 20(SP)
492:                   int q, r, c;
493:                   switch( test_mode )
9D003334  8F8280A0   LW V0, -32608(GP)
9D003338  2C42000E   SLTIU V0, V0, 14
9D00333C  10400098   BEQ V0, ZERO, 0x9D0035A0
9D003340  8F8280A0   LW V0, -32608(GP)
9D003344  00021080   SLL V0, V0, 2
9D003348  3C039D00   LUI V1, -25344
9D00334C  24633360   ADDIU V1, V1, 13152
9D003350  00621021   ADDU V0, V1, V0
9D003354  8C420000   LW V0, 0(V0)
9D003358  00400008   JR V0
9D00335C  00000000   NOP
9D003398  3C03A000   LUI V1, -24576
9D00339C  24630640   ADDIU V1, V1, 1600
9D0033A0  00001021   ADDU V0, ZERO, ZERO
494:                     {
495:                     case 1:
496:                     case 2:
497:                       // joystick test screen
498:                       for(r=0; r<128; r++)
9D0033A8  24080080   ADDIU T0, ZERO, 128
9D0033C4  24420001   ADDIU V0, V0, 1
9D0033C8  1448FFF8   BNE V0, T0, 0x9D0033AC
9D0033CC  24630084   ADDIU V1, V1, 132
9D0033D0  0B400D5F   J 0x9D00357C
9D0033D4  24030001   ADDIU V1, ZERO, 1
499:                         {
500:                           framebuffer[r][0]   = 0x01;
9D0033A4  24060001   ADDIU A2, ZERO, 1
9D0033AC  A0660000   SB A2, 0(V1)
501:                           framebuffer[r][64]  = (r & 1) && r<127 ? 0x01 : 0x00;
9D0033B0  30470001   ANDI A3, V0, 1
9D0033B4  2845007F   SLTI A1, V0, 127
9D0033B8  0007280A   MOVZ A1, ZERO, A3
9D0033BC  A0650040   SB A1, 64(V1)
502:                           framebuffer[r][127] = 0x01;
9D0033C0  A066007F   SB A2, 127(V1)
503:                         }
504:                       for(c=0; c<128; c++)
9D0033F8  24630001   ADDIU V1, V1, 1
9D0033FC  1467FFF6   BNE V1, A3, 0x9D0033D8
9D003400  A0452100   SB A1, 8448(V0)
9D003404  0B400D69   J 0x9D0035A4
9D003408  8FBF0034   LW RA, 52(SP)
9D003598  0B400CFD   J 0x9D0033F4
9D00359C  24070080   ADDIU A3, ZERO, 128
505:                         {
506:                           framebuffer[0][c]   = 0x01;
9D0033D8  A045DF85   SB A1, -8315(V0)
9D00357C  3C02A000   LUI V0, -24576
9D003580  A0430640   SB V1, 1600(V0)
9D003584  3C02A000   LUI V0, -24576
9D003588  244226BC   ADDIU V0, V0, 9916
9D00358C  00001821   ADDU V1, ZERO, ZERO
507:                           framebuffer[63][c]  = (c & 1) && c<127 ? 0x00 : 0x01;
9D0033DC  30660001   ANDI A2, V1, 1
9D0033E0  10C00003   BEQ A2, ZERO, 0x9D0033F0
9D0033E4  24040001   ADDIU A0, ZERO, 1
9D0033E8  2864007F   SLTI A0, V1, 127
9D0033EC  38840001   XORI A0, A0, 1
9D0033F0  24420001   ADDIU V0, V0, 1
9D0033F4  A0440000   SB A0, 0(V0)
9D003480  02A08821   ADDU S1, S5, ZERO
9D003484  0B400D1A   J 0x9D003468
9D003488  00009821   ADDU S3, ZERO, ZERO
9D003590  24040001   ADDIU A0, ZERO, 1
508:                           framebuffer[127][c] = 0x01;
9D003594  24050001   ADDIU A1, ZERO, 1
509:                         }
510:                       break;
511:                                         
512:                     case 11:
513:                       // color test pattern
514:                       ColorOn();
515:                       for(q=0; q<4; q++)
9D003424  0B400D20   J 0x9D003480
9D003428  24160200   ADDIU S6, ZERO, 512
9D003478  12B6004A   BEQ S5, S6, 0x9D0035A4
9D00347C  8FBF0034   LW RA, 52(SP)
516:                         for(r=0; r<16; r++)
9D003420  24140010   ADDIU S4, ZERO, 16
9D00345C  26730001   ADDIU S3, S3, 1
9D003460  12740004   BEQ S3, S4, 0x9D003474
9D003464  26310007   ADDIU S1, S1, 7
9D003468  02608021   ADDU S0, S3, ZERO
9D00346C  0B400D0B   J 0x9D00342C
9D003470  26720008   ADDIU S2, S3, 8
9D003474  26B50080   ADDIU S5, S5, 128
517:                           for(c=0; c<8; c++)
9D003454  5612FFF6   BNEL S0, S2, 0x9D003430
9D003458  32050007   ANDI A1, S0, 7
518:                             update_byte(q*128+r*8+c, ((r+c)&7) + 16*(((r+c)&7)+8));
9D00342C  32050007   ANDI A1, S0, 7
9D003430  24A50008   ADDIU A1, A1, 8
9D003434  00052900   SLL A1, A1, 4
9D003438  32020007   ANDI V0, S0, 7
9D00343C  00A22821   ADDU A1, A1, V0
9D003440  02112021   ADDU A0, S0, S1
9D003444  8F82802C   LW V0, -32724(GP)
9D003448  0040F809   JALR V0
9D00344C  30A500FF   ANDI A1, A1, 255
9D003450  26100001   ADDIU S0, S0, 1
519:                       break;
520:                                         
521:                     case 12:
522:                       // gray-scale test pattern
523:                       ColorOff();
524:                       for(q=0; q<4; q++)
9D0034A4  0B400D43   J draw_test_screen::PLIB_PORTS_PinSet
9D0034A8  24170200   ADDIU S7, ZERO, 512
9D0034AC  26050001   ADDIU A1, S0, 1
9D003504  12D70027   BEQ S6, S7, 0x9D0035A4
9D003508  8FBF0034   LW RA, 52(SP)
525:                         for(r=0; r<16; r++)
9D0034A0  24150010   ADDIU S5, ZERO, 16
9D0034E0  26730001   ADDIU S3, S3, 1
9D0034E4  12750006   BEQ S3, S5, 0x9D003500
9D0034E8  26940008   ADDIU S4, S4, 8
9D0034EC  327000FF   ANDI S0, S3, 255
9D0034F0  26120010   ADDIU S2, S0, 16
9D0034F4  325200FF   ANDI S2, S2, 255
526:                           for(c=0; c<8; c++)
9D0034D8  1612FFF4   BNE S0, S2, 0x9D0034AC
9D0034DC  26310001   ADDIU S1, S1, 1
527:                             update_byte(q*128+r*8+c, ((r+c*2)&15) + 16*((r+c*2+1)&15));
9D0034B0  30A5000F   ANDI A1, A1, 15
9D0034B4  00052900   SLL A1, A1, 4
9D0034B8  3202000F   ANDI V0, S0, 15
9D0034BC  00A22821   ADDU A1, A1, V0
9D0034C0  02202021   ADDU A0, S1, ZERO
9D0034C4  8F82802C   LW V0, -32724(GP)
9D0034C8  0040F809   JALR V0
9D0034CC  30A500FF   ANDI A1, A1, 255
9D0034D0  26100002   ADDIU S0, S0, 2
9D0034D4  321000FF   ANDI S0, S0, 255
528:                       break;
529:                                       
530:                     case 13:
531:                       // black-and-white grid pattern
532:                       ColorOff();
533:                       for(r=0; r<128; r++)
9D003530  00004021   ADDU T0, ZERO, ZERO
9D003564  25080001   ADDIU T0, T0, 1
9D003568  1106000D   BEQ T0, A2, 0x9D0035A0
9D00356C  24A50084   ADDIU A1, A1, 132
534:                         for(c=0; c<128; c++)
9D003534  0B400D5C   J draw_test_screen::PLIB_PORTS_PinClear
9D003538  24060080   ADDIU A2, ZERO, 128
9D003558  24420001   ADDIU V0, V0, 1
9D00355C  1446FFF7   BNE V0, A2, 0x9D00353C
9D003560  A0830000   SB V1, 0(A0)
535:                           framebuffer[r][c] = r&1 ? 0xff : ((c&1) ? 0x00 : 0xff);
9D00353C  14E00005   BNE A3, ZERO, 0x9D003554
9D003540  240300FF   ADDIU V1, ZERO, 255
9D003544  38430001   XORI V1, V0, 1
9D003548  30630001   ANDI V1, V1, 1
9D00354C  00031823   SUBU V1, ZERO, V1
9D003550  306300FF   ANDI V1, V1, 255
9D003554  00A22021   ADDU A0, A1, V0
9D003574  0B400D4F   J 0x9D00353C
9D003578  31070001   ANDI A3, T0, 1
536:                       break;
537:                     }
538:                 }
9D0035A0  8FBF0034   LW RA, 52(SP)
539:                 
540:                 
541:                 void check_test_button()
542:                 {
9D007F48  27BDFFE8   ADDIU SP, SP, -24
9D007F4C  AFBF0014   SW RA, 20(SP)
543:                   static int debounce = 0;
544:                     
545:                   if( g_current_line==2 && debounce==0 && !TestButtonStateGet() )
9D007F50  8F8380A8   LW V1, -32600(GP)
9D007F54  24020002   ADDIU V0, ZERO, 2
9D007F58  14620009   BNE V1, V0, 0x9D007F80
9D007F5C  8F82806C   LW V0, -32660(GP)
9D007F60  14400007   BNE V0, ZERO, 0x9D007F80
9D007F64  3C02BF88   LUI V0, -16504
9D007F70  14400003   BNE V0, ZERO, 0x9D007F80
9D007F74  24020001   ADDIU V0, ZERO, 1
546:                     {
547:                       // button press detected
548:                       debounce = 1;
9D007F78  0B401FFC   J 0x9D007FF0
9D007F7C  AF82806C   SW V0, -32660(GP)
549:                     }
550:                   else if( g_current_line==1 && debounce==1 && !TestButtonStateGet() )
9D007F80  8F8380A8   LW V1, -32600(GP)
9D007F84  24020001   ADDIU V0, ZERO, 1
9D007F88  54620015   BNEL V1, V0, check_test_button::PLIB_PORTS_PinGet
9D007F8C  3C02BF88   LUI V0, -16504
9D007F90  8F83806C   LW V1, -32660(GP)
9D007F94  14620012   BNE V1, V0, check_test_button::PLIB_PORTS_PinGet
9D007F98  3C02BF88   LUI V0, -16504
9D007FA4  1440000E   BNE V0, ZERO, check_test_button::PLIB_PORTS_PinGet
9D007FA8  3C02BF88   LUI V0, -16504
551:                     {
552:                       // button still pressed after one frame => valid button press (not a bounce))
553:                       test_mode = test_mode+1;
9D007FAC  8F8280A0   LW V0, -32608(GP)
9D007FB0  24420001   ADDIU V0, V0, 1
9D007FC0  0B401FF3   J 0x9D007FCC
9D007FC4  AF8280A0   SW V0, -32608(GP)
554:                       if( test_mode>13 ) test_mode = 11;
9D007FB4  2843000E   SLTI V1, V0, 14
9D007FB8  50600003   BEQL V1, ZERO, 0x9D007FC8
9D007FBC  2402000B   ADDIU V0, ZERO, 11
9D007FC8  AF8280A0   SW V0, -32608(GP)
555:                       draw_test_screen();
9D007FCC  0F400CC3   JAL draw_test_screen
9D007FD0  00000000   NOP
556:                       debounce = 2;
9D007FD4  24020002   ADDIU V0, ZERO, 2
9D007FD8  0B401FFC   J 0x9D007FF0
9D007FDC  AF82806C   SW V0, -32660(GP)
557:                     }
558:                   else if( TestButtonStateGet() )
9D007FE8  54400001   BNEL V0, ZERO, 0x9D007FF0
9D007FEC  AF80806C   SW ZERO, -32660(GP)
559:                   {
560:                     // button no longer pressed
561:                     debounce = 0;
562:                   }
563:                 }
9D007FF0  8FBF0014   LW RA, 20(SP)
564:                 
565:                 
566:                 // -----------------------------------------------------------------------------
567:                 // ----------------------------- joystick handling -----------------------------
568:                 // -----------------------------------------------------------------------------
569:                 
570:                 #if USE_USB>0
571:                 volatile uint64_t usb_joydata = 0;
572:                 #endif
573:                 
574:                 
575:                 #define AVGC 4
576:                 int rolling_average(int n, int v)
577:                 {
578:                   static int8_t ptr[4] = {-1,-1,-1,-1};
579:                   static int buf[4][AVGC], sum[4];
580:                   int i, rv;
581:                   
582:                   if( ptr[n]<0 )
9D006F34  27828020   ADDIU V0, GP, -32736
9D006F38  00441021   ADDU V0, V0, A0
9D006F3C  80420000   LB V0, 0(V0)
9D006F40  04410013   BGEZ V0, 0x9D006F90
9D006F44  00041880   SLL V1, A0, 2
583:                   {
584:                       for(i=0; i<AVGC; i++) buf[n][i] = v;
9D006F48  00041100   SLL V0, A0, 4
9D006F4C  3C03A000   LUI V1, -24576
9D006F50  24630148   ADDIU V1, V1, 328
9D006F54  00431021   ADDU V0, V0, V1
9D006F58  AC450000   SW A1, 0(V0)
9D006F5C  AC450004   SW A1, 4(V0)
9D006F60  AC450008   SW A1, 8(V0)
9D006F64  AC45000C   SW A1, 12(V0)
585:                       sum[n]=v*AVGC;
9D006F68  00041080   SLL V0, A0, 2
9D006F6C  3C03A000   LUI V1, -24576
9D006F70  24630138   ADDIU V1, V1, 312
9D006F74  00431021   ADDU V0, V0, V1
9D006F78  00052880   SLL A1, A1, 2
9D006F7C  AC450000   SW A1, 0(V0)
586:                       ptr[n]=0;
9D006F80  27828020   ADDIU V0, GP, -32736
9D006F84  00441021   ADDU V0, V0, A0
9D006F88  0B401BFD   J 0x9D006FF4
9D006F8C  A0400000   SB ZERO, 0(V0)
587:                   }
588:                   else
589:                   {
590:                       sum[n] += v - buf[n][ptr[n]];
9D006F90  3C06A000   LUI A2, -24576
9D006F94  24C60138   ADDIU A2, A2, 312
9D006F98  00663021   ADDU A2, V1, A2
9D006F9C  00621821   ADDU V1, V1, V0
9D006FA0  00031880   SLL V1, V1, 2
9D006FA4  3C07A000   LUI A3, -24576
9D006FA8  24E70148   ADDIU A3, A3, 328
9D006FAC  00671821   ADDU V1, V1, A3
9D006FB0  8C670000   LW A3, 0(V1)
9D006FB4  00A73823   SUBU A3, A1, A3
9D006FB8  8CC80000   LW T0, 0(A2)
9D006FBC  01073821   ADDU A3, T0, A3
9D006FC0  ACC70000   SW A3, 0(A2)
591:                       buf[n][ptr[n]] = v;
9D006FC4  AC650000   SW A1, 0(V1)
592:                       ptr[n]++;
9D006FC8  24420001   ADDIU V0, V0, 1
9D006FCC  7C021420   SEB V0, V0
9D006FDC  27838020   ADDIU V1, GP, -32736
9D006FE0  00641821   ADDU V1, V1, A0
9D006FE4  0B401BFD   J 0x9D006FF4
9D006FE8  A0620000   SB V0, 0(V1)
593:                       if( ptr[n]>=AVGC ) ptr[n]=0;
9D006FD0  28430004   SLTI V1, V0, 4
9D006FD4  50600005   BEQL V1, ZERO, 0x9D006FEC
9D006FD8  27828020   ADDIU V0, GP, -32736
9D006FEC  00441021   ADDU V0, V0, A0
9D006FF0  A0400000   SB ZERO, 0(V0)
594:                   }
595:                   
596:                   return sum[n]/AVGC;
9D006FF4  00042080   SLL A0, A0, 2
9D006FF8  3C02A000   LUI V0, -24576
9D006FFC  24420138   ADDIU V0, V0, 312
9D007000  00822021   ADDU A0, A0, V0
9D007004  8C830000   LW V1, 0(A0)
9D007008  24620003   ADDIU V0, V1, 3
9D00700C  28640000   SLTI A0, V1, 0
9D007010  0064100A   MOVZ V0, V1, A0
597:                 }
9D007014  03E00008   JR RA
598:                 
599:                 
600:                 inline char scale_joystick_pot(int v, int center)
601:                 {
602:                   v = center-v;
9D0016D0  0B4005C8   J 0x9D001720
9D0016D4  00001021   ADDU V0, ZERO, ZERO
9D0017A4  0B4005FD   J 0x9D0017F4
9D0017A8  00001021   ADDU V0, ZERO, ZERO
9D001878  0B400632   J 0x9D0018C8
9D00187C  00001021   ADDU V0, ZERO, ZERO
9D001950  0B400668   J 0x9D0019A0
9D001954  00001021   ADDU V0, ZERO, ZERO
603:                   
604:                   if( v<0 && center!=1023 )
9D0016D8  04410009   BGEZ V0, check_joystick::scale_joystick_pot
9D0016DC  240403FF   ADDIU A0, ZERO, 1023
9D0016E0  106400EE   BEQ V1, A0, check_joystick::scale_joystick_pot
9D0016E4  00000000   NOP
9D0017AC  04410009   BGEZ V0, check_joystick::scale_joystick_pot
9D0017B0  240403FF   ADDIU A0, ZERO, 1023
9D0017B4  106400BD   BEQ V1, A0, check_joystick::scale_joystick_pot
9D0017B8  00000000   NOP
9D001880  04410009   BGEZ V0, check_joystick::scale_joystick_pot
9D001884  240403FF   ADDIU A0, ZERO, 1023
9D001888  1064008C   BEQ V1, A0, check_joystick::scale_joystick_pot
9D00188C  00000000   NOP
9D001958  04410009   BGEZ V0, check_joystick::scale_joystick_pot
9D00195C  240403FF   ADDIU A0, ZERO, 1023
9D001960  1064005A   BEQ V1, A0, check_joystick::scale_joystick_pot
9D001964  00000000   NOP
605:                     v = v*128/(1023-center);
9D0016E8  000211C0   SLL V0, V0, 7
9D0016EC  00831823   SUBU V1, A0, V1
9D0016F0  0043001A   DIV V0, V1
9D0016F4  006001F4   TEQ V1, ZERO
9D0016F8  0B4005C8   J 0x9D001720
9D0016FC  00001012   MFLO V0
9D0017BC  000211C0   SLL V0, V0, 7
9D0017C0  00831823   SUBU V1, A0, V1
9D0017C4  0043001A   DIV V0, V1
9D0017C8  006001F4   TEQ V1, ZERO
9D0017CC  0B4005FD   J 0x9D0017F4
9D0017D0  00001012   MFLO V0
9D001890  000211C0   SLL V0, V0, 7
9D001894  00831823   SUBU V1, A0, V1
9D001898  0043001A   DIV V0, V1
9D00189C  006001F4   TEQ V1, ZERO
9D0018A0  0B400632   J 0x9D0018C8
9D0018A4  00001012   MFLO V0
9D001968  000211C0   SLL V0, V0, 7
9D00196C  00831823   SUBU V1, A0, V1
9D001970  0043001A   DIV V0, V1
9D001974  006001F4   TEQ V1, ZERO
9D001978  0B400668   J 0x9D0019A0
9D00197C  00001012   MFLO V0
606:                   else if( v>0 && center!=0 )
9D001700  18400008   BLEZ V0, 0x9D001724
9D001704  24440004   ADDIU A0, V0, 4
9D001708  10600007   BEQ V1, ZERO, 0x9D001728
9D00170C  2C840009   SLTIU A0, A0, 9
9D0017D4  18400008   BLEZ V0, 0x9D0017F8
9D0017D8  24440004   ADDIU A0, V0, 4
9D0017DC  10600007   BEQ V1, ZERO, 0x9D0017FC
9D0017E0  2C840009   SLTIU A0, A0, 9
9D0018A8  18400008   BLEZ V0, 0x9D0018CC
9D0018AC  24440004   ADDIU A0, V0, 4
9D0018B0  10600007   BEQ V1, ZERO, 0x9D0018D0
9D0018B4  2C840009   SLTIU A0, A0, 9
9D001980  18400008   BLEZ V0, 0x9D0019A4
9D001984  24440004   ADDIU A0, V0, 4
9D001988  10600007   BEQ V1, ZERO, 0x9D0019A8
9D00198C  2C840009   SLTIU A0, A0, 9
9D001A9C  5C40FF1D   BGTZL V0, 0x9D001714
9D001AA0  000211C0   SLL V0, V0, 7
9D001AAC  5C40FF4E   BGTZL V0, 0x9D0017E8
9D001AB0  000211C0   SLL V0, V0, 7
9D001ABC  5C40FF7F   BGTZL V0, 0x9D0018BC
9D001AC0  000211C0   SLL V0, V0, 7
9D001ACC  5C40FFB1   BGTZL V0, 0x9D001994
9D001AD0  000211C0   SLL V0, V0, 7
607:                     v = v*128/center;
9D001710  000211C0   SLL V0, V0, 7
9D001714  0043001A   DIV V0, V1
9D001718  006001F4   TEQ V1, ZERO
9D00171C  00001012   MFLO V0
9D0017E4  000211C0   SLL V0, V0, 7
9D0017E8  0043001A   DIV V0, V1
9D0017EC  006001F4   TEQ V1, ZERO
9D0017F0  00001012   MFLO V0
9D0018B8  000211C0   SLL V0, V0, 7
9D0018BC  0043001A   DIV V0, V1
9D0018C0  006001F4   TEQ V1, ZERO
9D0018C4  00001012   MFLO V0
9D001990  000211C0   SLL V0, V0, 7
9D001994  0043001A   DIV V0, V1
9D001998  006001F4   TEQ V1, ZERO
9D00199C  00001012   MFLO V0
608:                     
609:                   // Some games can have problems if the joystick values 
610:                   // go all the way to extremes -128/127. For example there seems to be
611:                   // a bug in Gotcha where if the initial value read for the joystick 
612:                   // is 0 then a full left or full down (value -128) will actually move
613:                   // the player in the opposite direction.
614:                   // So we keep the values in range -127..126 to avoid that.
615:                   if( v>=-4 && v<=4 ) 
9D001720  24440004   ADDIU A0, V0, 4
9D001724  2C840009   SLTIU A0, A0, 9
9D001728  1480000A   BNE A0, ZERO, 0x9D001754
9D00172C  00001821   ADDU V1, ZERO, ZERO
9D0017F4  24440004   ADDIU A0, V0, 4
9D0017F8  2C840009   SLTIU A0, A0, 9
9D0017FC  1480000A   BNE A0, ZERO, 0x9D001828
9D001800  00001821   ADDU V1, ZERO, ZERO
9D0018C8  24440004   ADDIU A0, V0, 4
9D0018CC  2C840009   SLTIU A0, A0, 9
9D0018D0  1480000A   BNE A0, ZERO, 0x9D0018FC
9D0018D4  00001821   ADDU V1, ZERO, ZERO
9D0019A0  24440004   ADDIU A0, V0, 4
9D0019A4  2C840009   SLTIU A0, A0, 9
9D0019A8  1480000A   BNE A0, ZERO, 0x9D0019D4
9D0019AC  00001821   ADDU V1, ZERO, ZERO
9D001AA4  0B4005C9   J 0x9D001724
9D001AA8  24440004   ADDIU A0, V0, 4
9D001AB4  0B4005FE   J 0x9D0017F8
9D001AB8  24440004   ADDIU A0, V0, 4
9D001AC4  0B400633   J 0x9D0018CC
9D001AC8  24440004   ADDIU A0, V0, 4
9D001AD4  0B400669   J 0x9D0019A4
9D001AD8  24440004   ADDIU A0, V0, 4
616:                    return 0; 
617:                   else if( v<-127 )
9D001730  2843FF81   SLTI V1, V0, -127
9D001734  14600006   BNE V1, ZERO, check_joystick::scale_joystick_pot
9D001738  2843007F   SLTI V1, V0, 127
9D001804  2843FF81   SLTI V1, V0, -127
9D001808  14600006   BNE V1, ZERO, check_joystick::scale_joystick_pot
9D00180C  2843007F   SLTI V1, V0, 127
9D0018D8  2843FF81   SLTI V1, V0, -127
9D0018DC  14600006   BNE V1, ZERO, check_joystick::scale_joystick_pot
9D0018E0  2843007F   SLTI V1, V0, 127
9D0019B0  2843FF81   SLTI V1, V0, -127
9D0019B4  14600006   BNE V1, ZERO, check_joystick::scale_joystick_pot
9D0019B8  2843007F   SLTI V1, V0, 127
618:                     return -127;
9D001750  2403FF81   ADDIU V1, ZERO, -127
9D001824  2403FF81   ADDIU V1, ZERO, -127
9D0018F8  2403FF81   ADDIU V1, ZERO, -127
9D0019D0  2403FF81   ADDIU V1, ZERO, -127
619:                   else if( v>126 )
620:                     return 126;
621:                   else
622:                     return v;
9D00173C  7C021420   SEB V0, V0
9D001740  2404007E   ADDIU A0, ZERO, 126
9D001744  0043200B   MOVN A0, V0, V1
9D001748  0B4005D5   J 0x9D001754
9D00174C  00801821   ADDU V1, A0, ZERO
9D001810  7C021420   SEB V0, V0
9D001814  2404007E   ADDIU A0, ZERO, 126
9D001818  0043200B   MOVN A0, V0, V1
9D00181C  0B40060A   J 0x9D001828
9D001820  00801821   ADDU V1, A0, ZERO
9D0018E4  7C021420   SEB V0, V0
9D0018E8  2404007E   ADDIU A0, ZERO, 126
9D0018EC  0043200B   MOVN A0, V0, V1
9D0018F0  0B40063F   J 0x9D0018FC
9D0018F4  00801821   ADDU V1, A0, ZERO
9D0019BC  7C021420   SEB V0, V0
9D0019C0  2404007E   ADDIU A0, ZERO, 126
9D0019C4  0043200B   MOVN A0, V0, V1
9D0019C8  0B400675   J 0x9D0019D4
9D0019CC  00801821   ADDU V1, A0, ZERO
623:                 }
624:                 
625:                 
626:                 uint8_t read_joystick_buttons()
627:                 {
628:                   int delay;
629:                   uint8_t i, b = 0;
9D00822C  00001021   ADDU V0, ZERO, ZERO
630:                 
631:                   // turn off clock
632:                   ButtonsClockOff();
633:                    
634:                   // produce low pulse on "shift/load"
635:                   ButtonsShiftOff();
636:                   for(delay=0; delay<5; delay++) asm volatile("nop");
9D00820C  00000000   NOP
9D008210  00000000   NOP
9D008214  00000000   NOP
9D008218  00000000   NOP
9D00821C  00000000   NOP
637:                   ButtonsShiftOn();
638:                 
639:                   for(i=0; i<8; i++)
9D00827C  5460FFF1   BNEL V1, ZERO, 0x9D008244
9D008280  00021040   SLL V0, V0, 1
640:                     {
641:                       // read data
642:                       b = b * 2;
9D008240  00021040   SLL V0, V0, 1
9D008244  304200FF   ANDI V0, V0, 255
643:                       if( ButtonsDataStateGet() ) b |= 1;
9D008250  34450001   ORI A1, V0, 1
9D008254  00A6100B   MOVN V0, A1, A2
644:                 
645:                       // pulse clock
646:                       ButtonsClockOn();
647:                       for(delay=0; delay<5; delay++) asm volatile("nop");
9D00825C  00000000   NOP
9D008260  00000000   NOP
9D008264  00000000   NOP
9D008268  00000000   NOP
9D00826C  00000000   NOP
648:                       ButtonsClockOff();
649:                     }
650:                    
651:                   ButtonsShiftOff();
652:                   return b;
653:                 }
9D008290  03E00008   JR RA
654:                 
655:                 
656:                 void check_joystick()
657:                 {
9D001620  27BDFFE8   ADDIU SP, SP, -24
9D001624  AFBF0014   SW RA, 20(SP)
9D001628  AFB00010   SW S0, 16(SP)
658:                   int v;
659:                   static int joy1_center_x = -1, joy1_center_y = -1;
660:                   static int joy2_center_x = -1, joy2_center_y = -1;
661:                   static int x1  = 0, y1  = 0, x2  = 0, y2  = 0, b1  = 0, b2  = 0;
662:                   static int x1p = 0, y1p = 0, x2p = 0, y2p = 0, b1p = 0, b2p = 0;
663:                   static int m = 0;
664:                 
665:                   // during the first few lines of the vertical back porch
666:                   // do one "joystick action" per scan line
667:                   if( g_current_line==m )
9D00162C  8F8280A8   LW V0, -32600(GP)
9D001630  8F838068   LW V1, -32664(GP)
9D001634  5443012A   BNEL V0, V1, 0x9D001AE0
9D001638  8FBF0014   LW RA, 20(SP)
668:                     {
669:                       switch( m )
9D00163C  2C430008   SLTIU V1, V0, 8
9D001640  10600126   BEQ V1, ZERO, 0x9D001ADC
9D001644  00021080   SLL V0, V0, 2
9D001648  3C039D00   LUI V1, -25344
9D00164C  24631660   ADDIU V1, V1, 5728
9D001650  00621021   ADDU V0, V1, V0
9D001654  8C420000   LW V0, 0(V0)
9D001658  00400008   JR V0
9D00165C  00000000   NOP
670:                         {
671:                         case 0: 
672:                           // set ADC to read AN9 input (joystick 1, x axis)
673:                           PLIB_ADC_MuxChannel0InputPositiveSelect(ADC_ID_1, ADC_MUX_A, ADC_INPUT_POSITIVE_AN9);
674:                           PLIB_ADC_SamplingStart(ADC_ID_1);
675:                           m++;
9D0016A0  24020001   ADDIU V0, ZERO, 1
676:                           break;
9D0016A4  0B4006B7   J 0x9D001ADC
9D0016A8  AF828068   SW V0, -32664(GP)
677:                 
678:                         case 1: 
679:                           // read joystick 1, x axis, initialize center on first read
680:                           v = rolling_average(0, PLIB_ADC_ResultGetByIndex(ADC_ID_1, 0));
9D0016B8  0F401BCD   JAL rolling_average
9D0016BC  00002021   ADDU A0, ZERO, ZERO
681:                           if( joy1_center_x < 0 ) joy1_center_x = v;
9D0016C0  8F83801C   LW V1, -32740(GP)
9D0016C4  04630004   BGEZL V1, check_joystick::scale_joystick_pot
9D0016C8  00621023   SUBU V0, V1, V0
9D0016CC  AF82801C   SW V0, -32740(GP)
682:                           x1 = scale_joystick_pot(v, joy1_center_x);
9D001754  AF838064   SW V1, -32668(GP)
683:                           // set ADC to read AN10 input (joystick 1, y axis)
684:                           PLIB_ADC_MuxChannel0InputPositiveSelect(ADC_ID_1, ADC_MUX_A, ADC_INPUT_POSITIVE_AN10);
685:                           PLIB_ADC_SamplingStart(ADC_ID_1);
686:                           m++;
687:                           break;
9D001778  0B4006B7   J 0x9D001ADC
9D00177C  AF838068   SW V1, -32664(GP)
688:                                    
689:                         case 2: 
690:                           // read joystick 1, y axis, initialize center on first read
691:                           v = rolling_average(1, PLIB_ADC_ResultGetByIndex(ADC_ID_1, 0));
9D00178C  0F401BCD   JAL rolling_average
9D001790  24040001   ADDIU A0, ZERO, 1
692:                           if( joy1_center_y < 0 ) joy1_center_y = v;
9D001794  8F838018   LW V1, -32744(GP)
9D001798  04630004   BGEZL V1, check_joystick::scale_joystick_pot
9D00179C  00621023   SUBU V0, V1, V0
9D0017A0  AF828018   SW V0, -32744(GP)
693:                           y1 = scale_joystick_pot(v, joy1_center_y);
9D001828  AF838060   SW V1, -32672(GP)
694:                           // set ADC to read AN0 input (joystick 2, x axis)
695:                           PLIB_ADC_MuxChannel0InputPositiveSelect(ADC_ID_1, ADC_MUX_A, ADC_INPUT_POSITIVE_AN0);
696:                           PLIB_ADC_SamplingStart(ADC_ID_1);
697:                           m++;
9D001848  24020003   ADDIU V0, ZERO, 3
698:                           break;
9D00184C  0B4006B7   J 0x9D001ADC
9D001850  AF828068   SW V0, -32664(GP)
699:                                    
700:                         case 3: 
701:                           // read joystick 2, x axis, initialize center on first read
702:                           v = rolling_average(2, PLIB_ADC_ResultGetByIndex(ADC_ID_1, 0));
9D001860  0F401BCD   JAL rolling_average
9D001864  24040002   ADDIU A0, ZERO, 2
703:                           if( joy2_center_x < 0 ) joy2_center_x = v;
9D001868  8F838014   LW V1, -32748(GP)
9D00186C  04630004   BGEZL V1, check_joystick::scale_joystick_pot
9D001870  00621023   SUBU V0, V1, V0
9D001874  AF828014   SW V0, -32748(GP)
704:                           x2 = scale_joystick_pot(v, joy2_center_x);
9D0018FC  AF83805C   SW V1, -32676(GP)
705:                           // set ADC to read AN1 input (joystick 2, y axis)
706:                           PLIB_ADC_MuxChannel0InputPositiveSelect(ADC_ID_1, ADC_MUX_A, ADC_INPUT_POSITIVE_AN1);
707:                           PLIB_ADC_SamplingStart(ADC_ID_1);
708:                           m++;
9D001920  24020004   ADDIU V0, ZERO, 4
709:                           break;
9D001924  0B4006B7   J 0x9D001ADC
9D001928  AF828068   SW V0, -32664(GP)
710:                                    
711:                         case 4: 
712:                           // read joystick 2, y axis, initialize center on first read
713:                           v = rolling_average(3, PLIB_ADC_ResultGetByIndex(ADC_ID_1, 0));
9D001938  0F401BCD   JAL rolling_average
9D00193C  24040003   ADDIU A0, ZERO, 3
714:                           if( joy2_center_y < 0 ) joy2_center_y = v;
9D001940  8F838010   LW V1, -32752(GP)
9D001944  04630004   BGEZL V1, check_joystick::scale_joystick_pot
9D001948  00621023   SUBU V0, V1, V0
9D00194C  AF828010   SW V0, -32752(GP)
715:                           y2 = scale_joystick_pot(v, joy2_center_y);
9D0019D4  AF838058   SW V1, -32680(GP)
716:                           m++;
9D0019D8  24020005   ADDIU V0, ZERO, 5
717:                           break;
9D0019DC  0B4006B7   J 0x9D001ADC
9D0019E0  AF828068   SW V0, -32664(GP)
718:                                    
719:                         case 5: 
720:                           {
721:                             // read joystick buttons
722:                             uint8_t b = read_joystick_buttons();
9D0019E4  0F40207E   JAL read_joystick_buttons
9D0019E8  00000000   NOP
723:                             b1 = b & 0x0f;
9D0019EC  3043000F   ANDI V1, V0, 15
9D0019F0  AF838054   SW V1, -32684(GP)
724:                             b2 = b / 16;
9D0019F4  7C423900   EXT V0, V0, 4, 8
9D0019F8  AF828050   SW V0, -32688(GP)
725:                             m++;
9D0019FC  24020006   ADDIU V0, ZERO, 6
726:                             break;
9D001A00  0B4006B7   J 0x9D001ADC
9D001A04  AF828068   SW V0, -32664(GP)
727:                           }
728:                               
729:                         case 6: 
730:                           {
731:                 #if USE_USB>0
732:                             // copy joystick 1 data to USB send buffer
733:                             uint8_t *jd = (uint8_t *) &usb_joydata;
734:                             jd[0] = DAZ_JOY1 | b1;
9D001A08  8F908054   LW S0, -32684(GP)
9D001A0C  27828090   ADDIU V0, GP, -32624
9D001A10  36030010   ORI V1, S0, 16
9D001A14  A0430000   SB V1, 0(V0)
735:                             jd[1] = x1;
9D001A18  8F848064   LW A0, -32668(GP)
9D001A1C  A0440001   SB A0, 1(V0)
736:                             jd[2] = y1;
9D001A20  8F858060   LW A1, -32672(GP)
9D001A24  A0450002   SB A1, 2(V0)
737:                 #else
738:                             // check if there are any any changes for joystick 1
739:                             if( x1!=x1p || y1!=y1p || b1 != b1p )
740:                               {
741:                                 // send joystick 1 data over serial
742:                                 PLIB_USART_TransmitterByteSend(USART_ID_2, DAZ_JOY1 | b1);
743:                                 PLIB_USART_TransmitterByteSend(USART_ID_2, x1);
744:                                 PLIB_USART_TransmitterByteSend(USART_ID_2, y1);
745:                              
746:                                 // remember current values
747:                                 x1p = x1; y1p = y1; b1p = b1;
748:                               }
749:                 #endif
750:                             // draw calibration info if in calibration mode
751:                             if( test_mode==1 ) 
9D001A28  24020001   ADDIU V0, ZERO, 1
9D001A2C  8F8380A0   LW V1, -32608(GP)
9D001A30  14620006   BNE V1, V0, 0x9D001A4C
9D001A34  24020007   ADDIU V0, ZERO, 7
752:                               {
753:                                 draw_joystick_pixel(x1, y1);
9D001A38  0F4020F0   JAL draw_joystick_pixel
9D001A3C  00000000   NOP
754:                                 draw_joystick_buttons(b1);
9D001A40  0F402272   JAL draw_joystick_buttons
9D001A44  320400FF   ANDI A0, S0, 255
755:                               }
756:                  
757:                             m++;
9D001A48  24020007   ADDIU V0, ZERO, 7
758:                             break;
9D001A4C  0B4006B7   J 0x9D001ADC
9D001A50  AF828068   SW V0, -32664(GP)
759:                           }
760:                           
761:                         case 7:
762:                           {
763:                 #if USE_USB>0
764:                             // copy joystick 2 data to USB send buffer
765:                             uint8_t *jd = (uint8_t *) &usb_joydata;
766:                             jd[3] = DAZ_JOY2 | b2;
9D001A54  8F908050   LW S0, -32688(GP)
9D001A58  27828090   ADDIU V0, GP, -32624
9D001A5C  36030020   ORI V1, S0, 32
9D001A60  A0430003   SB V1, 3(V0)
767:                             jd[4] = x2;
9D001A64  8F84805C   LW A0, -32676(GP)
9D001A68  A0440004   SB A0, 4(V0)
768:                             jd[5] = y2;
9D001A6C  8F858058   LW A1, -32680(GP)
9D001A70  A0450005   SB A1, 5(V0)
769:                 #else          
770:                             // check if there are any any changes for joystick 2
771:                             if( x2!=x2p || y2!=y2p || b2 != b2p )
772:                               {
773:                                 // send joystick 2 data over serial
774:                                 PLIB_USART_TransmitterByteSend(USART_ID_2, DAZ_JOY2 | b2);
775:                                 PLIB_USART_TransmitterByteSend(USART_ID_2, x2);
776:                                 PLIB_USART_TransmitterByteSend(USART_ID_2, y2);
777:                 
778:                                 // remember current values
779:                                 x2p = x2; y2p = y2; b2p = b2;
780:                               }
781:                 #endif
782:                 
783:                             // draw calibration info if in calibration mode
784:                             if( test_mode==2 ) 
9D001A74  24020002   ADDIU V0, ZERO, 2
9D001A78  8F8380A0   LW V1, -32608(GP)
9D001A7C  54620017   BNEL V1, V0, 0x9D001ADC
9D001A80  AF808068   SW ZERO, -32664(GP)
785:                               {
786:                                 draw_joystick_pixel(x2, y2);
9D001A84  0F4020F0   JAL draw_joystick_pixel
9D001A88  00000000   NOP
787:                                 draw_joystick_buttons(b2);
9D001A8C  0F402272   JAL draw_joystick_buttons
9D001A90  320400FF   ANDI A0, S0, 255
788:                               }
789:                           
790:                             m=0;
791:                             break;
9D001A94  0B4006B7   J 0x9D001ADC
9D001A98  AF808068   SW ZERO, -32664(GP)
792:                           }
793:                         }
794:                     }
795:                 }
9D001ADC  8FBF0014   LW RA, 20(SP)
796:                 
797:                 
798:                 // -----------------------------------------------------------------------------
799:                 // -------------------------------- video output -------------------------------
800:                 // -----------------------------------------------------------------------------
801:                 
802:                 
803:                 void __ISR(_TIMER_2_VECTOR, ipl7AUTO) IntHandlerTimer2(void)
804:                 {
9D004FE8  415DE800   RDPGPR SP, SP
9D004FEC  401B7000   MFC0 K1, EPC
9D004FF0  401A6002   MFC0 K0, SRSCtl
9D004FF4  27BDFFE0   ADDIU SP, SP, -32
9D004FF8  401B6000   MFC0 K1, Status
9D004FFC  AFBA0018   SW K0, 24(SP)
9D005000  AFBB001C   SW K1, 28(SP)
9D005004  7C1B7844   INS K1, ZERO, 1, 15
9D005008  377B1C00   ORI K1, K1, 7168
9D00500C  409B6000   MTC0 K1, Status
9D005010  AFA30004   SW V1, 4(SP)
9D005014  AFA20000   SW V0, 0(SP)
9D005018  8FA30018   LW V1, 24(SP)
9D00501C  3063000F   ANDI V1, V1, 15
9D005020  14600003   BNE V1, ZERO, 0x9D005030
9D005024  00000000   NOP
9D005028  AFA5000C   SW A1, 12(SP)
9D00502C  AFA40008   SW A0, 8(SP)
805:                   // This interrupt happens when timer2 runs over, which signifies
806:                   // the end of the horizontal back porch (i.e. left margin).
807:                   // We use this interrupt to time the beginning of picture data
808:                   // and to set up the output compare registers producing the VSYNC pulse
809:                 
810:                   if( g_current_line>=VBP_LENGTH && g_current_line<(VBP_LENGTH+DISPLAY_LINES) )
9D005030  8F8280A8   LW V0, -32600(GP)
9D005034  28420043   SLTI V0, V0, 67
9D005038  1440001C   BNE V0, ZERO, 0x9D0050AC
9D00503C  00000000   NOP
9D005040  8F8280A8   LW V0, -32600(GP)
9D005044  28420243   SLTI V0, V0, 579
9D005048  10400018   BEQ V0, ZERO, 0x9D0050AC
9D00504C  00000000   NOP
811:                     {
812:                       // we are in the vertically visible region
813:                       uint8_t *ptr = framebuffer[(g_current_line-VBP_LENGTH)/4];
9D005050  8F8380A8   LW V1, -32600(GP)
9D005060  2463FFC0   ADDIU V1, V1, -64
9D005064  28440000   SLTI A0, V0, 0
9D005068  0044180A   MOVZ V1, V0, A0
9D00506C  00031883   SRA V1, V1, 2
9D005070  00031080   SLL V0, V1, 2
9D005074  000319C0   SLL V1, V1, 7
9D005078  00431821   ADDU V1, V0, V1
9D00507C  3C02A000   LUI V0, -24576
9D005080  24420640   ADDIU V0, V0, 1600
9D005084  00431021   ADDU V0, V0, V1
814:                       uint8_t *end = ptr + 129;
9D005088  24440081   ADDIU A0, V0, 129
815:                 
816:                       if( dazzler_ctrl & 0x80 )
9D005054  838280A4   LB V0, -32604(GP)
9D005058  0441002B   BGEZ V0, 0x9D005108
9D00505C  2462FFBD   ADDIU V0, V1, -67
817:                         // The assembly code below outputs the pixels at roughly a
818:                         // 9.7MHz rate (pixel clock). The loop is just the same as the
819:                         // following C code: while( ptr!=end ) LATB = *ptr++;
820:                         // It is in assembly here since it its timing is essential and we
821:                         // do not want compiler optimization settings to influence the code.
822:                         // One small difference is that the assembly code (unlike the
823:                         // C code) only updates the lower 8 bits of LATB, leaving the 
824:                         // upper 24 bits unchanged. That allows us to still use RB8-15
825:                         // as other outputs that do not constantly get overwritten.
826:                         // The ".set noreorder" prevents the assembler from trying to
827:                         // reorganize the code for better performance. Note that the
828:                         // final ADDIU sits in the BNE's "branch delay slot" and gets
829:                         // executed even though it appears to be outside the loop.
830:                         asm volatile ("    .set noreorder    \n"
9D00508C  3C05BF88   LUI A1, -16504
9D005090  24A56130   ADDIU A1, A1, 24880
9D005094  24420001   ADDIU V0, V0, 1
9D005098  9043FFFF   LBU V1, -1(V0)
9D00509C  A0A30000   SB V1, 0(A1)
9D0050A0  1444FFFD   BNE V0, A0, lp
9D0050A4  24420001   ADDIU V0, V0, 1
9D0050A8  0B401442   J 0x9D005108
831:                                       "    ADDIU  %0, %0, 1  \n"      
832:                                       "lp: LBU    $3, -1(%0) \n"
833:                                       "    SB     $3,  0(%2) \n"
834:                                       "    BNE    %0, %1, lp \n"
835:                                       "    ADDIU  %0, %0, 1  \n"
836:                                       :: "d"(ptr), "d"(end), "d"(&LATB) : "$3" );
837:                     }
838:                   else if( g_current_line==NUM_LINES-VSYNC_LENGTH-1 )
9D0050AC  8F8380A8   LW V1, -32600(GP)
9D0050B0  2402026F   ADDIU V0, ZERO, 623
9D0050B4  14620009   BNE V1, V0, 0x9D0050DC
9D0050B8  3C02BF80   LUI V0, -16512
839:                     {
840:                       // We are one line before the sync signal (i.e. the end of the vertical 
841:                       // front porch). Set up OC3 (output compare 3) to set 
842:                       // the vertical sync signal high at the next timer2 interrupt
843:                       PLIB_OC_ModeSelect(OC_ID_3, OC_SET_HIGH_SINGLE_PULSE_MODE);
844:                       PLIB_OC_Enable(OC_ID_3);
845:                     }
846:                   else if( g_current_line==NUM_LINES-1 )
9D0050DC  8F8380A8   LW V1, -32600(GP)
9D0050E0  24020273   ADDIU V0, ZERO, 627
9D0050E4  14620008   BNE V1, V0, 0x9D005108
9D0050E8  3C02BF80   LUI V0, -16512
847:                     {
848:                       // We are one line before the end of the sync signal (i.e. the beginning
849:                       // of the vertical back porch). Set up OC3 (output compare 3) 
850:                       // to set the vertical sync signal low at the next timer2 interrupt
851:                       PLIB_OC_ModeSelect(OC_ID_3, OC_SET_LOW_SINGLE_PULSE_MODE);
852:                       PLIB_OC_Enable(OC_ID_3);
853:                     }
854:                 
855:                 #if USE_USB==0
856:                   // The line rate is 37300Hz, i.e. each line takes 0.027 milliseconds.
857:                   // At 750000 baud, each character (10 bits) takes 0.013 milliseconds
858:                   // => no more than 3 characters can be received per line
859:                   ringbuffer_enqueue_usart(); 
860:                   ringbuffer_enqueue_usart(); 
861:                   ringbuffer_enqueue_usart();
862:                 #endif
863:                     
864:                   // increase line counter and roll over when we reach the bottom of the screen
865:                   if( ++g_current_line==NUM_LINES ) g_current_line=0;
9D005108  8F8280A8   LW V0, -32600(GP)
9D00510C  24420001   ADDIU V0, V0, 1
9D005110  AF8280A8   SW V0, -32600(GP)
9D005114  24030274   ADDIU V1, ZERO, 628
9D005118  50430001   BEQL V0, V1, IntHandlerTimer2::PLIB_INT_SourceFlagClear
9D00511C  AF8080A8   SW ZERO, -32600(GP)
866:                 
867:                   // allow next interrupt
868:                   PLIB_INT_SourceFlagClear(INT_ID_0,INT_SOURCE_TIMER_2);
869:                 }
9D005130  8FA20018   LW V0, 24(SP)
870:                 
871:                 
872:                 void __ISR(_OUTPUT_COMPARE_2_VECTOR, ipl6AUTO) IntHandlerOC2(void)
873:                 {
9D006988  415DE800   RDPGPR SP, SP
9D00698C  401B7000   MFC0 K1, EPC
9D006990  401A6002   MFC0 K0, SRSCtl
9D006994  27BDFFE8   ADDIU SP, SP, -24
9D006998  AFBB0014   SW K1, 20(SP)
9D00699C  401B6000   MFC0 K1, Status
9D0069A0  AFBA000C   SW K0, 12(SP)
9D0069A4  AFBB0010   SW K1, 16(SP)
9D0069A8  7C1B7844   INS K1, ZERO, 1, 15
9D0069AC  377B1800   ORI K1, K1, 6144
9D0069B0  409B6000   MTC0 K1, Status
9D0069B4  AFA30004   SW V1, 4(SP)
9D0069B8  AFA20000   SW V0, 0(SP)
874:                   // This interrupt occurs a few cycles before the timer2 interrupt
875:                   // and its purpose is to put the CPU in a defined state that allows
876:                   // the timer2 interrupt to occur precisely at its scheduled time and
877:                   // not be delayed by a few cycles due to the current CPU activity
878:                   // (which causes a "wobbly" picture).
879:                     
880:                 #if USE_USB==0
881:                   asm volatile("wait");
882:                 #else
883:                   // For some reason putting the CPU into idle mode prevents USB from 
884:                   // working properly (even if PLIB_USB_StopInIdleDisable was called).
885:                   // So instead we just execute enough NOPs to delay until
886:                   // the timer2 interrupt happens.
887:                   asm volatile("\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n");
9D0069BC  00000000   NOP
9D0069C0  00000000   NOP
9D0069C4  00000000   NOP
9D0069C8  00000000   NOP
9D0069CC  00000000   NOP
9D0069D0  00000000   NOP
9D0069D4  00000000   NOP
9D0069D8  00000000   NOP
9D0069DC  00000000   NOP
9D0069E0  00000000   NOP
888:                   asm volatile("\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n");
9D0069E4  00000000   NOP
9D0069E8  00000000   NOP
9D0069EC  00000000   NOP
9D0069F0  00000000   NOP
9D0069F4  00000000   NOP
9D0069F8  00000000   NOP
9D0069FC  00000000   NOP
9D006A00  00000000   NOP
9D006A04  00000000   NOP
9D006A08  00000000   NOP
889:                   asm volatile("\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n");
9D006A0C  00000000   NOP
9D006A10  00000000   NOP
9D006A14  00000000   NOP
9D006A18  00000000   NOP
9D006A1C  00000000   NOP
9D006A20  00000000   NOP
9D006A24  00000000   NOP
9D006A28  00000000   NOP
9D006A2C  00000000   NOP
9D006A30  00000000   NOP
890:                 #endif
891:                   PLIB_INT_SourceFlagClear(INT_ID_0,INT_SOURCE_OUTPUT_COMPARE_2);
892:                 }
9D006A44  8FA2000C   LW V0, 12(SP)
893:                 
894:                     
895:                 // -----------------------------------------------------------------------------
896:                 // -------------------------------- USB handlers -------------------------------
897:                 // -----------------------------------------------------------------------------
898:                 
899:                 #if USE_USB>0
900:                 
901:                 static USB_HOST_CDC_OBJ    usbCdcObject     = NULL;
902:                 static USB_HOST_CDC_HANDLE usbCdcHostHandle = USB_HOST_CDC_HANDLE_INVALID;
903:                 static uint8_t usbInData[64];
904:                 volatile bool usbBusy = false;
905:                 
906:                 
907:                 void usbScheduleTransfer()
908:                 {
9D007E90  27BDFFE8   ADDIU SP, SP, -24
9D007E94  AFBF0014   SW RA, 20(SP)
909:                   static uint64_t joydata_prev = 0;
910:                 
911:                   if( usbBusy )
9D007E98  93828084   LBU V0, -32636(GP)
9D007E9C  304200FF   ANDI V0, V0, 255
9D007EA0  54400027   BNEL V0, ZERO, 0x9D007F40
9D007EA4  8FBF0014   LW RA, 20(SP)
912:                     {
913:                       // a USB read or write request is currently in process so we can't
914:                       // schedule a transfer right now
915:                       return;
916:                     }
917:                   else if( usb_joydata!=joydata_prev )
9D007EA8  8F828090   LW V0, -32624(GP)
9D007EAC  8F838094   LW V1, -32620(GP)
9D007EB0  8F848048   LW A0, -32696(GP)
9D007EB4  14820003   BNE A0, V0, 0x9D007EC4
9D007EB8  8F82804C   LW V0, -32692(GP)
9D007EBC  1043000E   BEQ V0, V1, 0x9D007EF8
9D007EC0  8F82809C   LW V0, -32612(GP)
918:                     {
919:                       // note that the joystick data is only updated once per frame
920:                       // so at 60fps it can not change fast enough to starve out the reads
921:                       joydata_prev = usb_joydata;
9D007EC4  8F828090   LW V0, -32624(GP)
9D007EC8  8F838094   LW V1, -32620(GP)
9D007ECC  AF828048   SW V0, -32696(GP)
9D007ED0  AF83804C   SW V1, -32692(GP)
922:                       USB_HOST_CDC_Write(usbCdcHostHandle, NULL, (void *) &joydata_prev, 6);
9D007ED4  8F848028   LW A0, -32728(GP)
9D007ED8  00002821   ADDU A1, ZERO, ZERO
9D007EDC  27868048   ADDIU A2, GP, -32696
9D007EE0  0F402218   JAL USB_HOST_CDC_Write
9D007EE4  24070006   ADDIU A3, ZERO, 6
923:                       usbBusy = true;
9D007EE8  24020001   ADDIU V0, ZERO, 1
9D007EEC  A3828084   SB V0, -32636(GP)
9D007EF0  0B401FD0   J 0x9D007F40
9D007EF4  8FBF0014   LW RA, 20(SP)
924:                     }
925:                   else
926:                     {
927:                       // If there is space available in the ringbuffer then ask the client
928:                       // to send more data. If there is no space then do not start another
929:                       // request until we have processed some data and space is available.
930:                       size_t avail = ringbuffer_available();
9D007EF8  2442FFFF   ADDIU V0, V0, -1
9D007EFC  8F838098   LW V1, -32616(GP)
9D007F00  00431023   SUBU V0, V0, V1
9D007F04  30420FFF   ANDI V0, V0, 4095
931:                       if( avail>0 ) 
9D007F08  1040000D   BEQ V0, ZERO, 0x9D007F40
9D007F0C  8FBF0014   LW RA, 20(SP)
932:                         {
933:                           USB_HOST_CDC_Read(usbCdcHostHandle, NULL, usbInData, avail > 64 ? 64 : avail);
9D007F10  2C470041   SLTIU A3, V0, 65
9D007F14  8F848028   LW A0, -32728(GP)
9D007F18  00002821   ADDU A1, ZERO, ZERO
9D007F1C  3C06A000   LUI A2, -24576
9D007F20  24C60188   ADDIU A2, A2, 392
9D007F24  24030040   ADDIU V1, ZERO, 64
9D007F28  0067100A   MOVZ V0, V1, A3
9D007F2C  0F4022AD   JAL USB_HOST_CDC_Read
9D007F30  00403821   ADDU A3, V0, ZERO
934:                           usbBusy = true;
9D007F34  24020001   ADDIU V0, ZERO, 1
9D007F38  A3828084   SB V0, -32636(GP)
935:                         }
936:                     }
937:                 }
9D007F3C  8FBF0014   LW RA, 20(SP)
938:                 
939:                 
940:                 void USBHostCDCAttachEventListener(USB_HOST_CDC_OBJ cdcObj, uintptr_t context)
941:                 {
942:                   // a client has been attached
943:                   usbCdcObject = cdcObj;
9D009B34  03E00008   JR RA
944:                 }
945:                 
946:                 
947:                 USB_HOST_CDC_EVENT_RESPONSE USBHostCDCEventHandler(USB_HOST_CDC_HANDLE cdcHandle, USB_HOST_CDC_EVENT event, void * eventData, uintptr_t context)
948:                 {
9D007C54  27BDFFE8   ADDIU SP, SP, -24
949:                   USB_HOST_CDC_EVENT_WRITE_COMPLETE_DATA * writeCompleteEventData;
950:                   USB_HOST_CDC_EVENT_READ_COMPLETE_DATA * readCompleteEventData;
951:                     
952:                   switch(event)
9D007C58  24020001   ADDIU V0, ZERO, 1
9D007C5C  10A20023   BEQ A1, V0, 0x9D007CEC
9D007C60  AFBF0014   SW RA, 20(SP)
9D007C64  10A00005   BEQ A1, ZERO, 0x9D007C7C
9D007C68  24020007   ADDIU V0, ZERO, 7
9D007C6C  50A20024   BEQL A1, V0, 0x9D007D00
9D007C70  AF808088   SW ZERO, -32632(GP)
953:                     {
954:                     case USB_HOST_CDC_EVENT_READ_COMPLETE:
955:                       {
956:                         readCompleteEventData = (USB_HOST_CDC_EVENT_READ_COMPLETE_DATA *)(eventData);
957:                         if( readCompleteEventData->result == USB_HOST_CDC_RESULT_SUCCESS )
9D007C7C  8CC30004   LW V1, 4(A2)
9D007C80  24020001   ADDIU V0, ZERO, 1
9D007C84  14620014   BNE V1, V0, 0x9D007CD8
9D007C88  00000000   NOP
958:                           {
959:                             // received data from the client => put it in the ringbuffer so it can
960:                             // be processed when we get to it
961:                             size_t i;
962:                             for(i=0; i<readCompleteEventData->length; i++)
9D007C8C  8CC20008   LW V0, 8(A2)
9D007C90  10400011   BEQ V0, ZERO, 0x9D007CD8
9D007C94  8F838098   LW V1, -32616(GP)
9D007C98  00001021   ADDU V0, ZERO, ZERO
9D007CC0  24420001   ADDIU V0, V0, 1
9D007CC4  8CC40008   LW A0, 8(A2)
9D007CC8  0044202B   SLTU A0, V0, A0
9D007CCC  1480FFF7   BNE A0, ZERO, 0x9D007CAC
9D007CD0  30630FFF   ANDI V1, V1, 4095
9D007CD4  AF838098   SW V1, -32616(GP)
963:                               ringbuffer_enqueue(usbInData[i]);
964:                           }
965:                 
966:                         // transfer is finished => schedule the next transfer
967:                         usbBusy = false;
9D007CD8  A3808084   SB ZERO, -32636(GP)
968:                         usbScheduleTransfer();
9D007CDC  0F401FA4   JAL usbScheduleTransfer
9D007CE0  00000000   NOP
969:                         break;
9D007CE4  0B401F43   J 0x9D007D0C
9D007CE8  00001021   ADDU V0, ZERO, ZERO
970:                       }
971:                         
972:                     case USB_HOST_CDC_EVENT_WRITE_COMPLETE:
973:                       {   
974:                         // transfer is finished => schedule the next transfer
975:                         usbBusy = false;
9D007CEC  A3808084   SB ZERO, -32636(GP)
976:                         usbScheduleTransfer();
9D007CF0  0F401FA4   JAL usbScheduleTransfer
9D007CF4  00000000   NOP
977:                         break;
9D007CF8  0B401F43   J 0x9D007D0C
9D007CFC  00001021   ADDU V0, ZERO, ZERO
978:                       }
979:                             
980:                     case USB_HOST_CDC_EVENT_DEVICE_DETACHED:
981:                       {
982:                         // USB_HOST_CDC_Close(usbCdcHostHandle);
983:                         usbCdcObject = NULL;
984:                         usbCdcHostHandle = USB_HOST_CDC_HANDLE_INVALID;
9D007D00  2402FFFF   ADDIU V0, ZERO, -1
9D007D04  AF828028   SW V0, -32728(GP)
985:                         break;
986:                       }
987:                     }
988:                     
989:                   return(USB_HOST_CDC_EVENT_RESPONE_NONE);
990:                 }
9D007C74  0B401F43   J 0x9D007D0C
9D007C78  00001021   ADDU V0, ZERO, ZERO
9D007D08  00001021   ADDU V0, ZERO, ZERO
991:                 
992:                 
993:                 void usbTasks()
994:                 {
9D008764  27BDFFE8   ADDIU SP, SP, -24
9D008768  AFBF0014   SW RA, 20(SP)
995:                   if( usbCdcHostHandle==USB_HOST_CDC_HANDLE_INVALID )
9D00876C  2402FFFF   ADDIU V0, ZERO, -1
9D008770  8F838028   LW V1, -32728(GP)
9D008774  14620015   BNE V1, V0, 0x9D0087CC
9D008778  8F848088   LW A0, -32632(GP)
996:                     {
997:                       if( usbCdcObject!=NULL )
9D00877C  10800017   BEQ A0, ZERO, 0x9D0087DC
9D008780  8FBF0014   LW RA, 20(SP)
998:                         {
999:                           // a USB device was newly attached - try to open it
1000:                          usbCdcHostHandle = USB_HOST_CDC_Open(usbCdcObject);
9D008784  0F4025AD   JAL USB_HOST_CDC_Open
9D008788  00000000   NOP
1001:                          if(usbCdcHostHandle != USB_HOST_CDC_HANDLE_INVALID)
9D00878C  2403FFFF   ADDIU V1, ZERO, -1
9D008790  10430011   BEQ V0, V1, 0x9D0087D8
9D008794  AF828028   SW V0, -32728(GP)
1002:                            {
1003:                              // succeeded opening the device => all further processing is in event handler
1004:                              USB_HOST_CDC_EventHandlerSet(usbCdcHostHandle, USBHostCDCEventHandler, (uintptr_t)0);
9D008798  00402021   ADDU A0, V0, ZERO
9D00879C  3C059D00   LUI A1, -25344
9D0087A0  24A57C54   ADDIU A1, A1, 31828
9D0087A4  0F40266D   JAL USB_HOST_CDC_EventHandlerSet
9D0087A8  00003021   ADDU A2, ZERO, ZERO
1005:                          
1006:                              // request data
1007:                              USB_HOST_CDC_Read(usbCdcHostHandle, NULL, usbInData, 64);
9D0087AC  8F848028   LW A0, -32728(GP)
9D0087B0  00002821   ADDU A1, ZERO, ZERO
9D0087B4  3C06A000   LUI A2, -24576
9D0087B8  24C60188   ADDIU A2, A2, 392
9D0087BC  0F4022AD   JAL USB_HOST_CDC_Read
9D0087C0  24070040   ADDIU A3, ZERO, 64
1008:                            }
1009:                        }
1010:                    }
1011:                  else
1012:                    {
1013:                      // we have a connection => schedule a new transfer if none is currently going
1014:                      // (can't allow USB interrupts while scheduling a new transfer)
1015:                      asm volatile ("di");
1016:                      usbScheduleTransfer();
9D0087CC  0F401FA4   JAL usbScheduleTransfer
9D0087D0  41606000   DI ZERO
1017:                      asm volatile ("ei");
9D0087D4  41606020   EI ZERO
1018:                    }
1019:                }
9D0087C4  0B4021F7   J 0x9D0087DC
9D0087C8  8FBF0014   LW RA, 20(SP)
9D0087D8  8FBF0014   LW RA, 20(SP)
1020:                #endif
1021:                
1022:                // -----------------------------------------------------------------------------
1023:                // ------------------------------- initialization ------------------------------
1024:                // -----------------------------------------------------------------------------
1025:                
1026:                
1027:                void APP_Initialize ( void )
1028:                {
9D003040  27BDFFE0   ADDIU SP, SP, -32
9D003044  AFBF001C   SW RA, 28(SP)
9D003048  AFB10018   SW S1, 24(SP)
1029:                  int r, c, q;
1030:                
1031:                  // set CPU to switch into IDLE mode when executing "wait" instruction
1032:                  SYS_DEVCON_SystemUnlock();
9D00304C  0F40242A   JAL SYS_DEVCON_SystemUnlock
9D003050  AFB00014   SW S0, 20(SP)
1033:                  PLIB_OSC_OnWaitActionSet(OSC_ID_0, OSC_ON_WAIT_IDLE);
1034:                  SYS_DEVCON_SystemLock();
9D003064  0F402508   JAL SYS_DEVCON_SystemLock
9D003068  00000000   NOP
1035:                
1036:                  // set up timer 2 (at 24MHz)
1037:                  PLIB_TMR_ClockSourceSelect(TMR_ID_2, TMR_CLOCK_SOURCE_PERIPHERAL_CLOCK );
1038:                  PLIB_TMR_PrescaleSelect(TMR_ID_2, TMR_PRESCALE_VALUE_1);
1039:                  PLIB_TMR_Mode16BitEnable(TMR_ID_2);
1040:                  PLIB_TMR_Counter16BitClear(TMR_ID_2);
1041:                  PLIB_TMR_Period16BitSet(TMR_ID_2, NUM_PIXELS);
1042:                
1043:                  // set up timer 2 interrupt
1044:                  PLIB_INT_MultiVectorSelect( INT_ID_0 );
1045:                  PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_T2, INT_PRIORITY_LEVEL7);
1046:                  PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_T2, INT_SUBPRIORITY_LEVEL0);
1047:                  PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_TIMER_2);
1048:                  PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_TIMER_2);
1049:                    
1050:                  // set up output compare for HSYNC signal
1051:                  PLIB_OC_ModeSelect(OC_ID_1, OC_DUAL_COMPARE_CONTINUOUS_PULSE_MODE);
1052:                  PLIB_OC_BufferSizeSelect(OC_ID_1, OC_BUFFER_SIZE_16BIT);
1053:                  PLIB_OC_TimerSelect(OC_ID_1, OC_TIMER_16BIT_TMR2);
1054:                  PLIB_OC_Buffer16BitSet(OC_ID_1, HSYNC_START);  // turn on at timer value
1055:                  PLIB_OC_PulseWidth16BitSet(OC_ID_1, HSYNC_START+HSYNC_LENGTH); // turn off at timer value
1056:                  PLIB_OC_Enable(OC_ID_1);
1057:                    
1058:                  // set up output compare + interrupt for going into idle mode
1059:                  // (see comment in ISR function IntHandlerOC2)
1060:                  PLIB_INT_VectorPrioritySet(INT_ID_0, INT_VECTOR_OC2, INT_PRIORITY_LEVEL6);
1061:                  PLIB_INT_VectorSubPrioritySet(INT_ID_0, INT_VECTOR_OC2, INT_SUBPRIORITY_LEVEL0);
1062:                  PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_OUTPUT_COMPARE_2);
1063:                  PLIB_INT_SourceEnable(INT_ID_0, INT_SOURCE_OUTPUT_COMPARE_2);
1064:                  PLIB_OC_ModeSelect(OC_ID_2, OC_TOGGLE_CONTINUOUS_PULSE_MODE);
1065:                  PLIB_OC_BufferSizeSelect(OC_ID_2, OC_BUFFER_SIZE_16BIT);
1066:                  PLIB_OC_TimerSelect(OC_ID_2, OC_TIMER_16BIT_TMR2);
1067:                  PLIB_OC_Buffer16BitSet(OC_ID_2, NUM_PIXELS-20);
1068:                  PLIB_OC_Enable(OC_ID_2);
1069:                    
1070:                  // set up output compare for VSYNC signal
1071:                  PLIB_OC_BufferSizeSelect(OC_ID_3, OC_BUFFER_SIZE_16BIT);
1072:                  PLIB_OC_TimerSelect(OC_ID_3, OC_TIMER_16BIT_TMR2);
1073:                  PLIB_OC_Buffer16BitSet(OC_ID_3, 0);
1074:                
1075:                  // initialize update_byte function
1076:                  set_update_byte();
9D0031C4  0F4021F9   JAL set_update_byte
9D0031C8  00000000   NOP
1077:                 
1078:                  // set up ADC for joystick input
1079:                  PLIB_ADC_ConversionTriggerSourceSelect(ADC_ID_1, ADC_CONVERSION_TRIGGER_INTERNAL_COUNT);
1080:                  PLIB_ADC_InputScanMaskRemove(ADC_ID_1, ADC_INPUT_SCAN_AN10);
1081:                  PLIB_ADC_SampleAcquisitionTimeSet(ADC_ID_1, 2);
1082:                  PLIB_ADC_ConversionClockSet(ADC_ID_1, 80000000, 20000000);
1083:                  PLIB_ADC_Enable(ADC_ID_1);
1084:                
1085:                #if USE_USB==0
1086:                  // disable USB peripheral (was enabled in DRV_USBFS_Initialize() called from system_init.c)
1087:                  PLIB_USB_Disable(USB_ID_1);
1088:                
1089:                  // set up USART 2 on pins 21/22 (B10/B11) at 750000 baud, 8N1
1090:                  c = SYS_CLK_PeripheralFrequencyGet(CLK_BUS_PERIPHERAL_1);
1091:                  PLIB_PORTS_PinModePerPortSelect(PORTS_ID_0, PORT_CHANNEL_B, 10, PORTS_PIN_MODE_DIGITAL);
1092:                  PLIB_PORTS_PinModePerPortSelect(PORTS_ID_0, PORT_CHANNEL_B, 11, PORTS_PIN_MODE_DIGITAL);
1093:                  PLIB_PORTS_RemapOutput(PORTS_ID_0, OUTPUT_FUNC_U2TX, OUTPUT_PIN_RPB10);
1094:                  PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_U2RX, INPUT_PIN_RPB11);
1095:                  PLIB_USART_InitializeModeGeneral(USART_ID_2, false, false, false, false, false);
1096:                  PLIB_USART_LineControlModeSelect(USART_ID_2, USART_8N1);
1097:                  PLIB_USART_InitializeOperation(USART_ID_2, USART_RECEIVE_FIFO_ONE_CHAR, USART_TRANSMIT_FIFO_IDLE, USART_ENABLE_TX_RX_USED);
1098:                  PLIB_USART_BaudRateHighEnable(USART_ID_2);
1099:                  PLIB_USART_BaudRateHighSet(USART_ID_2, c, 750000);
1100:                  PLIB_USART_TransmitterEnable(USART_ID_2);
1101:                  PLIB_USART_ReceiverEnable(USART_ID_2);
1102:                  PLIB_USART_Enable(USART_ID_2);
1103:                #else
1104:                  // set up USB
1105:                  USB_HOST_CDC_AttachEventHandlerSet(USBHostCDCAttachEventListener, (uintptr_t) 0);
9D003208  3C049D01   LUI A0, -25343
9D00320C  24849B34   ADDIU A0, A0, -25804
9D003210  0F402571   JAL USB_HOST_CDC_AttachEventHandlerSet
9D003214  00002821   ADDU A1, ZERO, ZERO
1106:                  PLIB_USB_StopInIdleDisable(USB_ID_1);
1107:                  USB_HOST_BusEnable(0);
9D003228  0F402385   JAL USB_HOST_BusEnable
9D00322C  00002021   ADDU A0, ZERO, ZERO
1108:                #endif
1109:                    
1110:                  // set color/gray scale output pin
1111:                  ColorStateSet((dazzler_picture_ctrl & 0x10)!=0);
9D003230  93828030   LBU V0, -32720(GP)
9D003234  30420010   ANDI V0, V0, 16
1112:                    
1113:                  // clear frame buffer
1114:                  memset(framebuffer, 0, sizeof(framebuffer));
9D003250  0B400C9A   J 0x9D003268
9D003254  3C04A000   LUI A0, -24576
9D003264  3C04A000   LUI A0, -24576
9D003268  24840640   ADDIU A0, A0, 1600
9D00326C  00002821   ADDU A1, ZERO, ZERO
9D003270  0F40202B   JAL memset
9D003274  24064200   ADDIU A2, ZERO, 16896
1115:                
1116:                  // determine whether to enter joystick calibration (test) mode
1117:                  test_mode = read_joystick_buttons();
9D003278  0F40207E   JAL read_joystick_buttons
9D00327C  00000000   NOP
1118:                  if( (test_mode & 0x0f)!=0x0f )
9D003280  3044000F   ANDI A0, V0, 15
9D003284  2403000F   ADDIU V1, ZERO, 15
9D003288  10830004   BEQ A0, V1, 0x9D00329C
9D00328C  AF8280A0   SW V0, -32608(GP)
1119:                    test_mode = 1;
9D003290  24020001   ADDIU V0, ZERO, 1
9D003294  0B400CBA   J 0x9D0032E8
9D003298  AF8280A0   SW V0, -32608(GP)
1120:                  else if( (test_mode & 0xf0)!=0xf0 )
9D00329C  304200F0   ANDI V0, V0, 240
9D0032A0  240300F0   ADDIU V1, ZERO, 240
9D0032A4  10430003   BEQ V0, V1, APP_Initialize::PLIB_PORTS_PinGet
9D0032A8  24020002   ADDIU V0, ZERO, 2
9D0032AC  0B400CBA   J 0x9D0032E8
9D0032B0  AF8280A0   SW V0, -32608(GP)
1121:                    test_mode = 2;
1122:                  else if( !TestButtonStateGet() )
9D0032C0  54400004   BNEL V0, ZERO, APP_Initialize::PLIB_TMR_Start
9D0032C4  AF8080A0   SW ZERO, -32608(GP)
1123:                    test_mode = 13;
9D0032C8  2402000D   ADDIU V0, ZERO, 13
9D0032CC  0B400CBA   J 0x9D0032E8
9D0032D0  AF8280A0   SW V0, -32608(GP)
1124:                  else
1125:                    test_mode = 0;
1126:                
1127:                  // if we're in test mode, draw the test screen
1128:                  if( test_mode>0 ) { dazzler_ctrl = 0x80; draw_test_screen(); }
9D0032E8  2402FF80   ADDIU V0, ZERO, -128
9D0032EC  0F400CC3   JAL draw_test_screen
9D0032F0  A38280A4   SB V0, -32604(GP)
1129:                    
1130:                  // start timer
1131:                  if( ALWAYS_ON>0 || test_mode>0 ) PLIB_TMR_Start(TMR_ID_2);
1132:                }
9D0032E0  0B400CBF   J 0x9D0032FC
9D0032E4  8FBF001C   LW RA, 28(SP)
9D0032FC  8FB10018   LW S1, 24(SP)
1133:                
1134:                
1135:                // -----------------------------------------------------------------------------
1136:                // --------------------------------- main loop ---------------------------------
1137:                // -----------------------------------------------------------------------------
1138:                
1139:                
1140:                void APP_Tasks ( void )
1141:                {
9D00701C  27BDFFE8   ADDIU SP, SP, -24
9D007020  AFBF0014   SW RA, 20(SP)
1142:                  // Displaying the picture and receiving data is done in interrupts
1143:                  // so all we do in the main loop is querying the joysticks (once per frame)
1144:                  // and processing received data
1145:                  check_joystick();
9D007024  0F400588   JAL check_joystick
9D007028  00000000   NOP
1146:                
1147:                  // process received data    
1148:                  ringbuffer_dequeue();
1149:                  ringbuffer_dequeue();
1150:                  ringbuffer_dequeue();
1151:                
1152:                #if USE_USB>0
1153:                  // handle USB tasks
1154:                  usbTasks();
9D0070B4  0F4021D9   JAL usbTasks
9D0070B8  00000000   NOP
1155:                  if( test_mode==11 ) framebuffer[0][0] = (usbCdcObject==NULL) ? 9 : 10;
9D0070BC  8F8280A0   LW V0, -32608(GP)
9D0070C0  2403000B   ADDIU V1, ZERO, 11
9D0070C4  14430008   BNE V0, V1, 0x9D0070E8
9D0070C8  2842000B   SLTI V0, V0, 11
9D0070CC  24020009   ADDIU V0, ZERO, 9
9D0070D0  2403000A   ADDIU V1, ZERO, 10
9D0070D4  8F848088   LW A0, -32632(GP)
9D0070D8  0044180A   MOVZ V1, V0, A0
9D0070DC  3C02A000   LUI V0, -24576
9D0070E0  0B401C3C   J 0x9D0070F0
9D0070E4  A0430640   SB V1, 1600(V0)
1156:                #endif
1157:                
1158:                  // handle test mode switching
1159:                  if( test_mode>10 ) check_test_button();
9D0070E8  14400004   BNE V0, ZERO, 0x9D0070FC
9D0070EC  8FBF0014   LW RA, 20(SP)
9D0070F0  0F401FD2   JAL check_test_button
9D0070F4  00000000   NOP
1160:                }
9D0070F8  8FBF0014   LW RA, 20(SP)
